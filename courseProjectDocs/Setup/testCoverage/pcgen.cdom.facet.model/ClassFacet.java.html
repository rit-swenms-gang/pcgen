<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.model</a> &gt; <span class="el_source">ClassFacet.java</span></div><h1>ClassFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2009.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.model;

import java.util.Collections;
import java.util.EventListener;
import java.util.EventObject;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javax.swing.event.EventListenerList;

import pcgen.cdom.base.SetFacet;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.facet.base.AbstractDataFacet;
import pcgen.cdom.facet.event.DataFacetChangeEvent;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.core.PCClass;
import pcgen.output.publish.OutputDB;

/**
 * ClassFacet is a Facet that tracks the PCClass objects possessed by a Player
 * Character.
 *
 */
<span class="fc" id="L46">public class ClassFacet extends AbstractDataFacet&lt;CharID, PCClass&gt; implements SetFacet&lt;CharID, PCClass&gt;</span>
{
<span class="fc" id="L48">	private final ClassLevelChangeSupport support = new ClassLevelChangeSupport();</span>

	/**
	 * Add the given PCClass to the list of PCClass objects stored in this
	 * ClassFacet for the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given PCClass should be added
	 * @param obj
	 *            The PCClass to be added to the list of PCClass objects stored
	 *            in this AbstractListFacet for the Player Character represented
	 *            by the given CharID
	 */
	public void addClass(CharID id, PCClass obj)
	{
<span class="fc" id="L64">		Objects.requireNonNull(obj, &quot;PCClass to add may not be null&quot;);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		if (getConstructingClassInfo(id).addClass(obj))</span>
		{
<span class="fc" id="L67">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L69">	}</span>

	/**
	 * Sets the PCClassLevel object associated with the given PCClass for the Player
	 * Character represented by the given CharID. Returns true if the set is successful.
	 * The set will be successful if the given PCClass is possessed by the given
	 * PlayerCharacter; false otherwise.
	 *
	 * The (numeric) class level for which the given PCClassLevel should be applied is
	 * determined by the level value set in the PCClassLevel.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the given
	 *            PCClassLevel should be set
	 * @param pcc
	 *            The PCClass object for which the PCClassLevel object is set as the
	 *            PCClass
	 * @param pcl
	 *            The PCClassLevel object to be associated with the given PCClass and
	 *            Player Character represented by the given CharID
	 * @return true if the set is successful; false otherwise.
	 * @throws CloneNotSupportedException
	 *             if the class level cannot be thrown
	 */
	public boolean setClassLevel(CharID id, PCClass pcc, PCClassLevel pcl) throws CloneNotSupportedException
	{
<span class="fc" id="L95">		Objects.requireNonNull(pcc, &quot;Class cannot be null in setClassLevel&quot;);</span>
<span class="fc" id="L96">		Objects.requireNonNull(pcl, &quot;Class Level cannot be null in setClassLevel&quot;);</span>
<span class="fc" id="L97">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if (info == null)</span>
		{
<span class="fc" id="L100">			return false;</span>
		}
<span class="fc" id="L102">		PCClassLevel old = info.getClassLevel(pcc, pcl.get(IntegerKey.LEVEL));</span>
<span class="fc" id="L103">		boolean returnVal = info.setClassLevel(pcc, pcl);</span>
<span class="fc" id="L104">		support.fireClassLevelObjectChangeEvent(id, pcc, old, pcl);</span>
<span class="fc" id="L105">		return returnVal;</span>
	}

	/**
	 * Returns the PCClassLevel object associated with the Player Character
	 * represented by the given CharID, the given PCClass, and the given
	 * (numeric) class level.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            associated PCClassLevel will be returned
	 * @param obj
	 *            The PCClass object for which the PCClassLevel object should be
	 *            returned
	 * @param level
	 *            The (numeric) class level for which the PCClassLevel object
	 *            should be returned
	 * @return The PCClassLevel object associated with the Player Character
	 *         represented by the given CharID, the given PCClass, and the given
	 *         (numeric) class level.
	 */
	public PCClassLevel getClassLevel(CharID id, PCClass obj, int level)
	{
<span class="fc" id="L128">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">		if (info == null)</span>
		{
<span class="fc" id="L131">			return null;</span>
		}
<span class="fc" id="L133">		return info.getClassLevel(obj, level);</span>
	}

	/**
	 * Remove the given PCClass from the list of PCClass objects stored in this
	 * ClassFacet for the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given PCClass should be removed
	 * @param obj
	 *            The PCClass to be removed from the list of PCClass objects
	 *            stored in this AbstractListFacet for the Player Character
	 *            represented by the given CharID
	 */
	public void removeClass(CharID id, PCClass obj)
	{
<span class="fc" id="L150">		Objects.requireNonNull(obj, &quot;PCClass to add may not be null&quot;);</span>
<span class="fc" id="L151">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">		if (info != null)</span>
		{
<span class="fc bfc" id="L154" title="All 2 branches covered.">			if (info.containsClass(obj))</span>
			{
<span class="fc" id="L156">				setLevel(id, obj, 0);</span>
<span class="fc" id="L157">				info.removeClass(obj);</span>
<span class="fc" id="L158">				fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
			}
<span class="fc bfc" id="L160" title="All 2 branches covered.">			if (info.isEmpty())</span>
			{
<span class="fc" id="L162">				removeCache(id);</span>
			}
		}
<span class="fc" id="L165">	}</span>

	/**
	 * Removes all PCClass objects from the list of PCClass objects stored in
	 * this ClassFacet for the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character from which all
	 *            PCClass objects should be removed
	 */
	public ClassInfo removeAllClasses(CharID id)
	{
<span class="fc" id="L177">		ClassInfo info = (ClassInfo) removeCache(id);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (info != null)</span>
		{
<span class="fc bfc" id="L180" title="All 2 branches covered.">			for (PCClass obj : info.getClassSet())</span>
			{
<span class="fc" id="L182">				fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L183">				int oldLevel = info.getLevel(obj);</span>
<span class="fc" id="L184">				support.fireClassLevelChangeEvent(id, obj, oldLevel, 0);</span>
<span class="fc" id="L185">			}</span>
		}
<span class="fc" id="L187">		return info;</span>
	}

	/**
	 * Replaces the given old PCClass stored in this ClassFacet with the given
	 * new PCClass for the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given old PCClass should be replaced
	 * @param oldClass
	 *            The old PCClass to be removed from the list of PCClass objects
	 *            stored in this ClassFacet for the Player Character represented
	 *            by the given CharID
	 * @param newClass
	 *            The new PCClass to replace the old PCClass stored in this
	 *            ClassFacet for the Player Character represented by the given
	 *            CharID
	 */
	public void replaceClass(CharID id, PCClass oldClass, PCClass newClass)
	{
<span class="fc" id="L208">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (info != null)</span>
		{
<span class="fc" id="L211">			info.replace(oldClass, newClass);</span>
		}
<span class="fc" id="L213">	}</span>

	/**
	 * Returns a non-null copy of the Set of PCClass objects in this ClassFacet
	 * for the Player Character represented by the given CharID. This method
	 * returns an empty Set if no objects are in this ClassFacet for the Player
	 * Character identified by the given CharID.
	 *
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this ClassFacet and modification of this
	 * ClassFacet will not modify the returned List. Modifications to the
	 * returned List will also not modify any future or previous objects
	 * returned by this (or other) methods on ClassFacet. If you wish to modify
	 * the information stored in this ClassFacet, you must use the add*() and
	 * remove*() methods of ClassFacet.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this ClassFacet should be returned.
	 * @return A non-null Set of PCClass objects in this ClassFacet for the
	 *         Player Character represented by the given CharID
	 */
	@Override
	public Set&lt;PCClass&gt; getSet(CharID id)
	{
<span class="fc" id="L239">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (info == null)</span>
		{
<span class="fc" id="L242">			return Collections.emptySet();</span>
		}
<span class="fc" id="L244">		return info.getClassSet();</span>
	}

	/**
	 * Returns the count of PCClass objects in this ClassFacet for the Player
	 * Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            count of PCClass objects should be returned
	 * @return The count of PCClass objects in this ClassFacet for the Player
	 *         Character represented by the given CharID
	 */
	@Override
	public int getCount(CharID id)
	{
<span class="fc" id="L260">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (info == null)</span>
		{
<span class="fc" id="L263">			return 0;</span>
		}
<span class="fc" id="L265">		return info.classCount();</span>
	}

	/**
	 * Returns true if this ClassFacet does not contain any PCClass objects for
	 * the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharId representing the PlayerCharacter to test if any
	 *            PCClass objects are contained by this AbstractListFacet
	 * @return true if this ClassFacet does not contain any PCClass objects for
	 *         the Player Character represented by the given CharID; false
	 *         otherwise (if it does contain items for the Player Character)
	 */
	public boolean isEmpty(CharID id)
	{
<span class="fc" id="L281">		ClassInfo info = getClassInfo(id);</span>
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">		return info == null || info.isEmpty();</span>
	}

	/**
	 * Returns true if this ClassFacet contains the given PCClass in the list of
	 * PCClass objects for the Player Character represented by the given CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character used for testing
	 * @param obj
	 *            The PCClass to test if this ClassFacet contains that PCClass
	 *            for the Player Character represented by the given CharID
	 * @return true if this AbstractListFacet contains the given PCClass for the
	 *         Player Character represented by the given CharID; false otherwise
	 */
	public boolean contains(CharID id, PCClass obj)
	{
<span class="fc" id="L299">		ClassInfo info = getClassInfo(id);</span>
<span class="pc bpc" id="L300" title="1 of 4 branches missed.">		return info != null &amp;&amp; info.containsClass(obj);</span>
	}

	/**
	 * Sets the level for the given PCClass and the Player Character identified
	 * by the given CharID to the given value.
	 *
	 * @param id
	 *            The CharID identifying the Player Character for which a level
	 *            value is being set
	 * @param pcc
	 *            The PCClass identifying which class level is being set
	 * @param level
	 *            The level of the PCClass for the Player Character identified
	 *            by the given CharID
	 */
	public void setLevel(CharID id, PCClass pcc, int level)
	{
<span class="fc" id="L318">		int oldLevel = getConstructingClassInfo(id).setLevel(pcc, level);</span>
<span class="fc" id="L319">		support.fireClassLevelChangeEvent(id, pcc, oldLevel, level);</span>
<span class="fc" id="L320">	}</span>

	/**
	 * Returns the current (numerical) level for the given PCClass in the Player
	 * Character identified by the given CharID.
	 *
	 * @param id
	 *            The CharID identifying the Player Character for which the
	 *            level of the given PCClass should be returned
	 * @param pcc
	 *            The PCClass for which the level of the Player Character should
	 *            be returned
	 * @return The numeric value of the level for the given PCClass in the
	 *         Player Character identified by the given CharID
	 */
	public int getLevel(CharID id, PCClass pcc)
	{
<span class="fc" id="L337">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">		return (info == null) ? 0 : info.getLevel(pcc);</span>
	}

	/**
	 * Returns the ClassInfo for this ClassFacet and the given CharID. May
	 * return null if no information has been set in this ClassFacet for the
	 * given CharID.
	 *
	 * Note that this method SHOULD NOT be public. The ClassInfo is owned by
	 * ClassFacet, and since it can be modified, a reference to that object
	 * should not be exposed to any object other than ClassFacet.
	 *
	 * @param id
	 *            The CharID for which the ClassInfo should be returned
	 * @return The ClassInfo for the Player Character represented by the given
	 *         CharID; null if no information has been set in this ClassFacet
	 *         for the Player Character.
	 */
	private ClassInfo getClassInfo(CharID id)
	{
<span class="fc" id="L358">		return (ClassInfo) getCache(id);</span>
	}

	/**
	 * Returns a ClassInfo for this ClassFacet and the given CharID. Will return
	 * a new, empty ClassInfo if no information has been set in this ClassFacet
	 * for the given CharID. Will not return null.
	 *
	 * Note that this method SHOULD NOT be public. The ClassInfo object is owned
	 * by ClassFacet, and since it can be modified, a reference to that object
	 * should not be exposed to any object other than ClassFacet.
	 *
	 * @param id
	 *            The CharID for which the ClassInfo should be returned
	 * @return The ClassInfo for the Player Character represented by the given
	 *         CharID.
	 */
	private ClassInfo getConstructingClassInfo(CharID id)
	{
<span class="fc" id="L377">		ClassInfo info = getClassInfo(id);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">		if (info == null)</span>
		{
<span class="fc" id="L380">			info = new ClassInfo();</span>
<span class="fc" id="L381">			setCache(id, info);</span>
		}
<span class="fc" id="L383">		return info;</span>
	}

	/**
	 * ClassInfo is the Class used by ClassFacet to store information in the
	 * global character cache. This stores both the PCClassLevel objects active
	 * for a PCClass and Player Character, as well as the levels of the
	 * PCClasses for a Player Character.
	 *
	 */
	public static class ClassInfo
	{
		/**
		 * Map that stores the PCClassLevel objects active for a Player
		 * Character.
		 */
<span class="fc" id="L399">		private Map&lt;PCClass, Map&lt;Integer, PCClassLevel&gt;&gt; map = new LinkedHashMap&lt;&gt;();</span>
		/**
		 * Map that stores the numeric level values for the PCClasses in a
		 * Player Character.
		 */
<span class="fc" id="L404">		private Map&lt;PCClass, Integer&gt; levelmap = new HashMap&lt;&gt;();</span>

		public ClassInfo()
<span class="fc" id="L407">		{</span>
			//Default constructor for an empty ClassInfo
<span class="fc" id="L409">		}</span>

		public ClassInfo(ClassInfo info)
<span class="fc" id="L412">		{</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">			for (Map.Entry&lt;PCClass, Map&lt;Integer, PCClassLevel&gt;&gt; me : info.map.entrySet())</span>
			{
<span class="fc" id="L415">				map.put(me.getKey(), new HashMap&lt;&gt;(me.getValue()));</span>
<span class="fc" id="L416">			}</span>
<span class="fc" id="L417">			levelmap.putAll(info.levelmap);</span>
<span class="fc" id="L418">		}</span>

		public Integer setLevel(PCClass pcc, int level)
		{
<span class="fc" id="L422">			Objects.requireNonNull(pcc, &quot;Class for setLevel must not be null&quot;);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">			if (level &lt; 0)</span>
			{
<span class="fc" id="L425">				throw new IllegalArgumentException(&quot;Level for &quot; + pcc.getDisplayName() + &quot; must be &gt; 0&quot;);</span>
			}
<span class="fc bfc" id="L427" title="All 4 branches covered.">			if (level != 0 &amp;&amp; !map.containsKey(pcc))</span>
			{
<span class="fc" id="L429">				throw new IllegalArgumentException(</span>
<span class="fc" id="L430">					&quot;Cannot set level for PCClass &quot; + pcc.getKeyName() + &quot; which is not added&quot;);</span>
			}
<span class="fc" id="L432">			Integer oldlvl = levelmap.put(pcc, level);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">			return (oldlvl == null) ? Integer.valueOf(0) : oldlvl;</span>
		}

		public int getLevel(PCClass pcc)
		{
<span class="fc" id="L438">			Integer level = levelmap.get(pcc);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">			return (level == null) ? 0 : level;</span>
		}

		public void replace(PCClass oldClass, PCClass newClass)
		{
<span class="fc" id="L444">			Map&lt;PCClass, Map&lt;Integer, PCClassLevel&gt;&gt; oldMap = map;</span>
<span class="fc" id="L445">			map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">			for (Map.Entry&lt;PCClass, Map&lt;Integer, PCClassLevel&gt;&gt; me : oldMap.entrySet())</span>
			{
<span class="fc" id="L448">				PCClass currentClass = me.getKey();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">				if (oldClass.equals(currentClass))</span>
				{
<span class="fc" id="L451">					addClass(newClass);</span>
				}
				else
				{
<span class="fc" id="L455">					map.put(currentClass, me.getValue());</span>
				}
<span class="fc" id="L457">			}</span>
<span class="fc" id="L458">		}</span>

		public boolean addClass(PCClass pcc)
		{
<span class="fc bfc" id="L462" title="All 2 branches covered.">			if (map.containsKey(pcc))</span>
			{
<span class="fc" id="L464">				return false;</span>
			}
<span class="fc" id="L466">			Map&lt;Integer, PCClassLevel&gt; levelMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L467">			map.put(pcc, levelMap);</span>
			/*
			 * DO NOT initialize levelMap here - see CODE-208
			 */
<span class="fc" id="L471">			return true;</span>
		}

		public boolean setClassLevel(PCClass pcc, PCClassLevel pcl) throws CloneNotSupportedException
		{
<span class="fc" id="L476">			Map&lt;Integer, PCClassLevel&gt; localMap = map.get(pcc);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">			if (localMap == null)</span>
			{
<span class="nc" id="L479">				return false;</span>
			}
<span class="fc" id="L481">			pcl.ownBonuses(pcc);</span>
<span class="fc" id="L482">			pcl.put(ObjectKey.PARENT, pcc);</span>
<span class="fc" id="L483">			localMap.put(pcl.get(IntegerKey.LEVEL), pcl);</span>
<span class="fc" id="L484">			return true;</span>
		}

		public PCClassLevel getClassLevel(PCClass pcc, int level)
		{
<span class="fc" id="L489">			Objects.requireNonNull(pcc, &quot;Class in getClassLevel cannot be null&quot;);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">			if (level &lt; 0)</span>
			{
<span class="fc" id="L492">				throw new IllegalArgumentException(&quot;Level cannot be negative in getClassLevel&quot;);</span>
			}
			//map.get(pcc) doesn't seem to find the monster class
			//Map&lt;Integer, PCClassLevel&gt; localMap = map.get(pcc);
<span class="fc" id="L496">			Map&lt;Integer, PCClassLevel&gt; localMap = null;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">			for (final Map.Entry&lt;PCClass, Map&lt;Integer, PCClassLevel&gt;&gt; pcClassMapEntry : map.entrySet())</span>
			{
<span class="fc bfc" id="L499" title="All 2 branches covered.">				if (pcc.equals(pcClassMapEntry.getKey()))</span>
				{
<span class="fc" id="L501">					localMap = pcClassMapEntry.getValue();</span>
<span class="fc" id="L502">					break;</span>
				}
<span class="fc" id="L504">			}</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">			if (localMap == null)</span>
			{
<span class="fc" id="L507">				throw new IllegalArgumentException(</span>
<span class="fc" id="L508">					&quot;Level cannot be returned for Class &quot; + pcc.getKeyName() + &quot; which is not in the PC&quot;);</span>
			}
<span class="fc" id="L510">			PCClassLevel classLevel = localMap.get(level);</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">			if (classLevel == null)</span>
			{
<span class="fc" id="L513">				classLevel = pcc.getOriginalClassLevel(level);</span>
<span class="fc" id="L514">				classLevel.put(ObjectKey.PARENT, pcc);</span>
<span class="fc" id="L515">				localMap.put(level, classLevel);</span>
			}
<span class="fc" id="L517">			return classLevel;</span>
		}

		public boolean removeClass(PCClass pcc)
		{
<span class="fc" id="L522">			boolean returnValue = map.containsKey(pcc);</span>
<span class="fc" id="L523">			map.remove(pcc);</span>
<span class="fc" id="L524">			return returnValue;</span>
		}

		public Set&lt;PCClass&gt; getClassSet()
		{
<span class="fc" id="L529">			return Collections.unmodifiableSet(map.keySet());</span>
		}

		public boolean isEmpty()
		{
<span class="fc" id="L534">			return map.isEmpty();</span>
		}

		public int classCount()
		{
<span class="fc" id="L539">			return map.size();</span>
		}

		public boolean containsClass(PCClass pcc)
		{
<span class="fc" id="L544">			return map.containsKey(pcc);</span>
		}

		@Override
		public int hashCode()
		{
<span class="nc" id="L550">			return map.hashCode();</span>
		}

		@Override
		public boolean equals(Object o)
		{
<span class="nc bnc" id="L556" title="All 2 branches missed.">			if (o instanceof ClassInfo other)</span>
			{
<span class="nc bnc" id="L558" title="All 4 branches missed.">				return map.equals(other.map) &amp;&amp; levelmap.equals(other.levelmap);</span>
			}
<span class="nc" id="L560">			return false;</span>
		}
	}

	@Override
	public void copyContents(CharID source, CharID destination)
	{
<span class="fc" id="L567">		ClassInfo info = getClassInfo(source);</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">		if (info != null)</span>
		{
<span class="fc" id="L570">			setCache(destination, new ClassInfo(info));</span>
		}
<span class="fc" id="L572">	}</span>

	public void addLevelChangeListener(ClassLevelChangeListener listener)
	{
<span class="fc" id="L576">		support.addLevelChangeListener(listener);</span>
<span class="fc" id="L577">	}</span>

	public ClassLevelChangeListener[] getLevelChangeListeners()
	{
<span class="nc" id="L581">		return support.getLevelChangeListeners();</span>
	}

	public void removeLevelChangeListener(ClassLevelChangeListener listener)
	{
<span class="nc" id="L586">		support.removeLevelChangeListener(listener);</span>
<span class="nc" id="L587">	}</span>

	public static interface ClassLevelChangeListener extends EventListener
	{
		public void levelChanged(ClassLevelChangeEvent lce);

		public void levelObjectChanged(ClassLevelObjectChangeEvent lce);
	}

	public static class ClassLevelChangeEvent extends EventObject
	{

		/**
		 * The ID indicating the owning character for this ClassLevelChangeEvent
		 */
		private final CharID charID;

		private final PCClass pcClass;
		private final int oldLvl;
		private final int newLvl;

		public ClassLevelChangeEvent(CharID source, PCClass pcc, int oldLevel, int newLevel)
		{
<span class="fc" id="L610">			super(source);</span>
<span class="fc" id="L611">			Objects.requireNonNull(source, &quot;CharID cannot be null&quot;);</span>
<span class="fc" id="L612">			Objects.requireNonNull(pcc, &quot;PCClass cannot be null&quot;);</span>
<span class="fc" id="L613">			charID = source;</span>
<span class="fc" id="L614">			pcClass = pcc;</span>
<span class="fc" id="L615">			oldLvl = oldLevel;</span>
<span class="fc" id="L616">			newLvl = newLevel;</span>
<span class="fc" id="L617">		}</span>

		/**
		 * Returns an identifier indicating the PlayerCharacter on which this
		 * event occurred.
		 *
		 * @return A identifier indicating the PlayerCharacter on which this
		 *         event occurred.
		 */
		public CharID getCharID()
		{
<span class="fc" id="L628">			return charID;</span>
		}

		public PCClass getPCClass()
		{
<span class="fc" id="L633">			return pcClass;</span>
		}

		public int getOldLevel()
		{
<span class="fc" id="L638">			return oldLvl;</span>
		}

		public int getNewLevel()
		{
<span class="fc" id="L643">			return newLvl;</span>
		}
	}

	public static class ClassLevelObjectChangeEvent extends EventObject
	{

		/**
		 * The ID indicating the owning character for this ClassLevelChangeEvent
		 */
		private final CharID charID;

		private final PCClass pcClass;
		private final PCClassLevel oldLvl;
		private final PCClassLevel newLvl;

		public ClassLevelObjectChangeEvent(CharID source, PCClass pcc, PCClassLevel oldLevel, PCClassLevel newLevel)
		{
<span class="fc" id="L661">			super(source);</span>
<span class="fc" id="L662">			Objects.requireNonNull(source, &quot;CharID cannot be null&quot;);</span>
<span class="fc" id="L663">			Objects.requireNonNull(pcc, &quot;PCClass cannot be null&quot;);</span>
<span class="fc" id="L664">			Objects.requireNonNull(newLevel, &quot;New Level cannot be null&quot;);</span>
<span class="fc" id="L665">			charID = source;</span>
<span class="fc" id="L666">			pcClass = pcc;</span>
<span class="fc" id="L667">			oldLvl = oldLevel;</span>
<span class="fc" id="L668">			newLvl = newLevel;</span>
<span class="fc" id="L669">		}</span>

		/**
		 * Returns an identifier indicating the PlayerCharacter on which this
		 * event occurred.
		 *
		 * @return A identifier indicating the PlayerCharacter on which this
		 *         event occurred.
		 */
		public CharID getCharID()
		{
<span class="fc" id="L680">			return charID;</span>
		}

		public PCClass getPCClass()
		{
<span class="fc" id="L685">			return pcClass;</span>
		}

		public PCClassLevel getOldLevel()
		{
<span class="fc" id="L690">			return oldLvl;</span>
		}

		public PCClassLevel getNewLevel()
		{
<span class="fc" id="L695">			return newLvl;</span>
		}
	}

<span class="fc" id="L699">	public static class ClassLevelChangeSupport</span>
	{
		/**
		 * The listeners to which LevelChangeEvents will be fired when a change
		 * in the source ClassFacet occurs.
		 */
<span class="fc" id="L705">		private final EventListenerList listenerList = new EventListenerList();</span>

		/**
		 * Adds a new ClassLevelChangeListener to receive LevelChangeEvents
		 * (EdgeChangeEvent and NodeChangeEvent) from the source ClassFacet.
		 *
		 * @param listener
		 *            The LevelChangeListener to receive LevelChangeEvents
		 */
		public void addLevelChangeListener(ClassLevelChangeListener listener)
		{
<span class="fc" id="L716">			listenerList.add(ClassLevelChangeListener.class, listener);</span>
<span class="fc" id="L717">		}</span>

		/**
		 * Returns an Array of LevelChangeListeners receiving LevelChangeEvents
		 * from the source ClassFacet.
		 *
		 * Ownership of the returned Array is transferred to the calling Object.
		 * No reference to the Array is maintained by ClassLevelChangeSupport.
		 * However, the LevelChangeListeners contained in the Array are
		 * (obviously!) returned BY REFERENCE, and care should be taken with
		 * modifying those LevelChangeListeners.*
		 *
		 * @return An Array of LevelChangeListeners receiving LevelChangeEvents
		 *         from the source ClassFacet
		 */
		public synchronized ClassLevelChangeListener[] getLevelChangeListeners()
		{
<span class="nc" id="L734">			return listenerList.getListeners(ClassLevelChangeListener.class);</span>
		}

		/**
		 * Removes a LevelChangeListener so that it will no longer receive
		 * LevelChangeEvents from the source ClassFacet.
		 *
		 * @param listener
		 *            The LevelChangeListener to be removed
		 */
		public void removeLevelChangeListener(ClassLevelChangeListener listener)
		{
<span class="nc" id="L746">			listenerList.remove(ClassLevelChangeListener.class, listener);</span>
<span class="nc" id="L747">		}</span>

		/**
		 * Sends a NodeChangeEvent to the LevelChangeListeners that are
		 * receiving LevelChangeEvents from the source ClassFacet.
		 *
		 * @param id
		 *            The CharID that has beed added to or removed from the source
		 *            ClassFacet
		 * @param pcc
		 *			  The PCClass to be added to the list of PCClass objects stored
		 *            in this AbstractListFacet for the Player Character represented
		 *            by the given CharID
		 * @param oldLevel
		 * 			  The chracter's previous level
		 *
		 * @param newLevel
		 * 			  The new level specified by the user.
		 */
		protected void fireClassLevelChangeEvent(CharID id, PCClass pcc, int oldLevel, int newLevel)
		{
<span class="fc bfc" id="L768" title="All 2 branches covered.">			if (oldLevel == newLevel)</span>
			{
				// Nothing to do
<span class="fc" id="L771">				return;</span>
			}
<span class="fc" id="L773">			ClassLevelChangeListener[] listeners = listenerList.getListeners(ClassLevelChangeListener.class);</span>
			/*
			 * This list is decremented from the end of the list to the
			 * beginning in order to maintain consistent operation with how Java
			 * AWT and Swing listeners are notified of Events (they are in
			 * reverse order to how they were added to the Event-owning object).
			 */
<span class="fc" id="L780">			ClassLevelChangeEvent ccEvent = null;</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">			for (int i = listeners.length - 1; i &gt;= 0; i--)</span>
			{
				// Lazily create event
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">				if (ccEvent == null)</span>
				{
<span class="fc" id="L786">					ccEvent = new ClassLevelChangeEvent(id, pcc, oldLevel, newLevel);</span>
				}
<span class="fc" id="L788">				listeners[i].levelChanged(ccEvent);</span>
			}
<span class="fc" id="L790">		}</span>

		public void fireClassLevelObjectChangeEvent(CharID id, PCClass pcc, PCClassLevel oldLevel,
			PCClassLevel newLevel)
		{
<span class="fc bfc" id="L795" title="All 2 branches covered.">			if (oldLevel == newLevel)</span>
			{
				// Nothing to do
<span class="fc" id="L798">				return;</span>
			}
<span class="fc" id="L800">			ClassLevelChangeListener[] listeners = listenerList.getListeners(ClassLevelChangeListener.class);</span>
			/*
			 * This list is decremented from the end of the list to the
			 * beginning in order to maintain consistent operation with how Java
			 * AWT and Swing listeners are notified of Events (they are in
			 * reverse order to how they were added to the Event-owning object).
			 */
<span class="fc" id="L807">			ClassLevelObjectChangeEvent ccEvent = null;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">			for (int i = listeners.length - 1; i &gt;= 0; i--)</span>
			{
				// Lazily create event
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">				if (ccEvent == null)</span>
				{
<span class="fc" id="L813">					ccEvent = new ClassLevelObjectChangeEvent(id, pcc, oldLevel, newLevel);</span>
				}
<span class="fc" id="L815">				listeners[i].levelObjectChanged(ccEvent);</span>
			}
<span class="fc" id="L817">		}</span>

	}

	public void init()
	{
<span class="fc" id="L823">		OutputDB.register(&quot;classes&quot;, this);</span>
<span class="fc" id="L824">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>