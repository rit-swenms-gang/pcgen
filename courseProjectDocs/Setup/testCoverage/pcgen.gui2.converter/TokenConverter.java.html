<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.gui2.converter</a> &gt; <span class="el_source">TokenConverter.java</span></div><h1>TokenConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009 Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.gui2.converter;

import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;

import pcgen.base.util.DoubleKeyMap;
import pcgen.base.util.DoubleKeyMapToList;
import pcgen.cdom.base.Category;
import pcgen.cdom.base.Constants;
import pcgen.cdom.enumeration.AspectName;
import pcgen.cdom.enumeration.RaceSubType;
import pcgen.cdom.enumeration.RaceType;
import pcgen.cdom.enumeration.Region;
import pcgen.cdom.enumeration.SubClassCategory;
import pcgen.cdom.enumeration.SubRace;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.enumeration.VariableKey;
import pcgen.core.Ability;
import pcgen.core.AbilityCategory;
import pcgen.gui2.converter.event.TokenProcessEvent;
import pcgen.gui2.converter.event.TokenProcessorPlugin;
import pcgen.system.PluginLoader;
import pcgen.util.Logging;

public final class TokenConverter
{

<span class="fc" id="L47">	private static final DoubleKeyMap&lt;Class&lt;?&gt;, String, TokenProcessorPlugin&gt; MAP = new DoubleKeyMap&lt;&gt;();</span>

<span class="fc" id="L49">	private static final DoubleKeyMap&lt;Class&lt;?&gt;, String, Boolean&gt; CACHED = new DoubleKeyMap&lt;&gt;();</span>

<span class="fc" id="L51">	private static final DoubleKeyMapToList&lt;Class&lt;?&gt;, String, TokenProcessorPlugin&gt; TOKEN_CACHE =</span>
			new DoubleKeyMapToList&lt;&gt;();

<span class="fc" id="L54">	private static final DefaultTokenProcessor DEFAULT_PROC = new DefaultTokenProcessor();</span>

	private TokenConverter()
	{
	}

	public static void addToTokenMap(TokenProcessorPlugin tpp)
	{
<span class="nc" id="L62">		TokenProcessorPlugin old = MAP.put(tpp.getProcessedClass(), tpp.getProcessedToken(), tpp);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">		if (old != null)</span>
		{
<span class="nc" id="L65">			Logging.errorPrint(&quot;More than one Conversion token for &quot; + tpp.getProcessedClass().getSimpleName() + ' '</span>
<span class="nc" id="L66">				+ tpp.getProcessedToken() + &quot; found&quot;);</span>
		}
<span class="nc" id="L68">	}</span>

	public static PluginLoader getPluginLoader()
	{
<span class="nc" id="L72">		return new PluginLoader()</span>
<span class="nc" id="L73">		{</span>

			@Override
			public void loadPlugin(Class&lt;?&gt; clazz) throws Exception
			{
<span class="nc" id="L78">				addToTokenMap((TokenProcessorPlugin) clazz.newInstance());</span>
<span class="nc" id="L79">			}</span>

			@Override
			public Class[] getPluginClasses()
			{
<span class="nc" id="L84">				return new Class[]{TokenProcessorPlugin.class};</span>
			}
		};
	}

	public static String process(TokenProcessEvent tpe)
	{
<span class="nc" id="L91">		Class&lt;?&gt; cl = tpe.getPrimary().getClass();</span>
<span class="nc" id="L92">		String key = tpe.getKey();</span>

<span class="nc" id="L94">		ensureCategoryExists(tpe);</span>

<span class="nc" id="L96">		List&lt;TokenProcessorPlugin&gt; tokens = getTokens(cl, key);</span>
<span class="nc" id="L97">		StringBuilder error = new StringBuilder();</span>
		try
		{
<span class="nc bnc" id="L100" title="All 2 branches missed.">			if (tokens != null)</span>
			{
<span class="nc bnc" id="L102" title="All 2 branches missed.">				for (TokenProcessorPlugin converter : tokens)</span>
				{
<span class="nc" id="L104">					error.append(converter.process(tpe));</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">					if (tpe.isConsumed())</span>
					{
<span class="nc" id="L107">						break;</span>
					}
<span class="nc" id="L109">				}</span>
			}
<span class="nc bnc" id="L111" title="All 2 branches missed.">			if (!tpe.isConsumed())</span>
			{
<span class="nc" id="L113">				error.append(DEFAULT_PROC.process(tpe));</span>
			}
		}
<span class="nc" id="L116">		catch (Exception ex)</span>
		{
<span class="nc" id="L118">			Logging.errorPrint(&quot;Parse of &quot; + tpe.getKey() + ':' + tpe.getValue() + &quot; failed&quot;, ex);</span>
<span class="nc" id="L119">		}</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">		return tpe.isConsumed() ? null : error.toString();</span>
	}

	/**
	 * If this is an ABILITY token, ensure that we have an ability category 
	 * in place to use for conversion. This is because the categories can be 
	 * declared in data which may not be being converted. 
	 * @param tpe The token event that is being processed. 
	 */
	private static void ensureCategoryExists(TokenProcessEvent tpe)
	{
<span class="nc bnc" id="L131" title="All 2 branches missed.">		if (!tpe.getKey().equals(&quot;ABILITY&quot;))</span>
		{
<span class="nc" id="L133">			return;</span>
		}
<span class="nc" id="L135">		String value = tpe.getValue();</span>
<span class="nc" id="L136">		StringTokenizer tok = new StringTokenizer(value, Constants.PIPE);</span>
<span class="nc" id="L137">		String cat = tok.nextToken();</span>
<span class="nc" id="L138">		Category&lt;Ability&gt; category =</span>
<span class="nc" id="L139">				tpe.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(AbilityCategory.class, cat);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if (category == null)</span>
		{
			//			Logging.log(Logging.INFO, &quot;Found new cat &quot; + cat + &quot; in &quot; + tpe);
<span class="nc" id="L143">			tpe.getContext().getReferenceContext().constructCDOMObject(AbilityCategory.class, cat);</span>
		}
<span class="nc" id="L145">	}</span>

	static class ConverterIterator implements Iterator&lt;TokenProcessorPlugin&gt;
	{

		private Class&lt;?&gt; rootClass;
		private final String tokenKey;
<span class="nc" id="L152">		private TokenProcessorPlugin nextToken = null;</span>
<span class="nc" id="L153">		private boolean needNewToken = true;</span>

		public ConverterIterator(Class&lt;?&gt; cl, String key)
<span class="nc" id="L156">		{</span>
<span class="nc" id="L157">			rootClass = cl;</span>
<span class="nc" id="L158">			tokenKey = key;</span>
<span class="nc" id="L159">		}</span>

		@Override
		public boolean hasNext()
		{
<span class="nc" id="L164">			setNextToken();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			return !needNewToken;</span>
		}

		protected void setNextToken()
		{
<span class="nc bnc" id="L170" title="All 2 branches missed.">			if (needNewToken)</span>
			{
<span class="nc" id="L172">				nextToken = null;</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">				while (nextToken == null &amp;&amp; rootClass != null)</span>
				{
<span class="nc" id="L175">					nextToken = grabToken(rootClass, tokenKey);</span>
<span class="nc" id="L176">					rootClass = rootClass.getSuperclass();</span>
				}
<span class="nc bnc" id="L178" title="All 2 branches missed.">				needNewToken = nextToken == null;</span>
			}
<span class="nc" id="L180">		}</span>

		protected TokenProcessorPlugin grabToken(Class&lt;?&gt; cl, String key)
		{
<span class="nc" id="L184">			return MAP.get(cl, key);</span>
		}

		@Override
		public TokenProcessorPlugin next()
		{
<span class="nc" id="L190">			setNextToken();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if (needNewToken)</span>
			{
<span class="nc" id="L193">				throw new NoSuchElementException();</span>
			}
<span class="nc" id="L195">			needNewToken = true;</span>
<span class="nc" id="L196">			return nextToken;</span>
		}

		@Override
		public void remove()
		{
<span class="nc" id="L202">			throw new UnsupportedOperationException(&quot;Iterator does not support remove&quot;);</span>
		}
	}

	public static List&lt;TokenProcessorPlugin&gt; getTokens(Class&lt;?&gt; cl, String name)
	{
<span class="nc" id="L208">		List&lt;TokenProcessorPlugin&gt; list = TOKEN_CACHE.getListFor(cl, name);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">		if (!CACHED.containsKey(cl, name))</span>
		{
<span class="nc bnc" id="L211" title="All 2 branches missed.">			for (Iterator&lt;TokenProcessorPlugin&gt; it = new ConverterIterator(cl, name); it.hasNext();)</span>
			{
<span class="nc" id="L213">				TokenProcessorPlugin token = it.next();</span>
<span class="nc" id="L214">				TOKEN_CACHE.addToListFor(cl, name, token);</span>
<span class="nc" id="L215">			}</span>
<span class="nc" id="L216">			list = TOKEN_CACHE.getListFor(cl, name);</span>
<span class="nc" id="L217">			CACHED.put(cl, name, Boolean.TRUE);</span>
		}
<span class="nc" id="L219">		return list;</span>
	}

	public static void clearConstants()
	{
<span class="fc" id="L224">		AspectName.clearConstants();</span>
<span class="fc" id="L225">		RaceSubType.clearConstants();</span>
<span class="fc" id="L226">		RaceType.clearConstants();</span>
<span class="fc" id="L227">		Region.clearConstants();</span>
<span class="fc" id="L228">		SubClassCategory.clearConstants();</span>
<span class="fc" id="L229">		SubRace.clearConstants();</span>
<span class="fc" id="L230">		Type.buildMap();</span>
<span class="fc" id="L231">		VariableKey.clearConstants();</span>
<span class="fc" id="L232">	}</span>

	public static void clear()
	{
<span class="fc" id="L236">		MAP.clear();</span>
<span class="fc" id="L237">		TOKEN_CACHE.clear();</span>
<span class="fc" id="L238">		CACHED.clear();</span>
<span class="fc" id="L239">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>