<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractScopeFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractScopeFacet.java</span></div><h1>AbstractScopeFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2013.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;

import pcgen.base.util.ArrayUtilities;
import pcgen.base.util.GenericMapToList;
import pcgen.base.util.MapToList;
import pcgen.cdom.base.PCGenIdentifier;
import pcgen.cdom.facet.event.ScopeFacetChangeEvent;
import pcgen.cdom.facet.event.ScopeFacetChangeListener;

<span class="fc" id="L39">public class AbstractScopeFacet&lt;IDT extends PCGenIdentifier, S, T&gt; extends AbstractStorageFacet&lt;IDT&gt;</span>
{
	private Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; getConstructingInfo(IDT id)
	{
<span class="fc" id="L43">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L46">			map = new IdentityHashMap&lt;&gt;();</span>
<span class="fc" id="L47">			setCache(id, map);</span>
		}
<span class="fc" id="L49">		return map;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; getInfo(IDT id)
	{
<span class="fc" id="L55">		return (Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt;) getCache(id);</span>
	}

	public void add(IDT id, S scope, T obj, Object source)
	{
<span class="fc" id="L60">		Objects.requireNonNull(scope, &quot;Scope cannot be null&quot;);</span>
<span class="fc" id="L61">		Objects.requireNonNull(obj, &quot;Object cannot be null&quot;);</span>
<span class="fc" id="L62">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getConstructingInfo(id);</span>
<span class="fc" id="L63">		Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = map.computeIfAbsent(scope, k -&gt; new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L64">		Set&lt;Object&gt; sources = scopeMap.get(obj);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		boolean isNew = (sources == null);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		if (isNew)</span>
		{
<span class="fc" id="L68">			sources = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L69">			scopeMap.put(obj, sources);</span>
		}
<span class="fc" id="L71">		sources.add(source);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">		if (isNew)</span>
		{
<span class="fc" id="L74">			fireScopeFacetChangeEvent(id, scope, obj, ScopeFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L76">	}</span>

	public void addAll(IDT id, S scope, Collection&lt;T&gt; coll, Object source)
	{
<span class="nc" id="L80">		Objects.requireNonNull(scope, &quot;Scope cannot be null&quot;);</span>
<span class="nc" id="L81">		Objects.requireNonNull(coll, &quot;Collection cannot be null&quot;);</span>
<span class="nc" id="L82">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getConstructingInfo(id);</span>
<span class="nc" id="L83">		Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = map.computeIfAbsent(scope, k -&gt; new IdentityHashMap&lt;&gt;());</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">		for (T obj : coll)</span>
		{
<span class="nc" id="L86">			Set&lt;Object&gt; sources = scopeMap.get(obj);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">			boolean isNew = (sources == null);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">			if (isNew)</span>
			{
<span class="nc" id="L90">				sources = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="nc" id="L91">				scopeMap.put(obj, sources);</span>
			}
<span class="nc" id="L93">			sources.add(source);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">			if (isNew)</span>
			{
<span class="nc" id="L96">				fireScopeFacetChangeEvent(id, scope, obj, ScopeFacetChangeEvent.DATA_ADDED);</span>
			}
<span class="nc" id="L98">		}</span>
<span class="nc" id="L99">	}</span>

	public void remove(IDT id, S scope, T obj, Object source)
	{
<span class="fc" id="L103">		Objects.requireNonNull(scope, &quot;Scope cannot be null&quot;);</span>
<span class="fc" id="L104">		Objects.requireNonNull(obj, &quot;Object cannot be null&quot;);</span>
<span class="fc" id="L105">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L108">			return;</span>
		}
<span class="fc" id="L110">		Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = map.get(scope);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (scopeMap == null)</span>
		{
<span class="fc" id="L113">			return;</span>
		}
<span class="fc" id="L115">		Set&lt;Object&gt; sources = scopeMap.get(obj);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">		if (sources == null)</span>
		{
<span class="fc" id="L118">			return;</span>
		}
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">		if (sources.remove(source) &amp;&amp; sources.isEmpty())</span>
		{
<span class="fc" id="L122">			fireScopeFacetChangeEvent(id, scope, obj, ScopeFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L123">			scopeMap.remove(obj);</span>
		}
<span class="fc bfc" id="L125" title="All 2 branches covered.">		if (scopeMap.isEmpty())</span>
		{
<span class="fc" id="L127">			map.remove(scope);</span>
		}
<span class="fc bfc" id="L129" title="All 2 branches covered.">		if (map.isEmpty())</span>
		{
<span class="fc" id="L131">			removeCache(id);</span>
		}
<span class="fc" id="L133">	}</span>

	public Collection&lt;T&gt; getSet(IDT id, S scope)
	{
<span class="nc" id="L137">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L140">			return Collections.emptyList();</span>
		}
<span class="nc" id="L142">		Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = map.get(scope);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">		if (scopeMap == null)</span>
		{
<span class="nc" id="L145">			return Collections.emptyList();</span>
		}
<span class="nc" id="L147">		return new ArrayList&lt;&gt;(scopeMap.keySet());</span>
	}

	public Collection&lt;S&gt; getScopes(IDT id)
	{
<span class="nc" id="L152">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L155">			return Collections.emptyList();</span>
		}
<span class="nc" id="L157">		return new ArrayList&lt;&gt;(map.keySet());</span>
	}

	public boolean contains(IDT id, S scope, T obj)
	{
<span class="fc" id="L162">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L165">			return false;</span>
		}
<span class="fc" id="L167">		Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = map.get(scope);</span>
<span class="fc bfc" id="L168" title="All 4 branches covered.">		return (scopeMap != null) &amp;&amp; scopeMap.containsKey(obj);</span>
	}

	public void removeAllFromSource(IDT id, Object source)
	{
<span class="fc" id="L173">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(id);</span>
		/*
		 * This list exists primarily to eliminate the possibility of a
		 * concurrent modification exception on a recursive remove
		 */
<span class="fc" id="L178">		MapToList&lt;S, T&gt; removed = GenericMapToList.getMapToList(IdentityHashMap.class);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">		if (map != null)</span>
		{
<span class="nc bnc" id="L181" title="All 2 branches missed.">			for (Iterator&lt;Map.Entry&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; it = map.entrySet().iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L183">				Entry&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; entry = it.next();</span>
<span class="nc" id="L184">				S scope = entry.getKey();</span>
<span class="nc" id="L185">				Map&lt;T, Set&lt;Object&gt;&gt; scopeMap = entry.getValue();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">				for (Iterator&lt;Map.Entry&lt;T, Set&lt;Object&gt;&gt;&gt; lmit = scopeMap.entrySet().iterator(); lmit.hasNext();)</span>
				{
<span class="nc" id="L188">					Entry&lt;T, Set&lt;Object&gt;&gt; lme = lmit.next();</span>
<span class="nc" id="L189">					Set&lt;Object&gt; sources = lme.getValue();</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">					if (sources.remove(source) &amp;&amp; sources.isEmpty())</span>
					{
<span class="nc" id="L192">						T obj = lme.getKey();</span>
<span class="nc" id="L193">						lmit.remove();</span>
<span class="nc" id="L194">						removed.addToListFor(scope, obj);</span>
					}
<span class="nc" id="L196">				}</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">				if (scopeMap.isEmpty())</span>
				{
<span class="nc" id="L199">					it.remove();</span>
				}
<span class="nc" id="L201">			}</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (map.isEmpty())</span>
			{
<span class="nc" id="L204">				removeCache(id);</span>
			}
<span class="nc bnc" id="L206" title="All 2 branches missed.">			for (S scope : removed.getKeySet())</span>
			{
<span class="nc bnc" id="L208" title="All 2 branches missed.">				for (T obj : removed.getListFor(scope))</span>
				{
<span class="nc" id="L210">					fireScopeFacetChangeEvent(id, scope, obj, ScopeFacetChangeEvent.DATA_REMOVED);</span>
<span class="nc" id="L211">				}</span>
<span class="nc" id="L212">			}</span>
		}
<span class="fc" id="L214">	}</span>

	/**
	 * Copies the contents of the AbstractScopeFacet from one resource to
	 * another resource, based on the given IDTs representing those resources.
	 * 
	 * This is a method in AbstractScopeFacet in order to avoid exposing the
	 * mutable Map object to other classes. This should not be inlined, as the
	 * Map is internal information to AbstractScopeFacet and should not be
	 * exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the resources represented by the given IDTs (meaning once this
	 * copy takes place, any change to the AbstractScopeFacet of one resource
	 * will only impact the resource where the AbstractScopeFacet was changed).
	 * 
	 * @param source
	 *            The IDT representing the resource from which the information
	 *            should be copied
	 * @param copy
	 *            The IDT representing the resource to which the information
	 *            should be copied
	 */
	@Override
	public void copyContents(IDT source, IDT copy)
	{
<span class="fc" id="L240">		Map&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; map = getInfo(source);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">		if (map != null)</span>
		{
<span class="fc bfc" id="L243" title="All 2 branches covered.">			for (Entry&lt;S, Map&lt;T, Set&lt;Object&gt;&gt;&gt; lme : map.entrySet())</span>
			{
<span class="fc" id="L245">				S scope = lme.getKey();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">				for (Entry&lt;T, Set&lt;Object&gt;&gt; ome : lme.getValue().entrySet())</span>
				{
<span class="fc" id="L248">					T sp = ome.getKey();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">					for (Object spsource : ome.getValue())</span>
					{
<span class="fc" id="L251">						add(copy, scope, sp, spsource);</span>
<span class="fc" id="L252">					}</span>
<span class="fc" id="L253">				}</span>
<span class="fc" id="L254">			}</span>
		}
<span class="fc" id="L256">	}</span>

<span class="fc" id="L258">	private final Map&lt;Integer, ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt;[]&gt; listeners =</span>
			new TreeMap&lt;&gt;();

	/**
	 * Adds a new ScopeFacetChangeListener to receive ScopeFacetChangeEvents
	 * (EdgeChangeEvent and NodeChangeEvent) from this AbstractScopeFacet. The
	 * given ScopeFacetChangeListener is added at the default priority (zero).
	 * 
	 * Note that the ScopeFacetChangeListeners are a list, meaning a given
	 * ScopeFacetChangeListener can be added more than once at a given priority,
	 * and if that occurs, it must be removed an equivalent number of times in
	 * order to no longer receive events from this AbstractScopeFacet.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to receive ScopeFacetChangeEvents
	 *            from this AbstractScopeFacet
	 */
	public void addScopeFacetChangeListener(ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt; listener)
	{
<span class="fc" id="L277">		addScopeFacetChangeListener(0, listener);</span>
<span class="fc" id="L278">	}</span>

	/**
	 * Adds a new ScopeFacetChangeListener to receive ScopeFacetChangeEvents
	 * (EdgeChangeEvent and NodeChangeEvent) from this AbstractScopeFacet.
	 * 
	 * The ScopeFacetChangeListener is added at the given priority.
	 * 
	 * Note that the ScopeFacetChangeListeners are a list, meaning a given
	 * ScopeFacetChangeListener can be added more than once at a given priority,
	 * and if that occurs, it must be removed an equivalent number of times in
	 * order to no longer receive events from this AbstractScopeFacet.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to receive ScopeFacetChangeEvents
	 *            from this AbstractScopeFacet
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void addScopeFacetChangeListener(int priority,
		ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt; listener)
	{
<span class="fc" id="L299">		ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt;[] dfcl =</span>
<span class="fc" id="L300">				listeners.get(priority);</span>
<span class="fc" id="L301">		dfcl = Optional.ofNullable(dfcl).orElse(new ScopeFacetChangeListener[0]);</span>
<span class="fc" id="L302">		listeners.put(priority, ArrayUtilities.prependOnCopy(listener, dfcl,</span>
			ScopeFacetChangeListener.class));
<span class="fc" id="L304">	}</span>

	/**
	 * Removes a ScopeFacetChangeListener so that it will no longer receive
	 * ScopeFacetChangeEvents from this AbstractScopeFacet. This will remove the
	 * data facet change listener from the default priority (zero).
	 * 
	 * Note that if the given ScopeFacetChangeListener has been registered under
	 * a different priority, it will still receive events at that priority
	 * level.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to be removed
	 */
	public void removeScopeFacetChangeListener(ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt; listener)
	{
<span class="nc" id="L320">		removeScopeFacetChangeListener(0, listener);</span>
<span class="nc" id="L321">	}</span>

	/**
	 * Removes a ScopeFacetChangeListener so that it will no longer receive
	 * ScopeFacetChangeEvents from the source DataFacet. This will remove the
	 * data facet change listener from the given priority.
	 * 
	 * Note that if the given ScopeFacetChangeListener has been registered under
	 * a different priority, it will still receive events at that priority
	 * level.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to be removed
	 */
	public void removeScopeFacetChangeListener(int priority,
		ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt; listener)
	{
<span class="nc" id="L338">		ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt;[] dfcl = listeners.get(priority);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">		if (dfcl == null)</span>
		{
			// No worries
<span class="nc" id="L342">			return;</span>
		}
<span class="nc" id="L344">		int foundLoc = -1;</span>
<span class="nc" id="L345">		int newSize = dfcl.length - 1;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">		for (int i = newSize; i &gt;= 0; i--)</span>
		{
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if (dfcl[i] == listener)</span>
			{
<span class="nc" id="L350">				foundLoc = i;</span>
<span class="nc" id="L351">				break;</span>
			}
		}
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (foundLoc != -1)</span>
		{
<span class="nc bnc" id="L356" title="All 2 branches missed.">			if (dfcl.length == 1)</span>
			{
<span class="nc" id="L358">				listeners.remove(priority);</span>
			}
			else
			{
<span class="nc" id="L362">				ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt;[] newArray =</span>
						new ScopeFacetChangeListener[newSize];
<span class="nc bnc" id="L364" title="All 2 branches missed.">				if (foundLoc != 0)</span>
				{
<span class="nc" id="L366">					System.arraycopy(dfcl, 0, newArray, 0, foundLoc);</span>
				}
<span class="nc bnc" id="L368" title="All 2 branches missed.">				if (foundLoc != newSize)</span>
				{
<span class="nc" id="L370">					System.arraycopy(dfcl, foundLoc + 1, newArray, foundLoc, newSize - foundLoc);</span>
				}
<span class="nc" id="L372">				listeners.put(priority, newArray);</span>
			}
		}
<span class="nc" id="L375">	}</span>

	/**
	 * Sends a NodeChangeEvent to the ScopeFacetChangeListeners that are
	 * receiving ScopeFacetChangeEvents from this AbstractScopeFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier identifying the resource to which the
	 *            NodeChangeEvent relates
	 * @param scope
	 *            The Scope through which this facet's contents are viewed
	 * @param node
	 *            The Node that has been added to or removed from this
	 *            AbstractScopeFacet for the given PCGenIdentifier
	 * @param type
	 *            An identifier indicating whether the given CDOMObject was
	 *            added to or removed from this AbstractScopeFacet
	 */
	@SuppressWarnings(&quot;rawtypes&quot;)
	protected void fireScopeFacetChangeEvent(IDT id, S scope, T node, int type)
	{
<span class="fc bfc" id="L396" title="All 2 branches covered.">		for (ScopeFacetChangeListener&lt;? super IDT, ? super S, ? super T&gt;[] dfclArray : listeners.values())</span>
		{
			/*
			 * This list is decremented from the end of the list to the
			 * beginning in order to maintain consistent operation with how Java
			 * AWT and Swing listeners are notified of Events. This is obviously
			 * subordinate to the priority (loop above).
			 */
<span class="fc" id="L404">			ScopeFacetChangeEvent&lt;IDT, S, T&gt; ccEvent = null;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">			for (int i = dfclArray.length - 1; i &gt;= 0; i--)</span>
			{
				// Lazily create event
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">				if (ccEvent == null)</span>
				{
<span class="fc" id="L410">					ccEvent = new ScopeFacetChangeEvent&lt;&gt;(id, scope, node, this, type);</span>
				}
<span class="fc" id="L412">				ScopeFacetChangeListener dfcl = dfclArray[i];</span>
<span class="pc bpc" id="L413" title="1 of 3 branches missed.">				switch (ccEvent.getEventType())</span>
				{
<span class="fc" id="L415">					case ScopeFacetChangeEvent.DATA_ADDED -&gt; dfcl.dataAdded(ccEvent);</span>
<span class="fc" id="L416">					case ScopeFacetChangeEvent.DATA_REMOVED -&gt; dfcl.dataRemoved(ccEvent);</span>
					default -&gt; {
					}
				}
			}
<span class="fc" id="L421">		}</span>
<span class="fc" id="L422">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>