<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractQualifiedListFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractQualifiedListFacet.java</span></div><h1>AbstractQualifiedListFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2013.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

import pcgen.cdom.base.QualifiedActor;
import pcgen.cdom.base.QualifyingObject;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.facet.FacetLibrary;
import pcgen.cdom.facet.PrerequisiteFacet;
import pcgen.cdom.facet.event.DataFacetChangeEvent;

/**
 * An AbstractQualifiedListFacet is a DataFacet that contains information about
 * QualifyingObjects that are contained in a PlayerCharacter when a
 * PlayerCharacter may have more than one of that type of QualifyingObject (e.g.
 * Language, PCTemplate), the source of that object should be tracked, and the
 * PlayerCharacter can qualify for the object (they have prerequisites)
 * 
 * This class is designed to assume that each QualifyingObject may only be
 * contained one time by the PlayerCharacter, even if received from multiple
 * sources. The QualifyingObject will only trigger one DATA_ADDED event (when
 * added by the first source) and if removed by some sources, will only trigger
 * one DATA_REMOVED event (when it is removed by the last remaining source).
 * Sources do not need to be removed in the order in which they are added, and
 * the first source to be added does not possess special status with respect to
 * triggering a DATA_REMOVED event (it will only trigger removal if it was the
 * last source when removed)
 * 
 * The sources stored in this AbstractQualifiedListFacet are stored as a List,
 * meaning the list of sources may contain the same source multiple times. If
 * so, each call to remove will only remove that source one time from the list
 * of sources.
 * 
 * In general, QualifyingObjects that are stored in an
 * AbstractQualifiedListFacet are those where the Prerequisites are those that
 * are considered requirements. This means that as the Player Character changes,
 * the state of the Prerequisite can change and alter whether the underlying
 * object is granted to the Player Character. For PCGen 5.16, this will mean
 * things like the Prerequisite on the end of an ABILITY token (which are
 * continuously evaluated) not the PRExxx: tokens that appear directly on the
 * line of an Ability in the Ability LST file (those are evaluated only once,
 * when the Ability is first added to the Player Character)
 * 
 * null is a valid source but a valid item to be added to the list of objects
 * stored by AbstractQualifiedListFacet.
 * 
 */
<span class="fc" id="L75">public abstract class AbstractQualifiedListFacet&lt;T extends QualifyingObject&gt; extends AbstractDataFacet&lt;CharID, T&gt;</span>
{

<span class="fc" id="L78">	private PrerequisiteFacet prereqFacet = FacetLibrary.getFacet(PrerequisiteFacet.class);</span>

	/**
	 * Add the given object with the given source to the list of objects stored
	 * in this AbstractQualifiedListFacet for the Player Character represented
	 * by the given CharID
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given item should be added
	 * @param obj
	 *            The object to be added to the list of objects stored in this
	 *            AbstractQualifiedListFacet for the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the given object
	 */
	public void add(CharID id, T obj, Object source)
	{
<span class="fc" id="L97">		Objects.requireNonNull(obj, &quot;Object to add may not be null&quot;);</span>
<span class="fc" id="L98">		Map&lt;T, Set&lt;Object&gt;&gt; map = getConstructingCachedMap(id);</span>
<span class="fc" id="L99">		Set&lt;Object&gt; set = map.get(obj);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">		boolean fireNew = (set == null);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">		if (fireNew)</span>
		{
<span class="fc" id="L103">			set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L104">			map.put(obj, set);</span>
		}
<span class="fc" id="L106">		set.add(source);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">		if (fireNew)</span>
		{
<span class="fc" id="L109">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L111">	}</span>

	/**
	 * Adds all of the objects in the given Collection to the list of objects
	 * stored in this AbstractQualifiedListFacet for the Player Character
	 * represented by the given CharID. All objects are added as if granted with
	 * the given source.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given items should be added
	 * @param c
	 *            The Collection of objects to be added to the list of objects
	 *            stored in this AbstractQualifiedListFacet for the Player
	 *            Character represented by the given CharID
	 * @param source
	 *            The source for the objects in the given Collection
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void addAll(CharID id, Collection&lt;? extends T&gt; c, Object source)
	{
<span class="fc bfc" id="L133" title="All 2 branches covered.">		for (T obj : c)</span>
		{
<span class="fc" id="L135">			add(id, obj, source);</span>
<span class="fc" id="L136">		}</span>
<span class="fc" id="L137">	}</span>

	/**
	 * Removes the given source entry from the list of sources for the given
	 * object stored in this AbstractQualifiedListFacet for the Player Character
	 * represented by the given CharID. If the given source was the only source
	 * for the given object, then the object is removed from the list of objects
	 * stored in this AbstractQualifiedListFacet for the Player Character
	 * represented by the given CharID and a removal event is fired.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given item source should be removed
	 * @param obj
	 *            The object for which the source should be removed
	 * @param source
	 *            The source for the given object to be removed from the list of
	 *            sources.
	 */
	public void remove(CharID id, T obj, Object source)
	{
<span class="fc" id="L158">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc" id="L161">			processRemoval(id, componentMap, obj, source);</span>
		}
<span class="fc" id="L163">	}</span>

	/**
	 * Removes the given source entry from the list of sources for all of the
	 * objects in the given Collection for the Player Character represented by
	 * the given CharID. If the given source was the only source for any of the
	 * objects in the collection, then those objects are removed from the list
	 * of objects stored in this AbstractQualifiedListFacet for the Player
	 * Character represented by the given CharID and a removal event is fired.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given items should be removed
	 * @param c
	 *            The Collection of objects to be removed from the list of
	 *            objects stored in this AbstractQualifiedListFacet for the
	 *            Player Character represented by the given CharID
	 * @param source
	 *            The source for the objects in the given Collection to be
	 *            removed from the list of sources.
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id, Collection&lt;T&gt; c, Object source)
	{
<span class="fc" id="L188">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L191" title="All 2 branches covered.">			for (T obj : c)</span>
			{
<span class="fc" id="L193">				processRemoval(id, componentMap, obj, source);</span>
<span class="fc" id="L194">			}</span>
		}
<span class="fc" id="L196">	}</span>

	/**
	 * Removes all objects (and all sources for those objects) from the list of
	 * objects stored in this AbstractQualifiedListFacet for the Player
	 * Character represented by the given CharID
	 * 
	 * This method is value-semantic in that ownership of the returned Map is
	 * transferred to the class calling this method. Since this is a remove all
	 * function, modification of the returned Map will not modify this
	 * AbstractQualifiedListFacet and modification of this
	 * AbstractQualifiedListFacet will not modify the returned Map.
	 * Modifications to the returned Map will also not modify any future or
	 * previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which all
	 *            items should be removed
	 * @return A non-null Set of objects removed from the list of objects stored
	 *         in this AbstractQualifiedListFacet for the Player Character
	 *         represented by the given CharID
	 */
	public Map&lt;T, Set&lt;Object&gt;&gt; removeAll(CharID id)
	{
<span class="fc" id="L223">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L226">			return Collections.emptyMap();</span>
		}
<span class="fc" id="L228">		removeCache(id);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">		for (T obj : componentMap.keySet())</span>
		{
<span class="fc" id="L231">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L232">		}</span>
<span class="fc" id="L233">		return componentMap;</span>
	}

	/**
	 * Returns a non-null copy of the Set of objects in this
	 * AbstractQualifiedListFacet for the Player Character represented by the
	 * given CharID. This method returns an empty set if no objects are in this
	 * AbstractQualifiedListFacet for the Player Character identified by the
	 * given CharID.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractQualifiedListFacet and
	 * modification of this AbstractQualifiedListFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this AbstractQualifiedListFacet should be returned.
	 * @return A non-null Set of objects in this AbstractQualifiedListFacet for
	 *         the Player Character represented by the given CharID
	 */
	public Set&lt;T&gt; getSet(CharID id)
	{
<span class="fc" id="L261">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L264">			return Collections.emptySet();</span>
		}
<span class="fc" id="L266">		return Collections.unmodifiableSet(componentMap.keySet());</span>
	}

	/**
	 * Returns the count of items in this AbstractQualifiedListFacet for the
	 * Player Character represented by the given CharID
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            count of items should be returned
	 * @return The count of items in this AbstractQualifiedListFacet for the
	 *         Player Character represented by the given CharID
	 */
	public int getCount(CharID id)
	{
<span class="fc" id="L281">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L284">			return 0;</span>
		}
<span class="fc" id="L286">		return componentMap.size();</span>
	}

	/**
	 * Returns true if this AbstractQualifiedListFacet does not contain any
	 * items for the Player Character represented by the given CharID
	 * 
	 * @param id
	 *            The CharId representing the PlayerCharacter to test if any
	 *            items are contained by this AbstractsSourcedListFacet
	 * @return true if this AbstractQualifiedListFacet does not contain any
	 *         items for the Player Character represented by the given CharID;
	 *         false otherwise (if it does contain items for the Player
	 *         Character)
	 */
	public boolean isEmpty(CharID id)
	{
<span class="fc" id="L303">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L304" title="All 4 branches covered.">		return componentMap == null || componentMap.isEmpty();</span>
	}

	/**
	 * Returns true if this AbstractQualifiedListFacet contains the given value
	 * in the list of items for the Player Character represented by the given
	 * CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character used for testing
	 * @param obj
	 *            The object to test if this AbstractQualifiedListFacet contains
	 *            that item for the Player Character represented by the given
	 *            CharID
	 * @return true if this AbstractQualifiedListFacet contains the given value
	 *         for the Player Character represented by the given CharID; false
	 *         otherwise
	 */
	public boolean contains(CharID id, T obj)
	{
		/*
		 * TODO obj == null? - log an error?
		 * 
		 * This should share behavior with AbstractListFacet
		 */
<span class="fc" id="L329">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">		return componentMap != null &amp;&amp; componentMap.containsKey(obj);</span>
	}

	/**
	 * Returns a Set of sources for this AbstractQualifiedListFacet, the
	 * PlayerCharacter represented by the given CharID, and the given object.
	 * Will add the given object to the list of items for the PlayerCharacter
	 * represented by the given CharID and will return a new, empty Set if no
	 * information has been set in this AbstractQualifiedListFacet for the given
	 * CharID and given object. Will not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Set object is owned by
	 * AbstractQualifiedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID for which the Set should be returned
	 * @param obj
	 *            The object for which the Set of sources should be returned
	 * @return The Set of sources for the given object and Player Character
	 *         represented by the given CharID.
	 */
	private Set&lt;Object&gt; getConstructingCachedSetFor(CharID id, T obj)
	{
<span class="fc" id="L355">		Map&lt;T, Set&lt;Object&gt;&gt; map = getConstructingCachedMap(id);</span>
<span class="fc" id="L356">		Set&lt;Object&gt; set = map.get(obj);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (set == null)</span>
		{
<span class="fc" id="L359">			set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L360">			map.put(obj, set);</span>
		}
<span class="fc" id="L362">		return set;</span>
	}

	/**
	 * Returns the type-safe Map for this AbstractQualifiedListFacet and the
	 * given CharID. May return null if no information has been set in this
	 * AbstractQualifiedListFacet for the given CharID.
	 * 
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * AbstractQualifiedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID for which the Set should be returned
	 * @return The Set for the Player Character represented by the given CharID;
	 *         null if no information has been set in this
	 *         AbstractQualifiedListFacet for the Player Character.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private Map&lt;T, Set&lt;Object&gt;&gt; getCachedMap(CharID id)
	{
<span class="fc" id="L384">		return (Map&lt;T, Set&lt;Object&gt;&gt;) getCache(id);</span>
	}

	/**
	 * Returns a type-safe Map for this AbstractQualifiedListFacet and the given
	 * CharID. Will return a new, empty Map if no information has been set in
	 * this AbstractQualifiedListFacet for the given CharID. Will not return
	 * null.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractQualifiedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID for which the Map should be returned
	 * @return The Map for the Player Character represented by the given CharID.
	 */
	private Map&lt;T, Set&lt;Object&gt;&gt; getConstructingCachedMap(CharID id)
	{
<span class="fc" id="L404">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L407">			componentMap = getComponentMap();</span>
<span class="fc" id="L408">			setCache(id, componentMap);</span>
		}
<span class="fc" id="L410">		return componentMap;</span>
	}

	/**
	 * Returns a new (empty) Map for this AbstractQualifiedListFacet. Can be
	 * overridden by classes that extend AbstractQualifiedListFacet if a Map
	 * other than an IdentityHashMap is desired for storing the information in
	 * the AbstractQualifiedListFacet.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractQualifiedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractQualifiedListFacet.
	 * 
	 * Note that this method should always be the only method used to construct
	 * a Map for this AbstractQualifiedListFacet. It is actually preferred to
	 * use getConstructingCacheMap(CharID) in order to implicitly call this
	 * method.
	 * 
	 * @return A new (empty) Map for use in this AbstractQualifiedListFacet.
	 */
	protected Map&lt;T, Set&lt;Object&gt;&gt; getComponentMap()
	{
<span class="fc" id="L433">		return new IdentityHashMap&lt;&gt;();</span>
	}

	/**
	 * Copies the contents of the AbstractQualifiedListFacet from one Player
	 * Character to another Player Character, based on the given CharIDs
	 * representing those Player Characters.
	 * 
	 * This is a method in AbstractQualifiedListFacet in order to avoid exposing
	 * the mutable Map object to other classes. This should not be inlined, as
	 * the Map is internal information to AbstractQualifiedListFacet and should
	 * not be exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the Player Characters represented by the given CharIDs (meaning
	 * once this copy takes place, any change to the AbstractQualifiedListFacet
	 * of one Player Character will only impact the Player Character where the
	 * AbstractQualifiedListFacet was changed).
	 * 
	 * @param source
	 *            The CharID representing the Player Character from which the
	 *            information should be copied
	 * @param destination
	 *            The CharID representing the Player Character to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(CharID source, CharID destination)
	{
<span class="fc" id="L462">		Map&lt;T, Set&lt;Object&gt;&gt; sourceMap = getCachedMap(source);</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">		if (sourceMap != null)</span>
		{
<span class="fc bfc" id="L465" title="All 2 branches covered.">			for (Map.Entry&lt;T, Set&lt;Object&gt;&gt; me : sourceMap.entrySet())</span>
			{
<span class="fc" id="L467">				T obj = me.getKey();</span>
<span class="fc" id="L468">				Set&lt;Object&gt; sourceSet = me.getValue();</span>
<span class="fc" id="L469">				Set&lt;Object&gt; targetSet = getConstructingCachedSetFor(destination, obj);</span>
<span class="fc" id="L470">				targetSet.addAll(sourceSet);</span>
<span class="fc" id="L471">			}</span>
		}
<span class="fc" id="L473">	}</span>

	/**
	 * This method implements removal of a source for an object contained by
	 * this AbstractQualifiedListFacet. This implements the actual check that
	 * determines if the given source was the only source for the given object.
	 * If so, then that object is removed from the list of objects stored in
	 * this AbstractQualifiedListFacet for the Player Character represented by
	 * the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character which may have
	 *            the given item removed.
	 * @param componentMap
	 *            The (private) Map for this AbstractQualifiedListFacet that
	 *            will as least have the given source removed from the list for
	 *            the given object.
	 * @param obj
	 *            The object which may be removed if the given source is the
	 *            only source for this object in the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the given object to be removed from the list of
	 *            sources for that object
	 */
	private void processRemoval(CharID id, Map&lt;T, Set&lt;Object&gt;&gt; componentMap, T obj, Object source)
	{
<span class="fc" id="L500">		Objects.requireNonNull(obj, &quot;Object to remove may not be null&quot;);</span>
<span class="fc" id="L501">		Set&lt;Object&gt; set = componentMap.get(obj);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">		if (set != null)</span>
		{
<span class="fc" id="L504">			set.remove(source);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">			if (set.isEmpty())</span>
			{
<span class="fc" id="L507">				componentMap.remove(obj);</span>
<span class="fc" id="L508">				fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
			}
		}
<span class="fc" id="L511">	}</span>

	/**
	 * Removes all information for the given source from this
	 * AbstractQualifiedListFacet for the PlayerCharacter represented by the
	 * given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which items
	 *            from the given source will be removed
	 * @param source
	 *            The source for the objects to be removed from the list of
	 *            items stored for the Player Character identified by the given
	 *            CharID
	 */
	public void removeAll(CharID id, Object source)
	{
<span class="fc" id="L528">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
			/*
			 * This list exists primarily to eliminate the possibility of a
			 * concurrent modification exception on a recursive remove
			 */
<span class="fc" id="L535">			List&lt;T&gt; removedKeys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">			for (Iterator&lt;Map.Entry&lt;T, Set&lt;Object&gt;&gt;&gt; it = componentMap.entrySet().iterator(); it.hasNext();)</span>
			{
<span class="fc" id="L538">				Entry&lt;T, Set&lt;Object&gt;&gt; me = it.next();</span>
<span class="fc" id="L539">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="fc bfc" id="L540" title="All 4 branches covered.">				if (set.remove(source) &amp;&amp; set.isEmpty())</span>
				{
<span class="fc" id="L542">					T obj = me.getKey();</span>
<span class="fc" id="L543">					it.remove();</span>
<span class="fc" id="L544">					removedKeys.add(obj);</span>
				}
<span class="fc" id="L546">			}</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">			if (componentMap.isEmpty())</span>
			{
<span class="nc" id="L549">				removeCache(id);</span>
			}
<span class="fc bfc" id="L551" title="All 2 branches covered.">			for (T obj : removedKeys)</span>
			{
<span class="fc" id="L553">				fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L554">			}</span>
		}
<span class="fc" id="L556">	}</span>

	/**
	 * Returns a non-null copy of the Set of objects in this
	 * AbstractQualifiedListFacet for the Player Character represented by the
	 * given CharID and the given source. This method returns an empty set if no
	 * objects are in this AbstractQualifiedListFacet for the Player Character
	 * identified by the given CharID and source.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractQualifiedListFacet and
	 * modification of this AbstractQualifiedListFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this AbstractQualifiedListFacet should be returned.
	 * @param owner
	 *            The source object for which a copy of the List of objects in
	 *            this AbstractQualifiedListFacet should be returned.
	 * @return A non-null Set of objects in this AbstractQualifiedListFacet for
	 *         the Player Character represented by the given CharID
	 */
	public List&lt;? extends T&gt; getSet(CharID id, Object owner)
	{
<span class="fc" id="L586">		List&lt;T&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L587">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L590" title="All 2 branches covered.">			for (Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L592">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">				if (set.contains(owner))</span>
				{
<span class="fc" id="L595">					list.add(me.getKey());</span>
				}
<span class="fc" id="L597">			}</span>
		}
<span class="fc" id="L599">		return list;</span>
	}

	/**
	 * Returns a non-null copy of the Set of objects the character qualifies for
	 * in this AbstractQualifiedListFacet for the Player Character represented
	 * by the given CharID. This method returns an empty set if the Player
	 * Character identified by the given CharID qualifies for none of the
	 * objects in this AbstractQualifiedListFacet.
	 * 
	 * This method is value-semantic in that ownership of the returned
	 * Collection is transferred to the class calling this method. Modification
	 * of the returned Collection will not modify this
	 * AbstractQualifiedListFacet and modification of this
	 * AbstractQualifiedListFacet will not modify the returned Collection.
	 * Modifications to the returned Collection will also not modify any future
	 * or previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this AbstractQualifiedListFacet should be returned.
	 * @return A non-null Set of objects the Player Character represented by the
	 *         given CharID qualifies for in this AbstractQualifiedListFacet
	 */
	public Collection&lt;T&gt; getQualifiedSet(CharID id)
	{
<span class="fc" id="L628">		Set&lt;T&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc" id="L629">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L632" title="All 2 branches covered.">			for (Map.Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L634">				T obj = me.getKey();</span>
<span class="fc" id="L635">				Set&lt;Object&gt; sources = me.getValue();</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">				for (Object source : sources)</span>
				{
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">					if (prereqFacet.qualifies(id, obj, source))</span>
					{
<span class="fc" id="L640">						set.add(obj);</span>
<span class="fc" id="L641">						break;</span>
					}
<span class="nc" id="L643">				}</span>
<span class="fc" id="L644">			}</span>
		}
<span class="fc" id="L646">		return set;</span>
	}

	/**
	 * Returns a non-null copy of the Set of objects the character qualifies for
	 * in this AbstractQualifiedListFacet for the Player Character represented
	 * by the given CharID and the given source. This method returns an empty
	 * set if the Player Character identified by the given CharID qualifies for
	 * none of the objects in this AbstractQualifiedListFacet granted by the
	 * given source.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractQualifiedListFacet and
	 * modification of this AbstractQualifiedListFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * Generally, use of this method is discouraged in general operational
	 * aspects. However, it is recognized that certain output tokens can list
	 * certain items by source, and thus this method is required, and it is
	 * unreasonable to expect complete elimination of this method or entirely
	 * prohibit future use of this method.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this AbstractQualifiedListFacet should be returned.
	 * @param source
	 *            The source object for which a copy of the List of objects the
	 *            Player Character qualifies for should be returned.
	 * @return A non-null Set of objects the Player Character represented by the
	 *         given CharID qualifies for in this AbstractQualifiedListFacet
	 */
	public Collection&lt;T&gt; getQualifiedSet(CharID id, Object source)
	{
<span class="fc" id="L684">		Set&lt;T&gt; set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L685">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L688" title="All 2 branches covered.">			for (Map.Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L690">				T obj = me.getKey();</span>
<span class="fc" id="L691">				Set&lt;Object&gt; sources = me.getValue();</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">				if (sources.contains(source))</span>
				{
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">					if (prereqFacet.qualifies(id, obj, source))</span>
					{
<span class="fc" id="L696">						set.add(obj);</span>
					}
				}
<span class="fc" id="L699">			}</span>
		}
<span class="fc" id="L701">		return set;</span>
	}

	/**
	 * Acts on the Set of objects the character qualifies for in this
	 * AbstractQualifiedListFacet for the Player Character represented by the
	 * given CharID. The results of each action as provided by the given
	 * QualifiedActor are returned in a non-null List.
	 * 
	 * This method returns an empty List if the Player Character identified by
	 * the given CharID qualifies for none of the objects in this
	 * AbstractQualifiedListFacet.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractQualifiedListFacet and
	 * modification of this AbstractQualifiedListFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractQualifiedListFacet. If you wish to modify the information stored
	 * in this AbstractQualifiedListFacet, you must use the add*() and remove*()
	 * methods of AbstractQualifiedListFacet.
	 * 
	 * Note: If a particular item has been granted by more than one source, then
	 * the QualifiedActor will only be called for the first source that
	 * (successfully grants) the underlying object.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this AbstractQualifiedListFacet should be returned.
	 * @param qa
	 *            The QualifiedActor which will act on each of the items in this
	 *            AbstractQualifiedListFacet for which the Player Character
	 *            qualifies.
	 * @return A non-null List of objects created by the QualifiedActor from
	 *         each of the objects in this AbstractQualifiedListFacet for which
	 *         the Player Character qualifies.
	 */
	public &lt;R&gt; List&lt;R&gt; actOnQualifiedSet(CharID id, QualifiedActor&lt;T, R&gt; qa)
	{
<span class="fc" id="L741">		List&lt;R&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L742">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L745" title="All 2 branches covered.">			for (Map.Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L747">				T obj = me.getKey();</span>
<span class="fc" id="L748">				Set&lt;Object&gt; sources = me.getValue();</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">				for (Object source : sources)</span>
				{
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">					if (prereqFacet.qualifies(id, obj, source))</span>
					{
<span class="fc" id="L753">						list.add(qa.act(obj, source));</span>
					}
<span class="fc" id="L755">				}</span>
<span class="fc" id="L756">			}</span>
		}
<span class="fc" id="L758">		return list;</span>
	}

	public Collection&lt;Object&gt; getSources(CharID id, T obj)
	{
<span class="nc" id="L763">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc" id="L766">			Set&lt;Object&gt; sources = componentMap.get(obj);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">			if (sources != null)</span>
			{
<span class="nc" id="L769">				return Collections.unmodifiableSet(sources);</span>
			}
		}
<span class="nc" id="L772">		return Collections.emptySet();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>