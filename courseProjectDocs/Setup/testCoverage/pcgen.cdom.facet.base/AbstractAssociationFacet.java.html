<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractAssociationFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractAssociationFacet.java</span></div><h1>AbstractAssociationFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2012.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import pcgen.base.util.ListSet;
import pcgen.cdom.base.PCGenIdentifier;
import pcgen.cdom.facet.event.DataFacetChangeEvent;

/**
 * An AbstractAssociationFacet is a DataFacet that contains information about
 * associations for Objects.
 * 
 * This is used when each source may only have one association (such as
 * associating hit points to a class level), although the target can be a class
 * that can store multiple pieces of information in some implementations.
 * 
 * If the source object (e.g. the class level) is re-added with a second
 * association, this will overwrite the original association.
 * 
 * null is NOT a valid source.
 * 
 * null is NOT a valid base object or association.
 */
<span class="fc" id="L45">public abstract class AbstractAssociationFacet&lt;IDT extends PCGenIdentifier, S, A&gt; extends AbstractScopeFacet&lt;IDT, S, A&gt;</span>
{

	/**
	 * Gets the association for the item identified by the given PCGenIdentifier
	 * and the given source object.
	 * 
	 * @param id
	 *            The PCGenIdentifier identifying the item for which the
	 *            association get is being performed.
	 * @param obj
	 *            The source object for which the association get is being
	 *            performed.
	 * @return The association for the item (identified by the given
	 *         PCGenIdentifier) and the given source object
	 */
	public A get(IDT id, S obj)
	{
<span class="fc" id="L63">		Objects.requireNonNull(obj, &quot;Object for getting association may not be null&quot;);</span>
<span class="fc" id="L64">		Map&lt;S, A&gt; map = getCachedMap(id);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		if (map != null)</span>
		{
<span class="fc" id="L67">			return map.get(obj);</span>
		}
<span class="fc" id="L69">		return null;</span>
	}

	/**
	 * Set the given association for the given object in this
	 * AbstractAssociationFacet for the item represented by the given
	 * PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item for which the given
	 *            association should be made
	 * @param obj
	 *            The object for which the association will be set
	 * @param association
	 *            The association for the given object
	 */
	public void set(IDT id, S obj, A association)
	{
<span class="fc" id="L87">		Objects.requireNonNull(obj, &quot;Object to add may not be null&quot;);</span>
<span class="fc" id="L88">		Objects.requireNonNull(association, &quot;Association may not be null&quot;);</span>
<span class="fc" id="L89">		A old = getConstructingCachedMap(id).put(obj, association);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">		if (old != null)</span>
		{
<span class="fc" id="L92">			fireScopeFacetChangeEvent(id, obj, old, DataFacetChangeEvent.DATA_REMOVED);</span>
		}
<span class="fc" id="L94">		fireScopeFacetChangeEvent(id, obj, association, DataFacetChangeEvent.DATA_ADDED);</span>
<span class="fc" id="L95">	}</span>

	/**
	 * Removes the association for the given source object in this
	 * AbstractAssociationFacet for the item represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item from which the given
	 *            item association should be removed
	 * @param obj
	 *            The object for which the association should be removed
	 */
	public void remove(IDT id, S obj)
	{
<span class="fc" id="L110">		Map&lt;S, A&gt; map = getCachedMap(id);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (map != null)</span>
		{
<span class="fc" id="L113">			A old = map.remove(obj);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (old != null)</span>
			{
				// Only send out notifications if we really removed something.
<span class="fc" id="L117">				fireScopeFacetChangeEvent(id, obj, old, DataFacetChangeEvent.DATA_REMOVED);</span>
			}
		}
<span class="fc" id="L120">	}</span>

	/**
	 * Removes all objects (and all associations for those objects) from the
	 * list of objects stored in this AbstractAssociationFacet for the Player
	 * Character represented by the given PCGenIdentifier
	 * 
	 * This method is value-semantic in that ownership of the returned Map is
	 * transferred to the class calling this method. Since this is a remove all
	 * function, modification of the returned Map will not modify this
	 * AbstractAssociationFacet and modification of this
	 * AbstractAssociationFacet will not modify the returned Map. Modifications
	 * to the returned List will also not modify any future or previous objects
	 * returned by this (or other) methods on AbstractAssociationFacet. If you
	 * wish to modify the information stored in this AbstractAssociationFacet,
	 * you must use the add*() and remove*() methods of
	 * AbstractAssociationFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item from which all items
	 *            should be removed
	 * @return A non-null Map of objects to their associations that were removed
	 *         from this AbstractAssociationFacet for the item represented by
	 *         the given PCGenIdentifier
	 */
	public Map&lt;S, A&gt; removeAll(IDT id)
	{
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L148">		Map&lt;S, A&gt; componentMap = (Map&lt;S, A&gt;) removeCache(id);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L151">			return Collections.emptyMap();</span>
		}
<span class="fc bfc" id="L153" title="All 2 branches covered.">		for (Map.Entry&lt;S, A&gt; entry : componentMap.entrySet())</span>
		{
<span class="fc" id="L155">			fireScopeFacetChangeEvent(id, entry.getKey(), entry.getValue(), DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L156">		}</span>
<span class="fc" id="L157">		return componentMap;</span>
	}

	/**
	 * Returns a non-null copy of the Set of objects in this
	 * AbstractAssociationFacet for the item represented by the given
	 * PCGenIdentifier. This method returns an empty set if no objects are in
	 * this AbstractAssociationFacet for the item identified by the given
	 * PCGenIdentifier.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractAssociationFacet and
	 * modification of this AbstractAssociationFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractAssociationFacet. If you wish to modify the information stored in
	 * this AbstractAssociationFacet, you must use the add*() and remove*()
	 * methods of AbstractAssociationFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item for which the items
	 *            in this AbstractAssociationFacet should be returned.
	 * @return A non-null copy of the Set of objects in this
	 *         AbstractAssociationFacet for the item represented by the given
	 *         PCGenIdentifier
	 */
	public Set&lt;S&gt; getSet(IDT id)
	{
<span class="fc" id="L186">		Map&lt;S, A&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L189">			return Collections.emptySet();</span>
		}
<span class="fc" id="L191">		return Collections.unmodifiableSet(new ListSet&lt;&gt;(componentMap.keySet()));</span>
	}

	/**
	 * Returns the count of items {@literal (objects -&gt; association entries)} in this
	 * AbstractAssociationFacet for the item represented by the given
	 * PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item for which the count
	 *            of items should be returned
	 * @return The count of items (objects and thus also associations) in this
	 *         AbstractAssociationFacet for the item represented by the given
	 *         PCGenIdentifier
	 */
	public int getCount(IDT id)
	{
<span class="fc" id="L208">		Map&lt;S, A&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L211">			return 0;</span>
		}
<span class="fc" id="L213">		return componentMap.size();</span>
	}

	/**
	 * Returns true if this AbstractAssociationFacet does not contain any items
	 * for the item represented by the given PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the PlayerCharacter to test
	 *            if any items are contained by this AbstractsSourcedListFacet
	 * @return true if this AbstractAssociationFacet does not contain any items
	 *         for the item represented by the given PCGenIdentifier; false
	 *         otherwise (if it does contain items for the item)
	 */
	public boolean isEmpty(IDT id)
	{
<span class="fc" id="L229">		Map&lt;S, A&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L230" title="All 4 branches covered.">		return (componentMap == null) || componentMap.isEmpty();</span>
	}

	/**
	 * Returns true if this AbstractAssociationFacet contains the given source
	 * in the list of items for the item represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the item used for testing
	 * @param obj
	 *            The source object to test if this AbstractAssociationFacet
	 *            contains an association for that item for the item represented
	 *            by the given PCGenIdentifier
	 * @return true if this AbstractAssociationFacet contains an association for
	 *         the given source for the item represented by the given
	 *         PCGenIdentifier; false otherwise
	 */
	public boolean contains(IDT id, S obj)
	{
<span class="fc" id="L250">		Map&lt;S, A&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L251" title="All 4 branches covered.">		return (componentMap != null) &amp;&amp; componentMap.containsKey(obj);</span>
	}

	/**
	 * Returns the type-safe Map for this AbstractAssociationFacet and the given
	 * PCGenIdentifier. May return null if no information has been set in this
	 * AbstractAssociationFacet for the given PCGenIdentifier.
	 * 
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * AbstractAssociationFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractAssociationFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier for which the Map should be returned
	 * @return The Map for the item represented by the given PCGenIdentifier;
	 *         null if no information has been set in this
	 *         AbstractAssociationFacet for the item.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Map&lt;S, A&gt; getCachedMap(IDT id)
	{
<span class="fc" id="L273">		return (Map&lt;S, A&gt;) getCache(id);</span>
	}

	/**
	 * Returns a type-safe Map for this AbstractAssociationFacet and the given
	 * PCGenIdentifier. Will return a new, empty Map if no information has been
	 * set in this AbstractAssociationFacet for the given PCGenIdentifier. Will
	 * not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractAssociationFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractAssociationFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier for which the Map should be returned
	 * @return The Map for the item represented by the given PCGenIdentifier.
	 */
	private Map&lt;S, A&gt; getConstructingCachedMap(IDT id)
	{
<span class="fc" id="L293">		Map&lt;S, A&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L296">			componentMap = getComponentMap();</span>
<span class="fc" id="L297">			setCache(id, componentMap);</span>
		}
<span class="fc" id="L299">		return componentMap;</span>
	}

	/**
	 * Returns a new (empty) Map for this AbstractAssociationFacet. Can be
	 * overridden by classes that extend AbstractAssociationFacet if a Map other
	 * than an IdentityHashMap is desired for storing the information in the
	 * AbstractAssociationFacet.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractAssociationFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractAssociationFacet.
	 * 
	 * Note that this method should always be the only method used to construct
	 * a Map for this AbstractAssociationFacet. It is actually preferred to use
	 * getConstructingCacheMap(PCGenIdentifier) in order to implicitly call this
	 * method.
	 * 
	 * @return A new (empty) Map for use in this AbstractAssociationFacet.
	 */
	protected Map&lt;S, A&gt; getComponentMap()
	{
<span class="fc" id="L322">		return new IdentityHashMap&lt;&gt;();</span>
	}

	/**
	 * Copies the contents of the AbstractAssociationFacet from one Player
	 * Character to another item, based on the given PCGenIdentifiers
	 * representing those items.
	 * 
	 * This is a method in AbstractAssociationFacet in order to avoid exposing
	 * the mutable Map object to other classes. This should not be inlined, as
	 * the Map is internal information to AbstractAssociationFacet and should
	 * not be exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the items represented by the given PCGenIdentifiers (meaning once
	 * this copy takes place, any change to the AbstractAssociationFacet of one
	 * item will only impact the item where the AbstractAssociationFacet was
	 * changed).
	 * 
	 * @param source
	 *            The PCGenIdentifier representing the item from which the
	 *            information should be copied
	 * @param destination
	 *            The PCGenIdentifier representing the item to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(IDT source, IDT destination)
	{
<span class="fc" id="L351">		Map&lt;S, A&gt; sourceMap = getCachedMap(source);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">		if (sourceMap != null)</span>
		{
<span class="fc" id="L354">			getConstructingCachedMap(destination).putAll(sourceMap);</span>
		}
<span class="fc" id="L356">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>