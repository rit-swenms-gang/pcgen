<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractItemConvertingFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractItemConvertingFacet.java</span></div><h1>AbstractItemConvertingFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2010-14.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.Collection;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.facet.event.DataFacetChangeEvent;

/**
 * An AbstractItemConvertingFacet is a DataFacet that converts information from
 * one type to another when the source of that object should be tracked.
 * 
 * This class is designed to assume that each original object may only be
 * contained one time by the PlayerCharacter, even if received from multiple
 * sources. The original object will only trigger one DATA_ADDED event (when
 * added by the first source) and if removed by some sources, will only trigger
 * one DATA_REMOVED event (when it is removed by the last remaining source).
 * Sources do not need to be removed in the order in which they are added, and
 * the first source to be added does not possess special status with respect to
 * triggering a DATA_REMOVED event (it will only trigger removal if it was the
 * last source when removed)
 * 
 * The sources stored in this AbstractItemConvertingFacet are stored as a List,
 * meaning the list of sources may contain the same source multiple times. If
 * so, each call to remove will only remove that source one time from the list
 * of sources.
 * 
 * Note: There is no requirement that the conversion process is reversible. In
 * other words, more than once source object may produce the same (or equal)
 * destination objects.
 * 
 * null is a valid source.
 * 
 */
<span class="fc" id="L58">public abstract class AbstractItemConvertingFacet&lt;S, D&gt; extends AbstractDataFacet&lt;CharID, D&gt;</span>
{
	/**
	 * Add the converted version of the given object with the given source to
	 * the list of (converted) objects stored in this
	 * AbstractItemConvertingFacet for the Player Character represented by the
	 * given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given item should be added
	 * @param obj
	 *            The object for which the converted version will be added to
	 *            the list of (converted) objects stored in this
	 *            AbstractItemConvertingFacet for the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the given object
	 */
	public void add(CharID id, S obj, Object source)
	{
<span class="fc" id="L79">		Objects.requireNonNull(obj, &quot;Object to add may not be null&quot;);</span>
<span class="fc" id="L80">		Target target = getConstructingCachedSetFor(id, obj);</span>
<span class="fc" id="L81">		target.set.add(source);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">		if (target.dest == null)</span>
		{
<span class="fc" id="L84">			target.dest = convert(obj);</span>
<span class="fc" id="L85">			fireDataFacetChangeEvent(id, target.dest, DataFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L87">	}</span>

	/**
	 * Adds conversions of all of the objects in the given Collection to the
	 * list of (converted) objects stored in this AbstractItemConvertingFacet
	 * for the Player Character represented by the given CharID. All items are
	 * added with the given source.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given items should be added
	 * @param c
	 *            The Collection of objects for which the converted versions
	 *            will be added to the list of objects stored in this
	 *            AbstractItemConvertingFacet for the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the given objects in the collection
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void addAll(CharID id, Collection&lt;? extends S&gt; c, Object source)
	{
<span class="nc bnc" id="L110" title="All 2 branches missed.">		for (S obj : c)</span>
		{
<span class="nc" id="L112">			add(id, obj, source);</span>
<span class="nc" id="L113">		}</span>
<span class="nc" id="L114">	}</span>

	/**
	 * Removes the given source entry from the list of sources for conversion of
	 * the given object stored in this AbstractItemConvertingFacet for the
	 * Player Character represented by the given CharID. If the given source was
	 * the only source for the given object, then the converted object is
	 * removed from the list of objects stored in this
	 * AbstractItemConvertingFacet for the Player Character represented by the
	 * given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given item source should be removed
	 * @param obj
	 *            The object for which the source should be removed from the
	 *            converted version of that object
	 * @param source
	 *            The source for the given object is to be removed from the list
	 *            of sources for the converted version of the given object
	 */
	public void remove(CharID id, S obj, Object source)
	{
<span class="fc" id="L137">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="fc" id="L140">			processRemoval(id, componentMap, obj, source);</span>
		}
<span class="fc" id="L142">	}</span>

	/**
	 * Removes the given source entry from the list of sources for the converted
	 * version of all of the objects in the given Collection for the Player
	 * Character represented by the given CharID. If the given source was the
	 * only source for any of the (converted) objects in the collection, then
	 * those objects are removed from the list of objects stored in this
	 * AbstractItemConvertingFacet for the Player Character represented by the
	 * given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given items should be removed
	 * @param c
	 *            The Collection of objects for which the conversions will be
	 *            removed from the list of objects stored in this
	 *            AbstractItemConvertingFacet for the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the objects in the given Collection to be
	 *            removed from the list of sources
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id, Collection&lt;S&gt; c, Object source)
	{
<span class="nc" id="L169">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc bnc" id="L172" title="All 2 branches missed.">			for (S obj : c)</span>
			{
<span class="nc" id="L174">				processRemoval(id, componentMap, obj, source);</span>
<span class="nc" id="L175">			}</span>
		}
<span class="nc" id="L177">	}</span>

	/**
	 * Removes all converted objects (and all sources for those objects) from
	 * the list of objects stored in this AbstractItemConvertingFacet for the
	 * Player Character represented by the given CharID.
	 * 
	 * This method is value-semantic in that ownership of the returned Map is
	 * transferred to the class calling this method. Since this is a remove all
	 * function, modification of the returned Map will not modify this
	 * AbstractItemConvertingFacet and modification of this
	 * AbstractItemConvertingFacet will not modify the returned Map.
	 * Modifications to the returned Map will also not modify any future or
	 * previous objects returned by this (or other) methods on
	 * AbstractItemConvertingFacet. If you wish to modify the information stored
	 * in this AbstractItemConvertingFacet, you must use the add*() and
	 * remove*() methods of AbstractItemConvertingFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which all
	 *            items should be removed
	 * @return A non-null Map of converted object mapped to their sources, all
	 *         of which were removed from the list of original objects stored in
	 *         this AbstractItemConvertingFacet for the Player Character
	 *         represented by the given CharID
	 */
	public Map&lt;S, Target&gt; removeAll(CharID id)
	{
<span class="nc" id="L205">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L208">			return Collections.emptyMap();</span>
		}
<span class="nc" id="L210">		removeCache(id);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">		for (Target tgt : componentMap.values())</span>
		{
<span class="nc" id="L213">			fireDataFacetChangeEvent(id, tgt.dest, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="nc" id="L214">		}</span>
<span class="nc" id="L215">		return componentMap;</span>
	}

	/**
	 * Returns the count of (non-equal) original objects in this
	 * AbstractItemConvertingFacet for the Player Character represented by the
	 * given CharID.
	 * 
	 * Note: This does not necessarily return the count of the number of
	 * (non-equal) converted objects added. It may, but it will do so if and
	 * only if the conversion process can not produce identical conversion
	 * targets from two unequal sources.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            count of items should be returned
	 * @return The count of converted objects in this
	 *         AbstractItemConvertingFacet for the Player Character represented
	 *         by the given CharID
	 */
	public int getCount(CharID id)
	{
<span class="nc" id="L237">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L240">			return 0;</span>
		}
<span class="nc" id="L242">		return componentMap.size();</span>
	}

	/**
	 * Returns true if this AbstractItemConvertingFacet does not contain any
	 * items for the Player Character represented by the given CharID.
	 * 
	 * @param id
	 *            The CharId representing the PlayerCharacter to test if any
	 *            items are contained by this AbstractsSourcedListFacet
	 * @return true if this AbstractItemConvertingFacet does not contain any
	 *         items for the Player Character represented by the given CharID;
	 *         false otherwise (if it does contain items for the Player
	 *         Character)
	 */
	public boolean isEmpty(CharID id)
	{
<span class="nc" id="L259">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">		return (componentMap == null) || componentMap.isEmpty();</span>
	}

	/**
	 * Returns true if this AbstractItemConvertingFacet was provided with the
	 * given source object to be converted and stored in the list of items for
	 * the Player Character represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character used for testing
	 * @param obj
	 *            The object to test if this AbstractItemConvertingFacet
	 *            contains that original item for the Player Character
	 *            represented by the given CharID
	 * @return true if this AbstractItemConvertingFacet was provided with the
	 *         given source object to be converted and stored in the list of
	 *         items for the Player Character represented by the given CharID;
	 *         false otherwise
	 */
	public boolean contains(CharID id, S obj)
	{
<span class="nc" id="L281">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">		return (componentMap != null) &amp;&amp; componentMap.containsKey(obj);</span>
	}

	/**
	 * Returns a Target storage object for this AbstractItemConvertingFacet, the
	 * PlayerCharacter represented by the given CharID, and the given source
	 * object. Will add the given object to the list of items for the
	 * PlayerCharacter represented by the given CharID and will return a new,
	 * empty Target object if no information has been set in this
	 * AbstractItemConvertingFacet for the given CharID and given object. Will
	 * not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Set object is owned by
	 * AbstractItemConvertingFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractItemConvertingFacet.
	 * 
	 * @param id
	 *            The CharID for which the Target should be returned
	 * @param obj
	 *            The object for which the Target should be returned
	 * @return The Target object for the given object and Player Character
	 *         represented by the given CharID.
	 */
	private Target getConstructingCachedSetFor(CharID id, S obj)
	{
<span class="fc" id="L308">		Map&lt;S, Target&gt; map = getConstructingCachedMap(id);</span>
<span class="fc" id="L309">		Target target = map.get(obj);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">		if (target == null)</span>
		{
<span class="fc" id="L312">			target = new Target();</span>
<span class="fc" id="L313">			map.put(obj, target);</span>
		}
<span class="fc" id="L315">		return target;</span>
	}

	/**
	 * Returns the type-safe Map for this AbstractItemConvertingFacet and the
	 * given CharID. May return null if no information has been set in this
	 * AbstractItemConvertingFacet for the given CharID.
	 * 
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * AbstractItemConvertingFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractItemConvertingFacet.
	 * 
	 * @param id
	 *            The CharID for which the Set should be returned
	 * @return The Set for the Player Character represented by the given CharID;
	 *         null if no information has been set in this
	 *         AbstractItemConvertingFacet for the Player Character.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Map&lt;S, Target&gt; getCachedMap(CharID id)
	{
<span class="fc" id="L337">		return (Map&lt;S, Target&gt;) getCache(id);</span>
	}

	/**
	 * Returns a type-safe Map for this AbstractItemConvertingFacet and the
	 * given CharID. Will return a new, empty Map if no information has been set
	 * in this AbstractItemConvertingFacet for the given CharID. Will not return
	 * null.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractItemConvertingFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractItemConvertingFacet.
	 * 
	 * @param id
	 *            The CharID for which the Map should be returned
	 * @return The Map for the Player Character represented by the given CharID.
	 */
	private Map&lt;S, Target&gt; getConstructingCachedMap(CharID id)
	{
<span class="fc" id="L357">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L360">			componentMap = getComponentMap();</span>
<span class="fc" id="L361">			setCache(id, componentMap);</span>
		}
<span class="fc" id="L363">		return componentMap;</span>
	}

	/**
	 * Returns a new (empty) Map for this AbstractItemConvertingFacet. Can be
	 * overridden by classes that extend AbstractItemConvertingFacet if a Map
	 * other than an IdentityHashMap is desired for storing the information in
	 * the AbstractItemConvertingFacet.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractItemConvertingFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractItemConvertingFacet.
	 * 
	 * Note that this method should always be the only method used to construct
	 * a Map for this AbstractItemConvertingFacet. It is actually preferred to
	 * use getConstructingCacheMap(CharID) in order to implicitly call this
	 * method.
	 * 
	 * @return A new (empty) Map for use in this AbstractItemConvertingFacet.
	 */
	protected Map&lt;S, Target&gt; getComponentMap()
	{
<span class="fc" id="L386">		return new IdentityHashMap&lt;&gt;();</span>
	}

	/**
	 * Copies the contents of the AbstractItemConvertingFacet from one Player
	 * Character to another Player Character, based on the given CharIDs
	 * representing those Player Characters.
	 * 
	 * This is a method in AbstractItemConvertingFacet in order to avoid
	 * exposing the mutable Map object to other classes. This should not be
	 * inlined, as the Map is internal information to
	 * AbstractItemConvertingFacet and should not be exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the Player Characters represented by the given CharIDs (meaning
	 * once this copy takes place, any change to the AbstractItemConvertingFacet
	 * of one Player Character will only impact the Player Character where the
	 * AbstractItemConvertingFacet was changed).
	 * 
	 * @param source
	 *            The CharID representing the Player Character from which the
	 *            information should be copied
	 * @param destination
	 *            The CharID representing the Player Character to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(CharID source, CharID destination)
	{
<span class="nc" id="L415">		Map&lt;S, Target&gt; sourceMap = getCachedMap(source);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">		if (sourceMap != null)</span>
		{
<span class="nc bnc" id="L418" title="All 2 branches missed.">			for (Map.Entry&lt;S, Target&gt; me : sourceMap.entrySet())</span>
			{
<span class="nc" id="L420">				Target origTarget = me.getValue();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">				if (origTarget != null)</span>
				{
<span class="nc" id="L423">					S obj = me.getKey();</span>
<span class="nc" id="L424">					Target target = getConstructingCachedSetFor(destination, obj);</span>
					//This could be dangerous!
<span class="nc" id="L426">					target.dest = origTarget.dest;</span>
<span class="nc" id="L427">					target.set.addAll(origTarget.set);</span>
				}
<span class="nc" id="L429">			}</span>
		}
<span class="nc" id="L431">	}</span>

	/**
	 * This method implements removal of a source for an object contained by
	 * this AbstractItemConvertingFacet. This implements the actual check that
	 * determines if the given source was the only source for the given object.
	 * If so, then that object is removed from the list of objects stored in
	 * this AbstractQualifiedListFacet for the Player Character represented by
	 * the given CharID and a removal event is fired.
	 * 
	 * @param id
	 *            The CharID representing the Player Character which may have
	 *            the given item removed.
	 * @param componentMap
	 *            The (private) Map for this AbstractItemConvertingFacet that
	 *            will as least have the given source removed from the list for
	 *            the given object.
	 * @param obj
	 *            The object which may be removed if the given source is the
	 *            only source for this object in the Player Character
	 *            represented by the given CharID
	 * @param source
	 *            The source for the given object to be removed from the list of
	 *            sources for that object
	 */
	private void processRemoval(CharID id, Map&lt;S, Target&gt; componentMap, S obj, Object source)
	{
<span class="fc" id="L458">		Objects.requireNonNull(obj, &quot;Object to remove may not be null&quot;);</span>
<span class="fc" id="L459">		Target target = componentMap.get(obj);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">		if (target != null)</span>
		{
<span class="fc" id="L462">			target.set.remove(source);</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">			if (target.set.isEmpty())</span>
			{
<span class="fc" id="L465">				componentMap.remove(obj);</span>
<span class="fc" id="L466">				fireDataFacetChangeEvent(id, target.dest, DataFacetChangeEvent.DATA_REMOVED);</span>
			}
		}
<span class="fc" id="L469">	}</span>

	/**
	 * Removes all information (converted and unconverted objects) for the given
	 * source from this AbstractItemConvertingFacet for the PlayerCharacter
	 * represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which items
	 *            from the given source will be removed
	 * @param source
	 *            The source for the objects to be removed from the list of
	 *            items stored for the Player Character identified by the given
	 *            CharID
	 */
	public void removeAll(CharID id, Object source)
	{
<span class="nc" id="L486">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc bnc" id="L489" title="All 2 branches missed.">			for (Iterator&lt;Target&gt; it = componentMap.values().iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L491">				Target target = it.next();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">				if (target != null)</span>
				{
<span class="nc bnc" id="L494" title="All 4 branches missed.">					if (target.set.remove(source) &amp;&amp; target.set.isEmpty())</span>
					{
<span class="nc" id="L496">						it.remove();</span>
<span class="nc" id="L497">						fireDataFacetChangeEvent(id, target.dest, DataFacetChangeEvent.DATA_REMOVED);</span>
					}
				}
<span class="nc" id="L500">			}</span>
		}
<span class="nc" id="L502">	}</span>

	/**
	 * Returns true if this AbstractItemConvertingFacet contains an object from
	 * the given source for the Player Character identified by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character which will be
	 *            checked to see if this AbstractItemConvertingFacet contains
	 *            any objects for that Player Character
	 * @param source
	 *            The source for the objects to be checked, along with the
	 *            Player Character identified by the given CharID, to see if
	 *            this AbstractItemConvertingFacet contains an object from the
	 *            given source
	 * @return true if this AbstractItemConvertingFacet contains an object from
	 *         the given source for the Player Character identified by the given
	 *         CharID; false otherwise
	 */
	public boolean containsFrom(CharID id, Object source)
	{
<span class="nc" id="L523">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc bnc" id="L526" title="All 2 branches missed.">			for (Entry&lt;S, Target&gt; me : componentMap.entrySet())</span>
			{
<span class="nc" id="L528">				Target target = me.getValue();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">				if (target != null)</span>
				{
<span class="nc bnc" id="L531" title="All 2 branches missed.">					if (target.set.contains(source))</span>
					{
<span class="nc" id="L533">						return true;</span>
					}
				}
<span class="nc" id="L536">			}</span>
		}
<span class="nc" id="L538">		return false;</span>
	}

	/**
	 * The storage class for AbstractItemConvertingFacet. Used to store both the
	 * converted object as well as the list of sources for the given destination
	 * object.
	 * 
	 */
<span class="fc" id="L547">	private class Target</span>
	{
		/**
		 * The set of objects from which the converted object has been received
		 */
<span class="fc" id="L552">		public Set&lt;Object&gt; set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>

		/**
		 * The converted (&quot;destination&quot;) object
		 */
		public D dest;

		@Override
		public int hashCode()
		{
<span class="nc" id="L562">			return dest.hashCode();</span>
		}

		@Override
		public boolean equals(Object o)
		{
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">			if (o == this)</span>
			{
<span class="nc" id="L570">				return true;</span>
			}
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">			if (o instanceof AbstractItemConvertingFacet.Target)</span>
			{
<span class="fc" id="L574">				Target other = (Target) o;</span>
<span class="pc bpc" id="L575" title="2 of 4 branches missed.">				return dest.equals(other.dest) &amp;&amp; set.equals(other.set);</span>
			}
<span class="nc" id="L577">			return false;</span>
		}
	}

	/**
	 * Converts the given object to the destination object type stored in this
	 * AbstractItemConvertingFacet. Must be implemented by classes that extend
	 * AbstractItemConvertingFacet.
	 * 
	 * @param obj
	 *            The original object stored in this AbstractItemConvertingFacet
	 * @return The converted object to be stored in this
	 *         AbstractItemConvertingFacet for the given original object
	 */
	protected abstract D convert(S obj);

	public Collection&lt;S&gt; getSourceObjects(CharID id)
	{
<span class="nc" id="L595">		Set&lt;S&gt; set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="nc" id="L596">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc" id="L599">			set.addAll(componentMap.keySet());</span>
		}
<span class="nc" id="L601">		return set;</span>
	}

	public D getResultFor(CharID id, S obj)
	{
<span class="nc" id="L606">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		return (componentMap == null) ? null : componentMap.get(obj).dest;</span>
	}

	public Collection&lt;Object&gt; getSourcesFor(CharID id, S obj)
	{
<span class="nc" id="L612">		Map&lt;S, Target&gt; componentMap = getCachedMap(id);</span>
<span class="nc" id="L613">		Set&lt;Object&gt; set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L616">			return set;</span>
		}
<span class="nc" id="L618">		set.addAll(componentMap.get(obj).set);</span>
<span class="nc" id="L619">		return set;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>