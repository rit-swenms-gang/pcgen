<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractSourcedListFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractSourcedListFacet.java</span></div><h1>AbstractSourcedListFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2009-14.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

import pcgen.base.util.ListSet;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.PCGenIdentifier;
import pcgen.cdom.facet.event.DataFacetChangeEvent;

/**
 * An AbstractSourcedListFacet is a DataFacet that contains information about
 * Objects that are contained in a resource when a resource may have more than
 * one of that type of Object (e.g. Language, PCTemplate) and the source of that
 * object should be tracked.
 * 
 * This class is designed to assume that each Object may only be contained one
 * time by the resource, even if received from multiple sources. The Object will
 * only trigger one DATA_ADDED event (when added by the first source) and if
 * removed by some sources, will only trigger one DATA_REMOVED event (when it is
 * removed by the last remaining source). Sources do not need to be removed in
 * the order in which they are added, and the first source to be added does not
 * possess special status with respect to triggering a DATA_REMOVED event (it
 * will only trigger removal if it was the last source when removed)
 * 
 * The sources stored in this AbstractSourcedListFacet are stored as a List,
 * meaning the list of sources may contain the same source multiple times. If
 * so, each call to remove will only remove that source one time from the list
 * of sources.
 * 
 * null is a valid source.
 * 
 * @param &lt;IDT&gt;
 *            The Type of identifier used in this AbstractSourcedListFacet
 * @param &lt;T&gt;
 *            The Type of object stored in this AbstractSourcedListFacet
 */
<span class="fc" id="L63">public abstract class AbstractSourcedListFacet&lt;IDT extends PCGenIdentifier, T&gt; extends AbstractDataFacet&lt;IDT, T&gt;</span>
{
	/**
	 * Add the given object with the given source to the list of objects stored
	 * in this AbstractSourcedListFacet for the resource represented by the
	 * given PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            given item should be added
	 * @param obj
	 *            The object to be added to the list of objects stored in this
	 *            AbstractSourcedListFacet for the resource represented by the
	 *            given PCGenIdentifier
	 * @param source
	 *            The source for the given object
	 */
	public void add(IDT id, T obj, Object source)
	{
<span class="fc" id="L82">		Objects.requireNonNull(obj, &quot;Object to add may not be null&quot;);</span>
<span class="fc" id="L83">		Map&lt;T, Set&lt;Object&gt;&gt; map = getConstructingCachedMap(id);</span>
<span class="fc" id="L84">		Set&lt;Object&gt; set = map.get(obj);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">		boolean fireNew = (set == null);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">		if (fireNew)</span>
		{
<span class="fc" id="L88">			set = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L89">			map.put(obj, set);</span>
		}
<span class="fc" id="L91">		set.add(source);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">		if (fireNew)</span>
		{
<span class="fc" id="L94">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L96">	}</span>

	/**
	 * Adds all of the objects with the given source in the given Collection to
	 * the list of objects stored in this AbstractSourcedListFacet for the
	 * resource represented by the given PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            given items should be added
	 * @param c
	 *            The Collection of objects to be added to the list of objects
	 *            stored in this AbstractSourcedListFacet for the resource
	 *            represented by the given PCGenIdentifier
	 * @param source
	 *            The source for the given object
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void addAll(IDT id, Collection&lt;? extends T&gt; c, Object source)
	{
<span class="fc bfc" id="L117" title="All 2 branches covered.">		for (T obj : c)</span>
		{
<span class="fc" id="L119">			add(id, obj, source);</span>
<span class="fc" id="L120">		}</span>
<span class="fc" id="L121">	}</span>

	/**
	 * Removes the given source entry from the list of sources for the given
	 * object stored in this AbstractSourcedListFacet for the resource
	 * represented by the given PCGenIdentifier. If the given source was the
	 * only source for the given object, then the object is removed from the
	 * list of objects stored in this AbstractSourcedListFacet for the resource
	 * represented by the given PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource from which the
	 *            given item source should be removed
	 * @param obj
	 *            The object for which the source should be removed
	 * @param source
	 *            The source for the given object to be removed from the list of
	 *            sources.
	 */
	public boolean remove(IDT id, T obj, Object source)
	{
<span class="fc" id="L142">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L143" title="All 4 branches covered.">		return (componentMap != null) &amp;&amp; processRemoval(id, componentMap, obj, source);</span>
	}

	/**
	 * Removes the given source entry from the list of sources for all of the
	 * objects in the given Collection for the resource represented by the given
	 * PCGenIdentifier. If the given source was the only source for any of the
	 * objects in the collection, then those objects are removed from the list
	 * of objects stored in this AbstractSourcedListFacet for the resource
	 * represented by the given PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource from which the
	 *            given items should be removed
	 * @param c
	 *            The Collection of objects to be removed from the list of
	 *            objects stored in this AbstractSourcedListFacet for the
	 *            resource represented by the given PCGenIdentifier
	 * @param source
	 *            The source for the objects in the given Collection to be
	 *            removed from the list of sources.
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(IDT id, Collection&lt;T&gt; c, Object source)
	{
<span class="fc" id="L169">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L172" title="All 2 branches covered.">			for (T obj : c)</span>
			{
<span class="fc" id="L174">				processRemoval(id, componentMap, obj, source);</span>
<span class="fc" id="L175">			}</span>
		}
<span class="fc" id="L177">	}</span>

	/**
	 * Removes all objects (and all sources for those objects) from the list of
	 * objects stored in this AbstractSourcedListFacet for the resource
	 * represented by the given PCGenIdentifier
	 * 
	 * This method is value-semantic in that ownership of the returned Map is
	 * transferred to the class calling this method. Since this is a remove all
	 * function, modification of the returned Map will not modify this
	 * AbstractSourcedListFacet and modification of this
	 * AbstractSourcedListFacet will not modify the returned Map. Modifications
	 * to the returned Map will also not modify any future or previous objects
	 * returned by this (or other) methods on AbstractSourcedListFacet. If you
	 * wish to modify the information stored in this AbstractSourcedListFacet,
	 * you must use the add*() and remove*() methods of
	 * AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource from which all
	 *            items should be removed
	 * @return A non-null Set of objects removed from the list of objects stored
	 *         in this AbstractSourcedListFacet for the resource represented by
	 *         the given PCGenIdentifier
	 */
	public Map&lt;T, Set&lt;Object&gt;&gt; removeAll(IDT id)
	{
<span class="fc" id="L204">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L207">			return Collections.emptyMap();</span>
		}
<span class="fc" id="L209">		removeCache(id);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">		for (T obj : componentMap.keySet())</span>
		{
<span class="fc" id="L212">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L213">		}</span>
<span class="fc" id="L214">		return componentMap;</span>
	}

	/**
	 * Returns a non-null copy of the Set of objects in this
	 * AbstractSourcedListFacet for the resource represented by the given
	 * PCGenIdentifier. This method returns an empty set if no objects are in
	 * this AbstractSourcedListFacet for the resource identified by the given
	 * PCGenIdentifier.
	 * 
	 * This method is value-semantic in that ownership of the returned Set is
	 * transferred to the class calling this method. Modification of the
	 * returned Set will not modify this AbstractSourcedListFacet and
	 * modification of this AbstractSourcedListFacet will not modify the
	 * returned Set. Modifications to the returned Set will also not modify any
	 * future or previous objects returned by this (or other) methods on
	 * AbstractSourcedListFacet. If you wish to modify the information stored in
	 * this AbstractSourcedListFacet, you must use the add*() and remove*()
	 * methods of AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            items in this AbstractSourcedListFacet should be returned.
	 * @return A non-null copy of the Set of objects in this
	 *         AbstractSourcedListFacet for the resource represented by the
	 *         given PCGenIdentifier
	 */
	public Set&lt;T&gt; getSet(IDT id)
	{
<span class="fc" id="L243">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L246">			return Collections.emptySet();</span>
		}
<span class="fc" id="L248">		return Collections.unmodifiableSet(new ListSet&lt;&gt;(componentMap.keySet()));</span>
	}

	/**
	 * Returns the count of items in this AbstractSourcedListFacet for the
	 * resource represented by the given PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            count of items should be returned
	 * @return The count of items in this AbstractSourcedListFacet for the
	 *         resource represented by the given PCGenIdentifier
	 */
	public int getCount(IDT id)
	{
<span class="fc" id="L263">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L266">			return 0;</span>
		}
<span class="fc" id="L268">		return componentMap.size();</span>
	}

	/**
	 * Returns true if this AbstractSourcedListFacet does not contain any items
	 * for the resource represented by the given PCGenIdentifier
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource to test if any
	 *            items are contained by this AbstractsSourcedListFacet
	 * @return true if this AbstractSourcedListFacet does not contain any items
	 *         for the resource represented by the given PCGenIdentifier; false
	 *         otherwise (if it does contain items for the resource)
	 */
	public boolean isEmpty(IDT id)
	{
<span class="fc" id="L284">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">		return componentMap == null || componentMap.isEmpty();</span>
	}

	/**
	 * Returns true if this AbstractSourcedListFacet contains the given value in
	 * the list of items for the resource represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource used for testing
	 * @param obj
	 *            The object to test if this AbstractSourcedListFacet contains
	 *            that item for the resource represented by the given
	 *            PCGenIdentifier
	 * @return true if this AbstractSourcedListFacet contains the given value
	 *         for the resource represented by the given PCGenIdentifier; false
	 *         otherwise
	 */
	public boolean contains(IDT id, T obj)
	{
		/*
		 * TODO obj == null? - log an error?
		 * 
		 * This should share behavior with AbstractListFacet
		 */
<span class="fc" id="L310">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L311" title="All 4 branches covered.">		return componentMap != null &amp;&amp; componentMap.containsKey(obj);</span>
	}

	/**
	 * Returns a Set of sources for this AbstractSourcedListFacet, the resource
	 * represented by the given PCGenIdentifier, and the given object. Will add
	 * the given object to the list of items for the resource represented by the
	 * given PCGenIdentifier and will return a new, empty Set if no information
	 * has been set in this AbstractSourcedListFacet for the given
	 * PCGenIdentifier and given object. Will not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Set object is owned by
	 * AbstractSourcedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier for which the Set should be returned
	 * @param obj
	 *            The object for which the Set of sources should be returned
	 * @return The Set of sources for the given object and resource represented
	 *         by the given PCGenIdentifier.
	 */
	private Set&lt;Object&gt; getConstructingCachedSetFor(IDT id, T obj)
	{
<span class="fc" id="L336">		Map&lt;T, Set&lt;Object&gt;&gt; map = getConstructingCachedMap(id);</span>

<span class="fc" id="L338">        return map.computeIfAbsent(obj, k -&gt; Collections.newSetFromMap(new IdentityHashMap&lt;&gt;()));</span>
	}

	/**
	 * Returns the type-safe Map for this AbstractSourcedListFacet and the given
	 * PCGenIdentifier. May return null if no information has been set in this
	 * AbstractSourcedListFacet for the given PCGenIdentifier.
	 * 
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * AbstractSourcedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier for which the Set should be returned
	 * @return The Map for the resource represented by the given
	 *         PCGenIdentifier; null if no information has been set in this
	 *         AbstractSourcedListFacet for the resource.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Map&lt;T, Set&lt;Object&gt;&gt; getCachedMap(IDT id)
	{
<span class="fc" id="L360">		return (Map&lt;T, Set&lt;Object&gt;&gt;) getCache(id);</span>
	}

	/**
	 * Returns the type-safe Map for this AbstractSourcedListFacet and the given
	 * PCGenIdentifier. Will return a new, empty Map if no information has been
	 * set in this AbstractSourcedListFacet for the given PCGenIdentifier. Will
	 * not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractSourcedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier for which the Map should be returned
	 * @return The Map for the resource represented by the given
	 *         PCGenIdentifier.
	 */
	private Map&lt;T, Set&lt;Object&gt;&gt; getConstructingCachedMap(IDT id)
	{
<span class="fc" id="L381">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L384">			componentMap = getComponentMap();</span>
<span class="fc" id="L385">			setCache(id, componentMap);</span>
		}
<span class="fc" id="L387">		return componentMap;</span>
	}

	/**
	 * Returns a new (empty) Map for this AbstractSourcedListFacet. Can be
	 * overridden by classes that extend AbstractSourcedListFacet if a Map other
	 * than an IdentityHashMap is desired for storing the information in the
	 * AbstractSourcedListFacet.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * AbstractSourcedListFacet, and since it can be modified, a reference to
	 * that object should not be exposed to any object other than
	 * AbstractSourcedListFacet.
	 * 
	 * Note that this method should always be the only method used to construct
	 * a Map for this AbstractSourcedListFacet. It is actually preferred to use
	 * getConstructingCacheMap(PCGenIdentifier) in order to implicitly call this
	 * method.
	 * 
	 * @return A new (empty) Map for use in this AbstractSourcedListFacet.
	 */
	protected Map&lt;T, Set&lt;Object&gt;&gt; getComponentMap()
	{
<span class="fc" id="L410">		return new IdentityHashMap&lt;&gt;();</span>
	}

	/**
	 * Copies the contents of the AbstractSourcedListFacet from one resource to
	 * another resource, based on the given PCGenIdentifiers representing those
	 * resources.
	 * 
	 * This is a method in AbstractSourcedListFacet in order to avoid exposing
	 * the mutable Map object to other classes. This should not be inlined, as
	 * the Map is internal information to AbstractSourcedListFacet and should
	 * not be exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the resources represented by the given PCGenIdentifiers (meaning
	 * once this copy takes place, any change to the AbstractSourcedListFacet of
	 * one resource will only impact the resource where the
	 * AbstractSourcedListFacet was changed).
	 * 
	 * @param source
	 *            The PCGenIdentifier representing the resource from which the
	 *            information should be copied
	 * @param destination
	 *            The PCGenIdentifier representing the resource to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(IDT source, IDT destination)
	{
<span class="fc" id="L439">		Map&lt;T, Set&lt;Object&gt;&gt; sourceMap = getCachedMap(source);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">		if (sourceMap != null)</span>
		{
<span class="fc bfc" id="L442" title="All 2 branches covered.">			for (Map.Entry&lt;T, Set&lt;Object&gt;&gt; me : sourceMap.entrySet())</span>
			{
<span class="fc" id="L444">				T obj = me.getKey();</span>
<span class="fc" id="L445">				Set&lt;Object&gt; sourceSet = me.getValue();</span>
<span class="fc" id="L446">				Set&lt;Object&gt; targetSet = getConstructingCachedSetFor(destination, obj);</span>
<span class="fc" id="L447">				targetSet.addAll(sourceSet);</span>
<span class="fc" id="L448">			}</span>
		}
<span class="fc" id="L450">	}</span>

	/**
	 * This method implements removal of a source for an object contained by
	 * this AbstractSourcedListFacet. This implements the actual check that
	 * determines if the given source was the only source for the given object.
	 * If so, then that object is removed from the list of objects stored in
	 * this AbstractQualifiedListFacet for the resource represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource which may have
	 *            the given item removed.
	 * @param componentMap
	 *            The (private) Map for this AbstractSourcedListFacet that will
	 *            as least have the given source removed from the list for the
	 *            given object.
	 * @param obj
	 *            The object which may be removed if the given source is the
	 *            only source for this object in the resource represented by the
	 *            given PCGenIdentifier
	 * @param source
	 *            The source for the given object to be removed from the list of
	 *            sources for that object
	 */
	private boolean processRemoval(IDT id, Map&lt;T, Set&lt;Object&gt;&gt; componentMap, T obj, Object source)
	{
<span class="fc" id="L477">		Objects.requireNonNull(obj, &quot;Object to remove may not be null&quot;);</span>
<span class="fc" id="L478">		Set&lt;Object&gt; set = componentMap.get(obj);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">		if (set == null)</span>
		{
<span class="fc" id="L481">			return false;</span>
		}
<span class="fc" id="L483">		boolean returnVal = set.remove(source);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (set.isEmpty())</span>
		{
<span class="fc" id="L486">			componentMap.remove(obj);</span>
<span class="fc" id="L487">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">			if (componentMap.isEmpty())</span>
			{
<span class="fc" id="L490">				removeCache(id);</span>
			}
		}
<span class="fc" id="L493">		return returnVal;</span>
	}

	/**
	 * Removes all information for the given source from this
	 * AbstractSourcedListFacet for the resource represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which items
	 *            from the given source will be removed
	 * @param source
	 *            The source for the objects to be removed from the list of
	 *            items stored for the resource identified by the given
	 *            PCGenIdentifier
	 */
	public void removeAll(IDT id, Object source)
	{
<span class="fc" id="L511">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
			/*
			 * This list exists primarily to eliminate the possibility of a
			 * concurrent modification exception on a recursive remove
			 */
<span class="fc" id="L518">			List&lt;T&gt; removedKeys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">			for (Iterator&lt;Map.Entry&lt;T, Set&lt;Object&gt;&gt;&gt; it = componentMap.entrySet().iterator(); it.hasNext();)</span>
			{
<span class="fc" id="L521">				Entry&lt;T, Set&lt;Object&gt;&gt; me = it.next();</span>
<span class="fc" id="L522">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="fc bfc" id="L523" title="All 4 branches covered.">				if (set.remove(source) &amp;&amp; set.isEmpty())</span>
				{
<span class="fc" id="L525">					T obj = me.getKey();</span>
<span class="fc" id="L526">					it.remove();</span>
<span class="fc" id="L527">					removedKeys.add(obj);</span>
				}
<span class="fc" id="L529">			}</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">			if (componentMap.isEmpty())</span>
			{
<span class="fc" id="L532">				removeCache(id);</span>
			}
<span class="fc bfc" id="L534" title="All 2 branches covered.">			for (T obj : removedKeys)</span>
			{
<span class="fc" id="L536">				fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L537">			}</span>
		}
<span class="fc" id="L539">	}</span>

	/**
	 * Returns a non-null copy of the Set of objects in this
	 * AbstractSourcedListFacet for the resource represented by the given
	 * PCGenIdentifier and the given source. This method returns an empty set if
	 * no objects are in this AbstractSourcedListFacet for the resource
	 * identified by the given PCGenIdentifier and source.
	 * 
	 * This method is value-semantic in that ownership of the returned List is
	 * transferred to the class calling this method. Modification of the
	 * returned List will not modify this AbstractSourcedListFacet and
	 * modification of this AbstractSourcedListFacet will not modify the
	 * returned List. Modifications to the returned List will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * AbstractSourcedListFacet. If you wish to modify the information stored in
	 * this AbstractSourcedListFacet, you must use the add*() and remove*()
	 * methods of AbstractSourcedListFacet.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            items in this AbstractSourcedListFacet should be returned.
	 * @param owner
	 *            The source object for which a copy of the List of objects in
	 *            this AbstractSourcedListFacet should be returned.
	 * @return A non-null Set of objects in this AbstractSourcedListFacet for
	 *         the resource represented by the given PCGenIdentifier
	 */
	public List&lt;? extends T&gt; getSet(IDT id, Object owner)
	{
<span class="fc" id="L569">		List&lt;T&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L570">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L573" title="All 2 branches covered.">			for (Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L575">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">				if (set.contains(owner))</span>
				{
<span class="fc" id="L578">					list.add(me.getKey());</span>
				}
<span class="fc" id="L580">			}</span>
		}
<span class="fc" id="L582">		return Collections.unmodifiableList(list);</span>
	}

	/**
	 * Returns true if this AbstractSourcedListFacet contains any item from the
	 * given source in the list of items for the resource represented by the
	 * given PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource used for testing
	 * @param owner
	 *            The source object for which must have granted an object in
	 *            this AbstractSourcedListFacet for the resource identified by
	 *            the given PCGenIdentifier
	 * @return true if this AbstractSourcedListFacet contains any item from the
	 *         given source for the resource represented by the given
	 *         PCGenIdentifier; false otherwise
	 */
	public boolean containsFrom(IDT id, Object owner)
	{
<span class="fc" id="L602">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">		if (componentMap != null)</span>
		{
<span class="fc bfc" id="L605" title="All 2 branches covered.">			for (Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="fc" id="L607">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">				if (set.contains(owner))</span>
				{
<span class="fc" id="L610">					return true;</span>
				}
<span class="fc" id="L612">			}</span>
		}
<span class="fc" id="L614">		return false;</span>
	}

	/**
	 * Returns the count of items granted by the given source in this
	 * AbstractSourcedListFacet for the resource represented by the given
	 * PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource for which the
	 *            count of items should be returned
	 * @param owner
	 *            The source object used to determine the count of objects in
	 *            this AbstractSourcedListFacet for the resource identified by
	 *            the given PCGenIdentifier
	 * @return The count of items granted by the given source in this
	 *         AbstractSourcedListFacet for the resource represented by the
	 *         given PCGenIdentifier
	 */
	public int getCountFrom(IDT id, CDOMObject owner)
	{
<span class="nc" id="L635">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="nc" id="L636">		int count = 0;</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc bnc" id="L639" title="All 2 branches missed.">			for (Entry&lt;T, Set&lt;Object&gt;&gt; me : componentMap.entrySet())</span>
			{
<span class="nc" id="L641">				Set&lt;Object&gt; set = me.getValue();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">				if (set.contains(owner))</span>
				{
<span class="nc" id="L644">					count++;</span>
				}
<span class="nc" id="L646">			}</span>
		}
<span class="nc" id="L648">		return count;</span>
	}

	/**
	 * Returns true if this AbstractSourcedListFacet contains the given value
	 * (granted by the given source) in the list of items for the resource
	 * represented by the given PCGenIdentifier.
	 * 
	 * @param id
	 *            The PCGenIdentifier representing the resource used for testing
	 * @param owner
	 *            The source object for which must have granted the object being
	 *            tested to see if it is contained by this
	 *            AbstractSourcedListFacet for the resource identified by the
	 *            given PCGenIdentifier
	 * @param obj
	 *            The object to test if this AbstractSourcedListFacet contains
	 *            that item for the resource represented by the given
	 *            PCGenIdentifier
	 * @return true if this AbstractSourcedListFacet contains the given value
	 *         (granted by the given source) for the resource represented by the
	 *         given PCGenIdentifier; false otherwise
	 */
	public boolean containsFrom(IDT id, T obj, CDOMObject owner)
	{
<span class="nc" id="L673">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc" id="L676">			Set&lt;Object&gt; sources = componentMap.get(obj);</span>
<span class="nc bnc" id="L677" title="All 4 branches missed.">			return sources != null &amp;&amp; sources.contains(owner);</span>
		}
<span class="nc" id="L679">		return false;</span>
	}

	public Collection&lt;Object&gt; getSources(IDT id, T obj)
	{
<span class="nc" id="L684">		Map&lt;T, Set&lt;Object&gt;&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc" id="L687">			Set&lt;Object&gt; sources = componentMap.get(obj);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">			if (sources != null)</span>
			{
<span class="nc" id="L690">				return Collections.unmodifiableSet(sources);</span>
			}
		}
<span class="nc" id="L693">		return Collections.emptySet();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>