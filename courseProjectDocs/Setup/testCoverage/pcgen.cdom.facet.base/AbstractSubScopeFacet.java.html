<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractSubScopeFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet.base</a> &gt; <span class="el_source">AbstractSubScopeFacet.java</span></div><h1>AbstractSubScopeFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2013.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet.base;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;

import pcgen.base.util.ArrayUtilities;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.facet.event.SubScopeFacetChangeEvent;
import pcgen.cdom.facet.event.SubScopeFacetChangeListener;

<span class="fc" id="L37">public class AbstractSubScopeFacet&lt;S1, S2, T&gt; extends AbstractStorageFacet&lt;CharID&gt;</span>
{
	private Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; getConstructingInfo(CharID id)
	{
<span class="fc" id="L41">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L44">			map = new IdentityHashMap&lt;&gt;();</span>
<span class="fc" id="L45">			setCache(id, map);</span>
		}
<span class="fc" id="L47">		return map;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; getInfo(CharID id)
	{
<span class="fc" id="L53">		return (Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt;) getCache(id);</span>
	}

	public void add(CharID id, S1 scope1, S2 scope2, T obj, Object source)
	{
<span class="fc" id="L58">		Objects.requireNonNull(scope1, &quot;Scope 1 cannot be null&quot;);</span>
<span class="fc" id="L59">		Objects.requireNonNull(scope2, &quot;Scope 2 cannot be null&quot;);</span>
<span class="fc" id="L60">		Objects.requireNonNull(obj, &quot;Object cannot be null&quot;);</span>
<span class="fc" id="L61">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getConstructingInfo(id);</span>
<span class="fc" id="L62">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = map.computeIfAbsent(scope1, k -&gt; new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L63">		Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = scope1Map.computeIfAbsent(scope2, k -&gt; new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L64">		Set&lt;Object&gt; sources = scope2Map.get(obj);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		boolean isNew = (sources == null);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		if (isNew)</span>
		{
<span class="fc" id="L68">			sources = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="fc" id="L69">			scope2Map.put(obj, sources);</span>
		}
<span class="fc" id="L71">		sources.add(source);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">		if (isNew)</span>
		{
<span class="fc" id="L74">			fireSubScopeFacetChangeEvent(id, scope1, scope2, obj, SubScopeFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="fc" id="L76">	}</span>

	public void remove(CharID id, S1 scope1, S2 scope2, T obj, Object source)
	{
<span class="fc" id="L80">		Objects.requireNonNull(scope1, &quot;Scope 1 cannot be null&quot;);</span>
<span class="fc" id="L81">		Objects.requireNonNull(scope2, &quot;Scope 2 cannot be null&quot;);</span>
<span class="fc" id="L82">		Objects.requireNonNull(obj, &quot;Object cannot be null&quot;);</span>
<span class="fc" id="L83">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L86">			return;</span>
		}
<span class="fc" id="L88">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = map.get(scope1);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		if (scope1Map == null)</span>
		{
<span class="fc" id="L91">			return;</span>
		}
<span class="fc" id="L93">		Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = scope1Map.get(scope2);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">		if (scope2Map == null)</span>
		{
<span class="fc" id="L96">			return;</span>
		}
<span class="fc" id="L98">		Set&lt;Object&gt; sources = scope2Map.get(obj);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">		if (sources == null)</span>
		{
<span class="fc" id="L101">			return;</span>
		}
<span class="fc bfc" id="L103" title="All 4 branches covered.">		if (sources.remove(source) &amp;&amp; sources.isEmpty())</span>
		{
<span class="fc" id="L105">			fireSubScopeFacetChangeEvent(id, scope1, scope2, obj, SubScopeFacetChangeEvent.DATA_REMOVED);</span>
<span class="fc" id="L106">			scope2Map.remove(obj);</span>
		}
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (scope2Map.isEmpty())</span>
		{
<span class="fc" id="L110">			scope1Map.remove(scope2);</span>
		}
<span class="fc bfc" id="L112" title="All 2 branches covered.">		if (scope1Map.isEmpty())</span>
		{
<span class="fc" id="L114">			map.remove(scope1);</span>
		}
<span class="fc bfc" id="L116" title="All 2 branches covered.">		if (map.isEmpty())</span>
		{
<span class="fc" id="L118">			removeCache(id);</span>
		}
<span class="fc" id="L120">	}</span>

	public Collection&lt;T&gt; getSet(CharID id, S1 scope1, S2 scope2)
	{
<span class="nc" id="L124">		Objects.requireNonNull(scope1, &quot;Scope 1 cannot be null&quot;);</span>
<span class="nc" id="L125">		Objects.requireNonNull(scope2, &quot;Scope 2 cannot be null&quot;);</span>
<span class="nc" id="L126">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L129">			return Collections.emptyList();</span>
		}
<span class="nc" id="L131">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = map.get(scope1);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (scope1Map == null)</span>
		{
<span class="nc" id="L134">			return Collections.emptyList();</span>
		}
<span class="nc" id="L136">		Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = scope1Map.get(scope2);</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (scope2Map == null)</span>
		{
<span class="nc" id="L139">			return Collections.emptyList();</span>
		}
<span class="nc" id="L141">		return new ArrayList&lt;&gt;(scope2Map.keySet());</span>
	}

	public int getSize(CharID id, S1 scope1, S2 scope2)
	{
<span class="nc" id="L146">		Objects.requireNonNull(scope1, &quot;Scope 1 cannot be null&quot;);</span>
<span class="nc" id="L147">		Objects.requireNonNull(scope2, &quot;Scope 2 cannot be null&quot;);</span>
<span class="nc" id="L148">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L151">			return 0;</span>
		}
<span class="nc" id="L153">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = map.get(scope1);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">		if (scope1Map == null)</span>
		{
<span class="nc" id="L156">			return 0;</span>
		}
<span class="nc" id="L158">		Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = scope1Map.get(scope2);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (scope2Map == null)</span>
		{
<span class="nc" id="L161">			return 0;</span>
		}
<span class="nc" id="L163">		return scope2Map.size();</span>
	}

	public boolean contains(CharID id, S1 scope1, S2 scope2, T obj)
	{
<span class="fc" id="L168">		Objects.requireNonNull(scope1, &quot;Scope 1 cannot be null&quot;);</span>
<span class="fc" id="L169">		Objects.requireNonNull(scope2, &quot;Scope 2 cannot be null&quot;);</span>
<span class="fc" id="L170">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (map == null)</span>
		{
<span class="fc" id="L173">			return false;</span>
		}
<span class="fc" id="L175">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = map.get(scope1);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (scope1Map == null)</span>
		{
<span class="fc" id="L178">			return false;</span>
		}
<span class="fc" id="L180">		Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = scope1Map.get(scope2);</span>
<span class="fc bfc" id="L181" title="All 4 branches covered.">		return (scope2Map != null) &amp;&amp; scope2Map.containsKey(obj);</span>
	}

	public Collection&lt;S1&gt; getScopes1(CharID id)
	{
<span class="nc" id="L186">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L189">			return Collections.emptyList();</span>
		}
<span class="nc" id="L191">		return new ArrayList&lt;&gt;(map.keySet());</span>
	}

	public Collection&lt;S2&gt; getScopes2(CharID id, S1 scope1)
	{
<span class="nc" id="L196">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L199">			return Collections.emptyList();</span>
		}
<span class="nc" id="L201">		Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; submap = map.get(scope1);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">		if (submap == null)</span>
		{
<span class="nc" id="L204">			return Collections.emptyList();</span>
		}
<span class="nc" id="L206">		return new ArrayList&lt;&gt;(submap.keySet());</span>
	}

	public void removeAllFromSource(CharID id, Object source)
	{
<span class="fc" id="L211">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">		if (map != null)</span>
		{
<span class="fc bfc" id="L214" title="All 2 branches covered.">			for (Iterator&lt;Entry&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt;&gt; s1it = map.entrySet().iterator(); s1it.hasNext();)</span>
			{
<span class="fc" id="L216">				Entry&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; s1entry = s1it.next();</span>
<span class="fc" id="L217">				S1 scope1 = s1entry.getKey();</span>
<span class="fc" id="L218">				Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; scope1Map = s1entry.getValue();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">				for (Iterator&lt;Entry&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; s2it = scope1Map.entrySet().iterator(); s2it.hasNext();)</span>
				{
<span class="fc" id="L221">					Entry&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; s2entry = s2it.next();</span>
<span class="fc" id="L222">					S2 scope2 = s2entry.getKey();</span>
<span class="fc" id="L223">					Map&lt;T, Set&lt;Object&gt;&gt; scope2Map = s2entry.getValue();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">					for (Iterator&lt;Map.Entry&lt;T, Set&lt;Object&gt;&gt;&gt; lmit = scope2Map.entrySet().iterator(); lmit.hasNext();)</span>
					{
<span class="fc" id="L226">						Entry&lt;T, Set&lt;Object&gt;&gt; lme = lmit.next();</span>
<span class="fc" id="L227">						Set&lt;Object&gt; sources = lme.getValue();</span>
<span class="fc bfc" id="L228" title="All 4 branches covered.">						if (sources.remove(source) &amp;&amp; sources.isEmpty())</span>
						{
<span class="fc" id="L230">							T obj = lme.getKey();</span>
<span class="fc" id="L231">							lmit.remove();</span>
<span class="fc" id="L232">							fireSubScopeFacetChangeEvent(id, scope1, scope2, obj,</span>
								SubScopeFacetChangeEvent.DATA_REMOVED);
						}
<span class="fc" id="L235">					}</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">					if (scope2Map.isEmpty())</span>
					{
<span class="fc" id="L238">						s2it.remove();</span>
					}
<span class="fc" id="L240">				}</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">				if (scope1Map.isEmpty())</span>
				{
<span class="fc" id="L243">					s1it.remove();</span>
				}
<span class="fc" id="L245">			}</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			if (map.isEmpty())</span>
			{
<span class="fc" id="L248">				removeCache(id);</span>
			}
		}
<span class="fc" id="L251">	}</span>

	/**
	 * Copies the contents of the AbstractScopeFacet from one Player Character
	 * to another Player Character, based on the given CharIDs representing
	 * those Player Characters.
	 * 
	 * This is a method in AbstractScopeFacet in order to avoid exposing the
	 * mutable Map object to other classes. This should not be inlined, as the
	 * Map is internal information to AbstractScopeFacet and should not be
	 * exposed to other classes.
	 * 
	 * Note also the copy is a one-time event and no references are maintained
	 * between the Player Characters represented by the given CharIDs (meaning
	 * once this copy takes place, any change to the AbstractScopeFacet of one
	 * Player Character will only impact the Player Character where the
	 * AbstractScopeFacet was changed).
	 * 
	 * @param source
	 *            The CharID representing the Player Character from which the
	 *            information should be copied
	 * @param copy
	 *            The CharID representing the Player Character to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(CharID source, CharID copy)
	{
<span class="fc" id="L279">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(source);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">		if (map != null)</span>
		{
<span class="fc bfc" id="L282" title="All 2 branches covered.">			for (Entry&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; l1me : map.entrySet())</span>
			{
<span class="fc" id="L284">				S1 scope1 = l1me.getKey();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">				for (Entry&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt; l2me : l1me.getValue().entrySet())</span>
				{
<span class="fc" id="L287">					S2 scope2 = l2me.getKey();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">					for (Entry&lt;T, Set&lt;Object&gt;&gt; ome : l2me.getValue().entrySet())</span>
					{
<span class="fc" id="L290">						T sp = ome.getKey();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">						for (Object spsource : ome.getValue())</span>
						{
<span class="fc" id="L293">							add(copy, scope1, scope2, sp, spsource);</span>
<span class="fc" id="L294">						}</span>
<span class="fc" id="L295">					}</span>
<span class="fc" id="L296">				}</span>
<span class="fc" id="L297">			}</span>
		}
<span class="fc" id="L299">	}</span>

<span class="fc" id="L301">	private final Map&lt;Integer, SubScopeFacetChangeListener&lt;? super S1, ? super S2, ? super T&gt;[]&gt; listeners =</span>
			new TreeMap&lt;&gt;();

	/**
	 * Adds a new ScopeFacetChangeListener to receive TwoScopeFacetChangeEvents
	 * (EdgeChangeEvent and NodeChangeEvent) from this AbstractScopeFacet. The
	 * given ScopeFacetChangeListener is added at the default priority (zero).
	 * 
	 * Note that the ScopeFacetChangeListeners are a list, meaning a given
	 * ScopeFacetChangeListener can be added more than once at a given priority,
	 * and if that occurs, it must be removed an equivalent number of times in
	 * order to no longer receive events from this AbstractScopeFacet.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to receive
	 *            TwoScopeFacetChangeEvents from this AbstractScopeFacet
	 */
	public void addSubScopeFacetChangeListener(SubScopeFacetChangeListener&lt;? super S1, ? super S2, ? super T&gt; listener)
	{
<span class="fc" id="L320">		addSubScopeFacetChangeListener(0, listener);</span>
<span class="fc" id="L321">	}</span>

	/**
	 * Adds a new ScopeFacetChangeListener to receive TwoScopeFacetChangeEvents
	 * (EdgeChangeEvent and NodeChangeEvent) from this AbstractScopeFacet.
	 * 
	 * The ScopeFacetChangeListener is added at the given priority.
	 * 
	 * Note that the ScopeFacetChangeListeners are a list, meaning a given
	 * ScopeFacetChangeListener can be added more than once at a given priority,
	 * and if that occurs, it must be removed an equivalent number of times in
	 * order to no longer receive events from this AbstractScopeFacet.
	 * 
	 * @param listener
	 *            The ScopeFacetChangeListener to receive
	 *            TwoScopeFacetChangeEvents from this AbstractScopeFacet
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void addSubScopeFacetChangeListener(int priority,
		SubScopeFacetChangeListener&lt;? super S1, ? super S2, ? super T&gt; listener)
	{
<span class="fc" id="L342">		SubScopeFacetChangeListener&lt;? super S1, ? super S2, ? super T&gt;[] dfcl =</span>
<span class="fc" id="L343">				listeners.get(priority);</span>
<span class="fc" id="L344">		dfcl = Optional.ofNullable(dfcl).orElse(new SubScopeFacetChangeListener[0]);</span>
<span class="fc" id="L345">		listeners.put(priority, ArrayUtilities.prependOnCopy(listener, dfcl,</span>
			SubScopeFacetChangeListener.class));
<span class="fc" id="L347">	}</span>

	/**
	 * Sends a NodeChangeEvent to the ScopeFacetChangeListeners that are
	 * receiving TwoScopeFacetChangeEvents from this AbstractScopeFacet.
	 * 
	 * @param id
	 *            The CharID identifying the Player Character to which the
	 *            NodeChangeEvent relates.
	 * @param scope1
	 *            A Scope through which this facet's contents are viewed.
	 * @param scope2
	 *            Another Scope passed on to the listener.
	 * @param node
	 *            The Node that has been added to or removed from this
	 *            AbstractScopeFacet for the given CharID.
	 * @param type
	 *            An identifier indicating whether the given CDOMObject was
	 *            added to or removed from this AbstractScopeFacet.
	 */
	@SuppressWarnings(&quot;rawtypes&quot;)
	protected void fireSubScopeFacetChangeEvent(CharID id, S1 scope1, S2 scope2, T node, int type)
	{
<span class="fc bfc" id="L370" title="All 2 branches covered.">		for (SubScopeFacetChangeListener&lt;? super S1, ? super S2, ? super T&gt;[] dfclArray : listeners.values())</span>
		{
			/*
			 * This list is decremented from the end of the list to the
			 * beginning in order to maintain consistent operation with how Java
			 * AWT and Swing listeners are notified of Events. This is obviously
			 * subordinate to the priority (loop above).
			 */
<span class="fc" id="L378">			SubScopeFacetChangeEvent&lt;S1, S2, T&gt; ccEvent = null;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			for (int i = dfclArray.length - 1; i &gt;= 0; i--)</span>
			{
				// Lazily create event
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">				if (ccEvent == null)</span>
				{
<span class="fc" id="L384">					ccEvent = new SubScopeFacetChangeEvent&lt;&gt;(id, scope1, scope2, node, this, type);</span>
				}
<span class="fc" id="L386">				SubScopeFacetChangeListener dfcl = dfclArray[i];</span>
<span class="pc bpc" id="L387" title="1 of 3 branches missed.">				switch (ccEvent.getEventType())</span>
				{
<span class="fc" id="L389">					case SubScopeFacetChangeEvent.DATA_ADDED -&gt; dfcl.dataAdded(ccEvent);</span>
<span class="fc" id="L390">					case SubScopeFacetChangeEvent.DATA_REMOVED -&gt; dfcl.dataRemoved(ccEvent);</span>
					default -&gt; {
					}
				}
			}
<span class="fc" id="L395">		}</span>
<span class="fc" id="L396">	}</span>

	public boolean containsFor(CharID id, S1 scope1)
	{
<span class="fc" id="L400">		Map&lt;S1, Map&lt;S2, Map&lt;T, Set&lt;Object&gt;&gt;&gt;&gt; map = getInfo(id);</span>
<span class="pc bpc" id="L401" title="2 of 4 branches missed.">		return (map != null) &amp;&amp; map.containsKey(scope1);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>