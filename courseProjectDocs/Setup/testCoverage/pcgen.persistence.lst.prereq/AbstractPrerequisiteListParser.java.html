<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractPrerequisiteListParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.persistence.lst.prereq</a> &gt; <span class="el_source">AbstractPrerequisiteListParser.java</span></div><h1>AbstractPrerequisiteListParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Bryan McRoberts &lt;merton_monk@yahoo.com&gt;
 * Copyright 2003 (C) Chris Ward &lt;frugal@purplewombat.co.uk&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	   See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *
 *
 */
package pcgen.persistence.lst.prereq;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import pcgen.core.prereq.Prerequisite;
import pcgen.core.prereq.PrerequisiteOperator;
import pcgen.persistence.PersistenceLayerException;
import pcgen.rules.persistence.token.ParseResult;
import pcgen.util.Logging;

import org.apache.commons.lang3.StringUtils;

/**
 * Abstract PRE parser, provides common parsing for many PRE tokens.
 */
<span class="fc" id="L39">public abstract class AbstractPrerequisiteListParser extends AbstractPrerequisiteParser</span>
		implements PrerequisiteParserInterface
{

	protected void convertKeysToSubKeys(Prerequisite prereq, String kind)
	{
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">		if (prereq == null)</span>
		{
<span class="nc" id="L47">			return;</span>
		}
<span class="fc bfc" id="L49" title="All 4 branches covered.">		if (prereq.getKind() != null &amp;&amp; prereq.getKind().equalsIgnoreCase(kind))</span>
		{
<span class="fc" id="L51">			String key = prereq.getKey().trim();</span>

<span class="fc" id="L53">			int index = key.indexOf('(');</span>
<span class="fc" id="L54">			int endIndex = key.lastIndexOf(')');</span>

<span class="pc bpc" id="L56" title="1 of 4 branches missed.">			if ((index &gt;= 0) &amp;&amp; (endIndex == key.length() - 1))</span>
			{
<span class="fc" id="L58">				String subKey = key.substring(index + 1, endIndex).trim();</span>
<span class="fc" id="L59">				key = key.substring(0, index).trim();</span>

<span class="fc" id="L61">				prereq.setKey(key);</span>
<span class="fc" id="L62">				prereq.setSubKey(subKey);</span>
			}
		}

<span class="fc bfc" id="L66" title="All 2 branches covered.">		for (Prerequisite element : prereq.getPrerequisites())</span>
		{
<span class="fc" id="L68">			convertKeysToSubKeys(element, kind);</span>
<span class="fc" id="L69">		}</span>
<span class="fc" id="L70">	}</span>

	/**
	 * Parse the pre req list.
	 * 
	 * @param kind The kind of the prerequisite (less the &quot;PRE&quot; prefix)
	 * @param formula The body of the prerequisite.
	 * @param invertResult Whether the prerequisite should invert the result.
	 * @param overrideQualify
	 *           if set true, this prerequisite will be enforced in spite
	 *           of any &quot;QUALIFY&quot; tag that may be present.
	 * @return PreReq 
	 * @throws PersistenceLayerException 
	 */
	@Override
	public Prerequisite parse(String kind, String formula, boolean invertResult, boolean overrideQualify)
		throws PersistenceLayerException
	{

<span class="fc" id="L89">		Prerequisite prereq = super.parse(kind, formula, invertResult, overrideQualify);</span>
<span class="fc" id="L90">		parsePrereqListType(prereq, kind, formula);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">		if (invertResult)</span>
		{
<span class="fc" id="L94">			prereq.setOperator(prereq.getOperator().invert());</span>
		}
<span class="fc" id="L96">		return prereq;</span>
	}

	/*
	 * Parses a PRE type, some examples below:
	 * 
	 * CLASS:1,Spellcaster=3
	* &lt;prereq kind=&quot;class&quot; key=&quot;Spellcaster&quot; min=&quot;3&quot; /&gt;
	 *
	* SKILL:1,Heal=5
	* &lt;prereq kind=&quot;skill&quot; key=&quot;Heal&quot; min=&quot;5&quot; /&gt;
	 *
	* FEAT:1,TYPE=Necromantic
	* &lt;prereq kind=&quot;feat&quot; key=&quot;TYPE=Necromantic&quot; /&gt;
	 *
	* SKILL:2,Knowledge (Anthropology),Knowledge (Biology),Knowledge
	* (Chemistry)=5
	* &lt;prereq min=&quot;2&quot;&gt;
	*   &lt;prereq kind=&quot;skill&quot; key=&quot;Knowledge (Anthropology)&quot; min=&quot;5&quot; /&gt;
	*   &lt;prereq kind=&quot;skill&quot; key=&quot;Knowledge (Biology)&quot; min=&quot;5&quot; /&gt;
	*   &lt;prereq kind=&quot;skill&quot; key=&quot;Knowledge (Chemistry)&quot; min=&quot;5&quot; /&gt;
	* &lt;/prereq&gt;
	 *
	* FEAT:2,CHECKMULT,Spell Focus
	* &lt;prereq kind=&quot;feat&quot; count-multiples=&quot;true&quot; key=&quot;feat.spell_focus&quot; /&gt;
	 *
	* FEAT:2,CHECKMULT,Spell Focus,[Spell Focus(Enchantment)]
	* &lt;prereq min=&quot;2&quot;&gt;
	*  &lt;prereq kind=&quot;feat&quot; key=&quot;feat.spell_focus&quot; count-multiples=&quot;true&quot; min=&quot;2&quot;/&gt;
	*   &lt;prereq kind=&quot;feat&quot; key=&quot;feat.spell_focus_enchantment&quot; logical=&quot;not&quot; /&gt;
	* &lt;/prereq&gt;
	 *
	* STAT:1,DEX=9,STR=13
	* &lt;prereq operator=&quot;gteq&quot; op1=&quot;1&quot;&gt;
	*   &lt;prereq kind=&quot;stat&quot; key=&quot;dex&quot; operator=&quot;gteq&quot; op1=&quot;9&quot; /&gt;
	*   &lt;prereq kind=&quot;stat&quot; key=&quot;str&quot; operator=&quot;gteq&quot; op1=&quot;13&quot; /&gt;
	* &lt;/prereq&gt;
	*/
	protected void parsePrereqListType(Prerequisite prereq, String kind, String formula)
		throws PersistenceLayerException
	{
		// Sanity checking
<span class="fc" id="L138">		ParseResult parseResult = checkForIllegalSeparator(kind, ',', formula);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">		if (!parseResult.passed())</span>
		{
<span class="nc" id="L141">			throw new PersistenceLayerException(parseResult.toString());</span>
		}
<span class="pc bpc" id="L143" title="1 of 6 branches missed.">		if (!allowsNegate() &amp;&amp; (formula.indexOf('[') &gt;= 0 || formula.indexOf(']') &gt;= 0))</span>
		{
<span class="fc" id="L145">			throw new PersistenceLayerException(&quot;Prerequisite &quot; + kind + &quot; can not contain []: &quot; + formula);</span>
		}
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if (formula.indexOf('|') &gt;= 0)</span>
		{
<span class="nc" id="L149">			throw new PersistenceLayerException(&quot;Prerequisite &quot; + kind + &quot; can not contain |: &quot; + formula);</span>
		}

<span class="fc" id="L152">		String[] elements = formula.split(&quot;,&quot;);</span>
		int numRequired;
		try
		{
<span class="fc" id="L156">			numRequired = Integer.parseInt(elements[0]);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">			if (elements.length == 1)</span>
			{
<span class="nc" id="L159">				throw new PersistenceLayerException(&quot;Prerequisite &quot; + kind + &quot; can not have only a count: &quot; + formula);</span>
			}
		}
<span class="fc" id="L162">		catch (NumberFormatException nfe)</span>
		{
<span class="fc" id="L164">			throw new PersistenceLayerException(&quot;'&quot; + elements[0] + &quot;' is not a valid integer&quot;, nfe);</span>
<span class="fc" id="L165">		}</span>

		// Examine the last element to see if it is of the form &quot;foo=n&quot;
<span class="fc" id="L168">		int elementsLength = elements.length;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		for (int i = elementsLength - 1; i &gt;= 0; --i)</span>
		{
<span class="fc bfc" id="L171" title="All 2 branches covered.">			if (&quot;CHECKMULT&quot;.equalsIgnoreCase(elements[i]))</span>
			{
<span class="fc" id="L173">				prereq.setCountMultiples(true);</span>
<span class="fc" id="L174">				--elementsLength;</span>
			}
		}

		// Token now contains all of the possible matches,
		// min contains the target number (if there is one)
		// number contains the number of 'tokens' that be at least 'min'
<span class="fc bfc" id="L181" title="All 2 branches covered.">		if (elementsLength &gt; 2)</span>
		{
			// we have more than one option, so use a group
<span class="fc" id="L184">			prereq.setOperator(PrerequisiteOperator.GTEQ);</span>
<span class="fc" id="L185">			prereq.setOperand(Integer.toString(numRequired));</span>
<span class="fc" id="L186">			prereq.setKind(null);</span>
<span class="fc" id="L187">			boolean hasKeyValue = false;</span>
<span class="fc" id="L188">			boolean hasKeyOnly = false;</span>
<span class="fc" id="L189">			int min = -99;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">			for (int i = 1; i &lt; elements.length; i++)</span>
			{
<span class="fc" id="L192">				String thisElement = elements[i];</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">				if (&quot;CHECKMULT&quot;.equals(thisElement))</span>
				{
<span class="fc" id="L195">					continue;</span>
				}
<span class="fc" id="L197">				boolean warnIgnored = isNoWarnElement(thisElement);</span>
<span class="fc" id="L198">				Prerequisite subreq = new Prerequisite();</span>
<span class="fc" id="L199">				subreq.setKind(kind.toLowerCase());</span>
<span class="fc" id="L200">				subreq.setCountMultiples(true);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">				if (thisElement.indexOf('=') &gt;= 0)</span>
				{
					// The element is either of the form &quot;TYPE=foo&quot; or &quot;DEX=9&quot;
					// if it is the later, we need to extract the '9'
<span class="fc" id="L205">					subreq.setOperator(PrerequisiteOperator.GTEQ);</span>
<span class="fc" id="L206">					String[] tokens = thisElement.split(&quot;=&quot;);</span>
					try
					{
<span class="fc" id="L209">						int valueIndx = tokens.length - 1;</span>
<span class="fc" id="L210">						min = Integer.parseInt(tokens[valueIndx]);</span>
<span class="fc" id="L211">						subreq.setOperand(Integer.toString(min));</span>
<span class="fc" id="L212">						String requirementKey = getRequirementKey(tokens);</span>
<span class="fc" id="L213">						subreq.setKey(requirementKey);</span>
						// now back fill all of the previous prereqs with this minimum
<span class="fc bfc" id="L215" title="All 2 branches covered.">						for (Prerequisite p : new ArrayList&lt;&gt;(prereq.getPrerequisites()))</span>
						{
<span class="fc bfc" id="L217" title="All 2 branches covered.">							if (p.getOperand().equals(&quot;-99&quot;))</span>
							{
<span class="fc" id="L219">								p.setOperand(Integer.toString(min));</span>
								// If this requirement has already been added, we don't want to repeat it.
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">								if (p.getKey().equals(requirementKey))</span>
								{
<span class="nc" id="L223">									prereq.removePrerequisite(p);</span>
								}
							}
<span class="fc" id="L226">						}</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">						if (!warnIgnored)</span>
						{
<span class="fc" id="L229">							hasKeyValue = true;</span>
						}
					}
<span class="fc" id="L232">					catch (NumberFormatException nfe)</span>
					{
<span class="fc" id="L234">						subreq.setKey(thisElement);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">						if (!warnIgnored)</span>
						{
<span class="fc" id="L237">							hasKeyOnly = true;</span>
						}
<span class="fc" id="L239">					}</span>
<span class="fc" id="L240">				}</span>
				else
				{
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">					if (requiresValue())</span>
					{
<span class="nc" id="L245">						throw new PersistenceLayerException(</span>
							&quot;Prerequisites of kind &quot; + kind + &quot; require a target value, e.g. Key=Value&quot;);
					}
<span class="fc" id="L248">					String assumed = getAssumedValue();</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">					if (assumed == null)</span>
					{
<span class="fc" id="L251">						subreq.setOperand(Integer.toString(min));</span>
					}
					else
					{
<span class="nc" id="L255">						Logging.deprecationPrint(&quot;Old syntax detected: &quot; + &quot;Prerequisites of kind &quot; + kind</span>
							+ &quot; now require a target value, &quot; + &quot;e.g. Key=Value.  Assuming Value=&quot; + assumed);
<span class="nc" id="L257">						subreq.setOperand(assumed);</span>
					}
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">					if (!warnIgnored)</span>
					{
<span class="fc" id="L261">						hasKeyOnly = true;</span>
					}
<span class="fc" id="L263">					subreq.setKey(thisElement);</span>
<span class="fc" id="L264">					subreq.setOperator(PrerequisiteOperator.GTEQ);</span>
				}
<span class="fc" id="L266">				subreq.setOperand(Integer.toString(min));</span>
<span class="fc" id="L267">				prereq.addPrerequisite(subreq);</span>
			}
<span class="fc bfc" id="L269" title="All 2 branches covered.">			for (Prerequisite element : prereq.getPrerequisites())</span>
			{
<span class="fc bfc" id="L271" title="All 2 branches covered.">				if (element.getOperand().equals(&quot;-99&quot;))</span>
				{
<span class="fc" id="L273">					element.setOperand(&quot;1&quot;);</span>
				}
<span class="fc" id="L275">			}</span>
<span class="pc bpc" id="L276" title="1 of 4 branches missed.">			if (hasKeyOnly &amp;&amp; hasKeyValue)</span>
			{
<span class="nc" id="L278">				Logging.deprecationPrint(&quot;You are using a deprecated syntax of PRE&quot; + kind + &quot;:&quot; + formula</span>
					+ &quot; ... Each item in the list should have a target value, e.g.: PRE&quot; + kind
					+ &quot;:1,First=99,Second=5&quot;);
			}
<span class="fc" id="L282">		}</span>
		else
		{
			// We only have a number of prereqs to pass, and a single prereq so we do not want a
			// wrapper prereq around a list of 1 element.
			// i.e. 1,Alertness, or 2,TYPE=ItemCreation, or 1,Reflex=7 or 3,Knowledge%=2 or 4,TYPE.Craft=5
<span class="fc" id="L288">			Prerequisite subreq = prereq;</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">			if (elementsLength &gt; 1)</span>
			{
<span class="fc bfc" id="L291" title="All 2 branches covered.">				for (int i = 1; i &lt; elements.length; ++i)</span>
				{
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">					if (&quot;CHECKMULT&quot;.equalsIgnoreCase(elements[i]))</span>
					{
<span class="nc" id="L295">						continue;</span>
					}

<span class="fc bfc" id="L298" title="All 2 branches covered.">					if (elements[i].indexOf('=') &gt;= 0)</span>
					{
						// i.e. TYPE=ItemCreation or Reflex=7
<span class="fc" id="L301">						String[] tokens = elements[i].split(&quot;=&quot;);</span>
<span class="fc" id="L302">						int valueIdx = tokens.length - 1;</span>
						try
						{
							// i.e. Reflex=7 or TYPE.Craft=5
<span class="fc" id="L306">							int iOper = Integer.parseInt(tokens[valueIdx]);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">							if (numRequired != 1)</span>
							{
								//
								// If we would lose the required number of matches,
								// then make this a PREMULT
								//
<span class="fc" id="L313">								prereq.setOperator(PrerequisiteOperator.GTEQ);</span>
<span class="fc" id="L314">								prereq.setOperand(Integer.toString(numRequired));</span>
<span class="fc" id="L315">								prereq.setKind(null);</span>
<span class="fc" id="L316">								subreq = new Prerequisite();</span>
<span class="fc" id="L317">								prereq.addPrerequisite(subreq);</span>
<span class="fc" id="L318">								subreq.setCountMultiples(true);</span>
							}
<span class="fc" id="L320">							subreq.setOperand(Integer.toString(iOper));</span>
<span class="fc" id="L321">							String requirementKey = getRequirementKey(tokens);</span>
<span class="fc" id="L322">							subreq.setKey(requirementKey);</span>
						}
<span class="fc" id="L324">						catch (NumberFormatException nfe)</span>
						{
<span class="fc bfc" id="L326" title="All 2 branches covered.">							if (tokens[valueIdx].equals(&quot;ANY&quot;))</span>
							{
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">								if (isAnyLegal())</span>
								{
<span class="fc" id="L330">									subreq.setOperand(tokens[valueIdx]);</span>
<span class="fc" id="L331">									subreq.setKey(getRequirementKey(tokens));</span>
								}
								else
								{
<span class="nc" id="L335">									throw new PersistenceLayerException(</span>
										&quot;Prerequisites of kind &quot; + kind + &quot; do not support 'ANY'&quot;, nfe);
								}
							}
							else
							{
								// i.e. TYPE=ItemCreation
<span class="fc" id="L342">								subreq.setOperand(elements[0]);</span>
<span class="fc" id="L343">								subreq.setKey(elements[i]);</span>
							}
<span class="fc" id="L345">						}</span>
<span class="fc" id="L346">					}</span>
					else
					{
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">						if (requiresValue())</span>
						{
<span class="nc" id="L351">							throw new PersistenceLayerException(</span>
								&quot;Prerequisites of kind &quot; + kind + &quot; require a target value, e.g. Key=Value&quot;);
						}
<span class="fc" id="L354">						String assumed = getAssumedValue();</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">						if (assumed == null)</span>
						{
<span class="fc" id="L357">							subreq.setOperand(elements[0]);</span>
						}
						else
						{
<span class="nc" id="L361">							Logging.deprecationPrint(&quot;Old syntax detected: &quot; + &quot;Prerequisites of kind &quot; + kind</span>
								+ &quot; now require a target value, &quot; + &quot;e.g. Key=Value.  Assuming Value=&quot; + assumed);
<span class="nc" id="L363">							subreq.setOperand(assumed);</span>
						}
<span class="fc" id="L365">						subreq.setKey(elements[i]);</span>
					}
				}
			}
			else
			{
<span class="nc" id="L371">				subreq.setOperand(elements[0]);</span>
			}
<span class="fc" id="L373">			subreq.setKind(kind.toLowerCase());</span>
<span class="fc" id="L374">			subreq.setOperator(PrerequisiteOperator.GTEQ);</span>
		}
<span class="fc" id="L376">	}</span>

	private String getRequirementKey(String[] tokens)
	{
		String reqKey;
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (tokens.length == 2)</span>
		{
<span class="fc" id="L383">			reqKey = tokens[0];</span>
		}
		else
		{
<span class="nc" id="L387">			List&lt;String&gt; parts = new ArrayList&lt;&gt;(Arrays.asList(tokens));</span>
<span class="nc" id="L388">			parts.remove(parts.size() - 1);</span>
<span class="nc" id="L389">			reqKey = StringUtils.join(parts, &quot;=&quot;);</span>
		}
<span class="fc" id="L391">		return reqKey;</span>
	}

	protected boolean isNoWarnElement(String thisElement)
	{
<span class="fc" id="L396">		return false;</span>
	}

	protected boolean isAnyLegal()
	{
<span class="fc" id="L401">		return true;</span>
	}

	protected String getAssumedValue()
	{
<span class="fc" id="L406">		return null;</span>
	}

	protected boolean requiresValue()
	{
<span class="fc" id="L411">		return false;</span>
	}

	/**
	 * @return Does this PREreq kind allow []  for negation 
	 */
	protected boolean allowsNegate()
	{
<span class="fc" id="L419">		return false;</span>
	}

	/**
	 * Flag each Prerequisite created to indicate that no character is 
	 * required to successfully test the Prerequisite. The function is 
	 * recursive to handle a single Prerequisite that gets split out 
	 * into a premult.
	 * 
	 * @param prereq the new no need for char
	 */
	protected void setNoNeedForChar(Prerequisite prereq)
	{
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">		if (prereq == null)</span>
		{
<span class="nc" id="L434">			return;</span>
		}
<span class="fc" id="L436">		prereq.setCharacterRequired(false);</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">		for (Prerequisite element : prereq.getPrerequisites())</span>
		{
<span class="fc" id="L440">			setNoNeedForChar(element);</span>
<span class="fc" id="L441">		}</span>
<span class="fc" id="L442">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>