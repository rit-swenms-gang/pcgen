<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompanionSupportFacadeImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.gui2.facade</a> &gt; <span class="el_source">CompanionSupportFacadeImpl.java</span></div><h1>CompanionSupportFacadeImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012 (C) Connor Petty &lt;cpmeister@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.gui2.facade;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.list.CompanionList;
import pcgen.core.FollowerOption;
import pcgen.core.Globals;
import pcgen.core.PlayerCharacter;
import pcgen.core.Race;
import pcgen.core.character.Follower;
import pcgen.core.display.CharacterDisplay;
import pcgen.facade.core.CharacterFacade;
import pcgen.facade.core.CompanionFacade;
import pcgen.facade.core.CompanionStubFacade;
import pcgen.facade.core.CompanionSupportFacade;
import pcgen.facade.core.PartyFacade;
import pcgen.facade.util.DefaultListFacade;
import pcgen.facade.util.DefaultMapFacade;
import pcgen.facade.util.ListFacade;
import pcgen.facade.util.MapFacade;
import pcgen.facade.util.ReferenceFacade;
import pcgen.facade.util.event.ListEvent;
import pcgen.facade.util.event.ListListener;
import pcgen.facade.util.event.ReferenceEvent;
import pcgen.facade.util.event.ReferenceListener;
import pcgen.system.CharacterManager;
import pcgen.util.Logging;
import pcgen.util.enumeration.Tab;

import org.apache.commons.lang3.StringUtils;

/**
 * This class implements the basic CompanionSupportFacade
 * for a given
 * {@code PlayerCharacter} and is
 * used to help implement companion support for the
 * CharacterFacade.
 * @see pcgen.gui2.facade.CharacterFacadeImpl
 */
public class CompanionSupportFacadeImpl implements CompanionSupportFacade, ListListener&lt;CharacterFacade&gt;
{

	private final DefaultListFacade&lt;CompanionFacadeDelegate&gt; companionList;
	private final PlayerCharacter theCharacter;
	private final CharacterDisplay charDisplay;
	private final DefaultListFacade&lt;CompanionStubFacade&gt; availCompList;
	private final DefaultMapFacade&lt;String, Integer&gt; maxCompanionsMap;
	private final Map&lt;String, CompanionList&gt; keyToCompanionListMap;
	private final TodoManager todoManager;
	private final CharacterFacadeImpl pcFacade;

	/**
	 * Create a new instance of CompanionSupportFacadeImpl
	 * @param theCharacter The character to be represented.
	 * @param todoManager The user tasks tracker.
	 * @param nameRef The reference to the character's name. 
	 * @param fileRef The reference to the character's file. 
	 * @param pcFacade The UI facade for the master.
	 */
	public CompanionSupportFacadeImpl(PlayerCharacter theCharacter, TodoManager todoManager,
		ReferenceFacade&lt;String&gt; nameRef, ReferenceFacade&lt;File&gt; fileRef, CharacterFacadeImpl pcFacade)
<span class="nc" id="L84">	{</span>
<span class="nc" id="L85">		this.theCharacter = theCharacter;</span>
<span class="nc" id="L86">		this.pcFacade = pcFacade;</span>
<span class="nc" id="L87">		this.charDisplay = theCharacter.getDisplay();</span>
<span class="nc" id="L88">		this.todoManager = todoManager;</span>
<span class="nc" id="L89">		this.companionList = new DefaultListFacade&lt;&gt;();</span>
<span class="nc" id="L90">		this.availCompList = new DefaultListFacade&lt;&gt;();</span>
<span class="nc" id="L91">		this.maxCompanionsMap = new DefaultMapFacade&lt;&gt;();</span>
<span class="nc" id="L92">		this.keyToCompanionListMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L93">		initCompData(true);</span>
<span class="nc" id="L94">		CharacterManager.getCharacters().addListListener(this);</span>
<span class="nc" id="L95">		addMasterListeners(nameRef, fileRef);</span>
<span class="nc" id="L96">	}</span>

	/**
	 * Add listeners to the master name and file that will update the master 
	 * information of all companions when the master changes.
	 * @param nameRef The reference to the character's name. 
	 * @param fileRef The reference to the character's file.
	 */
	private void addMasterListeners(ReferenceFacade&lt;String&gt; nameRef, ReferenceFacade&lt;File&gt; fileRef)
	{
<span class="nc" id="L106">		nameRef.addReferenceListener(e -&gt; {</span>
<span class="nc" id="L107">            String newName = e.getNewReference();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            for (CompanionFacadeDelegate delegate : companionList)</span>
            {
<span class="nc" id="L110">                CharacterFacade companion = CharacterManager.getCharacterMatching(delegate);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                if (companion != null)</span>
                {
<span class="nc" id="L113">                    CharacterFacadeImpl compFacadeImpl = (CharacterFacadeImpl) companion;</span>
<span class="nc" id="L114">                    Follower follower = compFacadeImpl.getTheCharacter().getDisplay().getMaster();</span>
<span class="nc" id="L115">                    follower.setName(newName);</span>
                }
<span class="nc" id="L117">            }</span>

<span class="nc" id="L119">        });</span>
<span class="nc" id="L120">		fileRef.addReferenceListener(e -&gt; {</span>
<span class="nc" id="L121">            File newFile = e.getNewReference();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (CompanionFacadeDelegate delegate : companionList)</span>
            {
<span class="nc" id="L124">                CharacterFacade companion = CharacterManager.getCharacterMatching(delegate);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                if (companion != null)</span>
                {
<span class="nc" id="L127">                    CharacterFacadeImpl compFacadeImpl = (CharacterFacadeImpl) companion;</span>
<span class="nc" id="L128">                    Follower follower = compFacadeImpl.getTheCharacter().getDisplay().getMaster();</span>
<span class="nc" id="L129">                    follower.setFileName(newFile.getAbsolutePath());</span>
                }
<span class="nc" id="L131">            }</span>

<span class="nc" id="L133">        });</span>
<span class="nc" id="L134">	}</span>

	/**
	 * Refresh the character's companion information, reflecting any changes in 
	 * the character's qualification for companions.   
	 */
	void refreshCompanionData()
	{
<span class="nc" id="L142">		initCompData(false);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">		for (CompanionFacadeDelegate delegate : companionList)</span>
		{
<span class="nc" id="L145">			CompanionFacade compFacade = delegate.getDelegate();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if (compFacade instanceof CharacterFacadeImpl compFacadeImpl)</span>
			{
<span class="nc" id="L148">				PlayerCharacter pc = compFacadeImpl.getTheCharacter();</span>
<span class="nc" id="L149">				pc.setMaster(pc.getDisplay().getMaster());</span>
<span class="nc" id="L150">				compFacadeImpl.refreshClassLevelModel();</span>
<span class="nc" id="L151">				compFacadeImpl.postLevellingUpdates();</span>
			}
<span class="nc" id="L153">		}</span>
<span class="nc" id="L154">	}</span>

	/**
	 * Initialisation of the character's companion data.
	 * @param rebuildCompanionList Should the list of the character;s companions be rebuilt?
	 */
	private void initCompData(boolean rebuildCompanionList)
	{
<span class="nc" id="L162">		List&lt;CompanionStub&gt; companions = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">		for (CompanionList compList : Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L164">			.getConstructedCDOMObjects(CompanionList.class))</span>
		{
<span class="nc" id="L166">			keyToCompanionListMap.put(compList.getKeyName(), compList);</span>
<span class="nc" id="L167">			Map&lt;FollowerOption, CDOMObject&gt; fMap = charDisplay.getAvailableFollowers(compList.getKeyName(), null);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			for (FollowerOption followerOpt : fMap.keySet())</span>
			{
<span class="nc bnc" id="L170" title="All 4 branches missed.">				if (!followerOpt.getRace().isUnselected() &amp;&amp; followerOpt.qualifies(theCharacter, null))</span>
				{
<span class="nc" id="L172">					companions.add(new CompanionStub(followerOpt.getRace(), compList.getKeyName()));</span>
				}
<span class="nc" id="L174">			}</span>
<span class="nc" id="L175">			int maxVal = theCharacter.getMaxFollowers(compList);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (maxVal == 0)</span>
			{
<span class="nc" id="L178">				maxCompanionsMap.removeKey(compList.toString());</span>
			}
			else
			{
<span class="nc" id="L182">				maxCompanionsMap.putValue(compList.toString(), maxVal);</span>
			}
<span class="nc" id="L184">		}</span>
<span class="nc" id="L185">		availCompList.updateContents(companions);</span>
		//Logging.debugPrint(&quot;Available comps &quot; + availCompList);
		//Logging.debugPrint(&quot;Max comps &quot; + maxCompanionsMap);

<span class="nc bnc" id="L189" title="All 2 branches missed.">		if (rebuildCompanionList)</span>
		{
<span class="nc bnc" id="L191" title="All 2 branches missed.">			for (Follower follower : charDisplay.getFollowerList())</span>
			{
<span class="nc" id="L193">				CompanionFacade comp = new CompanionNotLoaded(follower.getName(), new File(follower.getFileName()),</span>
<span class="nc" id="L194">					follower.getRace(), follower.getType().toString());</span>
<span class="nc" id="L195">				CompanionFacadeDelegate delegate = new CompanionFacadeDelegate();</span>
<span class="nc" id="L196">				delegate.setCompanionFacade(comp);</span>
<span class="nc" id="L197">				companionList.addElement(delegate);</span>
<span class="nc" id="L198">			}</span>
		}
		//Logging.debugPrint(&quot;Companion list &quot; + companionList);
<span class="nc bnc" id="L201" title="All 2 branches missed.">		for (CompanionList compList : Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L202">			.getConstructedCDOMObjects(CompanionList.class))</span>
		{
<span class="nc" id="L204">			updateCompanionTodo(compList.toString());</span>
<span class="nc" id="L205">		}</span>
<span class="nc" id="L206">	}</span>

	private void updateCompanionTodo(String companionType)
	{
<span class="nc" id="L210">		Integer max = maxCompanionsMap.getValue(companionType);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">		int maxCompanions = max == null ? 0 : max;</span>
<span class="nc" id="L212">		int numCompanions = 0;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">		for (CompanionFacadeDelegate cfd : companionList)</span>
		{
<span class="nc bnc" id="L215" title="All 2 branches missed.">			if (cfd.getCompanionType().equals(companionType))</span>
			{
<span class="nc" id="L217">				numCompanions++;</span>
			}
<span class="nc" id="L219">		}</span>

<span class="nc bnc" id="L221" title="All 4 branches missed.">		if (maxCompanions &gt; -1 &amp;&amp; maxCompanions &lt; numCompanions)</span>
		{
<span class="nc" id="L223">			todoManager.addTodo(</span>
				new TodoFacadeImpl(
					Tab.COMPANIONS, companionType, &quot;in_companionTodoTooMany&quot;, companionType, 1)); //$NON-NLS-1$
<span class="nc" id="L226">			todoManager.removeTodo(&quot;in_companionTodoRemain&quot;, companionType); //$NON-NLS-1$</span>
		}
<span class="nc bnc" id="L228" title="All 4 branches missed.">		else if (maxCompanions &gt; -1 &amp;&amp; maxCompanions &gt; numCompanions)</span>
		{
<span class="nc" id="L230">			todoManager.addTodo(</span>
				new TodoFacadeImpl(
					Tab.COMPANIONS, companionType, &quot;in_companionTodoRemain&quot;, companionType, 1)); //$NON-NLS-1$
<span class="nc" id="L233">			todoManager.removeTodo(&quot;in_companionTodoTooMany&quot;, companionType); //$NON-NLS-1$</span>
		}
		else
		{
<span class="nc" id="L237">			todoManager.removeTodo(&quot;in_companionTodoRemain&quot;, companionType); //$NON-NLS-1$</span>
<span class="nc" id="L238">			todoManager.removeTodo(&quot;in_companionTodoTooMany&quot;, companionType); //$NON-NLS-1$</span>
		}
<span class="nc" id="L240">	}</span>

	@Override
	public void addCompanion(CharacterFacade companion, String companionType)
	{
<span class="nc bnc" id="L245" title="All 4 branches missed.">		if (companion == null || !(companion instanceof CharacterFacadeImpl compFacadeImpl))</span>
		{
<span class="nc" id="L247">			return;</span>
		}

<span class="nc" id="L250">		CompanionList compList = keyToCompanionListMap.get(companionType);</span>
<span class="nc" id="L251">		Race compRace = compFacadeImpl.getRaceRef().get();</span>
<span class="nc" id="L252">		FollowerOption followerOpt = getFollowerOpt(compList, compRace);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (followerOpt == null)</span>
		{
<span class="nc" id="L255">			Logging.errorPrint(&quot;Unable to find follower option for companion &quot; //$NON-NLS-1$</span>
				+ companion + &quot; of race &quot; + compRace); //$NON-NLS-1$
<span class="nc" id="L257">			return;</span>
		}

<span class="nc bnc" id="L260" title="All 2 branches missed.">		if (!followerOpt.qualifies(theCharacter, null))</span>
		{
<span class="nc" id="L262">			Logging.errorPrint(&quot;Not qualified to take companion &quot; //$NON-NLS-1$</span>
				+ companion + &quot; of race &quot; + compRace); //$NON-NLS-1$
<span class="nc" id="L264">			return;</span>
		}

		// Update the companion with the master details
<span class="nc" id="L268">		Logging.log(Logging.INFO, &quot;Setting master to &quot; + charDisplay.getName() //$NON-NLS-1$</span>
			+ &quot; for character &quot; + compFacadeImpl); //$NON-NLS-1$
<span class="nc" id="L270">		final Follower newMaster = new Follower(charDisplay.getFileName(), charDisplay.getName(), compList);</span>
<span class="nc" id="L271">		newMaster.setAdjustment(followerOpt.getAdjustment());</span>
<span class="nc" id="L272">		compFacadeImpl.getTheCharacter().setMaster(newMaster);</span>
<span class="nc" id="L273">		compFacadeImpl.refreshClassLevelModel();</span>
<span class="nc" id="L274">		compFacadeImpl.postLevellingUpdates();</span>

		// Update the master with the new companion
<span class="nc" id="L277">		File compFile = compFacadeImpl.getFileRef().get();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">		String compFilename = StringUtils.isEmpty(compFile.getPath()) ? &quot;&quot; : compFile.getAbsolutePath();</span>
<span class="nc" id="L279">		Follower follower = new Follower(compFilename, compFacadeImpl.getNameRef().get(), compList);</span>
<span class="nc" id="L280">		follower.setRace(compRace);</span>
<span class="nc" id="L281">		theCharacter.addFollower(follower);</span>
<span class="nc" id="L282">		theCharacter.setCalcFollowerBonus();</span>
<span class="nc" id="L283">		theCharacter.calcActiveBonuses();</span>
<span class="nc" id="L284">		pcFacade.postLevellingUpdates();</span>

<span class="nc" id="L286">		CompanionFacadeDelegate delegate = new CompanionFacadeDelegate();</span>
<span class="nc" id="L287">		delegate.setCompanionFacade(companion);</span>
<span class="nc" id="L288">		companionList.addElement(delegate);</span>

		// Watch companion file name and character name to update follower record
<span class="nc" id="L291">		companion.getFileRef().addReferenceListener(new DelegateFileListener(follower));</span>
<span class="nc" id="L292">		companion.getNameRef().addReferenceListener(new DelegateNameListener(follower));</span>

<span class="nc" id="L294">		updateCompanionTodo(companionType);</span>
<span class="nc" id="L295">	}</span>

	private FollowerOption getFollowerOpt(CompanionList compList, Race compRace)
	{
<span class="nc" id="L299">		FollowerOption followerOpt = null;</span>
<span class="nc" id="L300">		Map&lt;FollowerOption, CDOMObject&gt; fMap = charDisplay.getAvailableFollowers(compList.getKeyName(), null);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">		for (FollowerOption fOpt : fMap.keySet())</span>
		{
<span class="nc bnc" id="L303" title="All 2 branches missed.">			if (compRace == fOpt.getRace())</span>
			{
<span class="nc" id="L305">				followerOpt = fOpt;</span>
<span class="nc" id="L306">				break;</span>
			}
<span class="nc" id="L308">		}</span>
<span class="nc" id="L309">		return followerOpt;</span>
	}

	@Override
	public void removeCompanion(CompanionFacade companion)
	{
<span class="nc bnc" id="L315" title="All 2 branches missed.">		if (!(companion instanceof CompanionFacadeDelegate))</span>
		{
<span class="nc" id="L317">			return;</span>
		}

<span class="nc" id="L320">		File compFile = companion.getFileRef().get();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">		for (Follower follower : charDisplay.getFollowerList())</span>
		{
<span class="nc" id="L323">			File followerFile = new File(follower.getFileName());</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">			if (followerFile.equals(compFile))</span>
			{
<span class="nc" id="L326">				theCharacter.delFollower(follower);</span>
<span class="nc" id="L327">				break;</span>
			}
<span class="nc" id="L329">		}</span>
<span class="nc" id="L330">		companionList.removeElement((CompanionFacadeDelegate) companion);</span>

<span class="nc" id="L332">		updateCompanionTodo(companion.getCompanionType());</span>
<span class="nc" id="L333">	}</span>

	/**
	 * Adds a newly opened character into the existing
	 * companion framework. This character will replace
	 * the dummy CompanionFacade that has the same
	 * file name. This should typically be called
	 * when a character is opened from one of the follower stubs
	 * @param character the character to link
	 */
	private void linkCompanion(CharacterFacade character)
	{
<span class="nc bnc" id="L345" title="All 2 branches missed.">		for (CompanionFacadeDelegate delegate : companionList)</span>
		{
<span class="nc" id="L347">			File file = delegate.getFileRef().get();</span>
<span class="nc" id="L348">			String name = delegate.getNameRef().get();</span>
<span class="nc" id="L349">			Race race = delegate.getRaceRef().get();</span>
<span class="nc bnc" id="L350" title="All 6 branches missed.">			if (file.equals(character.getFileRef().get()) &amp;&amp; name.equals(character.getNameRef().get())</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">				&amp;&amp; (race == null || race.equals(character.getRaceRef().get())))</span>
			{
<span class="nc" id="L353">				String companionType = delegate.getCompanionType();</span>
<span class="nc" id="L354">				delegate.setCompanionFacade(character);</span>

				// Check for a companion being loaded that is not properly linked to the master.
				// Note: When creating a companion we leave the linking to the create code.  
<span class="nc bnc" id="L358" title="All 4 branches missed.">				if (character.getMaster() == null &amp;&amp; character.getRaceRef().get() != null</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">					&amp;&amp; !character.getRaceRef().get().isUnselected())</span>
				{
<span class="nc" id="L361">					CompanionList compList = keyToCompanionListMap.get(companionType);</span>
<span class="nc" id="L362">					final Follower newMaster = new Follower(charDisplay.getFileName(), charDisplay.getName(), compList);</span>
<span class="nc" id="L363">					FollowerOption followerOpt = getFollowerOpt(compList, character.getRaceRef().get());</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">					if (followerOpt != null)</span>
					{
<span class="nc" id="L366">						newMaster.setAdjustment(followerOpt.getAdjustment());</span>
					}
					else
					{
<span class="nc" id="L370">						Logging.log(Logging.WARNING, &quot;Failed to find FollowerOption for complist &quot; + compList</span>
<span class="nc" id="L371">							+ &quot; and race &quot; + character.getRaceRef().get());</span>
					}
<span class="nc" id="L373">					((CharacterFacadeImpl) character).getTheCharacter().setMaster(newMaster);</span>
				}
<span class="nc" id="L375">				return;</span>
			}
<span class="nc" id="L377">		}</span>
<span class="nc" id="L378">	}</span>

	/**
	 * Remove ourselves from the global characters list so that
	 * the current character can be garbage collected.
	 */
	void closeCharacter()
	{
<span class="nc" id="L386">		CharacterManager.getCharacters().removeListListener(this);</span>
<span class="nc" id="L387">	}</span>

	/**
	 * Removes a character from the companion framework.
	 * This will replace the specified character with a dummy
	 * CompanionFacade.
	 * This should be called after the specified character has been closed
	 * or is closing.
	 * If this method is not called after closing a companion character
	 * the underlying CharacterFacade would not be able to be garbage collected.
	 * @param character the character to unlink
	 */
	private void unlinkCompanion(CharacterFacade character)
	{
<span class="nc bnc" id="L401" title="All 2 branches missed.">		for (CompanionFacadeDelegate delegate : companionList)</span>
		{
<span class="nc" id="L403">			File file = delegate.getFileRef().get();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">			if (file.equals(character.getFileRef().get()))</span>
			{
<span class="nc" id="L406">				CompanionFacade comp = new CompanionNotLoaded(character.getNameRef().get(),</span>
<span class="nc" id="L407">					character.getFileRef().get(), character.getRaceRef().get(), delegate.getCompanionType());</span>
<span class="nc" id="L408">				delegate.setCompanionFacade(comp);</span>
<span class="nc" id="L409">				return;</span>
			}
<span class="nc" id="L411">		}</span>
<span class="nc" id="L412">	}</span>

	@Override
	public ListFacade&lt;CompanionStubFacade&gt; getAvailableCompanions()
	{
<span class="nc" id="L417">		return availCompList;</span>
	}

	@Override
	public MapFacade&lt;String, Integer&gt; getMaxCompanionsMap()
	{
<span class="nc" id="L423">		return maxCompanionsMap;</span>
	}

	@Override
	public ListFacade&lt;? extends CompanionFacade&gt; getCompanions()
	{
<span class="nc" id="L429">		return companionList;</span>
	}

	@Override
	public void elementAdded(ListEvent&lt;CharacterFacade&gt; e)
	{
<span class="nc" id="L435">		linkCompanion(e.getElement());</span>
<span class="nc" id="L436">	}</span>

	@Override
	public void elementRemoved(ListEvent&lt;CharacterFacade&gt; e)
	{
<span class="nc" id="L441">		unlinkCompanion(e.getElement());</span>
<span class="nc" id="L442">	}</span>

	@Override
	public void elementsChanged(ListEvent&lt;CharacterFacade&gt; e)
	{
<span class="nc" id="L447">		PartyFacade characters = CharacterManager.getCharacters();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">		for (CharacterFacade characterFacade : characters)</span>
		{
<span class="nc" id="L450">			linkCompanion(characterFacade);</span>
<span class="nc" id="L451">		}</span>
		// TODO: Unlink characters no longer open 
<span class="nc" id="L453">	}</span>

	@Override
	public void elementModified(ListEvent&lt;CharacterFacade&gt; e)
	{
		// Ignored.
<span class="nc" id="L459">	}</span>

	/**
	 * The Class {@code DelegateFileListener} tracks the file name of a companion and
	 * keeps the associated Follower record up to date.
	 */
	private static class DelegateFileListener implements ReferenceListener&lt;File&gt;
	{
		private final Follower follower;

		public DelegateFileListener(Follower followerIn)
<span class="nc" id="L470">		{</span>
<span class="nc" id="L471">			this.follower = followerIn;</span>
<span class="nc" id="L472">		}</span>

		@Override
		public void referenceChanged(ReferenceEvent&lt;File&gt; e)
		{
<span class="nc" id="L477">			follower.setFileName(e.getNewReference().getAbsolutePath());</span>
<span class="nc" id="L478">		}</span>
	}

	/**
	 * The Class {@code DelegateNameListener} tracks the name of a companion and
	 * keeps the associated Follower record up to date.
	 */
	private static class DelegateNameListener implements ReferenceListener&lt;String&gt;
	{
		private final Follower follower;

		public DelegateNameListener(Follower followerIn)
<span class="nc" id="L490">		{</span>
<span class="nc" id="L491">			this.follower = followerIn;</span>
<span class="nc" id="L492">		}</span>

		@Override
		public void referenceChanged(ReferenceEvent&lt;String&gt; e)
		{
<span class="nc" id="L497">			follower.setName(e.getNewReference());</span>
<span class="nc" id="L498">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>