<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BonusCalc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core.analysis</a> &gt; <span class="el_source">BonusCalc.java</span></div><h1>BonusCalc.java</h1><pre class="source lang-java linenums">/*
 * Missing License Header, Copyright 2016 (C) Andrew Maitland &lt;amaitland@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core.analysis;

import java.util.Collection;
import java.util.StringTokenizer;

import pcgen.core.Ability;
import pcgen.core.AbilityUtilities;
import pcgen.core.Equipment;
import pcgen.core.Globals;
import pcgen.core.PCStat;
import pcgen.core.PObject;
import pcgen.core.PlayerCharacter;
import pcgen.core.RuleConstants;
import pcgen.core.bonus.BonusObj;
import pcgen.core.prereq.PrereqHandler;
import pcgen.util.Logging;

public final class BonusCalc
{

	private BonusCalc()
	{
	}

	/**
	 * Gets the bonuses to a given stat.
	 *
	 * @param po
	 * @param stat the Stat to get the bonus for
	 * @param aPC the Player Character that the bonus will apply to
	 * @return the bonus to the given stat.
	 */
	public static int getStatMod(PObject po, PCStat stat, final PlayerCharacter aPC)
	{
<span class="nc" id="L52">		return (int) BonusCalc.charBonusTo(po, &quot;STAT&quot;, stat.getKeyName(), aPC);</span>
	}

	public static double bonusTo(PObject po, String aType, String aName, final Object obj,
		final Collection&lt;BonusObj&gt; aBonusList, final PlayerCharacter aPC)
	{
<span class="nc bnc" id="L58" title="All 4 branches missed.">		if ((aBonusList == null) || (aBonusList.isEmpty()))</span>
		{
<span class="nc" id="L60">			return 0;</span>
		}

<span class="nc" id="L63">		double retVal = 0;</span>

<span class="nc" id="L65">		aType = aType.toUpperCase();</span>
<span class="nc" id="L66">		aName = aName.toUpperCase();</span>

<span class="nc" id="L68">		final String aTypePlusName = aType + '.' + aName + '.';</span>

<span class="nc bnc" id="L70" title="All 6 branches missed.">		if (!BonusCalc.dontRecurse &amp;&amp; (po instanceof Ability) &amp;&amp; (AbilityUtilities.isFeat(obj))</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">			&amp;&amp; !Globals.checkRule(RuleConstants.FEATPRE))</span>
		{
			// SUCK!  This is horrid, but bonusTo is actually recursive with respect to
			// passesPreReqToGain and there is no other way to do this without decomposing the
			// dependencies.  I am loathe to break working code.
			// This addresses bug #709677 -- Feats give bonuses even if you no longer qualify
<span class="nc" id="L77">			BonusCalc.dontRecurse = true;</span>

<span class="nc" id="L79">			boolean returnZero = false;</span>

<span class="nc bnc" id="L81" title="All 2 branches missed.">			if (!po.qualifies(aPC, po))</span>
			{
<span class="nc" id="L83">				returnZero = true;</span>
			}

<span class="nc" id="L86">			BonusCalc.dontRecurse = false;</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">			if (returnZero)</span>
			{
<span class="nc" id="L90">				return 0;</span>
			}
		}

<span class="nc" id="L94">		int iTimes = 1;</span>

<span class="nc bnc" id="L96" title="All 4 branches missed.">		if (aPC != null &amp;&amp; &quot;VAR&quot;.equals(aType))</span>
		{
<span class="nc" id="L98">			iTimes = Math.max(1, aPC.getConsolidatedAssociationList(po).size());</span>
		}

<span class="nc bnc" id="L101" title="All 2 branches missed.">		for (BonusObj bonus : aBonusList)</span>
		{
<span class="nc" id="L103">			String bString = bonus.toString().toUpperCase();</span>

<span class="nc bnc" id="L105" title="All 4 branches missed.">			if (aPC != null &amp;&amp; !aPC.getConsolidatedAssociationList(po).isEmpty())</span>
			{
<span class="nc" id="L107">				int span = 4;</span>
<span class="nc" id="L108">				int idx = bString.indexOf(&quot;%VAR&quot;);</span>

<span class="nc bnc" id="L110" title="All 2 branches missed.">				if (idx == -1)</span>
				{
<span class="nc" id="L112">					idx = bString.indexOf(&quot;%LIST|&quot;);</span>
<span class="nc" id="L113">					span = 5;</span>
				}

<span class="nc bnc" id="L116" title="All 2 branches missed.">				if (idx &gt;= 0)</span>
				{
<span class="nc" id="L118">					final String firstPart = bString.substring(0, idx);</span>
<span class="nc" id="L119">					final String secondPart = bString.substring(idx + span);</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">					for (String assoc : aPC.getConsolidatedAssociationList(po))</span>
					{
<span class="nc" id="L123">						final String xString = (firstPart + assoc + secondPart).toUpperCase();</span>

<span class="nc" id="L125">						retVal +=</span>
<span class="nc" id="L126">								BonusCalc.calcBonus(po, xString, aType, aName, aTypePlusName, obj, iTimes, bonus, aPC);</span>
<span class="nc" id="L127">					}</span>
				}
<span class="nc" id="L129">			}</span>
			else
			{
<span class="nc" id="L132">				retVal += BonusCalc.calcBonus(po, bString, aType, aName, aTypePlusName, obj, iTimes, bonus, aPC);</span>
			}
<span class="nc" id="L134">		}</span>

<span class="nc" id="L136">		return retVal;</span>
	}

	/** a boolean for whether something should recurse, default is false. */
<span class="nc" id="L140">	private static boolean dontRecurse = false;</span>

	/**
	 * Apply the bonus to a PC, pass through object's default bonuslist
	 *
	 * @param po
	 * @param aType
	 * @param aName
	 * @param aPC
	 * @return the bonus
	 */
	public static double charBonusTo(PObject po, final String aType, final String aName, final PlayerCharacter aPC)
	{
<span class="nc" id="L153">		return bonusTo(po, aType, aName, aPC, po.getBonusList(aPC), aPC);</span>
	}

	public static double equipBonusTo(Equipment po, final String aType, final String aName, final PlayerCharacter aPC)
	{
<span class="nc" id="L158">		return bonusTo(po, aType, aName, po, po.getBonusList(po), aPC);</span>
	}

	/**
	 * calcBonus adds together all the bonuses for aType of aName.
	 *
	 * @param po
	 * @param bString       Either the entire BONUS:COMBAT|AC|2 string or part of a %LIST or %VAR bonus section
	 * @param aType         Such as &quot;COMBAT&quot;
	 * @param aName         Such as &quot;AC&quot;
	 * @param aTypePlusName &quot;COMBAT.AC.&quot;
	 * @param obj           The object to get the bonus from
	 * @param iTimes        multiply bonus * iTimes
	 * @param aBonusObj
	 * @param aPC
	 * @return the value of the bonus
	 */
	private static double calcBonus(PObject po, final String bString, final String aType, final String aName,
		String aTypePlusName, final Object obj, final int iTimes, final BonusObj aBonusObj, final PlayerCharacter aPC)
	{
<span class="nc" id="L178">		final StringTokenizer aTok = new StringTokenizer(bString, &quot;|&quot;);</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">		if (aTok.countTokens() &lt; 3)</span>
		{
<span class="nc" id="L182">			Logging.errorPrint(&quot;Badly formed BONUS:&quot; + bString);</span>

<span class="nc" id="L184">			return 0;</span>
		}

<span class="nc" id="L187">		String aString = aTok.nextToken();</span>

<span class="nc bnc" id="L189" title="All 6 branches missed.">		if (!aString.equalsIgnoreCase(aType) || aString.endsWith(&quot;%LIST&quot;) || aName.equals(&quot;ALL&quot;))</span>
		{
<span class="nc" id="L191">			return 0;</span>
		}

<span class="nc" id="L194">		final String aList = aTok.nextToken();</span>

<span class="nc bnc" id="L196" title="All 6 branches missed.">		if (!aList.equals(&quot;LIST&quot;) &amp;&amp; !aList.equals(&quot;ALL&quot;) &amp;&amp; (!aList.toUpperCase().contains(aName.toUpperCase())))</span>
		{
<span class="nc" id="L198">			return 0;</span>
		}

<span class="nc bnc" id="L201" title="All 8 branches missed.">		if (aList.equals(&quot;ALL&quot;) &amp;&amp; ((aName.contains(&quot;STAT=&quot;)) || (aName.contains(&quot;TYPE=&quot;)) || (aName.contains(&quot;LIST&quot;))</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			|| (aName.contains(&quot;VAR&quot;))))</span>
		{
<span class="nc" id="L204">			return 0;</span>
		}

<span class="nc bnc" id="L207" title="All 2 branches missed.">		if (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L209">			aString = aTok.nextToken();</span>
		}

<span class="nc" id="L212">		double iBonus = 0;</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (obj instanceof PlayerCharacter)</span>
		{
<span class="nc" id="L216">			iBonus = ((PlayerCharacter) obj).getVariableValue(aString, &quot;&quot;).doubleValue();</span>
		}
<span class="nc bnc" id="L218" title="All 2 branches missed.">		else if (obj instanceof Equipment)</span>
		{
<span class="nc" id="L220">			iBonus = ((Equipment) obj).getVariableValue(aString, &quot;&quot;, aPC).doubleValue();</span>
		}
		else
		{
			try
			{
<span class="nc" id="L226">				iBonus = Float.parseFloat(aString);</span>
			}
<span class="nc" id="L228">			catch (NumberFormatException e)</span>
			{
				//Should this be ignored?
<span class="nc" id="L231">				Logging.errorPrint(&quot;calcBonus NumberFormatException in BONUS: &quot; + aString, e);</span>
<span class="nc" id="L232">			}</span>
		}

<span class="nc" id="L235">		final String possibleBonusTypeString = aBonusObj.getTypeString();</span>

		// must meet criteria before adding any bonuses
<span class="nc bnc" id="L238" title="All 2 branches missed.">		if (obj instanceof PlayerCharacter)</span>
		{
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if (!aBonusObj.qualifies((PlayerCharacter) obj, po))</span>
			{
<span class="nc" id="L242">				return 0;</span>
			}
		}
		else
		{
<span class="nc bnc" id="L247" title="All 2 branches missed.">			if (!PrereqHandler.passesAll(aBonusObj, (Equipment) obj, aPC))</span>
			{
<span class="nc" id="L249">				return 0;</span>
			}
		}

<span class="nc" id="L253">		double bonus = 0;</span>

<span class="nc" id="L255">		String bonusTypeString = null;</span>

<span class="nc" id="L257">		final StringTokenizer bTok = new StringTokenizer(aList, &quot;,&quot;);</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">		if (aList.equalsIgnoreCase(&quot;LIST&quot;))</span>
		{
<span class="nc" id="L261">			bTok.nextToken();</span>
		}
<span class="nc bnc" id="L263" title="All 2 branches missed.">		else if (aList.equalsIgnoreCase(&quot;ALL&quot;))</span>
		{
			// aTypePlusName looks like: &quot;SKILL.ALL.&quot;
			// so we need to reset it to &quot;SKILL.Hide.&quot;
<span class="nc" id="L267">			aTypePlusName = aType + '.' + aName + '.';</span>
<span class="nc" id="L268">			bonus = iBonus;</span>
<span class="nc" id="L269">			bonusTypeString = possibleBonusTypeString;</span>
		}

<span class="nc bnc" id="L272" title="All 2 branches missed.">		while (bTok.hasMoreTokens())</span>
		{
<span class="nc bnc" id="L274" title="All 2 branches missed.">			if (bTok.nextToken().equalsIgnoreCase(aName))</span>
			{
<span class="nc" id="L276">				bonus += iBonus;</span>
<span class="nc" id="L277">				bonusTypeString = possibleBonusTypeString;</span>
			}
		}

<span class="nc bnc" id="L281" title="All 2 branches missed.">		if (obj instanceof Equipment)</span>
		{
<span class="nc" id="L283">			((Equipment) obj).setBonusStackFor(bonus * iTimes, aTypePlusName + bonusTypeString);</span>
		}

		// The &quot;ALL&quot; subtag is used to build the stacking bonusMap
		// not to get a bonus value, so just return
<span class="nc bnc" id="L288" title="All 2 branches missed.">		if (aList.equals(&quot;ALL&quot;))</span>
		{
<span class="nc" id="L290">			return 0;</span>
		}

<span class="nc" id="L293">		return bonus * iTimes;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>