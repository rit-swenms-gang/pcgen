<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DomainApplication.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core.analysis</a> &gt; <span class="el_source">DomainApplication.java</span></div><h1>DomainApplication.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 (C) Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * Copyright 2001 (C) Bryan McRoberts &lt;merton_monk@yahoo.com&gt;
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core.analysis;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

import pcgen.base.formula.Formula;
import pcgen.cdom.base.AssociatedPrereqObject;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.enumeration.AssociationKey;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.helper.ClassSource;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.cdom.list.DomainSpellList;
import pcgen.cdom.reference.CDOMSingleRef;
import pcgen.core.Domain;
import pcgen.core.Globals;
import pcgen.core.PCClass;
import pcgen.core.PlayerCharacter;
import pcgen.core.QualifiedObject;
import pcgen.core.character.CharacterSpell;
import pcgen.core.prereq.PrereqHandler;
import pcgen.core.spell.Spell;

public final class DomainApplication
{
	private DomainApplication()
	{
	}

	/**
	 * Sets the locked flag on a PC
	 * 
	 * @param pc
	 */
	public static void applyDomain(PlayerCharacter pc, Domain d)
	{
<span class="nc" id="L58">		ClassSource source = pc.getDomainSource(d);</span>
<span class="nc" id="L59">		PCClass aClass = pc.getClassKeyed(source.getPcclass().getKeyName());</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if (aClass != null)</span>
		{
			int maxLevel;

<span class="nc bnc" id="L64" title="All 2 branches missed.">			for (maxLevel = 0; maxLevel &lt; 10; maxLevel++)</span>
			{
<span class="nc bnc" id="L66" title="All 2 branches missed.">				if (pc.getSpellSupport(aClass).getCastForLevel(maxLevel, pc) == 0)</span>
				{
<span class="nc" id="L68">					break;</span>
				}
			}

<span class="nc bnc" id="L72" title="All 2 branches missed.">			if (maxLevel &gt; 0)</span>
			{
<span class="nc" id="L74">				addSpellsToClassForLevels(pc, d, aClass, 0, maxLevel - 1);</span>
			}

<span class="nc bnc" id="L77" title="All 4 branches missed.">			if ((maxLevel &gt; 1) &amp;&amp; (aClass.getSafe(IntegerKey.KNOWN_SPELLS_FROM_SPECIALTY) == 0))</span>
			{
<span class="nc" id="L79">				DomainSpellList domainSpellList = d.get(ObjectKey.DOMAIN_SPELLLIST);</span>
<span class="nc" id="L80">				final List&lt;Spell&gt; aList = pc.getAllSpellsInLists(Collections.singletonList(domainSpellList));</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">				for (Spell gcs : aList)</span>
				{
<span class="nc bnc" id="L84" title="All 2 branches missed.">					if (SpellLevel.getFirstLvlForKey(gcs, domainSpellList, pc) &lt; maxLevel)</span>
					{
<span class="nc" id="L86">						pc.setDomainSpellCount(aClass, 1);</span>
<span class="nc" id="L87">						break;</span>
					}
<span class="nc" id="L89">				}</span>
			}
		}

<span class="nc" id="L93">		Collection&lt;CDOMReference&lt;Spell&gt;&gt; mods = d.getSafeListMods(Spell.SPELLS);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">		for (CDOMReference&lt;Spell&gt; ref : mods)</span>
		{
<span class="nc" id="L96">			Collection&lt;Spell&gt; spells = ref.getContainedObjects();</span>
<span class="nc" id="L97">			Collection&lt;AssociatedPrereqObject&gt; assoc = d.getListAssociations(Spell.SPELLS, ref);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">			for (AssociatedPrereqObject apo : assoc)</span>
			{
<span class="nc bnc" id="L100" title="All 2 branches missed.">				if (!PrereqHandler.passesAll(apo, pc, d))</span>
				{
<span class="nc" id="L102">					continue;</span>
				}
<span class="nc bnc" id="L104" title="All 2 branches missed.">				for (Spell s : spells)</span>
				{
<span class="nc" id="L106">					String book = apo.getAssociation(AssociationKey.SPELLBOOK);</span>
<span class="nc" id="L107">					List&lt;CharacterSpell&gt; aList = pc.getCharacterSpells(aClass, s, book, -1);</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">					if (aList.isEmpty())</span>
					{
<span class="nc" id="L111">						Formula times = apo.getAssociation(AssociationKey.TIMES_PER_UNIT);</span>
<span class="nc" id="L112">						CharacterSpell cs = new CharacterSpell(d, s);</span>
<span class="nc" id="L113">						int resolvedTimes = times.resolve(pc, d.getQualifiedKey()).intValue();</span>
<span class="nc" id="L114">						cs.addInfo(1, resolvedTimes, book);</span>
<span class="nc" id="L115">						pc.addCharacterSpell(aClass, cs);</span>
					}
<span class="nc" id="L117">				}</span>
<span class="nc" id="L118">			}</span>
<span class="nc" id="L119">		}</span>
<span class="nc" id="L120">	}</span>

	/**
	 * Remove a domain from the character.
	 * @param pc The character
	 * @param domain The domain.
	 */
	public static void removeDomain(PlayerCharacter pc, Domain domain)
	{
<span class="nc" id="L129">		ClassSource source = pc.getDomainSource(domain);</span>
<span class="nc" id="L130">		PCClass aClass = pc.getClassKeyed(source.getPcclass().getKeyName());</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (aClass != null)</span>
		{
			int maxLevel;

<span class="nc bnc" id="L136" title="All 2 branches missed.">			for (maxLevel = 0; maxLevel &lt; 10; maxLevel++)</span>
			{
<span class="nc bnc" id="L138" title="All 2 branches missed.">				if (pc.getSpellSupport(aClass).getCastForLevel(maxLevel, pc) == 0)</span>
				{
<span class="nc" id="L140">					break;</span>
				}
			}

<span class="nc bnc" id="L144" title="All 2 branches missed.">			if (maxLevel &gt; 0)</span>
			{
<span class="nc" id="L146">				removeSpellsFromClassForLevels(pc, domain, aClass);</span>
			}

<span class="nc bnc" id="L149" title="All 4 branches missed.">			if ((maxLevel &gt; 1) &amp;&amp; (aClass.getSafe(IntegerKey.KNOWN_SPELLS_FROM_SPECIALTY) == 0))</span>
			{
<span class="nc" id="L151">				DomainSpellList domainSpellList = domain.get(ObjectKey.DOMAIN_SPELLLIST);</span>
<span class="nc" id="L152">				final List&lt;Spell&gt; aList = pc.getAllSpellsInLists(Collections.singletonList(domainSpellList));</span>

<span class="nc bnc" id="L154" title="All 2 branches missed.">				for (Spell gcs : aList)</span>
				{
<span class="nc bnc" id="L156" title="All 2 branches missed.">					if (SpellLevel.getFirstLvlForKey(gcs, domainSpellList, pc) &lt; maxLevel)</span>
					{
<span class="nc" id="L158">						pc.removeDomainSpellCount(aClass);</span>
<span class="nc" id="L159">						break;</span>
					}
<span class="nc" id="L161">				}</span>
			}
		}

<span class="nc bnc" id="L165" title="All 2 branches missed.">		if (!pc.isImporting())</span>
		{
<span class="nc" id="L167">			BonusActivation.deactivateBonuses(domain, pc);</span>
		}
<span class="nc" id="L169">	}</span>

	/**
	 * Remove any spells granted by the domain to the class.
	 * @param pc The character.
	 * @param domain The domain.
	 * @param aClass The class which would have the spells allocated.
	 */
	public static void removeSpellsFromClassForLevels(PlayerCharacter pc, Domain domain, PCClass aClass)
	{
<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (aClass == null)</span>
		{
<span class="nc" id="L181">			return;</span>
		}

<span class="nc" id="L184">		Collection&lt;? extends CharacterSpell&gt; characterSpells = pc.getCharacterSpells(aClass);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">		for (CharacterSpell characterSpell : characterSpells)</span>
		{
<span class="nc bnc" id="L187" title="All 2 branches missed.">			if (characterSpell.getOwner() == domain)</span>
			{
<span class="nc" id="L189">				pc.removeCharacterSpell(aClass, characterSpell);</span>
			}
<span class="nc" id="L191">		}</span>
<span class="nc" id="L192">	}</span>

	public static void addSpellsToClassForLevels(PlayerCharacter pc, Domain d, PCClass aClass, int minLevel,
		int maxLevel)
	{
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (aClass == null)</span>
		{
<span class="nc" id="L199">			return;</span>
		}

<span class="nc bnc" id="L202" title="All 2 branches missed.">		for (int aLevel = minLevel; aLevel &lt;= maxLevel; aLevel++)</span>
		{
<span class="nc" id="L204">			Collection&lt;Spell&gt; domainSpells = pc.getSpellsIn(d.get(ObjectKey.DOMAIN_SPELLLIST), aLevel);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">			for (Spell spell : domainSpells)</span>
			{
<span class="nc" id="L207">				List&lt;CharacterSpell&gt; slist =</span>
<span class="nc" id="L208">						pc.getCharacterSpells(aClass, spell, Globals.getDefaultSpellBook(), aLevel);</span>
<span class="nc" id="L209">				boolean flag = true;</span>

<span class="nc bnc" id="L211" title="All 2 branches missed.">				for (CharacterSpell cs1 : slist)</span>
				{
<span class="nc bnc" id="L213" title="All 2 branches missed.">					flag = !(cs1.getOwner().equals(d));</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">					if (!flag)</span>
					{
<span class="nc" id="L217">						break;</span>
					}
<span class="nc" id="L219">				}</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">				if (flag)</span>
				{
<span class="nc" id="L223">					CharacterSpell cs = new CharacterSpell(d, spell);</span>
<span class="nc" id="L224">					cs.addInfo(aLevel, 1, Globals.getDefaultSpellBook());</span>
<span class="nc" id="L225">					pc.addCharacterSpell(aClass, cs);</span>
				}
<span class="nc" id="L227">			}</span>
		}
<span class="nc" id="L229">	}</span>

	private static void addDomain(final PlayerCharacter aPC, PCClass cl, Domain d)
	{
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (d.qualifies(aPC, d))</span>
		{
			// TODO Not entirely correct, as this takes this level, not
			// the level where BONUS DOMAINS was present
<span class="nc" id="L237">			ClassSource cs = new ClassSource(cl, aPC.getLevel(cl));</span>
<span class="nc" id="L238">			aPC.addDomain(d, cs);</span>
<span class="nc" id="L239">			applyDomain(aPC, d);</span>
		}
<span class="nc" id="L241">	}</span>

	public static void addDomainsUpToLevel(PCClass cl, final int aLevel, final PlayerCharacter aPC)
	{

		// any domains set by level would have already been saved
		// and don't need to be re-set at level up time
<span class="nc bnc" id="L248" title="All 2 branches missed.">		if (aPC.isImporting())</span>
		{
<span class="nc" id="L250">			return;</span>
		}

		/*
		 * Note this uses ALL of the domains up to and including this level,
		 * because there is the possibility (albeit strange) that the PC was not
		 * qualified at a previous level change, but the PlayerCharacter is now
		 * qualified for the given Domain. Even this has quirks, since it is
		 * only applied at the time of level increase, but I think that quirk
		 * should be resolved by a CDOM system around 6.0 - thpr 10/23/06
		 */
<span class="nc bnc" id="L261" title="All 2 branches missed.">		for (QualifiedObject&lt;CDOMSingleRef&lt;Domain&gt;&gt; qo : cl.getSafeListFor(ListKey.DOMAIN))</span>
		{
<span class="nc" id="L263">			CDOMSingleRef&lt;Domain&gt; ref = qo.getObject(aPC, cl);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">			if (ref != null)</span>
			{
<span class="nc" id="L266">				addDomain(aPC, cl, ref.get());</span>
			}
<span class="nc" id="L268">		}</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">		for (int i = 0; i &lt;= aLevel; i++)</span>
		{
			// TODO This stinks for really high level characters - can this ever
			// get null back?
<span class="nc" id="L273">			PCClassLevel pcl = aPC.getActiveClassLevel(cl, i);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">			for (QualifiedObject&lt;CDOMSingleRef&lt;Domain&gt;&gt; qo : pcl.getSafeListFor(ListKey.DOMAIN))</span>
			{
<span class="nc" id="L276">				CDOMSingleRef&lt;Domain&gt; ref = qo.getObject(aPC, cl);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">				if (ref != null)</span>
				{
<span class="nc" id="L279">					addDomain(aPC, cl, ref.get());</span>
				}
<span class="nc" id="L281">			}</span>
		}
<span class="nc" id="L283">	}</span>

	public static void removeDomainsForLevel(PCClass cl, final int removedLevel, final PlayerCharacter aPC)
	{

		/*
		 * Note this uses ALL of the domains up to and including this level,
		 * because there is the possibility (albeit strange) that the PC was
		 * qualified at a previous level change, but the PlayerCharacter is now
		 * not qualified for the given Domain. Even this has quirks, since it is
		 * only applied at the time of level increase, but I think that quirk
		 * should be resolved by a CDOM system around 6.0 - thpr 10/23/06
		 */
<span class="nc bnc" id="L296" title="All 2 branches missed.">		for (QualifiedObject&lt;CDOMSingleRef&lt;Domain&gt;&gt; qo : cl.getSafeListFor(ListKey.DOMAIN))</span>
		{
<span class="nc" id="L298">			CDOMSingleRef&lt;Domain&gt; ref = qo.getObject(aPC, cl);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">			if (ref == null)</span>
			{
<span class="nc" id="L301">				ref = qo.getRawObject();</span>
<span class="nc" id="L302">				aPC.removeDomain(ref.get());</span>
			}
<span class="nc" id="L304">		}</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">		for (int i = 0; i &lt;= removedLevel; i++)</span>
		{
			// TODO This stinks for really high level characters - can this ever
			// get null back?
<span class="nc" id="L309">			PCClassLevel pcl = aPC.getActiveClassLevel(cl, i);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">			for (QualifiedObject&lt;CDOMSingleRef&lt;Domain&gt;&gt; qo : pcl.getSafeListFor(ListKey.DOMAIN))</span>
			{
<span class="nc" id="L312">				CDOMSingleRef&lt;Domain&gt; ref = qo.getObject(aPC, cl);</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">				if ((ref == null) || (i == removedLevel))</span>
				{
<span class="nc" id="L315">					ref = qo.getRawObject();</span>
<span class="nc" id="L316">					aPC.removeDomain(ref.get());</span>
				}
<span class="nc" id="L318">			}</span>
		}
<span class="nc" id="L320">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>