<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbilitySelection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.content</a> &gt; <span class="el_source">AbilitySelection.java</span></div><h1>AbilitySelection.java</h1><pre class="source lang-java linenums">/*
 * Missing License Header, Copyright 2016 (C) Andrew Maitland &lt;amaitland@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.cdom.content;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.Reducible;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.reference.ReferenceManufacturer;
import pcgen.core.Ability;
import pcgen.core.AbilityCategory;
import pcgen.core.AbilityUtilities;
import pcgen.core.SettingsHandler;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.rules.context.LoadContext;

public class AbilitySelection extends Selection&lt;Ability, String&gt; implements Comparable&lt;AbilitySelection&gt;, Reducible
{

	public AbilitySelection(Ability obj, String sel)
	{
<span class="fc" id="L41">		super(obj, sel);</span>
<span class="fc" id="L42">	}</span>

	/**
	 * Decodes the given String into an AbilitySelection. The String format to
	 * be passed into this method is defined solely by the return result of the
	 * getPersistentFormat method. There is no guarantee that the encoding is
	 * human readable, simply that the encoding is uniquely identifying such
	 * that this method is capable of decoding the String into an
	 * AbilitySelection.
	 * 
	 * @param persistentFormat
	 *            The String which should be decoded to provide an
	 *            AbilitySelection.
	 * 
	 * @return An AbilitySelection that was encoded in the given String.
	 */
	public static AbilitySelection getAbilitySelectionFromPersistentFormat(LoadContext context, String persistentFormat)
	{
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">		if (!persistentFormat.contains(Constants.PIPE))</span>
		{
<span class="nc" id="L62">			return decodeFeatSelectionChoice(context, persistentFormat);</span>
		}
<span class="fc" id="L64">		StringTokenizer st = new StringTokenizer(persistentFormat, Constants.PIPE);</span>
<span class="fc" id="L65">		String catString = st.nextToken();</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		if (!catString.startsWith(&quot;CATEGORY=&quot;))</span>
		{
<span class="fc" id="L68">			throw new IllegalArgumentException(&quot;String in getAbilitySelectionFromPersistentFormat &quot;</span>
				+ &quot;must start with CATEGORY=, found: &quot; + persistentFormat);
		}
<span class="fc" id="L71">		String cat = catString.substring(9);</span>
<span class="fc" id="L72">		AbilityCategory ac = SettingsHandler.getGameAsProperty().get().getAbilityCategory(cat);</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">		if (ac == null)</span>
		{
<span class="nc" id="L75">			throw new IllegalArgumentException(</span>
				&quot;Category in getAbilitySelectionFromPersistentFormat &quot; + &quot;must exist found: &quot; + cat);
		}
<span class="fc" id="L78">		String ab = st.nextToken();</span>
<span class="fc" id="L79">		Ability a = context.getReferenceContext().getManufacturerId(ac).getActiveObject(ab);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">		if (a == null)</span>
		{
<span class="nc" id="L82">			throw new IllegalArgumentException(&quot;Second argument in String in getAbilitySelectionFromPersistentFormat &quot;</span>
				+ &quot;must be an Ability, but it was not found: &quot; + persistentFormat);
		}
<span class="fc" id="L85">		String sel = null;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">		if (st.hasMoreTokens())</span>
		{
			/*
			 * No need to check for MULT:YES/NO here, as that is checked
			 * implicitly in the construction of AbilitySelection below
			 */
<span class="fc" id="L92">			sel = st.nextToken();</span>
		}
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">		else if (persistentFormat.endsWith(Constants.PIPE))</span>
		{
			// Handle the StringTokenizer ignoring blank tokens at the end
<span class="nc" id="L97">			sel = &quot;&quot;;</span>
		}
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">		if (st.hasMoreTokens())</span>
		{
<span class="nc" id="L101">			throw new IllegalArgumentException(&quot;String in getAbilitySelectionFromPersistentFormat &quot;</span>
				+ &quot;must have 2 or 3 arguments, but found more: &quot; + persistentFormat);
		}
<span class="fc" id="L104">		return new AbilitySelection(a, sel);</span>
	}

	/**
	 * Decode a legacy feat selection format. This may come from a character 
	 * saved when an ability was coded with a FEATSELECTION but is loaded with 
	 * the same tag migrated to an ABILITYSELECTION.
	 *   
	 * @param context
	 *            The data loading context in use. 
	 * @param persistentFormat
	 *            The String which should be decoded to provide an
	 *            AbilitySelection.
	 * 
	 * @return An AbilitySelection that was encoded in the given String.
	 */
	private static AbilitySelection decodeFeatSelectionChoice(LoadContext context, String persistentFormat)
	{
<span class="nc" id="L122">		AbstractReferenceContext referenceContext = context.getReferenceContext();</span>
<span class="nc" id="L123">		AbilityCategory featCategory = referenceContext.get(AbilityCategory.class, &quot;FEAT&quot;);</span>
<span class="nc" id="L124">		ReferenceManufacturer&lt;Ability&gt; featManufacturer = referenceContext.getManufacturerId(featCategory);</span>
<span class="nc" id="L125">		Ability ability = featManufacturer.getActiveObject(persistentFormat);</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (ability == null)</span>
		{
<span class="nc" id="L129">			List&lt;String&gt; choices = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L130">			String baseKey = AbilityUtilities.getUndecoratedName(persistentFormat, choices);</span>
<span class="nc" id="L131">			ability = featManufacturer.getActiveObject(baseKey);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if (ability == null)</span>
			{
<span class="nc" id="L134">				throw new IllegalArgumentException(&quot;String in decodeChoice &quot; + &quot;must be a Feat Key &quot;</span>
					+ &quot;(or Feat Key with Selection if appropriate), was: &quot; + persistentFormat);
			}
<span class="nc" id="L137">			return new AbilitySelection(ability, choices.get(0));</span>
		}
<span class="nc bnc" id="L139" title="All 2 branches missed.">		else if (ability.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
		{
			/*
			 * MULT:YES, CHOOSE:NOCHOICE can land here
			 * 
			 * TODO There needs to be better validation at some point that this
			 * is proper (meaning it is actually CHOOSE:NOCHOICE!)
			 */
<span class="nc" id="L147">			return new AbilitySelection(ability, &quot;&quot;);</span>
		}
		else
		{
<span class="nc" id="L151">			return new AbilitySelection(ability, null);</span>
		}
	}

	/**
	 * Encodes the AbilitySelection into a String sufficient to uniquely
	 * identify the AbilitySelection. This may not sufficiently encode to be
	 * stored into a file or format which restricts certain characters (such as
	 * URLs), it simply encodes into an identifying String. There is no
	 * guarantee that this encoding is human readable, simply that the encoding
	 * is uniquely identifying such that the
	 * getAbilitySelectionFromPersistentFormat method of AbilitySelection is
	 * capable of decoding the String into an AbilitySelection.
	 * 
	 * @return A String sufficient to uniquely identify the AbilitySelection.
	 */
	public String getPersistentFormat()
	{
<span class="fc" id="L169">		Ability ability = getObject();</span>
<span class="fc" id="L170">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L171">		sb.append(&quot;CATEGORY=&quot;);</span>
<span class="fc" id="L172">		sb.append(ability.getCDOMCategory().getKeyName());</span>
<span class="fc" id="L173">		sb.append('|');</span>
<span class="fc" id="L174">		sb.append(ability.getKeyName());</span>
<span class="fc" id="L175">		String selection = getSelection();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (selection != null)</span>
		{
<span class="fc" id="L178">			sb.append('|');</span>
<span class="fc" id="L179">			sb.append(selection);</span>
		}
<span class="fc" id="L181">		return sb.toString();</span>
	}

	public String getAbilityKey()
	{
<span class="nc" id="L186">		return getObject().getKeyName();</span>
	}

	@Override
	public String toString()
	{
<span class="nc" id="L192">		StringBuilder sb = new StringBuilder(50);</span>
<span class="nc" id="L193">		sb.append(getAbilityKey());</span>
<span class="nc" id="L194">		String selection = getSelection();</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">		if ((selection != null) &amp;&amp; (!selection.isEmpty()))</span>
		{
<span class="nc" id="L197">			sb.append(&quot; (&quot;);</span>
<span class="nc" id="L198">			sb.append(selection);</span>
<span class="nc" id="L199">			sb.append(')');</span>
		}
<span class="nc" id="L201">		return sb.toString();</span>
	}

	@Override
	public int compareTo(AbilitySelection o)
	{
<span class="nc" id="L207">		int acompare = getObject().compareTo(o.getObject());</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">		if (acompare != 0)</span>
		{
<span class="nc" id="L210">			return acompare;</span>
		}
<span class="nc" id="L212">		String selection = getSelection();</span>
<span class="nc" id="L213">		String oselection = o.getSelection();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (selection == oselection)</span>
		{
<span class="nc" id="L216">			return 0;</span>
		}
<span class="nc bnc" id="L218" title="All 2 branches missed.">		if (selection == null)</span>
		{
<span class="nc" id="L220">			return -1;</span>
		}
<span class="nc" id="L222">		return selection.compareTo(oselection);</span>
	}

	@Override
	public CDOMObject getCDOMObject()
	{
<span class="nc" id="L228">		return getObject();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>