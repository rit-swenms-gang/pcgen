<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpellsLst.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">plugin.lsttokens</a> &gt; <span class="el_source">SpellsLst.java</span></div><h1>SpellsLst.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 (C) Thomas Parker &lt;thpr@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package plugin.lsttokens;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import pcgen.base.formula.Formula;
import pcgen.base.lang.StringUtil;
import pcgen.base.text.ParsingSeparator;
import pcgen.base.util.DoubleKeyMap;
import pcgen.base.util.MapToList;
import pcgen.base.util.TripleKeyMap;
import pcgen.cdom.base.AssociatedPrereqObject;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.FormulaFactory;
import pcgen.cdom.base.Ungranted;
import pcgen.cdom.enumeration.AssociationKey;
import pcgen.core.prereq.Prerequisite;
import pcgen.core.spell.Spell;
import pcgen.rules.context.AssociatedChanges;
import pcgen.rules.context.LoadContext;
import pcgen.rules.persistence.token.AbstractNonEmptyToken;
import pcgen.rules.persistence.token.CDOMPrimaryToken;
import pcgen.rules.persistence.token.ParseResult;

<span class="fc" id="L51">public class SpellsLst extends AbstractNonEmptyToken&lt;CDOMObject&gt; implements CDOMPrimaryToken&lt;CDOMObject&gt;</span>
{

	@Override
	public String getTokenName()
	{
<span class="fc" id="L57">		return &quot;SPELLS&quot;;</span>
	}

	/**
	 * {@literal 
	 * SPELLS:&lt;spellbook name&gt;|[&lt;optional parameters, pipe deliminated&gt;] |&lt;spell
	 * name&gt;[,&lt;formula for DC&gt;] |&lt;spell name2&gt;[,&lt;formula2 for DC&gt;] |PRExxx
	 * |PRExxx
	 *
	 * CASTERLEVEL=&lt;formula&gt; Casterlevel of spells TIMES=&lt;formula&gt; Cast Times
	 * per day, -1=At Will
	 *}
	 * @param sourceLine
	 *            Line from the LST file without the SPELLS:
	 * @return spells list
	 */
	@Override
	protected ParseResult parseNonEmptyToken(LoadContext context, CDOMObject obj, String sourceLine)
	{
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (obj instanceof Ungranted)</span>
		{
<span class="nc" id="L78">			return new ParseResult.Fail(</span>
<span class="nc" id="L79">				&quot;Cannot use &quot; + getTokenName() + &quot; on an Ungranted object type: &quot; + obj.getClass().getSimpleName());</span>
		}
<span class="pc bpc" id="L81" title="2 of 4 branches missed.">		if ((sourceLine == null) || sourceLine.isEmpty())</span>
		{
<span class="nc" id="L83">			return new ParseResult.Fail(&quot;Argument in &quot; + getTokenName() + &quot; cannot be empty&quot;);</span>
		}
<span class="fc bfc" id="L85" title="All 2 branches covered.">		if (sourceLine.equals(Constants.LST_DOT_CLEAR_ALL))</span>
		{
<span class="fc" id="L87">			context.getListContext().removeAllFromList(getTokenName(), obj, Spell.SPELLS);</span>
<span class="fc" id="L88">			return ParseResult.SUCCESS;</span>
		}
<span class="fc" id="L90">		ParsingSeparator sep = new ParsingSeparator(sourceLine, '|');</span>
<span class="fc" id="L91">		sep.addGroupingPair('[', ']');</span>
<span class="fc" id="L92">		sep.addGroupingPair('(', ')');</span>

<span class="fc" id="L94">		String spellBook = sep.next();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		if (spellBook.isEmpty())</span>
		{
<span class="fc" id="L97">			return new ParseResult.Fail(&quot;SpellBook in &quot; + getTokenName() + &quot; cannot be empty&quot;);</span>
		}
		// Formula casterLevel = null;
<span class="fc" id="L100">		String casterLevel = null;</span>
<span class="fc" id="L101">		String times = null;</span>
<span class="fc" id="L102">		String timeunit = null;</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">		if (!sep.hasNext())</span>
		{
<span class="fc" id="L106">			return new ParseResult.Fail(getTokenName() + &quot;: minimally requires a Spell Name&quot;);</span>
		}
<span class="fc" id="L108">		String token = sep.next();</span>

		while (true)
		{
<span class="fc bfc" id="L112" title="All 2 branches covered.">			if (token.startsWith(&quot;TIMES=&quot;))</span>
			{
<span class="fc bfc" id="L114" title="All 2 branches covered.">				if (times != null)</span>
				{
<span class="fc" id="L116">					return new ParseResult.Fail(</span>
<span class="fc" id="L117">						&quot;Found two TIMES entries in &quot; + getTokenName() + &quot;: invalid: &quot; + sourceLine);</span>
				}
<span class="fc" id="L119">				times = token.substring(6);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">				if (times.isEmpty())</span>
				{
<span class="fc" id="L122">					return new ParseResult.Fail(&quot;Error in Times in &quot; + getTokenName() + &quot;: argument was empty&quot;);</span>
				}
<span class="fc bfc" id="L124" title="All 2 branches covered.">				if (!sep.hasNext())</span>
				{
<span class="fc" id="L126">					return new ParseResult.Fail(</span>
<span class="fc" id="L127">						getTokenName() + &quot;: minimally requires &quot; + &quot;a Spell Name (after TIMES=)&quot;);</span>
				}
<span class="fc" id="L129">				token = sep.next();</span>
			}
<span class="fc bfc" id="L131" title="All 2 branches covered.">			else if (token.startsWith(&quot;TIMEUNIT=&quot;))</span>
			{
<span class="fc bfc" id="L133" title="All 2 branches covered.">				if (timeunit != null)</span>
				{
<span class="fc" id="L135">					return new ParseResult.Fail(</span>
<span class="fc" id="L136">						&quot;Found two TIMEUNIT entries in &quot; + getTokenName() + &quot;: invalid: &quot; + sourceLine);</span>
				}
<span class="fc" id="L138">				timeunit = token.substring(9);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">				if (timeunit.isEmpty())</span>
				{
<span class="fc" id="L141">					return new ParseResult.Fail(&quot;Error in TimeUnit in &quot; + getTokenName() + &quot;: argument was empty&quot;);</span>
				}
<span class="fc bfc" id="L143" title="All 2 branches covered.">				if (!sep.hasNext())</span>
				{
<span class="fc" id="L145">					return new ParseResult.Fail(</span>
<span class="fc" id="L146">						getTokenName() + &quot;: minimally requires &quot; + &quot;a Spell Name (after TIMEUNIT=)&quot;);</span>
				}
<span class="fc" id="L148">				token = sep.next();</span>
			}
<span class="fc bfc" id="L150" title="All 2 branches covered.">			else if (token.startsWith(&quot;CASTERLEVEL=&quot;))</span>
			{
<span class="fc bfc" id="L152" title="All 2 branches covered.">				if (casterLevel != null)</span>
				{
<span class="fc" id="L154">					return new ParseResult.Fail(</span>
<span class="fc" id="L155">						&quot;Found two CASTERLEVEL entries in &quot; + getTokenName() + &quot;: invalid: &quot; + sourceLine);</span>
				}
<span class="fc" id="L157">				casterLevel = token.substring(12);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">				if (casterLevel.isEmpty())</span>
				{
<span class="fc" id="L160">					return new ParseResult.Fail(&quot;Error in Caster Level in &quot; + getTokenName() + &quot;: argument was empty&quot;);</span>
				}
<span class="fc bfc" id="L162" title="All 2 branches covered.">				if (!sep.hasNext())</span>
				{
<span class="fc" id="L164">					return new ParseResult.Fail(</span>
<span class="fc" id="L165">						getTokenName() + &quot;: minimally requires a &quot; + &quot;Spell Name (after CASTERLEVEL=)&quot;);</span>
				}
<span class="fc" id="L167">				token = sep.next();</span>
			}
			else
			{
				break;
			}
		}
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (times == null)</span>
		{
<span class="fc" id="L176">			times = &quot;1&quot;;</span>
		}

<span class="fc bfc" id="L179" title="All 2 branches covered.">		if (token.isEmpty())</span>
		{
<span class="fc" id="L181">			return new ParseResult.Fail(&quot;Spell arguments may not be empty in &quot; + getTokenName() + &quot;: &quot; + sourceLine);</span>
		}
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (token.charAt(0) == ',')</span>
		{
<span class="fc" id="L185">			return new ParseResult.Fail(getTokenName() + &quot; Spell arguments may not start with , : &quot; + token);</span>
		}
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (token.charAt(token.length() - 1) == ',')</span>
		{
<span class="fc" id="L189">			return new ParseResult.Fail(getTokenName() + &quot; Spell arguments may not end with , : &quot; + token);</span>
		}
<span class="fc bfc" id="L191" title="All 2 branches covered.">		if (token.contains(&quot;,,&quot;))</span>
		{
<span class="fc" id="L193">			return new ParseResult.Fail(getTokenName() + &quot; Spell arguments uses double separator ,, : &quot; + token);</span>
		}

		/*
		 * CONSIDER This is currently order enforcing the reference fetching to
		 * match the integration tests that we perform, and their current
		 * behavior. Not sure if this is really tbe best solution?
		 *
		 * See CDOMObject.
		 */
<span class="fc" id="L203">		DoubleKeyMap&lt;CDOMReference&lt;Spell&gt;, AssociationKey&lt;?&gt;, Object&gt; dkm =</span>
				new DoubleKeyMap&lt;&gt;(LinkedHashMap.class, HashMap.class);
		while (true)
		{
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (token.isEmpty())</span>
			{
<span class="fc" id="L209">				return new ParseResult.Fail(</span>
<span class="fc" id="L210">					&quot;Spell arguments may not end with comma or pipe in &quot; + getTokenName() + &quot;: &quot; + sourceLine);</span>
			}
<span class="fc" id="L212">			int commaLoc = token.indexOf(',');</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">			String name = commaLoc == -1 ? token : token.substring(0, commaLoc);</span>
<span class="fc" id="L214">			CDOMReference&lt;Spell&gt; spell = context.getReferenceContext().getCDOMReference(Spell.class, name);</span>
<span class="fc" id="L215">			dkm.put(spell, AssociationKey.CASTER_LEVEL, casterLevel);</span>
<span class="fc" id="L216">			Formula timesFormula = FormulaFactory.getFormulaFor(times);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">			if (!timesFormula.isValid())</span>
			{
<span class="nc" id="L219">				return new ParseResult.Fail(</span>
<span class="nc" id="L220">					&quot;Times in &quot; + getTokenName() + &quot; was not valid: &quot; + timesFormula.toString());</span>
			}
<span class="fc" id="L222">			dkm.put(spell, AssociationKey.TIMES_PER_UNIT, timesFormula);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			if (timeunit != null)</span>
			{
<span class="fc" id="L225">				dkm.put(spell, AssociationKey.TIME_UNIT, timeunit);</span>
			}
<span class="fc" id="L227">			dkm.put(spell, AssociationKey.SPELLBOOK, spellBook);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if (commaLoc != -1)</span>
			{
<span class="fc" id="L230">				dkm.put(spell, AssociationKey.DC_FORMULA, token.substring(commaLoc + 1));</span>
			}
<span class="fc bfc" id="L232" title="All 2 branches covered.">			if (!sep.hasNext())</span>
			{
				// No prereqs, so we're done
<span class="fc" id="L235">				finish(context, obj, dkm, null);</span>
<span class="fc" id="L236">				return ParseResult.SUCCESS;</span>
			}
<span class="fc" id="L238">			token = sep.next();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">			if (looksLikeAPrerequisite(token))</span>
			{
<span class="fc" id="L241">				break;</span>
			}
<span class="fc" id="L243">		}</span>

<span class="fc" id="L245">		List&lt;Prerequisite&gt; prereqs = new ArrayList&lt;&gt;();</span>

		while (true)
		{
<span class="fc" id="L249">			Prerequisite prereq = getPrerequisite(token);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (prereq == null)</span>
			{
<span class="fc" id="L252">				return new ParseResult.Fail(&quot;   (Did you put spells after the &quot; + &quot;PRExxx tags in SPELLS:?)&quot;);</span>
			}
<span class="fc" id="L254">			prereqs.add(prereq);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">			if (!sep.hasNext())</span>
			{
<span class="fc" id="L257">				break;</span>
			}
<span class="fc" id="L259">			token = sep.next();</span>
<span class="fc" id="L260">		}</span>

<span class="fc" id="L262">		finish(context, obj, dkm, prereqs);</span>
<span class="fc" id="L263">		return ParseResult.SUCCESS;</span>
	}

	public void finish(LoadContext context, CDOMObject obj,
		DoubleKeyMap&lt;CDOMReference&lt;Spell&gt;, AssociationKey&lt;?&gt;, Object&gt; dkm, List&lt;Prerequisite&gt; prereqs)
	{
<span class="fc bfc" id="L269" title="All 2 branches covered.">		for (CDOMReference&lt;Spell&gt; spell : dkm.getKeySet())</span>
		{
<span class="fc" id="L271">			AssociatedPrereqObject edge = context.getListContext().addToList(getTokenName(), obj, Spell.SPELLS, spell);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">			for (AssociationKey ak : dkm.getSecondaryKeySet(spell))</span>
			{
<span class="fc" id="L274">				edge.setAssociation(ak, dkm.get(spell, ak));</span>
<span class="fc" id="L275">			}</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">			if (prereqs != null)</span>
			{
<span class="fc bfc" id="L278" title="All 2 branches covered.">				for (Prerequisite prereq : prereqs)</span>
				{
<span class="fc" id="L280">					edge.addPrerequisite(prereq);</span>
<span class="fc" id="L281">				}</span>
			}
<span class="fc" id="L283">		}</span>
<span class="fc" id="L284">	}</span>

	@Override
	public String[] unparse(LoadContext context, CDOMObject obj)
	{
<span class="fc" id="L289">		AssociatedChanges&lt;CDOMReference&lt;Spell&gt;&gt; changes =</span>
<span class="fc" id="L290">				context.getListContext().getChangesInList(getTokenName(), obj, Spell.SPELLS);</span>
<span class="fc" id="L291">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">		if (changes.includesGlobalClear())</span>
		{
<span class="nc" id="L294">			list.add(Constants.LST_DOT_CLEAR_ALL);</span>
		}
<span class="fc" id="L296">		MapToList&lt;CDOMReference&lt;Spell&gt;, AssociatedPrereqObject&gt; mtl = changes.getAddedAssociations();</span>
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">		if (mtl != null &amp;&amp; !mtl.isEmpty())</span>
		{
<span class="fc" id="L299">			list.addAll(processAdds(context, mtl));</span>
		}
<span class="fc bfc" id="L301" title="All 2 branches covered.">		if (list.isEmpty())</span>
		{
<span class="fc" id="L303">			return null;</span>
		}
<span class="fc" id="L305">		return list.toArray(new String[0]);</span>
	}

	private Collection&lt;? extends String&gt; processAdds(LoadContext context,
		MapToList&lt;CDOMReference&lt;Spell&gt;, AssociatedPrereqObject&gt; mtl)
	{
<span class="fc" id="L311">		TripleKeyMap&lt;Set&lt;Prerequisite&gt;, Map&lt;AssociationKey&lt;?&gt;, Object&gt;, CDOMReference&lt;Spell&gt;, String&gt; m =</span>
				new TripleKeyMap&lt;&gt;();
<span class="fc bfc" id="L313" title="All 2 branches covered.">		for (CDOMReference&lt;Spell&gt; lw : mtl.getKeySet())</span>
		{
<span class="fc bfc" id="L315" title="All 2 branches covered.">			for (AssociatedPrereqObject assoc : mtl.getListFor(lw))</span>
			{
<span class="fc" id="L317">				Map&lt;AssociationKey&lt;?&gt;, Object&gt; am = new HashMap&lt;&gt;();</span>
<span class="fc" id="L318">				String dc = null;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">				for (AssociationKey&lt;?&gt; ak : assoc.getAssociationKeys())</span>
				{
					// if (AssociationKey.SOURCE_URI.equals(ak)
					// || AssociationKey.FILE_LOCATION.equals(ak))
					// {
					// // Do nothing
					// }
					// else
<span class="fc bfc" id="L327" title="All 2 branches covered.">					if (AssociationKey.DC_FORMULA.equals(ak))</span>
					{
<span class="fc" id="L329">						dc = assoc.getAssociation(AssociationKey.DC_FORMULA);</span>
					}
					else
					{
<span class="fc" id="L333">						am.put(ak, assoc.getAssociation(ak));</span>
					}
<span class="fc" id="L335">				}</span>
<span class="fc" id="L336">				m.put(new HashSet&lt;&gt;(assoc.getPrerequisiteList()), am, lw, dc);</span>
<span class="fc" id="L337">			}</span>
<span class="fc" id="L338">		}</span>

<span class="fc" id="L340">		Set&lt;String&gt; set = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		for (Set&lt;Prerequisite&gt; prereqs : m.getKeySet())</span>
		{
<span class="fc bfc" id="L343" title="All 2 branches covered.">			for (Map&lt;AssociationKey&lt;?&gt;, Object&gt; am : m.getSecondaryKeySet(prereqs))</span>
			{
<span class="fc" id="L345">				StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L346">				sb.append(am.get(AssociationKey.SPELLBOOK));</span>
<span class="fc" id="L347">				Formula times = AssociationKey.TIMES_PER_UNIT.cast(am.get(AssociationKey.TIMES_PER_UNIT));</span>
<span class="fc" id="L348">				sb.append(Constants.PIPE).append(&quot;TIMES=&quot;).append(times);</span>
<span class="fc" id="L349">				String timeunit = AssociationKey.TIME_UNIT.cast(am.get(AssociationKey.TIME_UNIT));</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">				if (timeunit != null)</span>
				{
<span class="fc" id="L352">					sb.append(Constants.PIPE).append(&quot;TIMEUNIT=&quot;).append(timeunit);</span>
				}
<span class="fc" id="L354">				String casterLvl = AssociationKey.CASTER_LEVEL.cast(am.get(AssociationKey.CASTER_LEVEL));</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">				if (casterLvl != null)</span>
				{
<span class="fc" id="L357">					sb.append(Constants.PIPE).append(&quot;CASTERLEVEL=&quot;).append(casterLvl);</span>
				}
<span class="fc" id="L359">				Set&lt;String&gt; spellSet = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">				for (CDOMReference&lt;Spell&gt; spell : m.getTertiaryKeySet(prereqs, am))</span>
				{
<span class="fc" id="L362">					String spellString = spell.getLSTformat(false);</span>
<span class="fc" id="L363">					String dc = m.get(prereqs, am, spell);</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">					if (dc != null)</span>
					{
<span class="fc" id="L366">						spellString += Constants.COMMA + dc;</span>
					}
<span class="fc" id="L368">					spellSet.add(spellString);</span>
<span class="fc" id="L369">				}</span>
<span class="fc" id="L370">				sb.append(Constants.PIPE);</span>
<span class="fc" id="L371">				sb.append(StringUtil.join(spellSet, Constants.PIPE));</span>
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">				if (prereqs != null &amp;&amp; !prereqs.isEmpty())</span>
				{
<span class="fc" id="L374">					sb.append(Constants.PIPE);</span>
<span class="fc" id="L375">					sb.append(getPrerequisiteString(context, prereqs));</span>
				}
<span class="fc" id="L377">				set.add(sb.toString());</span>
<span class="fc" id="L378">			}</span>
<span class="fc" id="L379">		}</span>
<span class="fc" id="L380">		return set;</span>
	}

	@Override
	public Class&lt;CDOMObject&gt; getTokenClass()
	{
<span class="fc" id="L386">		return CDOMObject.class;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>