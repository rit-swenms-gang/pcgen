<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormulaFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.base</a> &gt; <span class="el_source">FormulaFactory.java</span></div><h1>FormulaFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.base;

import java.util.Objects;
import java.util.Optional;

import pcgen.base.formula.Formula;
import pcgen.base.formula.base.DependencyManager;
import pcgen.base.formula.base.EvaluationManager;
import pcgen.base.formula.base.FormulaManager;
import pcgen.base.formula.base.FormulaSemantics;
import pcgen.base.formula.base.ManagerFactory;
import pcgen.base.formula.exception.SemanticsException;
import pcgen.base.formula.inst.ComplexNEPFormula;
import pcgen.base.formula.inst.NEPFormula;
import pcgen.base.util.FormatManager;
import pcgen.cdom.formula.scope.PCGenScope;
import pcgen.core.Equipment;
import pcgen.core.PlayerCharacter;

/**
 * FormulaFactory is a utility class which creates Formula objects based on the
 * input provided
 */
public final class FormulaFactory
{

	/**
	 * A Formula for the integer constant ZERO. This is done in order to
	 * minimize memory usage in the many cases where a default Formula of ZERO
	 * is required.
	 */
<span class="fc" id="L49">	public static final Formula ZERO = new NumberFormula(0);</span>

	/**
	 * A Formula for the integer constant ONE. This is done in order to minimize
	 * memory usage in the many cases where a default Formula of ONE is
	 * required.
	 */
<span class="fc" id="L56">	public static final Formula ONE = new NumberFormula(1);</span>

	private FormulaFactory()
	{
		// Can't instantiate Utility Class
	}

	/**
	 * Returns a Formula for the given String.
	 * 
	 * @param formulaString
	 *            The String to be converted to a Formula
	 * @return A Formula for the given String.
	 * @throws IllegalArgumentException
	 *             if the given String is null or empty
	 */
	public static Formula getFormulaFor(String formulaString)
	{
<span class="pc bpc" id="L74" title="1 of 4 branches missed.">		if (formulaString == null || formulaString.isEmpty())</span>
		{
<span class="fc" id="L76">			throw new IllegalArgumentException(&quot;Formula cannot be empty&quot;);</span>
		}
		try
		{
<span class="fc" id="L80">			return getFormulaFor(Integer.valueOf(formulaString));</span>
		}
<span class="fc" id="L82">		catch (NumberFormatException e)</span>
		{
			// Okay, just not an integer
			try
			{
<span class="fc" id="L87">				return getFormulaFor(Double.valueOf(formulaString));</span>
			}
<span class="fc" id="L89">			catch (NumberFormatException e2)</span>
			{
				// Okay, just not a double
<span class="fc" id="L92">				return new JEPFormula(formulaString);</span>
			}
		}
	}

	/**
	 * Returns a Formula for the given Number.
	 * 
	 * @param number
	 *            The int to be converted to a Formula
	 * @return A Formula for the given Number.
	 * @throws IllegalArgumentException
	 *             if the given Number is null
	 */
	public static Formula getFormulaFor(Number number)
	{
<span class="fc" id="L108">		return new NumberFormula(number);</span>
	}

	/**
	 * NumberFormula is a fixed-value formula for a specific Integer.
	 */
	private static final class NumberFormula implements Formula
	{

		/**
		 * The Number value of this NumberFormula
		 */
		private final Number number;

		/**
		 * Creates a new NumberFormula from the given Number.
		 * 
		 * @param intValue
		 *            The Number value of this NumberFormula.
		 * @throws IllegalArgumentException
		 *             if the given Number is null
		 */
		private NumberFormula(Number intValue)
<span class="fc" id="L131">		{</span>
<span class="fc" id="L132">			Objects.requireNonNull(intValue, &quot;Cannot create an NumberFormula with a null Number&quot;);</span>
<span class="fc" id="L133">			number = intValue;</span>
<span class="fc" id="L134">		}</span>

		/**
		 * Resolves this NumberFormula, returning the Number in this
		 * NumberFormula.
		 * 
		 * @return the Number in this NumberFormula.
		 */
		@Override
		public Number resolve(PlayerCharacter pc, String source)
		{
<span class="fc" id="L145">			return number;</span>
		}

		/**
		 * Resolves this NumberFormula, returning the Number in this
		 * NumberFormula.
		 * 
		 * @return the Number in this NumberFormula.
		 */
		@Override
		public Number resolve(Equipment equipment, boolean primary, PlayerCharacter pc, String source)
		{
<span class="nc" id="L157">			return number;</span>
		}

		/**
		 * Returns a String representation of this NumberFormula.
		 */
		@Override
		public String toString()
		{
<span class="fc" id="L166">			return number.toString();</span>
		}

		/**
		 * Returns the consistent-with-equals hashCode for this NumberFormula
		 */
		@Override
		public int hashCode()
		{
<span class="fc" id="L175">			return number.intValue();</span>
		}

		/**
		 * Returns true if this NumberFormula is equal to the given Object.
		 * Equality is defined as being another NumberFormula object with equal
		 * value.
		 */
		@Override
		public boolean equals(Object obj)
		{
<span class="fc bfc" id="L186" title="All 4 branches covered.">			return (obj instanceof NumberFormula) &amp;&amp; ((NumberFormula) obj).number.equals(number);</span>
		}

		/**
		 * Returns true as an NumberFormula has an underlying Number (static)
		 * value
		 */
		@Override
		public boolean isStatic()
		{
<span class="fc" id="L196">			return true;</span>
		}

		/**
		 * Returns true as an NumberFormula is a valid Formula.
		 */
		@Override
		public boolean isValid()
		{
<span class="fc" id="L205">			return true;</span>
		}

		/**
		 * Resolves this NumberFormula, returning the Number in this
		 * NumberFormula.
		 * 
		 * @return the Integer in this NumberFormula.
		 */
		@Override
		public Number resolveStatic()
		{
<span class="fc" id="L217">			return number;</span>
		}
	}

	/**
	 * SimpleFormula is a fixed-value formula for a specific value.
	 */
	private static final class SimpleFormula&lt;T&gt; implements NEPFormula&lt;T&gt;
	{

		/**
		 * The value of this SimpleFormula.
		 */
		private final T value;

		/**
		 * The FormatManager of this SimpleFormula.
		 */
		private final FormatManager&lt;T&gt; formatManager;

		/**
		 * Creates a new SimpleFormula from the given value.
		 * 
		 * @param value
		 *            The value of this SimpleFormula.
		 * @param formatManager
		 *            The FormatManager for the value in this SimpleFormula
		 * @throws IllegalArgumentException
		 *             if the given value is null
		 */
		private SimpleFormula(T value, FormatManager&lt;T&gt; formatManager)
<span class="fc" id="L248">		{</span>
<span class="fc" id="L249">			this.value = Objects.requireNonNull(value);</span>
<span class="fc" id="L250">			this.formatManager = Objects.requireNonNull(formatManager);</span>
<span class="fc" id="L251">		}</span>

		/**
		 * Returns a String representation of this SimpleFormula.
		 */
		@Override
		public String toString()
		{
<span class="nc" id="L259">			return formatManager.unconvert(value);</span>
		}

		/**
		 * Returns the consistent-with-equals hashCode for this SimpleFormula
		 */
		@Override
		public int hashCode()
		{
<span class="nc" id="L268">			return value.hashCode();</span>
		}

		/**
		 * Returns true if this SimpleFormula is equal to the given Object.
		 * Equality is defined as being another SimpleFormula object with equal
		 * value.
		 */
		@Override
		public boolean equals(Object obj)
		{
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">			return (obj instanceof SimpleFormula)</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">				&amp;&amp; Objects.deepEquals(((SimpleFormula&lt;?&gt;) obj).value, value);</span>
		}

		@Override
		public void getDependencies(DependencyManager fdm)
		{
			//None
<span class="nc" id="L287">		}</span>

		@Override
		public T resolve(EvaluationManager evalManager)
		{
<span class="nc" id="L292">			return value;</span>
		}

		@Override
		public void isValid(FormulaSemantics semantics) throws SemanticsException
		{
<span class="fc" id="L298">			Class&lt;?&gt; expectedFormat = formatManager.getManagedClass();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">			if (!expectedFormat.isAssignableFrom(value.getClass()))</span>
			{
<span class="nc" id="L301">				throw new SemanticsException(&quot;Parse Error: Invalid Value Format: &quot; + value.getClass()</span>
					+ &quot; found in location requiring a &quot; + expectedFormat + &quot; (class cannot be evaluated)&quot;);
			}
<span class="fc" id="L304">		}</span>

		@Override
		public FormatManager&lt;T&gt; getFormatManager()
		{
<span class="nc" id="L309">			return formatManager;</span>
		}
	}

	/**
	 * Returns a &quot;New Equation Parser&quot; formula for the given String when
	 * interpreted by the given FormatManager.
	 * 
	 * Due to the type implied by the construction of ComplexNEPFormula, this
	 * should remain private and external users should be encouraged to use
	 * getValidFormula (or create a new NEPFormula themselves and check it for
	 * validity).
	 * 
	 * @param fmtManager
	 *            The FormulaManager to be used to interpret a &quot;simple&quot; formula
	 * @param expression
	 *            The expression to be interpreted by the formula parser
	 * @return The NEPFormula representing the given expression
	 */
	public static &lt;T&gt; NEPFormula&lt;T&gt; getNEPFormulaFor(FormatManager&lt;T&gt; fmtManager, String expression)
	{
<span class="pc bpc" id="L330" title="1 of 4 branches missed.">		if (expression == null || expression.isEmpty())</span>
		{
<span class="fc" id="L332">			throw new IllegalArgumentException(&quot;Formula cannot be empty&quot;);</span>
		}
		try
		{
<span class="fc" id="L336">			return new SimpleFormula&lt;&gt;(fmtManager.convert(expression), fmtManager);</span>
		}
<span class="fc" id="L338">		catch (IllegalArgumentException | NullPointerException e)</span>
		{
			// Okay, not simple :P
<span class="fc" id="L341">			return new ComplexNEPFormula&lt;&gt;(expression, fmtManager);</span>
		}
	}

	/**
	 * Returns a &quot;valid&quot; NEPFormula for the given expression.
	 * 
	 * If the given expression does not represent a valid formula, then this
	 * will throw an IllegalArgumentException.
	 * 
	 * If the given expression does not return an object of the type in the
	 * given FormatManager, then this will throw an IllegalArgumentException.
	 * 
	 * @param expression
	 *            The String representation of the formula to be converted to a
	 *            NEPFormula
	 * @param managerFactory
	 *            The ManagerFactory to be used for building the FormulaSemantics
	 * @param formulaManager
	 *            The FormulaManager to be used for validating the NEPFormula
	 * @param varScope
	 *            The PCGenScope in which the NEPFormula is established and
	 *            checked
	 * @param formatManager
	 *            The FormatManager in which the NEPFormula is established and
	 *            checked
	 * @return a &quot;valid&quot; NEPFormula for the given expression
	 */
	public static &lt;T&gt; NEPFormula&lt;T&gt; getValidFormula(String expression, ManagerFactory managerFactory,
		FormulaManager formulaManager, PCGenScope varScope, FormatManager&lt;T&gt; formatManager)
	{
<span class="fc" id="L372">		NEPFormula&lt;T&gt; formula = getNEPFormulaFor(formatManager, expression);</span>
<span class="fc" id="L373">		FormulaSemantics semantics = managerFactory.generateFormulaSemantics(formulaManager, varScope);</span>
<span class="fc" id="L374">		semantics = semantics.getWith(FormulaSemantics.INPUT_FORMAT, Optional.of(formatManager));</span>
		try
		{
<span class="fc" id="L377">			formula.isValid(semantics);</span>
		}
<span class="nc" id="L379">		catch (SemanticsException e)</span>
		{
<span class="nc" id="L381">			throw new IllegalArgumentException(</span>
<span class="nc" id="L382">				&quot;Cannot validate Formula built from: &quot; + formula.toString()</span>
<span class="nc" id="L383">					+ &quot;, with format &quot; + formatManager.getIdentifierType()</span>
<span class="nc" id="L384">					+ &quot;, due to: &quot; + e.getLocalizedMessage(),</span>
				e);
<span class="fc" id="L386">		}</span>
<span class="fc" id="L387">		return formula;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>