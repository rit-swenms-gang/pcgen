<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightedCollection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.base.util</a> &gt; <span class="el_source">WeightedCollection.java</span></div><h1>WeightedCollection.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007 (c) Tom Parker &lt;thpr@users.sourceforge.net&gt;
 *  Copyright 2006 (C) Aaron Divinsky &lt;boomer70@yahoo.com&gt;
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.base.util;

import java.util.AbstractCollection;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Objects;
import java.util.TreeSet;
import java.util.function.Predicate;

import org.jetbrains.annotations.NotNull;

/**
 * An implementation of the &lt;tt&gt;Collection&lt;/tt&gt; interface that allows objects
 * added to the Collection to have a &amp;quot;weight&amp;quot; associated with them.
 * This weight acts as though &lt;i&gt;weight&lt;/i&gt; copies of the item were added to
 * the Collection. The {@code size()} method returns the total weight of
 * all items in the Collection. The {@code get()} method returns the
 * &amp;quot;weight&amp;quot; element in the Collection.
 * &lt;p&gt;
 * As an example, if three items are added to the Collection
 * &lt;ul&gt;
 * &lt;li&gt;Item 1, weight 3&lt;/li&gt;
 * &lt;li&gt;Item 2, weight 2&lt;/li&gt;
 * &lt;li&gt;Item 3, weight 1&lt;/li&gt;
 * &lt;/ul&gt;
 * The Collection will have a total weight of 3+2+1=6. The call
 * {@code get(4)} will return Item 2.
 * &lt;p&gt;
 * 
 * @param &lt;E&gt;
 *            The Class stored in the WeightedCollection
 */
public class WeightedCollection&lt;E&gt; extends AbstractCollection&lt;E&gt;
{

	/**
	 * The actual list where the data is stored.
	 */
	private final Collection&lt;WeightedItem&lt;E&gt;&gt; theData;

	/**
	 * Default constructor. Creates an empty collection.
	 */
	public WeightedCollection()
<span class="fc" id="L64">	{</span>
<span class="fc" id="L65">		theData = new ListSet&lt;&gt;();</span>
<span class="fc" id="L66">	}</span>

	/**
	 * Constructs an empty collection with the specified initial capacity.
	 * 
	 * @param initialSize
	 *            the initial capacity of the collection.
	 * 
	 * @exception IllegalArgumentException
	 *                if the specified initial capacity is negative
	 */
	public WeightedCollection(int initialSize)
<span class="fc" id="L78">	{</span>
<span class="fc" id="L79">		theData = new ListSet&lt;&gt;(initialSize);</span>
<span class="fc" id="L80">	}</span>

	/**
	 * Creates a &lt;tt&gt;WeightedCollection&lt;/tt&gt; from the &lt;tt&gt;Collection&lt;/tt&gt;
	 * provided. All the elements added will have the default weight equal to
	 * the number of times they appear in the given collection.
	 * 
	 * This constructor is both reference-semantic and value-semantic. It will
	 * not modify or maintain a reference to the given Collection of objects.
	 * However, references to the objects contained in the Collection are
	 * maintained by the WeightedCollection, and the WeightedCollection may
	 * return references to those objects contained in the Collection.
	 * 
	 * @param collection
	 *            The &lt;tt&gt;Collection&lt;/tt&gt; to copy.
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public WeightedCollection(Collection&lt;? extends E&gt; collection)
	{
<span class="fc" id="L100">		this();</span>
<span class="fc" id="L101">		addAll(collection, 1);</span>
<span class="fc" id="L102">	}</span>

	/**
	 * Constructs an empty WeightedCollection with the given Comparator used to
	 * establish equality and order in the WeightedCollection.
	 * 
	 * @param comp
	 *            The Comparator this Set will use to determine equality and
	 *            order of the WeightedCollection
	 */
	public WeightedCollection(Comparator&lt;? super E&gt; comp)
<span class="fc" id="L113">	{</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">		if (comp == null)</span>
		{
<span class="fc" id="L116">			theData = new ListSet&lt;&gt;();</span>
		}
		else
		{
<span class="fc" id="L120">			theData = new TreeSet&lt;&gt;(new WeightedItemComparator&lt;&gt;(comp));</span>
		}
<span class="fc" id="L122">	}</span>

	/**
	 * Returns the total weight of the WeightedCollection. This is the sum of
	 * the weights of all the items in the WeightedCollection.
	 * 
	 * @return The total weight.
	 */
	@Override
	public int size()
	{
<span class="fc" id="L133">		return theData.stream()</span>
<span class="fc" id="L134">		              .mapToInt(WeightedItem::getWeight)</span>
<span class="fc" id="L135">		              .sum();</span>
	}

	/**
	 * Adds all the elements from the specified &lt;tt&gt;Collection&lt;/tt&gt; to this
	 * WeightedCollection with the default weight of 1.
	 * 
	 * This method is both reference-semantic and value-semantic. It will not
	 * modify or maintain a reference to the given Collection of objects.
	 * However, references to the objects contained in the Collection are
	 * maintained by the WeightedCollection, and the WeightedCollection may
	 * return references to those objects contained in the Collection.
	 * 
	 * @param collection
	 *            The &lt;tt&gt;Collection&lt;/tt&gt; to add the elements from.
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	@Override
	public boolean addAll(Collection&lt;? extends E&gt; collection)
	{
<span class="fc" id="L156">		return addAll(collection, 1);</span>
	}

	/**
	 * Adds an element to the WeightedCollection with the specified weight. If
	 * the element is already present in the WeightedCollection the weight is
	 * added to the existing element instead. Note that this is means
	 * WeightedCollection does not guarantee order of the collection.
	 * 
	 * @param weight
	 *            Weight to add this element with.
	 * @param element
	 *            Element to add.
	 * @return true if we added successfully
	 * 
	 * @throws IllegalArgumentException
	 *             if the given weight is less than zero
	 */
	public final boolean add(E element, int weight)
	{
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (weight &lt; 0)</span>
		{
<span class="fc" id="L178">			throw new IllegalArgumentException(&quot;Cannot items with weight &lt; 0&quot;);</span>
		}
<span class="fc bfc" id="L180" title="All 2 branches covered.">		else if (weight == 0)</span>
		{
<span class="fc" id="L182">			return false;</span>
		}
		// Lets see if we can find this element
<span class="fc bfc" id="L185" title="All 2 branches covered.">		for (WeightedItem&lt;E&gt; item : theData)</span>
		{
<span class="fc" id="L187">			E wiElement = item.getElement();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">			if (Objects.equals(wiElement, element))</span>
			{
<span class="fc" id="L190">				item.addWeight(weight);</span>
<span class="fc" id="L191">				return true;</span>
			}
<span class="fc" id="L193">		}</span>
<span class="fc" id="L194">		return theData.add(new WeightedItem&lt;&gt;(element, weight));</span>
	}

	/**
	 * Adds the specified element with the default weight.
	 * 
	 * @param element
	 *            The element to add
	 * @return true if the element was added.
	 * 
	 * @see WeightedCollection#add(Object, int)
	 */
	@Override
	public boolean add(E element)
	{
<span class="fc" id="L209">		return add(element, 1);</span>
	}

	/**
	 * Returns a random selection from the WeightedCollection based on weight.
	 * 
	 * @return The random element selected.
	 */
	public E getRandomValue()
	{
<span class="fc" id="L219">		int index = RandomUtil.getRandomInt(size());</span>
<span class="fc" id="L220">		int total = 0;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">		for (WeightedItem&lt;E&gt; item : theData)</span>
		{
<span class="fc" id="L223">			total += item.getWeight();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">			if (total &gt; index)</span>
			{
				/*
				 * NOTE The return statement can't be 100% covered with a Sun
				 * compiler for code coverage stats.
				 */
<span class="fc" id="L230">				return item.getElement();</span>
			}
<span class="nc" id="L232">		}</span>
		/*
		 * This can occur if the list is empty.
		 */
<span class="fc" id="L236">		throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot; + total);</span>
	}

	/**
	 * Returns an &lt;tt&gt;Iterator&lt;/tt&gt; that iterates over the elements in the
	 * WeightedCollection. This Iterator &lt;i&gt;accounts for the weight of the
	 * elements in the WeightedCollection&lt;/i&gt;.
	 * 
	 * This method is reference-semantic. While ownership of the Iterator is
	 * transferred to the calling object (no reference to the iterator is
	 * maintained by the WeightedCollection), actions on the returned Iterator
	 * (e.g. remove()) can alter the WeightedCollection on which this method was
	 * called.
	 * 
	 * @return An &lt;tt&gt;Iterator&lt;/tt&gt; for the WeightedCollection.
	 */
	@NotNull
	@Override
	public Iterator&lt;E&gt; iterator()
	{
<span class="fc" id="L256">		return new WeightedIterator();</span>
	}

	/**
	 * Returns an &lt;tt&gt;Iterator&lt;/tt&gt; that iterates over the elements in the
	 * WeightedCollection. This Iterator &lt;i&gt;does NOT account for the weight of
	 * the elements in the WeightedCollection&lt;/i&gt;. Therefore in a list with
	 * three elements of differing weights, this iterator simply returns each
	 * element in turn.
	 * 
	 * This method is reference-semantic. While ownership of the Iterator is
	 * transferred to the calling object (no reference to the iterator is
	 * maintained by the WeightedCollection), actions on the returned Iterator
	 * (e.g. remove()) can alter the WeightedCollection on which this method was
	 * called.
	 * 
	 * @return An &lt;tt&gt;Iterator&lt;/tt&gt; for the WeightedCollection.
	 */
	Iterator&lt;E&gt; unweightedIterator()
	{
<span class="fc" id="L276">		return new UnweightedIterator();</span>
	}

	/**
	 * Checks if the object specified exists in this WeightedCollection.
	 * 
	 * @param element
	 *            The object to test for
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the object is in the WeightedCollection.
	 */
	@Override
	public boolean contains(Object element)
	{
<span class="fc" id="L289">		return theData.stream()</span>
<span class="fc" id="L290">		              .map(WeightedItem::getElement)</span>
<span class="fc" id="L291">		              .anyMatch(Predicate.isEqual(element));</span>
	}

	/**
	 * Returns the weight for the given object in this WeightedCollection. If
	 * the given object is not in this collection, zero is returned.
	 * 
	 * @param element
	 *            The object for which the weight in this WeightedCollection
	 *            will be returned.
	 * @return the weight of the given object in this WeightedCollection, or
	 *         zero if the object is not in this WeightedCollection
	 */
	public int getWeight(Object element)
	{
<span class="fc" id="L306">		return theData.stream()</span>
<span class="fc" id="L307">				.filter(item -&gt; Objects.equals(item.getElement(), element))</span>
<span class="fc" id="L308">				.mapToInt(WeightedItem::getWeight)</span>
<span class="fc" id="L309">				.findFirst()</span>
<span class="fc" id="L310">				.orElse(0);</span>
	}

	/**
	 * Removes the object from the WeightedCollection if it is present. This
	 * removes the object from this WeightedCollection regardless of the weight
	 * of the object in this WeightedCollection. Therefore, if an object was
	 * weight 2 in this WeightedCollection and is removed, the size of this
	 * WeightedCollection will decrease by two, and NO copies of the given
	 * object will remain in this WeightedCollection.
	 * 
	 * @param element
	 *            The element to remove
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the element was removed.
	 */
	@Override
	public boolean remove(Object element)
	{
<span class="fc bfc" id="L328" title="All 2 branches covered.">		for (Iterator&lt;WeightedItem&lt;E&gt;&gt; it = theData.iterator(); it.hasNext();)</span>
		{
<span class="fc" id="L330">			WeightedItem&lt;E&gt; item = it.next();</span>
<span class="fc" id="L331">			E wiElement = item.getElement();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">			if (Objects.equals(wiElement, element))</span>
			{
<span class="fc" id="L334">				it.remove();</span>
<span class="fc" id="L335">				return true;</span>
			}
<span class="fc" id="L337">		}</span>
<span class="fc" id="L338">		return false;</span>
	}

	/**
	 * Tests if this WeightedCollection has any elements.
	 * 
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the WeightedCollection contains no elements.
	 */
	@Override
	public boolean isEmpty()
	{
<span class="fc" id="L349">		return theData.isEmpty();</span>
	}

	/**
	 * Removes all the elements from the WeightedCollection.
	 */
	@Override
	public void clear()
	{
<span class="fc" id="L358">		theData.clear();</span>
<span class="fc" id="L359">	}</span>

	/**
	 * Compares the specified object with this WeightedCollection for equality.
	 * Returns &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object is also a
	 * WeightedCollection, both WeightedCollections have the same size, and all
	 * corresponding pairs of elements in the two WeightedCollections are
	 * &lt;i&gt;equal&lt;/i&gt;. (Two elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are &lt;i&gt;equal&lt;/i&gt;
	 * if &lt;tt&gt;(e1==null ? e2==null :
	 * e1.equals(e2))&lt;/tt&gt;.) In other words,
	 * two WeightedCollections are defined to be equal if they contain the same
	 * elements in the same order.
	 * &lt;p&gt;
	 * 
	 * @param obj
	 *            The object to be compared for equality with this
	 *            WeightedCollection.
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this
	 *         WeightedCollection.
	 */
	@Override
	public boolean equals(Object obj)
	{
		/*
		 * CONSIDER Currently, this is ORDER SENSITIVE, which is probably bad
		 * for a collection? This needs to be seriously thought through to
		 * determine how exactly this should work... especially given that there
		 * is no solution for sorting a WeightedCollection and thus it is not
		 * possible to actually sort before doing the comparison. - thpr 2/5/07
		 */
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">		return obj instanceof WeightedCollection &amp;&amp; theData.equals(((WeightedCollection&lt;?&gt;) obj).theData);</span>
	}

	@Override
	public int hashCode()
	{
<span class="fc" id="L395">		return theData.hashCode();</span>
	}

	@SuppressWarnings(&quot;nls&quot;)
	@Override
	public String toString()
	{
<span class="fc" id="L402">		return &quot;WeightedCollection: &quot; + theData;</span>
	}

	/**
	 * Adds each element in the specified collection with the indicated weight
	 * value.
	 * 
	 * This method is both reference-semantic and value-semantic. It will not
	 * modify or maintain a reference to the given Collection of objects.
	 * However, references to the objects contained in the Collection are
	 * maintained by the WeightedCollection, and the WeightedCollection may
	 * return references to those objects contained in the Collection.
	 * 
	 * @param weight
	 *            The weight value to use for each element added.
	 * @param collection
	 *            The elements to add to the WeightedCollection
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the WeightedCollection is changed by this
	 *         call.
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public final boolean addAll(Collection&lt;? extends E&gt; collection, int weight)
	{
<span class="fc" id="L426">		boolean modified = false;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">		for (E element : collection)</span>
		{
<span class="fc" id="L429">			modified |= add(element, weight);</span>
<span class="fc" id="L430">		}</span>
<span class="fc" id="L431">		return modified;</span>
	}

	/**
	 * This class is a simple wrapper to associate an object from a
	 * &lt;tt&gt;WeightedList&lt;/tt&gt; and its weight.
	 * 
	 * 
	 * @param &lt;T&gt;
	 */
	static final class WeightedItem&lt;T&gt;
	{
		private final T theElement;

		private int theWeight;

		/**
		 * This constructor creates a new &lt;tt&gt;WeightedItem&lt;/tt&gt; with the
		 * specified weight.
		 * 
		 * @param element
		 *            The object this Item represents.
		 * @param weight
		 *            The weight of the item within the list.
		 */
		WeightedItem(T element, int weight)
<span class="fc" id="L457">		{</span>
<span class="fc" id="L458">			theElement = element;</span>
<span class="fc" id="L459">			theWeight = weight;</span>
<span class="fc" id="L460">		}</span>

		/**
		 * Gets the wrapped object.
		 * 
		 * @return The object this item wraps
		 */
		public T getElement()
		{
<span class="fc" id="L469">			return theElement;</span>
		}

		/**
		 * Gets the weight of this object.
		 * 
		 * @return The weight of this item
		 */
		public int getWeight()
		{
<span class="fc" id="L479">			return theWeight;</span>
		}

		/**
		 * Adds the specified amount of weight to the item.
		 * 
		 * @param weight
		 *            an amount of weight to add.
		 */
		void addWeight(int weight)
		{
<span class="fc" id="L490">			theWeight += weight;</span>
<span class="fc" id="L491">		}</span>

		@Override
		public int hashCode()
		{
<span class="fc bfc" id="L496" title="All 2 branches covered.">			return theWeight * 29 + (theElement == null ? 0 : theElement.hashCode());</span>
		}

		/**
		 * Equals method. Note this is required in order to have the .equals()
		 * at the WeightedCollection level work properly (it is a deep equals)
		 */
		@Override
		public boolean equals(Object obj)
		{
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">			if (obj instanceof WeightedItem&lt;?&gt; item)</span>
			{
<span class="fc bfc" id="L508" title="All 8 branches covered.">				return theWeight == item.theWeight &amp;&amp; (theElement == null &amp;&amp; item.theElement == null</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">					|| theElement != null &amp;&amp; theElement.equals(item.theElement));</span>
			}
			//Arguably unreachable code
<span class="nc" id="L512">			return false;</span>
		}

		@Override
		public String toString()
		{
<span class="fc" id="L518">			return theElement + &quot; (&quot; + theWeight + ')';</span>
		}
	}

	/**
	 * A weighted Iterator for a WeightedCollection
	 */
<span class="fc" id="L525">	private class WeightedIterator implements Iterator&lt;E&gt;</span>
	{

<span class="fc" id="L528">		private final Iterator&lt;WeightedItem&lt;E&gt;&gt; iter = theData.iterator();</span>

		private WeightedItem&lt;E&gt; currentEntry;

<span class="fc" id="L532">		private int currentReturned = 0;</span>

		@Override
		public boolean hasNext()
		{
<span class="fc bfc" id="L537" title="All 2 branches covered.">			if (currentEntry == null)</span>
			{
<span class="fc bfc" id="L539" title="All 2 branches covered.">				if (!iter.hasNext())</span>
				{
<span class="fc" id="L541">					return false;</span>
				}
<span class="fc" id="L543">				currentEntry = iter.next();</span>
<span class="fc" id="L544">				currentReturned = 0;</span>
			}
<span class="fc bfc" id="L546" title="All 2 branches covered.">			if (currentReturned &lt; currentEntry.theWeight)</span>
			{
<span class="fc" id="L548">				return true;</span>
			}
<span class="fc" id="L550">			return iter.hasNext();</span>
		}

		@Override
		public E next()
		{
<span class="fc bfc" id="L556" title="All 4 branches covered.">			if ((currentEntry == null) || (currentReturned &gt;= currentEntry.getWeight()))</span>
			{
<span class="fc" id="L558">				currentEntry = iter.next();</span>
<span class="fc" id="L559">				currentReturned = 0;</span>
			}
<span class="fc" id="L561">			currentReturned++;</span>
<span class="fc" id="L562">			return currentEntry.theElement;</span>
		}

		@Override
		public void remove()
		{
<span class="fc" id="L568">			iter.remove();</span>
<span class="fc" id="L569">			currentEntry = null;</span>
<span class="fc" id="L570">		}</span>
	}

	/**
	 * A Unweighted Iterator for the WeightedCollection
	 */
<span class="fc" id="L576">	private class UnweightedIterator implements Iterator&lt;E&gt;</span>
	{
		/** An iterator that iterates over the raw data elements. */
<span class="fc" id="L579">		private final Iterator&lt;WeightedItem&lt;E&gt;&gt; realIterator = theData.iterator();</span>

		/**
		 * Checks if there are any more elements in the iteration.
		 * 
		 * @return &lt;tt&gt;true&lt;/tt&gt; if there are more elements.
		 */
		@Override
		public boolean hasNext()
		{
<span class="fc" id="L589">			return realIterator.hasNext();</span>
		}

		/**
		 * Returns the next element in the iteration.
		 * 
		 * @return The next element.
		 */
		@Override
		public E next()
		{
<span class="fc" id="L600">			return realIterator.next().getElement();</span>
		}

		/**
		 * Removes from the WeightedCollection the last element returned from
		 * the iteration.
		 */
		@Override
		public void remove()
		{
<span class="fc" id="L610">			realIterator.remove();</span>
<span class="fc" id="L611">		}</span>
	}

	/**
	 * Implements a Comparator of WeightedItems. Takes in a Comparator to which
	 * it will delegate comparison of the underlying objects.
	 * 
	 * @param &lt;WICT&gt;
	 *            The type of the object underlying the WeightedItem objects
	 *            that this WeightedItemComparator can compare.
	 */
	private static final class WeightedItemComparator&lt;WICT&gt; implements Comparator&lt;WeightedItem&lt;WICT&gt;&gt;
	{

		/**
		 * The Comparator to which this WeightedItemComparator will delegate
		 * comparison of the underlying objects.
		 */
		private final Comparator&lt;? super WICT&gt; delegate;

		/**
		 * Constructs a new WeightedItemComparator with the given Comparator as
		 * the delegate given to provide comparison of the underlying objects.
		 * 
		 * @param comp
		 *            The delegate Comparator given to provide comparison of the
		 *            objects underlying the WeightedItem objects compared by
		 *            this WeightedItemComparator
		 */
		WeightedItemComparator(Comparator&lt;? super WICT&gt; comp)
<span class="fc" id="L641">		{</span>
<span class="fc" id="L642">			delegate = comp;</span>
<span class="fc" id="L643">		}</span>

		/**
		 * Compare two WeightedItem objects
		 */
		@Override
		public int compare(WeightedItem&lt;WICT&gt; item1, WeightedItem&lt;WICT&gt; item2)
		{
<span class="fc" id="L651">			return delegate.compare(item1.getElement(), item2.getElement());</span>
		}

	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>