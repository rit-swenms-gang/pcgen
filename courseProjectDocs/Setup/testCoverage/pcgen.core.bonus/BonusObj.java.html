<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BonusObj.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core.bonus</a> &gt; <span class="el_source">BonusObj.java</span></div><h1>BonusObj.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002 (C) Greg Bingleman &lt;byngl@hotmail.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core.bonus;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import pcgen.base.formula.Formula;
import pcgen.cdom.base.ConcretePrereqObject;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.FormulaFactory;
import pcgen.cdom.base.QualifyingObject;
import pcgen.core.PlayerCharacter;
import pcgen.core.utils.CoreUtility;
import pcgen.persistence.lst.output.prereq.PrerequisiteWriter;
import pcgen.rules.context.LoadContext;

/**
 * {@code BonusObj}
 *
 **/
<span class="fc" id="L41">public abstract class BonusObj extends ConcretePrereqObject implements Serializable, Cloneable, QualifyingObject</span>
{
<span class="fc" id="L43">	private List&lt;Object&gt; bonusInfo = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L44">	private Map&lt;String, String&gt; dependMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L45">	private Formula bonusFormula = FormulaFactory.ZERO;</span>

	/** The name of the bonus e.g. STAT or COMBAT */
<span class="fc" id="L48">	private String bonusName = Constants.EMPTY_STRING;</span>

	/** The type of the bonus e.g. Enhancement or Dodge */
<span class="fc" id="L51">	private String bonusType = Constants.EMPTY_STRING;</span>
<span class="fc" id="L52">	private String varPart = Constants.EMPTY_STRING;</span>
<span class="fc" id="L53">	private String typeOfBonus = Bonus.BONUS_UNDEFINED;</span>
<span class="fc" id="L54">	private String stringRepresentation = null;</span>
<span class="fc" id="L55">	private String tokenSource = null;</span>

	/** An enum for the possible stacking modifiers a bonus can have */
<span class="fc" id="L58">	public enum StackType</span>
	{
		/** This bonus will follow the normal stacking rules. */
<span class="fc" id="L61">		NORMAL,</span>
		/** This bonus will always stack regardless of its type. */
<span class="fc" id="L63">		STACK,</span>
		/** 
		 * This bonus will stack with other bonuses of its own type but not
		 * with bonuses of other types.
		 */
<span class="fc" id="L68">		REPLACE</span>
	}

<span class="fc" id="L71">	private StackType theStackingFlag = StackType.NORMAL;</span>

	/**
	 * Get Bonus Info
	 * @return Bonus info
	 */
	public String getBonusInfo()
	{
<span class="nc" id="L79">		final StringBuilder sb = new StringBuilder(50);</span>

<span class="nc bnc" id="L81" title="All 2 branches missed.">		if (!bonusInfo.isEmpty())</span>
		{
<span class="nc bnc" id="L83" title="All 2 branches missed.">			for (int i = 0; i &lt; bonusInfo.size(); ++i)</span>
			{
<span class="nc bnc" id="L85" title="All 2 branches missed.">				sb.append(i == 0 ? Constants.EMPTY_STRING : Constants.COMMA);</span>
<span class="nc" id="L86">				sb.append(unparseToken(bonusInfo.get(i)));</span>
			}
		}
		else
		{
<span class="nc" id="L91">			sb.append(&quot;|ERROR&quot;); //$NON-NLS-1$</span>
		}

<span class="nc" id="L94">		return sb.toString().toUpperCase();</span>
	}

	/**
	 * Return a list of the unparsed (converted back to strings) 
	 * bonus info entries.
	 * @return The unparsed bonus info list
	 */
	public List&lt;String&gt; getUnparsedBonusInfoList()
	{
<span class="nc" id="L104">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">		for (Object info : bonusInfo)</span>
		{
<span class="nc" id="L107">			list.add(unparseToken(info));</span>
<span class="nc" id="L108">		}</span>
<span class="nc" id="L109">		return list;</span>
	}

	/**
	 * get Bonus Info List
	 * @return Bonus Info List
	 */
	public List&lt;?&gt; getBonusInfoList()
	{
<span class="nc" id="L118">		return bonusInfo;</span>
	}

	/**
	 * Get Bonus Name
	 * @return bonus name
	 */
	public String getBonusName()
	{
<span class="nc" id="L127">		return bonusName;</span>
	}

	/**
	 * Get depends on given a key
	 * @param aString
	 * @return true if it depends on
	 */
	public boolean getDependsOn(final String aString)
	{
<span class="nc" id="L137">		return dependMap.containsKey(aString);</span>
	}

	/**
	 * Get depends on given a set of keys
	 * @param aList List of bonus keys
	 * @return true if it any of the keys are depended on
	 */
	public boolean getDependsOn(final List&lt;String&gt; aList)
	{
<span class="nc bnc" id="L147" title="All 2 branches missed.">		for (String key : aList)</span>
		{
<span class="nc bnc" id="L149" title="All 2 branches missed.">			if (dependMap.containsKey(key))</span>
			{
<span class="nc" id="L151">				return true;</span>
			}
<span class="nc" id="L153">		}</span>
<span class="nc" id="L154">		return false;</span>
	}

	/**
	 * Check if this bonus requires bonuses of a particular name to be 
	 * resolved first. e.g. Supply STAT to check for all BONUS:STAT entries. 
	 * @param bonusName Bonus name to be checked for.
	 * @return true if there is a dependancy
	 */
	public boolean getDependsOnBonusName(final String bonusName)
	{
<span class="nc" id="L165">		return dependMap.containsKey(&quot;NAME|&quot; + bonusName);</span>
	}

	/**
	 * Report on the dependencies of the bonus.
	 * @return String the dependancies
	 */
	public String listDependsMap()
	{
<span class="nc" id="L174">		StringBuilder buff = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">		for (String key : dependMap.keySet())</span>
		{
<span class="nc bnc" id="L177" title="All 2 branches missed.">			if (buff.length() &gt; 1)</span>
			{
<span class="nc" id="L179">				buff.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L181">			buff.append(key);</span>
<span class="nc" id="L182">		}</span>
<span class="nc" id="L183">		buff.append(&quot;]&quot;);</span>
<span class="nc" id="L184">		return buff.toString();</span>
	}

	/**
	 * @return type of Bonus
	 */
	public String getTypeOfBonus()
	{
<span class="nc" id="L192">		return typeOfBonus;</span>
	}

	/**
	 * Get the bonus type
	 * @return the bonus type
	 */
	public String getTypeString()
	{
<span class="nc" id="L201">		return bonusType;</span>
	}

	/**
	 * Set value
	 * @param bValue
	 */
	Formula setValue(final String bValue)
	{
<span class="fc" id="L210">		bonusFormula = FormulaFactory.getFormulaFor(bValue);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (!bonusFormula.isStatic())</span>
		{
<span class="fc" id="L213">			buildDependMap(bValue.toUpperCase());</span>
		}
<span class="fc" id="L215">		return bonusFormula;</span>
	}

	/**
	 * Get the bonus formula
	 * @return the formula
	 */
	public Formula getFormula()
	{
<span class="nc" id="L224">		return bonusFormula;</span>
	}

	/**
	 * Get the bonus value
	 * @return the value
	 */
	public String getValue()
	{
<span class="fc" id="L233">		return bonusFormula.toString();</span>
	}

	/**
	 * Get the bonus value as a double
	 * @param string 
	 * @return bonus value as a double
	 */
	public Number resolve(PlayerCharacter pc, String string)
	{
<span class="nc" id="L243">		return bonusFormula.resolve(pc, string);</span>
	}

	/**
	 * is value static
	 * @return true if value is static
	 */
	public boolean isValueStatic()
	{
<span class="nc" id="L252">		return bonusFormula.isStatic();</span>
	}

	/**
	 * Set the variable
	 * @param aString
	 */
	public void setVariable(final String aString)
	{
<span class="nc" id="L261">		varPart = aString.toUpperCase();</span>
<span class="nc" id="L262">	}</span>

	/**
	 * Get the variable
	 * @return the variable
	 */
	public String getVariable()
	{
<span class="nc" id="L270">		return varPart;</span>
	}

	/**
	 * Has bonus type string
	 * @return true if bonus type string exists
	 */
	public boolean hasTypeString()
	{
<span class="nc bnc" id="L279" title="All 2 branches missed.">		return !bonusType.isEmpty();</span>
	}

	/**
	 * has variable
	 * @return true if bonus has variable
	 */
	public boolean hasVariable()
	{
<span class="nc bnc" id="L288" title="All 2 branches missed.">		return !varPart.isEmpty();</span>
	}

	/**
	 * Retrieve the persistent text for this bonus. This text
	 * when reparsed will recreate the bonus. PCC Text is used
	 * as a name here as this output could also be used by the
	 * LST editors.
	 * @return The text to be saved for example in a character.
	 */
	public String getPCCText()
	{
<span class="nc bnc" id="L300" title="All 2 branches missed.">		if (stringRepresentation == null)</span>
		{
<span class="nc" id="L302">			final StringBuilder sb = new StringBuilder(50);</span>

<span class="nc" id="L304">			sb.append(getTypeOfBonus());</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">			if (varPart != null &amp;&amp; !varPart.isEmpty())</span>
			{
<span class="nc" id="L307">				sb.append(varPart);</span>
			}

<span class="nc bnc" id="L310" title="All 2 branches missed.">			if (!bonusInfo.isEmpty())</span>
			{
<span class="nc bnc" id="L312" title="All 2 branches missed.">				for (int i = 0; i &lt; bonusInfo.size(); ++i)</span>
				{
<span class="nc bnc" id="L314" title="All 2 branches missed.">					sb.append(i == 0 ? '|' : ',').append(unparseToken(bonusInfo.get(i)));</span>
				}
			}
			else
			{
<span class="nc" id="L319">				sb.append(&quot;|ERROR&quot;);</span>
			}

<span class="nc" id="L322">			sb.append('|').append(bonusFormula);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">			if (!bonusType.isEmpty())</span>
			{
<span class="nc" id="L326">				sb.append(&quot;|TYPE=&quot;).append(bonusType);</span>
			}

			// And put the prereqs at the end of the string.
<span class="nc bnc" id="L330" title="All 2 branches missed.">			if (hasPrerequisites())</span>
			{
<span class="nc" id="L332">				sb.append(Constants.PIPE);</span>
<span class="nc" id="L333">				sb.append(new PrerequisiteWriter().getPrerequisiteString(getPrerequisiteList(), Constants.PIPE));</span>
			}

<span class="nc" id="L336">			stringRepresentation = sb.toString();</span>
		}
<span class="nc" id="L338">		return stringRepresentation;</span>
	}

	@Override
	public String toString()
	{
<span class="nc" id="L344">		return getPCCText();</span>
	}

	protected void setBonusName(final String aName)
	{
<span class="fc" id="L349">		bonusName = aName;</span>
<span class="fc" id="L350">	}</span>

	protected void setTypeOfBonus(final String type)
	{
<span class="fc" id="L354">		typeOfBonus = type;</span>
<span class="fc" id="L355">	}</span>

	protected void addBonusInfo(final Object obj)
	{
<span class="fc" id="L359">		bonusInfo.add(obj);</span>
<span class="fc" id="L360">	}</span>

	protected void replaceBonusInfo(final Object oldObj, final Object newObj)
	{
<span class="nc bnc" id="L364" title="All 2 branches missed.">		for (int i = 0; i &lt; bonusInfo.size(); ++i)</span>
		{
<span class="nc" id="L366">			final Object curObj = bonusInfo.get(i);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">			if (curObj == oldObj)</span>
			{
<span class="nc" id="L369">				bonusInfo.set(i, newObj);</span>
<span class="nc" id="L370">				break;</span>
			}
		}
<span class="nc" id="L373">	}</span>

	protected boolean addType(final String typeString)
	{
<span class="nc bnc" id="L377" title="All 2 branches missed.">		if (bonusType.isEmpty())</span>
		{
<span class="nc" id="L379">			bonusType = typeString.toUpperCase();</span>

<span class="nc" id="L381">			return true;</span>
		}

<span class="nc" id="L384">		return false;</span>
	}

	/**
	 * Sets the stacking flag for this bonus.
	 * 
	 * @param aFlag A &lt;tt&gt;StackType&lt;/tt&gt; to set.
	 */
	public void setStackingFlag(final StackType aFlag)
	{
<span class="nc" id="L394">		theStackingFlag = aFlag;</span>
<span class="nc" id="L395">	}</span>

	/**
	 * Gets the stacking flag for this bonus.
	 * 
	 * @return A &lt;tt&gt;StackType&lt;/tt&gt;.
	 */
	public StackType getStackingFlag()
	{
<span class="nc" id="L404">		return theStackingFlag;</span>
	}

	protected abstract boolean parseToken(LoadContext context, String token);

	protected abstract String unparseToken(Object obj);

	public abstract String getBonusHandled();

	private void buildDependMap(String aString)
	{
<span class="fc" id="L415">		addImpliedDependenciesFor(aString);</span>

		// First whack out all the () pairs to find variable names
<span class="fc bfc" id="L418" title="All 2 branches covered.">		while (aString.lastIndexOf('(') &gt;= 0)</span>
		{
<span class="fc" id="L420">			final int x = CoreUtility.innerMostStringStart(aString);</span>
<span class="fc" id="L421">			final int y = CoreUtility.innerMostStringEnd(aString);</span>

<span class="pc bpc" id="L423" title="1 of 2 branches missed.">			if (y &lt; x)</span>
			{
<span class="nc" id="L425">				return;</span>
			}

<span class="fc" id="L428">			final String bString = aString.substring(x + 1, y);</span>
<span class="fc" id="L429">			buildDependMap(bString);</span>
<span class="fc" id="L430">			aString = aString.substring(0, x)</span>
<span class="fc" id="L431">					+ aString.substring(y + 1);</span>
<span class="fc" id="L432">		}</span>

<span class="pc bpc" id="L434" title="3 of 6 branches missed.">		if (aString.indexOf('(') &gt;= 0 || aString.indexOf(')') &gt;= 0 || aString.indexOf('%') &gt;= 0)</span>
		{
<span class="nc" id="L436">			return;</span>
		}

		// We now have the substring we want to work on
<span class="fc" id="L440">		final StringTokenizer cTok = new StringTokenizer(aString, &quot;.,&quot;);</span>

<span class="fc bfc" id="L442" title="All 2 branches covered.">		while (cTok.hasMoreTokens())</span>
		{
<span class="fc" id="L444">			final String controlString = cTok.nextToken();</span>

			// skip flow control tags
<span class="pc bpc" id="L447" title="3 of 6 branches missed.">			if (&quot;IF&quot;.equals(controlString) || &quot;THEN&quot;.equals(controlString) || &quot;ELSE&quot;.equals(controlString)</span>
<span class="pc bpc" id="L448" title="3 of 6 branches missed.">				|| &quot;GT&quot;.equals(controlString) || &quot;GTEQ&quot;.equals(controlString) || &quot;EQ&quot;.equals(controlString)</span>
<span class="pc bpc" id="L449" title="2 of 4 branches missed.">				|| &quot;LTEQ&quot;.equals(controlString) || &quot;LT&quot;.equals(controlString))</span>
			{
<span class="nc" id="L451">				continue;</span>
			}

			// Now remove math strings: + - / *
			// and comparison strings: &gt; = &lt;
			// remember, a StringTokenizer will tokenize
			// on any of the found delimiters
<span class="fc" id="L458">			final StringTokenizer mTok = new StringTokenizer(controlString, &quot;+-/*&gt;=&lt;\&quot;&quot;);</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">			while (mTok.hasMoreTokens())</span>
			{
<span class="fc" id="L462">				String newString = mTok.nextToken();</span>
<span class="fc" id="L463">				String testString = newString;</span>
<span class="fc" id="L464">				boolean found = false;</span>

				// now Check for MIN or MAX
<span class="fc bfc" id="L467" title="All 2 branches covered.">				while (!found)</span>
				{
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">					if (newString.contains(&quot;MAX&quot;))</span>
					{
<span class="nc" id="L471">						testString = newString.substring(0, newString.indexOf(&quot;MAX&quot;));</span>
<span class="nc" id="L472">						newString = newString.substring(newString.indexOf(&quot;MAX&quot;) + 3);</span>
					}
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">					else if (newString.contains(&quot;MIN&quot;))</span>
					{
<span class="nc" id="L476">						testString = newString.substring(0, newString.indexOf(&quot;MIN&quot;));</span>
<span class="nc" id="L477">						newString = newString.substring(newString.indexOf(&quot;MIN&quot;) + 3);</span>
					}
					else
					{
<span class="fc" id="L481">						found = true;</span>
					}

					// check to see if it's a number
					try
					{
<span class="fc" id="L487">						Float.parseFloat(testString);</span>
					}
<span class="fc" id="L489">					catch (NumberFormatException e)</span>
					{
						// It's a Variable!
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">						if (!testString.isEmpty())</span>
						{
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">							if (testString.startsWith(&quot;MOVE[&quot;))</span>
							{
<span class="nc" id="L496">								testString = &quot;TYPE.&quot;</span>
<span class="nc" id="L497">										+ testString.substring(5, testString.length() - 1);</span>
							}
<span class="fc" id="L499">							dependMap.put(testString.intern(), &quot;1&quot;);</span>
<span class="fc" id="L500">							addImpliedDependenciesFor(testString);</span>
						}
<span class="fc" id="L502">					}</span>
				}
<span class="fc" id="L504">			}</span>
<span class="fc" id="L505">		}</span>
<span class="fc" id="L506">	}</span>

	/**
	 * Add any dependencies implied by the provided dependency.
	 * @param aString The direct dependency being added.
	 */
	private void addImpliedDependenciesFor(String aString)
	{
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">		if (aString.contains(&quot;SKILLINFO(&quot;))</span>
		{
<span class="nc" id="L516">			dependMap.put(&quot;JEPFORMULA&quot;, &quot;1&quot;);</span>
		}
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">		if (aString.contains(&quot;HP&quot;))</span>
		{
<span class="nc" id="L520">			dependMap.put(&quot;CURRENTMAX&quot;, &quot;1&quot;);</span>
		}
<span class="pc bpc" id="L522" title="2 of 4 branches missed.">		if (aString.contains(&quot;SKILL.&quot;) || aString.contains(&quot;SKILLINFO&quot;))</span>
		{
<span class="nc" id="L524">			dependMap.put(&quot;NAME|STAT&quot;, &quot;1&quot;);</span>
		}
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">		if (aString.contains(&quot;MODEQUIPMAXDEX&quot;))</span>
		{
<span class="nc" id="L528">			dependMap.put(&quot;MAXDEX&quot;, &quot;1&quot;);</span>
		}
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">		if (aString.equals(&quot;BAB&quot;))</span>
		{
<span class="nc" id="L532">			dependMap.put(&quot;BASEAB&quot;, &quot;1&quot;);</span>
		}
<span class="fc" id="L534">	}</span>

	@Override
	public BonusObj clone() throws CloneNotSupportedException
	{
<span class="nc" id="L539">		final BonusObj bonusObj = (BonusObj) super.clone();</span>

<span class="nc" id="L541">		bonusObj.bonusInfo = new ArrayList&lt;&gt;(bonusInfo);</span>

<span class="nc" id="L543">		bonusObj.dependMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L544">		bonusObj.setValue(bonusFormula.toString());</span>

		// we want to keep the same references to these objects
		// creatorObj
		// targetObj

		// These objects are immutable and do not need explicit cloning
		// bonusName
		// bonusType
		// choiceString
		// varPart
		// isApplied
		// valueIsStatic
		// pcLevel
		// typeOfBonus
<span class="nc" id="L559">		return bonusObj;</span>
	}

	public void setTokenSource(String tokenName)
	{
<span class="fc" id="L564">		tokenSource = tokenName;</span>
<span class="fc" id="L565">	}</span>

	public String getTokenSource()
	{
<span class="fc" id="L569">		return tokenSource;</span>
	}

	@Override
	public boolean equals(Object obj)
	{
<span class="fc bfc" id="L575" title="All 2 branches covered.">		if (obj == this)</span>
		{
<span class="fc" id="L577">			return true;</span>
		}
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">		if (!(obj instanceof BonusObj other))</span>
		{
<span class="nc" id="L581">			return false;</span>
		}
<span class="pc bpc" id="L583" title="3 of 6 branches missed.">		return equalsPrereqObject(other) &amp;&amp; bonusFormula.equals(other.bonusFormula) &amp;&amp; bonusName.equals(other.bonusName)</span>
<span class="pc bpc" id="L584" title="2 of 4 branches missed.">			&amp;&amp; bonusType.equals(other.bonusType) &amp;&amp; theStackingFlag == other.theStackingFlag</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">			&amp;&amp; bonusInfo.equals(other.bonusInfo);</span>
	}

	/*
	 * This makes an editor a bit more difficult, but since CHOOSE is an early
	 * target of 5.17, this probably isn't a big deal.
	 */
	private String originalString;

	public void putOriginalString(String bonusString)
	{
<span class="fc" id="L596">		originalString = bonusString;</span>
<span class="fc" id="L597">	}</span>

	public String getLSTformat()
	{
<span class="fc" id="L601">		return originalString;</span>
	}

	public String getDescription()
	{
<span class="nc" id="L606">		return getTypeOfBonus() + &quot; &quot; + getBonusInfo(); //$NON-NLS-1$</span>
	}

	/**
	 * Identify if this bonus cannot have its target changed to upper case. 
	 * @return true if the original case is needed for the targets.
	 */
	protected boolean requiresRealCaseTarget()
	{
<span class="fc" id="L615">		return false;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>