<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Bonus.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core.bonus</a> &gt; <span class="el_source">Bonus.java</span></div><h1>Bonus.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002 (C) Greg Bingleman &lt;byngl@hotmail.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core.bonus;

import java.lang.reflect.InvocationTargetException;
import java.util.Locale;
import java.util.StringTokenizer;

import pcgen.base.formula.Formula;
import pcgen.base.text.ParsingSeparator;
import pcgen.cdom.base.Constants;
import pcgen.core.bonus.BonusObj.StackType;
import pcgen.persistence.PersistenceLayerException;
import pcgen.persistence.lst.LstUtils;
import pcgen.persistence.lst.prereq.PreParserFactory;
import pcgen.rules.context.LoadContext;
import pcgen.rules.persistence.TokenLibrary;
import pcgen.util.Logging;

public final class Bonus
{
	static final String BONUS_UNDEFINED = &quot;*UNDEFINED&quot;;

	private Bonus()
	{
		// Constructor
	}

	/**
	 * Create a new Bonus
	 * @param context TODO
	 * @param bonusString
	 * @return BonusObj
	 * 
	 * TODO - This is doing all manner of string parsing.  It really belongs in
	 * the persistence layer.
	 */
	public static BonusObj newBonus(LoadContext context, final String bonusString)
	{
<span class="fc" id="L55">		ParsingSeparator sep = new ParsingSeparator(bonusString, '|');</span>
<span class="fc" id="L56">		sep.addGroupingPair('[', ']');</span>
<span class="fc" id="L57">		sep.addGroupingPair('(', ')');</span>

<span class="fc bfc" id="L59" title="All 2 branches covered.">		if ((bonusString.indexOf(Constants.PIPE) == bonusString.lastIndexOf(Constants.PIPE))</span>
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">			&amp;&amp; bonusString.indexOf('%') &lt; 0)</span>
		{
<span class="fc" id="L62">			Logging.errorPrint(&quot;Illegal bonus format: &quot; + bonusString);</span>

<span class="fc" id="L64">			return null;</span>
		}

<span class="fc" id="L67">		String bonusName = sep.next();</span>

		try
		{
			//Throw away old level value if present
<span class="nc" id="L72">			Integer.parseInt(bonusName);</span>
<span class="nc" id="L73">			bonusName = sep.next().toUpperCase(Locale.ENGLISH);</span>
		}
<span class="fc" id="L75">		catch (NumberFormatException exc)</span>
		{
<span class="fc" id="L77">			bonusName = bonusName.toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L78">		}</span>

<span class="fc" id="L80">		int equalOffset = -1;</span>
<span class="fc" id="L81">		Class&lt;? extends BonusObj&gt; bEntry = TokenLibrary.getBonus(bonusName);</span>
<span class="fc" id="L82">		String typeOfBonus = bonusName;</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">		if (bEntry == null)</span>
		{
<span class="nc" id="L85">			equalOffset = bonusName.indexOf('=');</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">			if (equalOffset &gt;= 0)</span>
			{
<span class="nc" id="L88">				typeOfBonus = bonusName.substring(0, equalOffset + 1);</span>
<span class="nc" id="L89">				bEntry = TokenLibrary.getBonus(typeOfBonus);</span>
			}
<span class="nc bnc" id="L91" title="All 2 branches missed.">			if (bEntry == null)</span>
			{
<span class="nc" id="L93">				Logging.errorPrint(&quot;Unrecognized bonus: &quot; + bonusString);</span>
<span class="nc" id="L94">				return null;</span>
			}
		}

<span class="fc" id="L98">		String bonusInfo = sep.next();</span>
<span class="fc" id="L99">		String bValue = &quot;0&quot;;</span>

<span class="pc bpc" id="L101" title="1 of 2 branches missed.">		if (sep.hasNext())</span>
		{
<span class="fc" id="L103">			bValue = sep.next();</span>
		}

<span class="pc bpc" id="L106" title="1 of 4 branches missed.">		if (bValue.startsWith(&quot;PRE&quot;) || bValue.startsWith(&quot;!PRE&quot;))</span>
		{
<span class="fc" id="L108">			Logging.errorPrint(&quot;Invalid BONUS has no value: &quot; + bonusString);</span>
<span class="fc" id="L109">			return null;</span>
		}

<span class="fc" id="L112">		bValue = bValue.toUpperCase(Locale.ENGLISH);</span>

		BonusObj aBonus;
		try
		{
<span class="fc" id="L117">			aBonus = bEntry.getConstructor().newInstance();</span>
		}
<span class="nc" id="L119">		catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException exc)</span>
		{
<span class="nc" id="L121">			Logging.errorPrint(&quot;Could not create bonusObj for:&quot; + bonusString, exc);</span>
<span class="nc" id="L122">			return null;</span>
<span class="fc" id="L123">		}</span>

<span class="fc" id="L125">		aBonus.putOriginalString(bonusString);</span>
<span class="fc" id="L126">		aBonus.setBonusName(bonusName);</span>
<span class="fc" id="L127">		aBonus.setTypeOfBonus(typeOfBonus);</span>
<span class="fc" id="L128">		Formula val = aBonus.setValue(bValue);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">		if (!val.isValid())</span>
		{
<span class="nc" id="L131">			Logging.errorPrint(</span>
				&quot;Could not create bonusObj for:&quot; + bonusString + &quot; since Formula &quot; + bValue + &quot; is not valid: &quot; + val);
<span class="nc" id="L133">			return null;</span>
		}

<span class="fc bfc" id="L136" title="All 2 branches covered.">		while (sep.hasNext())</span>
		{
<span class="fc" id="L138">			final String aString = sep.next().toUpperCase(Locale.ENGLISH);</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">			if (PreParserFactory.isPreReqString(aString))</span>
			{
				// Logging.errorPrint(&quot;Why is this not parsed in loading: &quot; +
				// aString + &quot; rather than in Bonus.newBonus()&quot;);

				try
				{
<span class="fc" id="L147">					final PreParserFactory factory = PreParserFactory.getInstance();</span>
<span class="fc" id="L148">					aBonus.addPrerequisite(factory.parse(aString));</span>
				}
<span class="nc" id="L150">				catch (PersistenceLayerException ple)</span>
				{
<span class="nc" id="L152">					Logging.errorPrint(ple.getMessage(), ple);</span>
<span class="nc" id="L153">					Logging.reportSource(Logging.ERROR, context);</span>
<span class="nc" id="L154">					return null;</span>
<span class="fc" id="L155">				}</span>
			}
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">			else if (aString.startsWith(&quot;TYPE=&quot;) || aString.startsWith(&quot;TYPE.&quot;))</span>
			{
<span class="nc" id="L159">				String bonusType = aString.substring(5);</span>
<span class="nc" id="L160">				int dotLoc = bonusType.indexOf('.');</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">				if (dotLoc != -1)</span>
				{
<span class="nc" id="L163">					final String stackingFlag = bonusType.substring(dotLoc + 1);</span>
					// TODO - Need to reset bonusType to exclude this but
					// there is too much dependancy on it being there
					// built into the code.
<span class="nc bnc" id="L167" title="All 2 branches missed.">					if (stackingFlag.startsWith(&quot;REPLACE&quot;)) //$NON-NLS-1$</span>
					{
<span class="nc" id="L169">						aBonus.setStackingFlag(StackType.REPLACE);</span>
					}
<span class="nc bnc" id="L171" title="All 2 branches missed.">					else if (stackingFlag.startsWith(&quot;STACK&quot;)) //$NON-NLS-1$</span>
					{
<span class="nc" id="L173">						aBonus.setStackingFlag(StackType.STACK);</span>
					}
				}
<span class="nc" id="L176">				final boolean result = aBonus.addType(bonusType);</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">				if (!result)</span>
				{
<span class="nc" id="L180">					Logging.log(Logging.LST_ERROR,</span>
<span class="nc" id="L181">							&quot;Could not add type &quot; + aString.substring(5)</span>
									+ &quot; to bonusType &quot; + typeOfBonus + &quot; in Bonus.newBonus&quot;);
<span class="nc" id="L183">					Logging.reportSource(Logging.LST_ERROR, context);</span>
<span class="nc" id="L184">					return null;</span>
				}
			}
<span class="fc" id="L187">		}</span>

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">		if (equalOffset &gt;= 0)</span>
		{
<span class="nc" id="L191">			aBonus.setVariable(bonusName.substring(equalOffset + 1));</span>
		}

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">		if (!aBonus.requiresRealCaseTarget())</span>
		{
<span class="fc" id="L196">			bonusInfo = bonusInfo.toUpperCase(Locale.ENGLISH);</span>
		}
<span class="fc" id="L198">		StringTokenizer aTok = new StringTokenizer(bonusInfo, &quot;,&quot;);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">		if (!aTok.hasMoreTokens())</span>
		{
<span class="fc" id="L202">			Logging.log(Logging.LST_ERROR, &quot;Could not parse empty target from BONUS:&quot; + bonusString);</span>
<span class="fc" id="L203">			Logging.reportSource(Logging.LST_ERROR, context);</span>
<span class="fc" id="L204">			return null;</span>
		}
<span class="fc" id="L206">		LstUtils.deprecationCheck(aBonus, bonusName, bonusString);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		while (aTok.hasMoreTokens())</span>
		{
<span class="fc" id="L209">			final String token = aTok.nextToken();</span>
<span class="fc" id="L210">			final boolean result = aBonus.parseToken(context, token);</span>

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">			if (!result)</span>
			{
<span class="nc" id="L214">				Logging.log(Logging.LST_ERROR, &quot;Could not parse token &quot; + token</span>
						+ &quot; from BONUS:&quot; + bonusString);
<span class="nc" id="L216">				Logging.reportSource(Logging.LST_ERROR, context);</span>
<span class="nc" id="L217">				return null;</span>
			}
<span class="fc" id="L219">		}</span>

<span class="fc" id="L221">		return aBonus;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>