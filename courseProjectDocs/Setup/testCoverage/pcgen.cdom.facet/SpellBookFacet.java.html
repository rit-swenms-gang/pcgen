<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpellBookFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet</a> &gt; <span class="el_source">SpellBookFacet.java</span></div><h1>SpellBookFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2009.
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;

import pcgen.cdom.base.Constants;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.facet.base.AbstractStorageFacet;
import pcgen.cdom.facet.event.DataFacetChangeEvent;
import pcgen.cdom.facet.event.DataFacetChangeListener;
import pcgen.core.Equipment;
import pcgen.core.character.SpellBook;

/**
 * SpellBookFacet is a Facet that tracks the SpellBooks possessed by a Player
 * Character.
 * 
 */
<span class="fc" id="L39">public class SpellBookFacet extends AbstractStorageFacet&lt;CharID&gt; implements DataFacetChangeListener&lt;CharID, Equipment&gt;</span>
{
	private EquipmentFacet equipmentFacet;

	/**
	 * Adds a SpellBook to this facet if the Equipment added to a Player
	 * Character was a SpellBook.
	 * 
	 * Triggered when one of the Facets to which SpellBookFacet listens fires a
	 * DataFacetChangeEvent to indicate a piece of Equipment was added to a
	 * Player Character.
	 * 
	 * @param dfce
	 *            The DataFacetChangeEvent containing the information about the
	 *            change
	 */
	@Override
	public void dataAdded(DataFacetChangeEvent&lt;CharID, Equipment&gt; dfce)
	{
<span class="nc" id="L58">		Equipment eq = dfce.getCDOMObject();</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">		if (eq.isType(Constants.TYPE_SPELLBOOK))</span>
		{
<span class="nc" id="L61">			CharID id = dfce.getCharID();</span>
<span class="nc" id="L62">			String baseBookname = eq.getName();</span>
<span class="nc" id="L63">			String bookName = eq.getName();</span>
<span class="nc" id="L64">			int qty = (int) eq.qty();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">			for (int i = 0; i &lt; qty; i++)</span>
			{
<span class="nc bnc" id="L67" title="All 2 branches missed.">				if (i &gt; 0)</span>
				{
<span class="nc" id="L69">					bookName = baseBookname + &quot; #&quot; + (i + 1);</span>
				}
<span class="nc" id="L71">				SpellBook book = getBookNamed(id, bookName);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">				if (book == null)</span>
				{
<span class="nc" id="L74">					book = new SpellBook(bookName, SpellBook.TYPE_SPELL_BOOK);</span>
				}
<span class="nc" id="L76">				book.setEquip(eq);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">				if (!containsBookNamed(id, book.getName()))</span>
				{
<span class="nc" id="L79">					add(id, book);</span>
				}
			}
		}
<span class="nc" id="L83">	}</span>

	/**
	 * Triggered when one of the Facets to which SpellBookFacet listens fires a
	 * DataFacetChangeEvent to indicate a piece of Equipment was removed from a
	 * Player Character.
	 * 
	 * @param dfce
	 *            The DataFacetChangeEvent containing the information about the
	 *            change
	 */
	@Override
	public void dataRemoved(DataFacetChangeEvent&lt;CharID, Equipment&gt; dfce)
	{
		//Ignore - for now this is one in PlayerCharacter...
		/*
		 * TODO This method should eventually be symmetric with dataAdded
		 */
<span class="nc" id="L101">	}</span>

	/**
	 * Adds all of the SpellBooks in the given Collection to the list of
	 * SpellBooks stored in this SpellBookFacet for the Player Character
	 * represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given SpellBooks should be added
	 * @param list
	 *            The Collection of SpellBooks to be added to the list of
	 *            SpellBooks stored in this SpellBookFacet for the Player
	 *            Character represented by the given CharID
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void addAll(CharID id, Collection&lt;SpellBook&gt; list)
	{
<span class="nc bnc" id="L120" title="All 2 branches missed.">		for (SpellBook sb : list)</span>
		{
<span class="nc" id="L122">			add(id, sb);</span>
<span class="nc" id="L123">		}</span>
<span class="nc" id="L124">	}</span>

	/**
	 * Add the given SpellBook to the list of SpellBooks stored in this
	 * SpellBookFacet for the Player Character represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given item should be added
	 * @param sb
	 *            The SpellBook to be added to the list of SpellBooks stored in
	 *            this SpellBookFacet for the Player Character represented by
	 *            the given CharID
	 */
	public void add(CharID id, SpellBook sb)
	{
<span class="fc" id="L140">		Objects.requireNonNull(sb, &quot;Object to add may not be null&quot;);</span>
<span class="fc" id="L141">		Map&lt;String, SpellBook&gt; sbMap = getConstructingCachedMap(id);</span>
<span class="fc" id="L142">		String name = sb.getName();</span>
<span class="fc" id="L143">		sbMap.put(name, sb);</span>
<span class="fc" id="L144">	}</span>

	/**
	 * Removes all of the SpellBooks in the given Collection from the list of
	 * SpellBooks stored in this SpellBookFacet for the Player Character
	 * represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given SpellBooks should be removed
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id)
	{
<span class="nc" id="L159">		removeCache(id);</span>
<span class="nc" id="L160">	}</span>

	/**
	 * Returns the type-safe Map for this SpellBookFacet and the given CharID.
	 * May return null if no information has been set in this SpellBookFacet for
	 * the given CharID.
	 * 
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * SpellBookFacet, and since it can be modified, a reference to that object
	 * should not be exposed to any object other than SpellBookFacet.
	 * 
	 * @param id
	 *            The CharID for which the Set should be returned
	 * @return The Set for the Player Character represented by the given CharID;
	 *         null if no information has been set in this
	 *         AbstractSourcedListFacet for the Player Character.
	 */
	private Map&lt;String, SpellBook&gt; getCachedMap(CharID id)
	{
<span class="fc" id="L179">		return (Map&lt;String, SpellBook&gt;) getCache(id);</span>
	}

	/**
	 * Returns a type-safe Map for this SpellBookFacet and the given CharID.
	 * Will return a new, empty Map if no information has been set in this
	 * SpellBookFacet for the given CharID. Will not return null.
	 * 
	 * Note that this method SHOULD NOT be public. The Map object is owned by
	 * SpellBookFacet, and since it can be modified, a reference to that object
	 * should not be exposed to any object other than SpellBookFacet.
	 * 
	 * @param id
	 *            The CharID for which the Map should be returned
	 * @return The Map for the Player Character represented by the given CharID.
	 */
	private Map&lt;String, SpellBook&gt; getConstructingCachedMap(CharID id)
	{
<span class="fc" id="L197">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">		if (componentMap == null)</span>
		{
<span class="fc" id="L200">			componentMap = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L201">			setCache(id, componentMap);</span>
		}
<span class="fc" id="L203">		return componentMap;</span>
	}

	/**
	 * Returns the SpellBook for the given SpellBook name and the Player
	 * Character identified by the given CharID.
	 * 
	 * @param id
	 *            The CharID identifying the PlayerCharacter for which the
	 *            SpellBook for the given name should be returned
	 * @param name
	 *            The name of the SpellBook to be returned
	 * @return The SpellBook for the given SpellBook name and the Player
	 *         Character identified by the given CharID
	 */
	public SpellBook getBookNamed(CharID id, String name)
	{
<span class="nc" id="L220">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L223">			return null;</span>
		}
<span class="nc" id="L225">		return componentMap.get(name);</span>
	}

	/**
	 * Returns a non-null Collection of SpellBook names in this SpellBookFacet
	 * for the Player Character represented by the given CharID. This method
	 * returns an empty Set if no SpellBooks are in this SpellBookFacet for the
	 * Player Character identified by the given CharID.
	 * 
	 * This method is value-semantic in that ownership of the returned
	 * Collection is transferred to the class calling this method. Modification
	 * of the returned Collection will not modify this SpellBookFacet and
	 * modification of this SpellBookFacet will not modify the returned
	 * Collection. Modifications to the returned Collection will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * SpellBookFacet. If you wish to modify the information stored in this
	 * SpellBookFacet, you must use the add*() and remove*() methods of
	 * SpellBookFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which a copy
	 *            of the SpellBooks in this SpellBookFacet should be returned.
	 * @return A non-null Collection of SpellBooks in this SpellBookFacet for
	 *         the Player Character represented by the given CharID
	 */
	public Collection&lt;String&gt; getBookNames(CharID id)
	{
<span class="nc" id="L252">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L255">			return Collections.emptySet();</span>
		}
<span class="nc" id="L257">		return Collections.unmodifiableSet(componentMap.keySet());</span>
	}

	/**
	 * Returns a non-null copy of the Collection of SpellBooks in this
	 * SpellBookFacet for the Player Character represented by the given CharID.
	 * This method returns an empty Set if no SpellBooks are in this
	 * SpellBookFacet for the Player Character identified by the given CharID.
	 * 
	 * This method is value-semantic in that ownership of the returned
	 * Collection is transferred to the class calling this method. Modification
	 * of the returned Collection will not modify this SpellBookFacet and
	 * modification of this SpellBookFacet will not modify the returned
	 * Collection. Modifications to the returned Collection will also not modify
	 * any future or previous objects returned by this (or other) methods on
	 * SpellBookFacet. If you wish to modify the information stored in this
	 * SpellBookFacet, you must use the add*() and remove*() methods of
	 * SpellBookFacet.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which a copy
	 *            of the SpellBooks in this SpellBookFacet should be returned.
	 * @return A non-null Collection of SpellBooks in this SpellBookFacet for
	 *         the Player Character represented by the given CharID
	 */
	public Collection&lt;SpellBook&gt; getBooks(CharID id)
	{
<span class="nc" id="L284">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">		if (componentMap == null)</span>
		{
<span class="nc" id="L287">			return Collections.emptySet();</span>
		}
<span class="nc" id="L289">		return Collections.unmodifiableCollection(componentMap.values());</span>
	}

	/**
	 * Returns true if this SpellBookFacet contains a SpellBook of the given
	 * name in the list of SpellBooks for the Player Character represented by
	 * the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character used for testing
	 * @param name
	 *            The SpellBook name to test if this SpellBookFacet contains a
	 *            SpellBook by that name for the Player Character represented by
	 *            the given CharID
	 * @return true if this SpellBookFacet contains a SpellBook with the given
	 *         name for the Player Character represented by the given CharID;
	 *         false otherwise
	 */
	public boolean containsBookNamed(CharID id, String name)
	{
<span class="fc" id="L309">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">		return (componentMap != null) &amp;&amp; componentMap.containsKey(name);</span>
	}

	/**
	 * Returns the count of SpellBooks in this SpellBookFacet for the Player
	 * Character represented by the given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            count of SpellBooks should be returned
	 * @return The count of SpellBooks in this SpellBookFacet for the Player
	 *         Character represented by the given CharID
	 */
	public int getCount(CharID id)
	{
<span class="nc" id="L325">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">		return (componentMap == null) ? 0 : componentMap.size();</span>
	}

	/**
	 * Removes the SpellBook with the given name from the list of SpellBooks
	 * stored in this SpellBookFacet for the Player Character represented by the
	 * given CharID.
	 * 
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            SpellBook with the given name should be removed
	 * @param name
	 *            The name of the SpellBook to be removed from the list of
	 *            SpellBooks stored in this SpellBookFacet for the Player
	 *            Character represented by the given CharID
	 */
	public void removeBookNamed(CharID id, String name)
	{
<span class="nc" id="L344">		Map&lt;String, SpellBook&gt; componentMap = getCachedMap(id);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">		if (componentMap != null)</span>
		{
<span class="nc" id="L347">			componentMap.remove(name);</span>
		}
<span class="nc" id="L349">	}</span>

	public void setEquipmentFacet(EquipmentFacet equipmentFacet)
	{
<span class="fc" id="L353">		this.equipmentFacet = equipmentFacet;</span>
<span class="fc" id="L354">	}</span>

	/**
	 * Initializes the connections for SpellBookFacet to other facets.
	 * 
	 * This method is automatically called by the Spring framework during
	 * initialization of the SpellBookFacet.
	 */
	public void init()
	{
<span class="fc" id="L364">		equipmentFacet.addDataFacetChangeListener(this);</span>
<span class="fc" id="L365">	}</span>

	/**
	 * Copies the contents of the SpellBookFacet from one Player Character to
	 * another Player Character, based on the given CharIDs representing those
	 * Player Characters.
	 * 
	 * This is a method in SpellBookFacet in order to avoid exposing the mutable
	 * Map object to other classes. This should not be inlined, as the Map is
	 * internal information to SpellBookFacet and should not be exposed to other
	 * classes.
	 * 
	 * Note also the copy is a one-time event and no SpellBook references are
	 * maintained between the Player Characters represented by the given CharIDs
	 * (meaning once this copy takes place, any change to the SpellBook will
	 * only impact the Player Character where the SpellBook was changed).
	 * 
	 * @param source
	 *            The CharID representing the Player Character from which the
	 *            information should be copied
	 * @param copy
	 *            The CharID representing the Player Character to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(CharID source, CharID copy)
	{
<span class="nc" id="L392">		Map&lt;String, SpellBook&gt; map = getCachedMap(source);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">		if (map != null)</span>
		{
<span class="nc" id="L395">			addAll(copy, map.values());</span>
		}
<span class="nc" id="L397">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>