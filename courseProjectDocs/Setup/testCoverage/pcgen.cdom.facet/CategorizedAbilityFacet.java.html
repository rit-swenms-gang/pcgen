<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CategorizedAbilityFacet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.facet</a> &gt; <span class="el_source">CategorizedAbilityFacet.java</span></div><h1>CategorizedAbilityFacet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) Thomas Parker, 2009.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package pcgen.cdom.facet;

import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import pcgen.cdom.base.Category;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.enumeration.Nature;
import pcgen.cdom.facet.base.AbstractDataFacet;
import pcgen.cdom.facet.event.DataFacetChangeEvent;
import pcgen.core.Ability;

/**
 * A CategorizedAbilityFacet is a DataFacet that contains information about
 * Ability objects that are contained in a PlayerCharacter
 *
 */
<span class="nc" id="L41">public class CategorizedAbilityFacet extends AbstractDataFacet&lt;CharID, Ability&gt;</span>
{

	/**
	 * Add the given Ability to the list of Abilities defined by the given
	 * Category and Nature, which is stored in this CategorizedAbilityFacet for
	 * the Player Character represented by the given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given Ability should be added
	 * @param cat
	 *            The Ability Category identifying the list to which the given
	 *            Ability should be added
	 * @param nat
	 *            The Ability Nature identifying the list to which the given
	 *            Ability should be added
	 * @param obj
	 *            The Ability to be added to the list of Abilities defined by
	 *            the given Category and Nature, which is stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 */
	public void add(CharID id, Category&lt;Ability&gt; cat, Nature nat, Ability obj)
	{
<span class="nc" id="L66">		boolean isNew = ensureCachedSet(id, cat, nat);</span>
<span class="nc bnc" id="L67" title="All 4 branches missed.">		if (getCachedSet(id, cat, nat).add(obj) || isNew)</span>
		{
<span class="nc" id="L69">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_ADDED);</span>
		}
<span class="nc" id="L71">	}</span>

	/**
	 * Adds all of the Abilities in the given Collection to the list of
	 * Abilities defined by the given Category and Nature, which is stored in
	 * this CategorizedAbilityFacet for the Player Character represented by the
	 * given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            given Abilities should be added
	 * @param cat
	 *            The Ability Category identifying the list to which the given
	 *            Abilities should be added
	 * @param nature
	 *            The Ability Nature identifying the list to which the given
	 *            Abilities should be added
	 * @param abilities
	 *            The Collection of Abilities to be added to the list of
	 *            Abilities defined by the given Category and Nature, which is
	 *            stored in this CategorizedAbilityFacet for the Player
	 *            Character represented by the given CharID
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void addAll(CharID id, Category&lt;Ability&gt; cat, Nature nature, Collection&lt;Ability&gt; abilities)
	{
<span class="nc bnc" id="L98" title="All 2 branches missed.">		for (Ability a : abilities)</span>
		{
<span class="nc" id="L100">			add(id, cat, nature, a);</span>
<span class="nc" id="L101">		}</span>
<span class="nc" id="L102">	}</span>

	/**
	 * Removes the given Ability from the list of Abilities defined by the given
	 * Category and Nature, which is stored in this CategorizedAbilityFacet for
	 * the Player Character represented by the given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given Ability should be removed
	 * @param cat
	 *            The Ability Category identifying the list from which the given
	 *            Ability should be removed
	 * @param nat
	 *            The Ability Nature identifying the list from which the given
	 *            Ability should be removed
	 * @param obj
	 *            The Ability to be removed from the list of Abilities defined
	 *            by the given Category and Nature, which is stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 */
	public void remove(CharID id, Category&lt;Ability&gt; cat, Nature nat, Ability obj)
	{
<span class="nc" id="L126">		Set&lt;Ability&gt; cached = getCachedSet(id, cat, nat);</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">		if (cached != null &amp;&amp; cached.remove(obj))</span>
		{
<span class="nc" id="L129">			fireDataFacetChangeEvent(id, obj, DataFacetChangeEvent.DATA_REMOVED);</span>
		}
<span class="nc" id="L131">	}</span>

	/**
	 * Returns a non-null copy of the Set of objects in thisSet of Abilities in
	 * this CategorizedAbilityFacet for the Player Character represented by the
	 * given CharID. This method returns an empty set if no objects are in this
	 * CategorizedAbilityFacet for the Player Character identified by the given
	 * CharID.
	 *
	 * This method is value-semantic in that ownership of the returned Set is
	 * transferred to the class calling this method. Modification of the
	 * returned Set will not modify this CategorizedAbilityFacet and
	 * modification of this CategorizedAbilityFacet will not modify the returned
	 * Set. Modifications to the returned Set will also not modify any future or
	 * previous objects returned by this (or other) methods on
	 * CategorizedAbilityFacet. If you wish to modify the information stored in
	 * this CategorizedAbilityFacet, you must use the add*() and remove*()
	 * methods of CategorizedAbilityFacet.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this CategorizedAbilityFacet should be returned.
	 * @param cat
	 *            The Ability Category identifying the list of Abilities to be
	 *            returned
	 * @param nat
	 *            The Ability Nature identifying the list of Abilities to be
	 *            returned
	 * @return A non-null Set of Abilities in this CategorizedAbilityFacet for
	 *         the Player Character represented by the given CharID
	 */
	public Set&lt;Ability&gt; get(CharID id, Category&lt;Ability&gt; cat, Nature nat)
	{
<span class="nc" id="L164">		Set&lt;Ability&gt; set = getCachedSet(id, cat, nat);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">		if (set == null)</span>
		{
<span class="nc" id="L167">			return Collections.emptySet();</span>
		}
<span class="nc" id="L169">		return Collections.unmodifiableSet(set);</span>
	}

	/**
	 * Returns true if this CategorizedAbilityFacet contains the given Ability
	 * in the list of items for the Player Character represented by the given
	 * CharID.
	 *
	 * @param id
	 *            The CharID representing the Player Character used for testing
	 * @param cat
	 *            The Ability Category identifying the list of Abilities to be
	 *            tested to see if it contains the given Ability
	 * @param nat
	 *            The Ability Nature identifying the list of Abilities to be
	 *            tested to see if it contains the given Ability
	 * @param a
	 *            The Ability to test if this CategorizedAbilityFacet contains
	 *            that item for the Player Character represented by the given
	 *            CharID
	 * @return true if this CategorizedAbilityFacet contains the given Ability
	 *         for the Player Character represented by the given CharID; false
	 *         otherwise
	 */
	public boolean contains(CharID id, Category&lt;Ability&gt; cat, Nature nat, Ability a)
	{
<span class="nc" id="L195">		Set&lt;Ability&gt; set = getCachedSet(id, cat, nat);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		if (set == null)</span>
		{
<span class="nc" id="L198">			return false;</span>
		}
<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (set.contains(a))</span>
		{
<span class="nc" id="L202">			return true;</span>
		}
		/*
		 * TODO Have to support slow method due to cloning issues :(
		 */
<span class="nc bnc" id="L207" title="All 2 branches missed.">		for (Ability ab : set)</span>
		{
<span class="nc bnc" id="L209" title="All 2 branches missed.">			if (ab.equals(a))</span>
			{
<span class="nc" id="L211">				return true;</span>
			}
<span class="nc" id="L213">		}</span>
<span class="nc" id="L214">		return false;</span>
	}

	private boolean ensureCachedSet(CharID id, Category&lt;Ability&gt; cat, Nature nat)
	{
<span class="nc" id="L219">		boolean isNew = false;</span>
<span class="nc" id="L220">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap = getCachedMap(id);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if (catMap == null)</span>
		{
<span class="nc" id="L223">			isNew = true;</span>
<span class="nc" id="L224">			catMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L225">			setCache(id, catMap);</span>
		}
<span class="nc" id="L227">		Map&lt;Nature, Set&lt;Ability&gt;&gt; natureMap = catMap.get(cat);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (natureMap == null)</span>
		{
<span class="nc" id="L230">			isNew = true;</span>
<span class="nc" id="L231">			natureMap = new EnumMap&lt;&gt;(Nature.class);</span>
<span class="nc" id="L232">			catMap.put(cat, natureMap);</span>
		}
<span class="nc" id="L234">		Set&lt;Ability&gt; abilitySet = natureMap.get(nat);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">		if (abilitySet == null)</span>
		{
<span class="nc" id="L237">			isNew = true;</span>
			// abilitySet = new HashSet&lt;Ability&gt;();
<span class="nc" id="L239">			abilitySet = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
<span class="nc" id="L240">			natureMap.put(nat, abilitySet);</span>
		}
<span class="nc" id="L242">		return isNew;</span>
	}

	/**
	 * Returns the type-safe Set for this CategorizedAbilityFacet and the given
	 * CharID. May return null if no information has been set in this
	 * CategorizedAbilityFacet for the given CharID.
	 *
	 * Note that this method SHOULD NOT be public. The Set is owned by
	 * CategorizedAbilityFacet, and since it can be modified, a reference to
	 * that Set should not be exposed to any object other than
	 * CategorizedAbilityFacet.
	 *
	 * @param id
	 *            The CharID for which the Set should be returned
	 * @param cat
	 *            The Ability Category identifying the list of Abilities to be
	 *            returned
	 * @param nat
	 *            The Ability Nature identifying the list of Abilities to be
	 *            returned
	 * @return The Set for the Player Character represented by the given CharID;
	 *         null if no information has been set in this
	 *         CategorizedAbilityFacet for the Player Character.
	 */
	private Set&lt;Ability&gt; getCachedSet(CharID id, Category&lt;Ability&gt; cat, Nature nat)
	{
<span class="nc" id="L269">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap = getCachedMap(id);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		if (catMap == null)</span>
		{
<span class="nc" id="L272">			return null;</span>
		}
<span class="nc" id="L274">		Map&lt;Nature, Set&lt;Ability&gt;&gt; natureMap = catMap.get(cat);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">		if (natureMap == null)</span>
		{
<span class="nc" id="L277">			return null;</span>
		}
<span class="nc" id="L279">		return natureMap.get(nat);</span>
	}

	/**
	 * Returns the type-safe Map for this CategorizedAbilityFacet and the given
	 * CharID. May return null if no information has been set in this
	 * CategorizedAbilityFacet for the given CharID.
	 *
	 * Note that this method SHOULD NOT be public. The Map is owned by
	 * CategorizedAbilityFacet, and since it can be modified, a reference to
	 * that Map should not be exposed to any object other than
	 * CategorizedAbilityFacet.
	 *
	 * @param id
	 *            The CharID for which the Map should be returned
	 * @return The Map for the Player Character represented by the given CharID;
	 *         null if no information has been set in this
	 *         CategorizedAbilityFacet for the Player Character.
	 */
	private Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; getCachedMap(CharID id)
	{
<span class="nc" id="L300">		return (Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt;) getCache(id);</span>
	}

	/**
	 * Removes all Abilities from the list of Abilities stored in this
	 * CategorizedAbilityFacet for the Player Character represented by the given
	 * CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character from which all
	 *            Abilities should be removed
	 */
	public void removeAll(CharID id)
	{
<span class="nc" id="L314">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap =</span>
<span class="nc" id="L315">				(Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt;) removeCache(id);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if (catMap != null)</span>
		{
<span class="nc bnc" id="L318" title="All 2 branches missed.">			for (Map.Entry&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catME : catMap.entrySet())</span>
			{
				// Category&lt;Ability&gt; cat = catME.getKey();
<span class="nc" id="L321">				Map&lt;Nature, Set&lt;Ability&gt;&gt; natMap = catME.getValue();</span>
<span class="nc" id="L322">				processRemoveNatureMap(id, natMap);</span>
<span class="nc" id="L323">			}</span>
		}
<span class="nc" id="L325">	}</span>

	/**
	 * Removes all of the Ability objects in the given Category from the lists
	 * of Abilities stored in this CategorizedAbilityFacet for the Player
	 * Character represented by the given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given Abilities should be removed
	 * @param cat
	 *            The Ability Category identifying which Ability objects are to
	 *            be removed from the lists of Abilities stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id, Category&lt;Ability&gt; cat)
	{
<span class="nc" id="L345">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap = getCachedMap(id);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">		if (catMap != null)</span>
		{
<span class="nc" id="L348">			Map&lt;Nature, Set&lt;Ability&gt;&gt; natMap = catMap.remove(cat);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">			if (natMap != null)</span>
			{
<span class="nc" id="L351">				processRemoveNatureMap(id, natMap);</span>
			}
		}
<span class="nc" id="L354">	}</span>

	/**
	 * Removes all of the objects of the given Category and Nature from the list
	 * of Abilities stored in this CategorizedAbilityFacet for the Player
	 * Character represented by the given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given Abilities should be removed
	 * @param cat
	 *            The Ability Category identifying which Ability objects are to
	 *            be removed from the lists of Abilities stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 * @param nature
	 *            The Ability Nature identifying which Ability objects are to be
	 *            removed from the lists of Abilities stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id, Category&lt;Ability&gt; cat, Nature nature)
	{
<span class="nc" id="L379">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap = getCachedMap(id);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		if (catMap != null)</span>
		{
<span class="nc" id="L382">			Map&lt;Nature, Set&lt;Ability&gt;&gt; natMap = catMap.remove(cat);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">			if (natMap != null)</span>
			{
<span class="nc" id="L385">				Set&lt;Ability&gt; abilitySet = natMap.get(nature);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">				if (abilitySet != null)</span>
				{
<span class="nc" id="L388">					processRemoveAbilityMap(id, abilitySet);</span>
				}
			}
		}
<span class="nc" id="L392">	}</span>

	private void processRemoveNatureMap(CharID id, Map&lt;Nature, Set&lt;Ability&gt;&gt; natMap)
	{
<span class="nc bnc" id="L396" title="All 2 branches missed.">		for (Map.Entry&lt;Nature, Set&lt;Ability&gt;&gt; natME : natMap.entrySet())</span>
		{
			// Nature nature = natME.getKey();
<span class="nc" id="L399">			processRemoveAbilityMap(id, natME.getValue());</span>
<span class="nc" id="L400">		}</span>
<span class="nc" id="L401">	}</span>

	/**
	 * Removes all of the Ability objects in the given Nature from the lists of
	 * Abilities stored in this CategorizedAbilityFacet for the Player Character
	 * represented by the given CharID
	 *
	 * @param id
	 *            The CharID representing the Player Character from which the
	 *            given Abilities should be removed
	 * @param nature
	 *            The Ability Nature identifying which Ability objects are to be
	 *            removed from the lists of Abilities stored in this
	 *            CategorizedAbilityFacet for the Player Character represented
	 *            by the given CharID
	 * @throws NullPointerException
	 *             if the given Collection is null
	 */
	public void removeAll(CharID id, Nature nature)
	{
<span class="nc" id="L421">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catMap = getCachedMap(id);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">		if (catMap != null)</span>
		{
<span class="nc bnc" id="L424" title="All 2 branches missed.">			for (Map.Entry&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; catME : catMap.entrySet())</span>
			{
				// Category&lt;Ability&gt; cat = catME.getKey();
<span class="nc" id="L427">				Set&lt;Ability&gt; abilitySet = catME.getValue().remove(nature);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				if (abilitySet != null)</span>
				{
<span class="nc" id="L430">					processRemoveAbilityMap(id, abilitySet);</span>
				}
<span class="nc" id="L432">			}</span>
		}
<span class="nc" id="L434">	}</span>

	private void processRemoveAbilityMap(CharID id, Set&lt;Ability&gt; abilitySet)
	{
<span class="nc bnc" id="L438" title="All 2 branches missed.">		for (Ability a : abilitySet)</span>
		{
<span class="nc" id="L440">			fireDataFacetChangeEvent(id, a, DataFacetChangeEvent.DATA_REMOVED);</span>
<span class="nc" id="L441">		}</span>
<span class="nc" id="L442">	}</span>

	/**
	 * Returns a non-null copy of the Set of Ability Category objects in this
	 * CategorizedAbilityFacet for the Player Character represented by the given
	 * CharID. This method returns an empty set if no objects are in this
	 * CategorizedAbilityFacet for the Player Character identified by the given
	 * CharID.
	 *
	 * This method is value-semantic in that ownership of the returned Set is
	 * transferred to the class calling this method. Modification of the
	 * returned Set will not modify this CategorizedAbilityFacet and
	 * modification of this CategorizedAbilityFacet will not modify the returned
	 * Set. Modifications to the returned Set will also not modify any future or
	 * previous objects returned by this (or other) methods on
	 * CategorizedAbilityFacet. If you wish to modify the information stored in
	 * this CategorizedAbilityFacet, you must use the add*() and remove*()
	 * methods of CategorizedAbilityFacet.
	 *
	 * @param id
	 *            The CharID representing the Player Character for which the
	 *            items in this CategorizedAbilityFacet should be returned.
	 * @return A non-null Set of Ability Category objects in this
	 *         CategorizedAbilityFacet for the Player Character represented by
	 *         the given CharID
	 */
	public Set&lt;Category&lt;Ability&gt;&gt; getCategories(CharID id)
	{
<span class="nc" id="L470">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; map = getCachedMap(id);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (map == null)</span>
		{
<span class="nc" id="L473">			return Collections.emptySet();</span>
		}
<span class="nc" id="L475">		return Collections.unmodifiableSet(map.keySet());</span>
	}

	/**
	 * Copies the contents of the CategorizedAbilityFacet from one Player
	 * Character to another Player Character, based on the given CharIDs
	 * representing those Player Characters.
	 *
	 * This is a method in CategorizedAbilityFacet in order to avoid exposing
	 * the mutable Map object to other classes. This should not be inlined, as
	 * the Map is internal information to CategorizedAbilityFacet and should not
	 * be exposed to other classes.
	 *
	 * Note also the copy is a one-time event and no references are maintained
	 * between the Player Characters represented by the given CharIDs (meaning
	 * once this copy takes place, any change to the CategorizedAbilityFacet of
	 * one Player Character will only impact the Player Character where the
	 * CategorizedAbilityFacet was changed).
	 *
	 * @param source
	 *            The CharID representing the Player Character from which the
	 *            information should be copied
	 * @param copy
	 *            The CharID representing the Player Character to which the
	 *            information should be copied
	 */
	@Override
	public void copyContents(CharID source, CharID copy)
	{
<span class="nc" id="L504">		Map&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; map = getCachedMap(source);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">		if (map != null)</span>
		{
<span class="nc bnc" id="L507" title="All 2 branches missed.">			for (Entry&lt;Category&lt;Ability&gt;, Map&lt;Nature, Set&lt;Ability&gt;&gt;&gt; me : map.entrySet())</span>
			{
<span class="nc" id="L509">				Category&lt;Ability&gt; cat = me.getKey();</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">				for (Entry&lt;Nature, Set&lt;Ability&gt;&gt; nme : me.getValue().entrySet())</span>
				{
<span class="nc" id="L512">					Nature nat = nme.getKey();</span>
<span class="nc" id="L513">					ensureCachedSet(copy, cat, nat);</span>
<span class="nc" id="L514">					getCachedSet(copy, cat, nat).addAll(nme.getValue());</span>
<span class="nc" id="L515">				}</span>
<span class="nc" id="L516">			}</span>
		}
<span class="nc" id="L518">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>