<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PCGenExportHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.io</a> &gt; <span class="el_source">PCGenExportHandler.java</span></div><h1>PCGenExportHandler.java</h1><pre class="source lang-java linenums">package pcgen.io;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import pcgen.cdom.base.Constants;
import pcgen.core.PlayerCharacter;
import pcgen.util.Logging;

public class PCGenExportHandler extends ExportHandler
{
	/**
	 * Constructor.  Populates the token map (a list of possible output tokens) and
	 * sets the character sheet template we are using.
	 *
	 * @param templateFile the template to use while exporting.
	 */
	PCGenExportHandler(File templateFile)
	{
<span class="nc" id="L27">		super(templateFile);</span>
<span class="nc" id="L28">	}</span>

	@Override
	public void write(PlayerCharacter aPC, BufferedWriter out)
	{
		// Set an output filter based on the type of template in use.
<span class="nc" id="L34">		FileAccess.setCurrentOutputFilter(getTemplateFile().getName());</span>

<span class="nc" id="L36">		try (FileInputStream fis = new FileInputStream(getTemplateFile());</span>
<span class="nc" id="L37">			 InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);</span>
<span class="nc" id="L38">			 BufferedReader br = new BufferedReader(isr))</span>
		{
			// A Buffer to hold the result of the preparation
<span class="nc" id="L41">			CharSequence template = prepareTemplate(br);</span>

			// Create a tokenizer based on EOL characters
			// 03-Nov-2008 Karianna, changed to use line separator instead of /r/n
<span class="nc" id="L45">			final StringTokenizer tokenizer = new StringTokenizer(template.toString(), Constants.LINE_SEPARATOR, false);</span>

			// Get FOR loops and IIF statements
<span class="nc" id="L48">			final FORNode root = parseFORsAndIIFs(tokenizer);</span>

			// TODO Not sure what these lines are for
<span class="nc" id="L51">			loopVariables.put(null, &quot;0&quot;);</span>
<span class="nc" id="L52">			existsOnly = false;</span>

			// Ensure that there 'are more items to process'
<span class="nc" id="L55">			noMoreItems = false;</span>

			// Now actually process the FOR loops in the template
			// and then clear the loop variables
<span class="nc" id="L59">			loopFOR(root, 0, 0, 1, out, aPC);</span>
<span class="nc" id="L60">			loopVariables.clear();</span>
<span class="nc" id="L61">		} catch (IOException exc)</span>
		{
<span class="nc" id="L63">			Logging.errorPrint(&quot;Error in ExportHandler::write&quot;, exc);</span>
<span class="nc" id="L64">		}</span>
<span class="nc" id="L65">	}</span>


	/**
	 * A helper method to prepare the template for exporting
	 *
	 * Read lines from the character sheet template and store them in a buffer
	 * with empty lines replaced by a space character and || replaced by | |
	 *
	 * @param br The BufferedReader containing the template
	 * @throws IOException
	 */
	private static StringBuilder prepareTemplate(BufferedReader br) throws IOException
	{
		// A pattern to replace || with | | to stop StringTokenizer from merging them
<span class="nc" id="L80">		Pattern pat = Pattern.compile(Pattern.quote(&quot;||&quot;));</span>
<span class="nc" id="L81">		String rep = Matcher.quoteReplacement(&quot;| |&quot;);</span>

		// Hold the results of the preparation
<span class="nc" id="L84">		StringBuilder inputLine = new StringBuilder();</span>

<span class="nc" id="L86">		String aString = br.readLine();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">		while (aString != null)</span>
		{
			// Karianna 29/11/2008 - No Longer replace blank lines with spaces,
			// doesn't seem to be needed

			// If the line is blank then append a space character
			//if (aString.length() == 0)
			//{
			//inputLine.append(' ');
			//}
			//else
			//{
			// Adjacent separators get merged by StringTokenizer,
			// so we break them up here, e.g. Change || to | |
<span class="nc" id="L101">			Matcher mat = pat.matcher(aString);</span>
<span class="nc" id="L102">			inputLine.append(mat.replaceAll(rep));</span>
			//}

<span class="nc" id="L105">			inputLine.append(Constants.LINE_SEPARATOR);</span>
<span class="nc" id="L106">			aString = br.readLine();</span>
<span class="nc" id="L107">		}</span>
<span class="nc" id="L108">		return inputLine;</span>
	}


	/**
	 * Parse the tokens for |FOR and |IIF sections and plain text sections
	 *
	 * @param tokens
	 * @return a FORNode object
	 */
	private FORNode parseFORsAndIIFs(StringTokenizer tokens)
	{
		// A FORNode that will hold a 'tree' of all of the FOR and IIF sections found
<span class="nc" id="L121">		final FORNode root = new FORNode(null, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;, false);</span>

<span class="nc bnc" id="L123" title="All 2 branches missed.">		while (tokens.hasMoreTokens())</span>
		{
<span class="nc" id="L125">			final String line = tokens.nextToken();</span>

			// If we detect a |FOR then add it as a child, if it has its own children
			// then add those as well
<span class="nc bnc" id="L129" title="All 2 branches missed.">			if (line.startsWith(&quot;|FOR&quot;))</span>
			{
<span class="nc" id="L131">				StringTokenizer newFor = new StringTokenizer(line, &quot;,&quot;);</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">				if (newFor.countTokens() &gt; 1)</span>
				{
<span class="nc" id="L135">					newFor.nextToken();</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">					if (newFor.nextToken().startsWith(&quot;%&quot;))</span>
					{
<span class="nc" id="L139">						root.addChild(parseFORs(line, tokens));</span>
					}
					else
					{
<span class="nc" id="L143">						root.addChild(line);</span>
					}
				}
				else
				{
<span class="nc" id="L148">					root.addChild(line);</span>
				}
<span class="nc" id="L150">			}</span>
			// If |IIF( is found and there is no ',' character on that line
			// then add it as a child
<span class="nc bnc" id="L153" title="All 4 branches missed.">			else if (line.startsWith(&quot;|IIF(&quot;) &amp;&amp; (line.lastIndexOf(',') == -1))</span>
			{
<span class="nc" id="L155">				String expr = line.substring(5, line.lastIndexOf(')'));</span>
<span class="nc" id="L156">				root.addChild(parseIIFs(expr, tokens));</span>
<span class="nc" id="L157">			}</span>
			// Else it's plain text so then just add it
			else
			{
<span class="nc" id="L161">				root.addChild(line);</span>
			}
<span class="nc" id="L163">		}</span>

<span class="nc" id="L165">		return root;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>