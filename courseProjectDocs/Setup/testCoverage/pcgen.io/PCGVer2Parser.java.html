<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PCGVer2Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.io</a> &gt; <span class="el_source">PCGVer2Parser.java</span></div><h1>PCGVer2Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002 (C) Thomas Behr &lt;ravenlock@gmx.de&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *
 *
 */
package pcgen.io;

import java.awt.Rectangle;
import java.io.File;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import pcgen.base.util.HashMapToList;
import pcgen.cdom.base.AssociatedPrereqObject;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.PersistentTransitionChoice;
import pcgen.cdom.base.SelectableSet;
import pcgen.cdom.base.UserSelection;
import pcgen.cdom.content.CNAbility;
import pcgen.cdom.content.CNAbilityFactory;
import pcgen.cdom.enumeration.AssociationKey;
import pcgen.cdom.enumeration.AssociationListKey;
import pcgen.cdom.enumeration.Gender;
import pcgen.cdom.enumeration.Handed;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.Nature;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.PCStringKey;
import pcgen.cdom.enumeration.Region;
import pcgen.cdom.enumeration.SkillFilter;
import pcgen.cdom.enumeration.SkillsOutputOrder;
import pcgen.cdom.enumeration.SourceFormat;
import pcgen.cdom.enumeration.StringKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.facet.FacetLibrary;
import pcgen.cdom.facet.input.DomainInputFacet;
import pcgen.cdom.facet.input.RaceInputFacet;
import pcgen.cdom.facet.input.TemplateInputFacet;
import pcgen.cdom.helper.CNAbilitySelection;
import pcgen.cdom.helper.ClassSource;
import pcgen.cdom.inst.EquipmentHead;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.cdom.list.ClassSpellList;
import pcgen.cdom.list.CompanionList;
import pcgen.cdom.list.DomainSpellList;
import pcgen.cdom.util.CControl;
import pcgen.core.Ability;
import pcgen.core.AbilityCategory;
import pcgen.core.BonusManager;
import pcgen.core.BonusManager.TempBonusInfo;
import pcgen.core.Campaign;
import pcgen.core.ChronicleEntry;
import pcgen.core.Deity;
import pcgen.core.Domain;
import pcgen.core.Equipment;
import pcgen.core.GameMode;
import pcgen.core.Globals;
import pcgen.core.Kit;
import pcgen.core.Language;
import pcgen.core.NoteItem;
import pcgen.core.PCAlignment;
import pcgen.core.PCClass;
import pcgen.core.PCStat;
import pcgen.core.PCTemplate;
import pcgen.core.PObject;
import pcgen.core.PlayerCharacter;
import pcgen.core.Race;
import pcgen.core.SettingsHandler;
import pcgen.core.Skill;
import pcgen.core.SpecialAbility;
import pcgen.core.SpellProhibitor;
import pcgen.core.SubClass;
import pcgen.core.SubstitutionClass;
import pcgen.core.SystemCollections;
import pcgen.core.WeaponProf;
import pcgen.core.analysis.BonusAddition;
import pcgen.core.analysis.ChooseActivation;
import pcgen.core.analysis.DomainApplication;
import pcgen.core.analysis.RaceAlignment;
import pcgen.core.analysis.SkillRankControl;
import pcgen.core.analysis.SpellLevel;
import pcgen.core.analysis.SubClassApplication;
import pcgen.core.analysis.SubstitutionLevelSupport;
import pcgen.core.bonus.Bonus;
import pcgen.core.bonus.BonusObj;
import pcgen.core.character.CharacterSpell;
import pcgen.core.character.EquipSet;
import pcgen.core.character.Follower;
import pcgen.core.character.SpellBook;
import pcgen.core.character.SpellInfo;
import pcgen.core.chooser.ChoiceManagerList;
import pcgen.core.chooser.ChooserUtilities;
import pcgen.core.display.BonusDisplay;
import pcgen.core.pclevelinfo.PCLevelInfo;
import pcgen.core.spell.Spell;
import pcgen.core.utils.CoreUtility;
import pcgen.core.utils.MessageType;
import pcgen.core.utils.ShowMessageDelegate;
import pcgen.facade.core.SourceSelectionFacade;
import pcgen.io.migration.AbilityMigration;
import pcgen.io.migration.AbilityMigration.CategorisedKey;
import pcgen.io.migration.EquipSetMigration;
import pcgen.io.migration.EquipmentMigration;
import pcgen.io.migration.RaceMigration;
import pcgen.io.migration.SourceMigration;
import pcgen.io.migration.SpellMigration;
import pcgen.output.channel.ChannelUtilities;
import pcgen.output.channel.compat.AlignmentCompat;
import pcgen.output.channel.compat.HairColorCompat;
import pcgen.output.channel.compat.HandedCompat;
import pcgen.output.channel.compat.HeightCompat;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.rules.context.LoadContext;
import pcgen.system.FacadeFactory;
import pcgen.system.LanguageBundle;
import pcgen.system.PCGenSettings;
import pcgen.util.Logging;
import pcgen.util.enumeration.ProhibitedSpellType;

import org.apache.commons.lang3.StringUtils;

/**
 * {@code PCGVer2Parser}
 * Parses a line oriented format.
 * Each line should adhere to the following grammar:&lt;br&gt;
 *
 * &lt;i&gt;line&lt;/i&gt; := EMPTY | &lt;i&gt;comment&lt;/i&gt; | &lt;i&gt;taglist&lt;/i&gt;
 * &lt;i&gt;comment&lt;/i&gt; := '#' STRING
 * &lt;i&gt;taglist&lt;/i&gt; := tag ('|' tag)*
 * &lt;i&gt;tag&lt;/i&gt; := simpletag | nestedtag
 * &lt;i&gt;nestedtag&lt;/i&gt; := TAGNAME ':' '[' taglist ']'
 * &lt;i&gt;simpletag&lt;/i&gt; := TAGNAME ':' TAGVALUE
 *
 *
 */
final class PCGVer2Parser implements PCGParser
{
<span class="fc" id="L165">	private static final Class&lt;Domain&gt; DOMAIN_CLASS = Domain.class;</span>

	private static final String TAG_PCTEMPLATE = &quot;PCTEMPLATE&quot;;

<span class="fc" id="L169">	private RaceInputFacet raceInputFacet = FacetLibrary.getFacet(RaceInputFacet.class);</span>
<span class="fc" id="L170">	private DomainInputFacet domainInputFacet = FacetLibrary.getFacet(DomainInputFacet.class);</span>
<span class="fc" id="L171">	private TemplateInputFacet templateInputFacet = FacetLibrary.getFacet(TemplateInputFacet.class);</span>

	/**
	 * DO NOT CHANGE line separator.
	 * Need to keep the Unix line separator to ensure cross-platform portability.
	 *
	 * author: Thomas Behr 2002-11-13
	 */
<span class="fc" id="L179">	private final List&lt;String&gt; warnings = new ArrayList&lt;&gt;();</span>
	private Cache cache;
	private PlayerCharacter thePC;
<span class="fc" id="L182">	private final Set&lt;String&gt; seenStats = new HashSet&lt;&gt;();</span>
<span class="fc" id="L183">	private final Set&lt;Language&gt; cachedLanguages = new HashSet&lt;&gt;();</span>

	//
	// MAJOR.MINOR.REVISION
	//
<span class="fc" id="L188">	private int[] pcgenVersion = {0, 0, 0};</span>
	private String pcgenVersionSuffix;
<span class="fc" id="L190">	private boolean calcFeatPoolAfterLoad = false;</span>
<span class="fc" id="L191">	private double baseFeatPool = 0.0;</span>
<span class="fc" id="L192">	private boolean featsPresent = false;</span>

	/**
	 * Constructor
	 * @param aPC
	 */
	PCGVer2Parser(PlayerCharacter aPC)
<span class="fc" id="L199">	{</span>
<span class="fc" id="L200">		thePC = aPC;</span>
<span class="fc" id="L201">	}</span>

	/**
	 * Selector
	 *
	 * &lt;br&gt;author: Thomas Behr 22-03-02
	 *
	 * @return a list of warning messages
	 */
	@Override
	public List&lt;String&gt; getWarnings()
	{
<span class="nc" id="L213">		return warnings;</span>
	}

	/**
	 * parse a String in PCG format
	 *
	 * &lt;br&gt;author: Thomas Behr 20-07-02
	 *
	 * @param lines   the String to parse
	 * @throws PCGParseException
	 */
	@Override
	public void parsePCG(String[] lines) throws PCGParseException
	{
<span class="nc" id="L227">		buildPcgLineCache(lines);</span>

<span class="nc" id="L229">		parseCachedLines();</span>
<span class="nc" id="L230">		resolveLanguages();</span>
<span class="nc" id="L231">	}</span>

	/**
	 * Check the game mode and then build a list of campaigns the character 
	 * requires to be loaded.
	 *   
	 * @param lines The PCG lines to be parsed.
	 * @return The list of campaigns.
	 * @throws PCGParseException If the lines are invalid 
	 */
	@Override
	public SourceSelectionFacade parcePCGSourceOnly(String[] lines) throws PCGParseException
	{
<span class="nc" id="L244">		buildPcgLineCache(lines);</span>

		/*
		 * VERSION:x.x.x
		 */
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_VERSION))</span>
		{
<span class="nc" id="L251">			parseVersionLine(cache.get(IOConstants.TAG_VERSION).get(0));</span>
		}

<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (!cache.containsKey(IOConstants.TAG_GAMEMODE))</span>
		{
<span class="nc" id="L256">			Logging.errorPrint(&quot;Character does not have game mode information.&quot;);</span>
<span class="nc" id="L257">			return null;</span>
		}
<span class="nc" id="L259">		String line = cache.get(IOConstants.TAG_GAMEMODE).get(0);</span>
<span class="nc" id="L260">		String requestedMode = line.substring(IOConstants.TAG_GAMEMODE.length() + 1);</span>
<span class="nc" id="L261">		GameMode mode = SystemCollections.getGameModeNamed(requestedMode);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">		if (mode == null)</span>
		{
<span class="nc bnc" id="L264" title="All 2 branches missed.">			for (GameMode gameMode : SystemCollections.getUnmodifiableGameModeList())</span>
			{
<span class="nc bnc" id="L266" title="All 2 branches missed.">				if (gameMode.getAllowedModes().contains(requestedMode))</span>
				{
<span class="nc" id="L268">					mode = gameMode;</span>
<span class="nc" id="L269">					break;</span>
				}
<span class="nc" id="L271">			}</span>
		}
		//if mode == null still then a game mode was not found
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if (mode == null)</span>
		{
<span class="nc" id="L276">			Logging.errorPrint(&quot;Character's game mode entry was not valid: &quot; + line);</span>
<span class="nc" id="L277">			return null;</span>
		}
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if (!cache.containsKey(IOConstants.TAG_CAMPAIGN))</span>
		{
<span class="nc" id="L281">			Logging.errorPrint(&quot;Character does not have campaign information.&quot;);</span>
<span class="nc" id="L282">			return FacadeFactory.createSourceSelection(mode, new ArrayList&lt;&gt;());</span>
		}
		/*
		 * #System Information
		 * CAMPAIGN:CMP - Monkey Book I - Book For Monkeys
		 * CAMPAIGN:CMP - Monkey Book II - Book By Monkeys
		 * ...
		 *
		 * first thing to do is checking campaigns - no matter what!
		 */
<span class="nc" id="L292">		List&lt;Campaign&gt; campaigns = getCampaignList(cache.get(IOConstants.TAG_CAMPAIGN), mode.getName());</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		if (campaigns.isEmpty())</span>
		{
<span class="nc" id="L295">			Logging.errorPrint(&quot;Character's campaign entry was empty.&quot;);</span>
		}
<span class="nc" id="L297">		return FacadeFactory.createSourceSelection(mode, campaigns);</span>
	}

	/**
	 * @param lines
	 */
	private void buildPcgLineCache(String[] lines)
	{
<span class="nc" id="L305">		initCache(lines.length);</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">		for (String line : lines)</span>
		{
<span class="nc bnc" id="L309" title="All 4 branches missed.">			if ((!line.trim().isEmpty()) &amp;&amp; !isComment(line))</span>
			{
<span class="nc" id="L311">				cacheLine(line.trim());</span>
			}
		}
<span class="nc" id="L314">	}</span>

	/*
	 * ###############################################################
	 * Miscellaneous methods
	 * ###############################################################
	 */

	/**
	 * Convenience Method
	 *
	 * &lt;br&gt;author: Thomas Behr 28-04-02
	 *
	 * @param line
	 * @return true if it is a comment
	 */
	private static boolean isComment(String line)
	{
<span class="nc" id="L332">		return line.trim().startsWith(IOConstants.TAG_COMMENT);</span>
	}

	/*
	 * Given a Source string and Target string,
	 * return a List of BonusObj's
	 */
	private Map&lt;BonusObj, TempBonusInfo&gt; getBonusFromName(String sName, String tName)
	{
		//sName = NAME=Haste
		//tName = PC
<span class="nc" id="L343">		String sourceStr = sName.substring(IOConstants.TAG_TEMPBONUS.length() + 1);</span>
<span class="nc" id="L344">		String targetStr = tName.substring(IOConstants.TAG_TEMPBONUSTARGET.length() + 1);</span>
<span class="nc" id="L345">		CDOMObject oSource = null;</span>

<span class="nc bnc" id="L347" title="All 2 branches missed.">		if (sourceStr.startsWith(IOConstants.TAG_FEAT + '='))</span>
		{
<span class="nc" id="L349">			sourceStr = sourceStr.substring(5);</span>
<span class="nc" id="L350">			oSource = Globals.getContext().getReferenceContext().getManufacturerId(AbilityCategory.FEAT)</span>
<span class="nc" id="L351">				.getActiveObject(sourceStr);</span>
<span class="nc" id="L352">			oSource = thePC.getAbilityKeyed(AbilityCategory.FEAT, sourceStr);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if (oSource == null)</span>
			{
<span class="nc bnc" id="L355" title="All 2 branches missed.">				for (final AbilityCategory cat : SettingsHandler.getGameAsProperty().get().getAllAbilityCategories())</span>
				{
<span class="nc" id="L357">					Ability abilSourceObj = Globals.getContext().getReferenceContext().getManufacturerId(cat)</span>
<span class="nc" id="L358">						.getActiveObject(sourceStr);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">					if (abilSourceObj != null)</span>
					{
<span class="nc" id="L361">						oSource = abilSourceObj;</span>
					}
<span class="nc" id="L363">				}</span>
			}
		}
<span class="nc bnc" id="L366" title="All 2 branches missed.">		else if (sourceStr.startsWith(IOConstants.TAG_SPELL + '='))</span>
		{
<span class="nc" id="L368">			sourceStr = sourceStr.substring(6);</span>

			//oSource = aPC.getSpellNamed(sourceStr);
			oSource =
<span class="nc" id="L372">					Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Spell.class, sourceStr);</span>
		}
<span class="nc bnc" id="L374" title="All 2 branches missed.">		else if (sourceStr.startsWith(IOConstants.TAG_EQUIPMENT + '='))</span>
		{
<span class="nc" id="L376">			sourceStr = sourceStr.substring(10);</span>
<span class="nc" id="L377">			oSource = thePC.getEquipmentNamed(sourceStr);</span>
		}
<span class="nc bnc" id="L379" title="All 2 branches missed.">		else if (sourceStr.startsWith(IOConstants.TAG_CLASS + '='))</span>
		{
<span class="nc" id="L381">			sourceStr = sourceStr.substring(6);</span>
<span class="nc" id="L382">			oSource = thePC.getClassKeyed(sourceStr);</span>
		}
<span class="nc bnc" id="L384" title="All 2 branches missed.">		else if (sourceStr.startsWith(IOConstants.TAG_TEMPLATE + '='))</span>
		{
<span class="nc" id="L386">			sourceStr = sourceStr.substring(9);</span>
<span class="nc" id="L387">			oSource = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCTemplate.class,</span>
				sourceStr);
		}
<span class="nc bnc" id="L390" title="All 2 branches missed.">		else if (sourceStr.startsWith(IOConstants.TAG_SKILL + '='))</span>
		{
<span class="nc" id="L392">			sourceStr = sourceStr.substring(6);</span>
			Skill aSkill =
<span class="nc" id="L394">					Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Skill.class, sourceStr);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">			if (thePC.hasSkill(aSkill))</span>
			{
<span class="nc" id="L397">				oSource = aSkill;</span>
			}
			else
			{
<span class="nc" id="L401">				Logging.errorPrint(&quot;The PC did not have the skill: &quot; + aSkill.getDisplayName());</span>
			}
<span class="nc" id="L403">		}</span>
		else
		{
			// TODO Error message
<span class="nc" id="L407">			Logging.errorPrint(sourceStr + &quot; is not a supported type&quot;);</span>
		}

<span class="nc bnc" id="L410" title="All 2 branches missed.">		if (oSource != null)</span>
		{
<span class="nc" id="L412">			sourceStr = oSource.getKeyName();</span>
		}

<span class="nc bnc" id="L415" title="All 2 branches missed.">		if (targetStr.equals(IOConstants.TAG_PC))</span>
		{
<span class="nc" id="L417">			targetStr = thePC.getName();</span>
		}
		else
		{
<span class="nc" id="L421">			CDOMObject oTarget = thePC.getEquipmentNamed(targetStr);</span>
<span class="nc" id="L422">			targetStr = oTarget.getDisplayName();</span>
		}

<span class="nc" id="L425">		return thePC.getTempBonusMap(sourceStr, targetStr);</span>
	}

	private void addKeyedTemplate(PCTemplate template, String choice)
	{
<span class="nc bnc" id="L430" title="All 4 branches missed.">		if (ChooseActivation.hasNewChooseToken(template) &amp;&amp; choice == null)</span>
		{
<span class="nc" id="L432">			final String message =</span>
					&quot;Template ignored: &quot; + template + &quot; as a choice was expected but none was present in character.&quot;;
<span class="nc" id="L434">			warnings.add(message);</span>
<span class="nc" id="L435">			return;</span>
		}
<span class="nc" id="L437">		final int preXP = thePC.getXP();</span>
<span class="nc" id="L438">		templateInputFacet.importSelection(thePC.getCharID(), template, choice);</span>
<span class="nc" id="L439">		thePC.addTemplate(template);</span>

		//
		// XP written to file contains leveladjustment XP. If template modifies
		// XP, then
		// it will have already been added into total. Need to make sure it is
		// not doubled.
		//
<span class="nc bnc" id="L447" title="All 2 branches missed.">		if (thePC.getXP() != preXP)</span>
		{
<span class="nc" id="L449">			thePC.setXP(preXP);</span>
		}
<span class="nc" id="L451">	}</span>

	private void cacheLine(String s)
	{
<span class="nc" id="L455">		cache.put(s.substring(0, s.indexOf(':')), s);</span>
<span class="nc" id="L456">	}</span>


	private void checkStats() throws PCGParseException
	{
<span class="nc bnc" id="L461" title="All 2 branches missed.">		if (seenStats.size() != Globals.getContext().getReferenceContext().getConstructedObjectCount(PCStat.class))</span>
		{
<span class="nc" id="L463">			final String message =</span>
<span class="nc" id="L464">					LanguageBundle.getFormattedString(&quot;Exceptions.PCGenParser.WrongNumAttributes&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L465">				seenStats.size(), Globals.getContext().getReferenceContext().getConstructedObjectCount(PCStat.class));</span>
<span class="nc" id="L466">			throw new PCGParseException(&quot;parseStatLines&quot;, &quot;N/A&quot;, message, null); //$NON-NLS-1$//$NON-NLS-2$</span>
		}
<span class="nc" id="L468">	}</span>

	/*
	 * ###############################################################
	 * private helper methods
	 * ###############################################################
	 */
	private void initCache(int capacity)
	{
<span class="nc" id="L477">		cache = new Cache((capacity * 4) / 3);</span>
<span class="nc" id="L478">	}</span>

	private void parseAgeLine(String line)
	{
		try
		{
<span class="nc" id="L484">			int age = Integer</span>
<span class="nc" id="L485">				.parseInt(line.substring(IOConstants.TAG_AGE.length() + 1));</span>
<span class="nc" id="L486">			ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
<span class="nc" id="L487">				CControl.AGEINPUT, age);</span>
		}
<span class="nc" id="L489">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L491">			final String message =</span>
<span class="nc" id="L492">					LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalAgeLine&quot;, //$NON-NLS-1$</span>
						line);
<span class="nc" id="L494">			warnings.add(message);</span>
<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">	}</span>

	private void parseAgeSet(String line)
	{
<span class="nc" id="L500">		final StringTokenizer aTok = new StringTokenizer(line, IOConstants.TAG_END, false);</span>
<span class="nc" id="L501">		int i = 0;</span>
<span class="nc" id="L502">		aTok.nextToken(); // skip tag</span>

<span class="nc bnc" id="L504" title="All 4 branches missed.">		while (aTok.hasMoreTokens() &amp;&amp; (i &lt; 10))</span>
		{
<span class="nc" id="L506">			thePC.setHasMadeKitSelectionForAgeSet(i++, aTok.nextToken().equals(&quot;1&quot;)); //$NON-NLS-1$</span>
		}
<span class="nc" id="L508">	}</span>

	private void parseAlignmentLine(String line)
	{
<span class="nc" id="L512">		final String alignment = line.substring(IOConstants.TAG_ALIGNMENT.length() + 1);</span>
<span class="nc" id="L513">		PCAlignment align = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L514">			.silentlyGetConstructedCDOMObject(PCAlignment.class, alignment);</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">		if (align != null)</span>
		{
<span class="nc bnc" id="L518" title="All 2 branches missed.">			if (!RaceAlignment.canBeAlignment(thePC.getRace(), align))</span>
			{
<span class="nc" id="L520">				ShowMessageDelegate.showMessageDialog(&quot;Invalid alignment. Setting to &lt;none selected&gt;&quot;,</span>
					Constants.APPLICATION_NAME, MessageType.INFORMATION);
<span class="nc" id="L522">				align = getNoAlignment();</span>
			}
<span class="nc" id="L524">			AlignmentCompat.setCurrentAlignment(thePC.getCharID(), align);</span>

<span class="nc" id="L526">			return;</span>
		}

<span class="nc" id="L529">		final String message = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalAlignment&quot;, //$NON-NLS-1$</span>
			line);
<span class="nc" id="L531">		warnings.add(message);</span>
<span class="nc" id="L532">	}</span>

	/**
	 * Ignore cost for gear (Y/N)
	 * @param line Line of saved data to be processed.
	 **/
	private void parseIgnoreCostLine(String line)
	{
<span class="nc" id="L540">		thePC.setIgnoreCost(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L541">	}</span>

	/**
	 * Allow debt for gear (Y/N)
	 * @param line Line of saved data to be processed.
	 **/
	private void parseAllowDebtLine(String line)
	{
<span class="nc" id="L549">		thePC.setAllowDebt(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L550">	}</span>

	/**
	 * Auto resize gear (Y/N)
	 * @param line Line of saved data to be processed.
	 **/
	private void parseAutoResizeGearLine(String line)
	{
<span class="nc" id="L558">		thePC.setAutoResize(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L559">	}</span>

	/**
	 * # Auto sort skills - transition only, line is no longer saved
	 * @param line
	 **/
	private void parseAutoSortSkillsLine(String line)
	{
<span class="nc bnc" id="L567" title="All 2 branches missed.">		if (line.endsWith(IOConstants.VALUE_Y))</span>
		{
<span class="nc" id="L569">			thePC.setSkillsOutputOrder(SkillsOutputOrder.NAME_ASC);</span>
		}
		else
		{
<span class="nc" id="L573">			thePC.setSkillsOutputOrder(SkillsOutputOrder.MANUAL);</span>
		}
<span class="nc" id="L575">	}</span>

	/**
	 * # Auto known spells
	 * @param line
	 **/
	private void parseAutoSpellsLine(String line)
	{
<span class="nc" id="L583">		thePC.setAutoSpells(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L584">	}</span>

	/**
	 * Process the Use Higher Known Spell Slot line.
	 * @param line The buffer to append to.
	 */
	private void parseUseHigherKnownSpellSlotsLine(String line)
	{
<span class="nc" id="L592">		thePC.setUseHigherKnownSlots(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L593">	}</span>

	/**
	 * Process the Use Higher Prepped Spell Slot line.
	 * @param line The buffer to append to.
	 */
	private void parseUseHigherPreppedSpellSlotsLine(String line)
	{
<span class="nc" id="L601">		thePC.setUseHigherPreppedSlots(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L602">	}</span>

	private void parseBirthdayLine(String line)
	{
<span class="nc" id="L606">		thePC.setPCAttribute(PCStringKey.BIRTHDAY,</span>
<span class="nc" id="L607">			EntityEncoder.decode(line.substring(IOConstants.TAG_BIRTHDAY.length() + 1)));</span>
<span class="nc" id="L608">	}</span>

	private void parseBirthplaceLine(String line)
	{
<span class="nc" id="L612">		thePC.setPCAttribute(PCStringKey.BIRTHPLACE,</span>
<span class="nc" id="L613">			EntityEncoder.decode(line.substring(IOConstants.TAG_BIRTHPLACE.length() + 1)));</span>
<span class="nc" id="L614">	}</span>

	/**
	 * Does the actual work:&lt;br&gt;
	 * Retrieves cached lines and parses each line.
	 *
	 * Note: May have to change parse order!
	 *
	 * &lt;br&gt;author: Thomas Behr 31-07-02
	 *
	 * @throws PCGParseException
	 */
	private void parseCachedLines() throws PCGParseException
	{
		/*
		 * VERSION:x.x.x
		 */
<span class="nc bnc" id="L631" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_VERSION))</span>
		{
<span class="nc" id="L633">			parseVersionLine(cache.get(IOConstants.TAG_VERSION).get(0));</span>
		}

<span class="nc bnc" id="L636" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_GAMEMODE))</span>
		{
<span class="nc" id="L638">			parseGameMode(cache.get(IOConstants.TAG_GAMEMODE).get(0));</span>
		}

		/*
		 * #System Information
		 * CAMPAIGN:CMP - Monkey Book I - Book For Monkeys
		 * CAMPAIGN:CMP - Monkey Book II - Book By Monkeys
		 * ...
		 *
		 * first thing to do is checking campaigns - no matter what!
		 */
<span class="nc bnc" id="L649" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CAMPAIGN))</span>
		{
<span class="nc" id="L651">			checkDisplayListsHappy();</span>
		}

		/*
		 * #Character Attributes
		 * STAT:STR=18
		 * STAT:DEX=18
		 * STAT:CON=18
		 * STAT:INT=18
		 * STAT:WIS=18
		 * STAT:CHA=18
		 * ALIGN:LG
		 * RACE:Human
		 */
<span class="nc bnc" id="L665" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_STAT))</span>
		{
<span class="nc bnc" id="L667" title="All 2 branches missed.">			for (final String stat : cache.get(IOConstants.TAG_STAT))</span>
			{
<span class="nc" id="L669">				parseStatLine(stat);</span>
<span class="nc" id="L670">			}</span>

<span class="nc" id="L672">			checkStats();</span>
		}

<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_ALIGNMENT))</span>
		{
<span class="nc" id="L677">			parseAlignmentLine(cache.get(IOConstants.TAG_ALIGNMENT).get(0));</span>
		}

		/*
		 * # Kits - Just adds a reference to the character that the template
		 * was picked.
		 */
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_KIT))</span>
		{
<span class="nc bnc" id="L686" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_KIT))</span>
			{
<span class="nc" id="L688">				parseKitLine(line);</span>
<span class="nc" id="L689">			}</span>
		}

<span class="nc bnc" id="L692" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_RACE))</span>
		{
<span class="nc" id="L694">			parseRaceLine(cache.get(IOConstants.TAG_RACE).get(0));</span>
		}

<span class="nc bnc" id="L697" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_FAVOREDCLASS))</span>
		{
<span class="nc" id="L699">			parseFavoredClassLine(cache.get(IOConstants.TAG_FAVOREDCLASS).get(0));</span>
		}

		/*
		 * #System Information
		 * CAMPAIGNS:&gt;:-delimited list&lt;
		 * VERSION:x.x.x
		 * ROLLMETHOD:xxx
		 * PURCHASEPOINTS:Y or N|TYPE:&gt;living City, Living greyhawk, etc&lt;
		 * UNLIMITEDPOOLCHECKED:Y or N
		 * POOLPOINTS:&gt;numeric value 0-?&lt;
		 * POOLPOINTSAVAIL:&gt;numeric value 0-?&lt;
		 * GAMEMODE:DnD
		 * TABLABEL:0
		 * AUTOSPELLS:Y or N
		 * LOADCOMPANIONS:Y or N
		 * USETEMPMODS:Y or N
		 * SKILLSOUTPUTORDER:0
		 */
<span class="nc bnc" id="L718" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_POOLPOINTS))</span>
		{
<span class="nc" id="L720">			parsePoolPointsLine(cache.get(IOConstants.TAG_POOLPOINTS).get(0));</span>
		}
<span class="nc bnc" id="L722" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_POOLPOINTSAVAIL))</span>
		{
<span class="nc" id="L724">			parsePoolPointsLine2(cache.get(IOConstants.TAG_POOLPOINTSAVAIL).get(0));</span>
		}

<span class="nc bnc" id="L727" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERTYPE))</span>
		{
<span class="nc" id="L729">			parseCharacterTypeLine(cache.get(IOConstants.TAG_CHARACTERTYPE).get(0));</span>
		}

<span class="nc bnc" id="L732" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PREVIEWSHEET))</span>
		{
<span class="nc" id="L734">			parsePreviewSheetLine(cache.get(IOConstants.TAG_PREVIEWSHEET).get(0));</span>
		}

<span class="nc bnc" id="L737" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_AUTOSPELLS))</span>
		{
<span class="nc" id="L739">			parseAutoSpellsLine(cache.get(IOConstants.TAG_AUTOSPELLS).get(0));</span>
		}

<span class="nc bnc" id="L742" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_USEHIGHERKNOWN))</span>
		{
<span class="nc" id="L744">			parseUseHigherKnownSpellSlotsLine(cache.get(IOConstants.TAG_USEHIGHERKNOWN).get(0));</span>
		}
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_USEHIGHERPREPPED))</span>
		{
<span class="nc" id="L748">			parseUseHigherPreppedSpellSlotsLine(cache.get(IOConstants.TAG_USEHIGHERPREPPED).get(0));</span>
		}

<span class="nc bnc" id="L751" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_LOADCOMPANIONS))</span>
		{
<span class="nc" id="L753">			parseLoadCompanionLine(cache.get(IOConstants.TAG_LOADCOMPANIONS).get(0));</span>
		}

<span class="nc bnc" id="L756" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_USETEMPMODS))</span>
		{
<span class="nc" id="L758">			parseUseTempModsLine(cache.get(IOConstants.TAG_USETEMPMODS).get(0));</span>
		}

<span class="nc bnc" id="L761" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_HTMLOUTPUTSHEET))</span>
		{
<span class="nc" id="L763">			parseHTMLOutputSheetLine(cache.get(IOConstants.TAG_HTMLOUTPUTSHEET).get(0));</span>
		}

<span class="nc bnc" id="L766" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PDFOUTPUTSHEET))</span>
		{
<span class="nc" id="L768">			parsePDFOutputSheetLine(cache.get(IOConstants.TAG_PDFOUTPUTSHEET).get(0));</span>
		}

<span class="nc bnc" id="L771" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_IGNORECOST))</span>
		{
<span class="nc" id="L773">			parseIgnoreCostLine(cache.get(IOConstants.TAG_IGNORECOST).get(0));</span>
		}

<span class="nc bnc" id="L776" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_ALLOWDEBT))</span>
		{
<span class="nc" id="L778">			parseAllowDebtLine(cache.get(IOConstants.TAG_ALLOWDEBT).get(0));</span>
		}

<span class="nc bnc" id="L781" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_AUTORESIZEGEAR))</span>
		{
<span class="nc" id="L783">			parseAutoResizeGearLine(cache.get(IOConstants.TAG_AUTORESIZEGEAR).get(0));</span>
		}

<span class="nc bnc" id="L786" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_AUTOSORTSKILLS))</span>
		{
<span class="nc" id="L788">			parseAutoSortSkillsLine(cache.get(IOConstants.TAG_AUTOSORTSKILLS).get(0));</span>
		}

<span class="nc bnc" id="L791" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SKILLSOUTPUTORDER))</span>
		{
<span class="nc" id="L793">			parseSkillsOutputOrderLine(cache.get(IOConstants.TAG_SKILLSOUTPUTORDER).get(0));</span>
		}

<span class="nc bnc" id="L796" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SKILLFILTER))</span>
		{
<span class="nc" id="L798">			parseSkillFilterLine(cache.get(IOConstants.TAG_SKILLFILTER).get(0));</span>
		}

		/*
		 * #Character Class(es)
		 * CLASS:Fighter|LEVEL=3
		 * CLASSABILITIESLEVEL:Fighter=1(&gt;This would only display up to the level the character has already,)
		 * CLASSABILITIESLEVEL:Fighter=2(&gt;with any special abilities not covered by other areas,)
		 * CLASSABILITIESLEVEL:Fighter=3(&gt;such as skills, feats, etc., but would list SA's, and the like&lt;)
		 * CLASS:Wizard|LEVEL=1
		 * CLASSABILITIESLEVEL:Wizard=1(SA's, MEMORIZE:Y, etc)
		 */
<span class="nc bnc" id="L810" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CLASS))</span>
		{
<span class="nc bnc" id="L812" title="All 2 branches missed.">			for (String line : cache.get(IOConstants.TAG_CLASS))</span>
			{
<span class="nc" id="L814">				parseClassLine(line);</span>
<span class="nc" id="L815">			}</span>
<span class="nc" id="L816">			thePC.setDirty(true);</span>
		}

<span class="nc" id="L819">		final List&lt;PCLevelInfo&gt; pcLevelInfoList = new ArrayList&lt;&gt;(thePC.getLevelInfo());</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CLASSABILITIESLEVEL))</span>
		{
<span class="nc" id="L822">			thePC.clearLevelInfo();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			for (String line : cache.get(IOConstants.TAG_CLASSABILITIESLEVEL))</span>
			{
<span class="nc" id="L825">				parseClassAbilitiesLevelLine(line, pcLevelInfoList);</span>
<span class="nc" id="L826">			}</span>
		}

		/*
		 * #Character Experience
		 * EXPERIENCE:6000
		 * EXPERIENCETABLE:Medium
		 */
<span class="nc bnc" id="L834" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EXPERIENCE))</span>
		{
<span class="nc" id="L836">			parseExperienceLine(cache.get(IOConstants.TAG_EXPERIENCE).get(0));</span>
		}
<span class="nc bnc" id="L838" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EXPERIENCETABLE))</span>
		{
<span class="nc" id="L840">			parseExperienceTableLine(cache.get(IOConstants.TAG_EXPERIENCETABLE).get(0));</span>
		}

		/*
		 * #Character Templates
		 * TEMPLATESAPPLIED:If any, else this would just have the comment line, and skip to the next
		 */
<span class="nc bnc" id="L847" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_TEMPLATESAPPLIED))</span>
		{
<span class="nc bnc" id="L849" title="All 2 branches missed.">			for (String line : cache.get(IOConstants.TAG_TEMPLATESAPPLIED))</span>
			{
<span class="nc" id="L851">				parseTemplateLine(line);</span>
<span class="nc" id="L852">			}</span>
		}

<span class="nc bnc" id="L855" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_REGION))</span>
		{
<span class="nc bnc" id="L857" title="All 2 branches missed.">			for (String line : cache.get(IOConstants.TAG_REGION))</span>
			{
<span class="nc" id="L859">				parseRegionLine(line);</span>
<span class="nc" id="L860">			}</span>
		}

		/*
		 * ###############################################################
		 * Character Skills methods
		 * ###############################################################
		 */
		/*
		 * #Character Skills
		 * CLASSBOUGHT:Fighter
		 * SKILL:Alchemy|CLASS:N|COST:2|RANK:7  (Should be Obvious what each of these does, I hope ;p)
		 * SKILL:Survival|CLASS:Y|COST:1|SYNERGY:Wilderness Lore=5=2|RANK:10
		 * CLASSBOUGHT:Wizard
		 * SKILL:Spellcraft|CLASS:Y|COST:1|RANK:7
		 *
		 * CLASSBOUGHT not supported
		 */
<span class="nc bnc" id="L878" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SKILL))</span>
		{
<span class="nc bnc" id="L880" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_SKILL))</span>
			{
<span class="nc" id="L882">				parseSkillLine(line);</span>
<span class="nc" id="L883">			}</span>
		}

		/*
		 * #Character Languages
		 * LANGUAGE:Chondathan|LANGUAGE:Common|LANGUAGE:Literacy
		 */
<span class="nc bnc" id="L890" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_LANGUAGE))</span>
		{
<span class="nc bnc" id="L892" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_LANGUAGE))</span>
			{
<span class="nc" id="L894">				parseLanguageLine(line);</span>
<span class="nc" id="L895">			}</span>
		}

		/*
		 * Anything that is already Pipe Delimited should be in
		 * parenthesis to avoid confusion on PCGen's part
		 *
		 * #Character Feats
		 * FEAT:Alertness|TYPE:General|(BONUS:SKILL|Listen,Spot|2)|DESC:+2 on Listen and Spot checks
		 * FEATPOOL:&gt;number of remaining feats&lt;
		 */
<span class="nc bnc" id="L906" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_FEAT))</span>
		{
<span class="nc bnc" id="L908" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_FEAT))</span>
			{
<span class="nc" id="L910">				parseFeatLine(line);</span>
<span class="nc" id="L911">			}</span>
		}

<span class="nc bnc" id="L914" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_VFEAT))</span>
		{
<span class="nc bnc" id="L916" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_VFEAT))</span>
			{
<span class="nc" id="L918">				parseVFeatLine(line);</span>
<span class="nc" id="L919">			}</span>
		}

<span class="nc bnc" id="L922" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_FEATPOOL))</span>
		{
<span class="nc bnc" id="L924" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_FEATPOOL))</span>
			{
<span class="nc" id="L926">				parseFeatPoolLine(line);</span>
<span class="nc" id="L927">			}</span>
		}

<span class="nc bnc" id="L930" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_ABILITY))</span>
		{
<span class="nc bnc" id="L932" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_ABILITY))</span>
			{
<span class="nc" id="L934">				parseAbilityLine(line);</span>
<span class="nc" id="L935">			}</span>
		}

<span class="nc bnc" id="L938" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_USERPOOL))</span>
		{
<span class="nc bnc" id="L940" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_USERPOOL))</span>
			{
<span class="nc" id="L942">				parseUserPoolLine(line);</span>
<span class="nc" id="L943">			}</span>
		}

		/*
		 * #Character Deity/Domain
		 * DEITY:Yondalla|DEITYDOMAINS:[DOMAIN:Good|DOMAIN:Law|DOMAIN:Protection]|ALIGNALLOW:013|DESC:Halflings, 
		 *             Protection, Fertility|SYMBOL:None|DEITYFAVWEAP:Sword (Short)|DEITYALIGN:ALIGN:LG
		 * DOMAIN:GOOD|DOMAINGRANTS:&gt;list of abilities&lt;
		 * DOMAINSPELLS:GOOD|SPELLLIST:[SPELL:bla|SPELL:blubber|...]
		 */
<span class="nc bnc" id="L953" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_DEITY))</span>
		{
<span class="nc bnc" id="L955" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_DEITY))</span>
			{
<span class="nc" id="L957">				parseDeityLine(line);</span>
<span class="nc" id="L958">			}</span>
		}

<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_DOMAIN))</span>
		{
<span class="nc bnc" id="L963" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_DOMAIN))</span>
			{
<span class="nc" id="L965">				parseDomainLine(line);</span>
<span class="nc" id="L966">			}</span>
		}

		//We ignore domain spells now

<span class="nc bnc" id="L971" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SPELLBOOK))</span>
		{
<span class="nc bnc" id="L973" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_SPELLBOOK))</span>
			{
<span class="nc" id="L975">				parseSpellBookLines(line);</span>
<span class="nc" id="L976">			}</span>
		}
		/*
		 * This one is what will make spellcasters U G L Y!!!
		 *
		 * #Character Spells Information
		 * CLASS:Wizard|CANCASTPERDAY:2,4(Totals the levels all up + includes attribute bonuses)
		 * SPELLNAME:Blah|SCHOOL:blah|SUBSCHOOL:blah|Etc
		 */
<span class="nc bnc" id="L985" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SPELLLIST))</span>
		{
<span class="nc bnc" id="L987" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_SPELLLIST))</span>
			{
<span class="nc" id="L989">				parseSpellListLines(line);</span>
<span class="nc" id="L990">			}</span>
		}

		//For those that weren't explicitly specified, insert them
<span class="nc" id="L994">		insertDefaultClassSpellLists();</span>

<span class="nc bnc" id="L996" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SPELLNAME))</span>
		{
			// Calculate what has been granted so far, particularly any ability granted spells
<span class="nc" id="L999">			thePC.setImporting(false);</span>
<span class="nc" id="L1000">			thePC.calcActiveBonuses();</span>
<span class="nc" id="L1001">			thePC.setImporting(true);</span>

<span class="nc bnc" id="L1003" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_SPELLNAME))</span>
			{
<span class="nc" id="L1005">				parseSpellLine(line);</span>
<span class="nc" id="L1006">			}</span>
		}

		/*
		 * #Character Description/Bio/Historys
		 * CHARACTERBIO:any text that's in the BIO field
		 * CHARACTERDESC:any text that's in the BIO field
		 */
<span class="nc bnc" id="L1014" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERBIO))</span>
		{
<span class="nc" id="L1016">			parseCharacterBioLine(cache.get(IOConstants.TAG_CHARACTERBIO).get(0));</span>
		}

<span class="nc bnc" id="L1019" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERDESC))</span>
		{
<span class="nc" id="L1021">			parseCharacterDescLine(cache.get(IOConstants.TAG_CHARACTERDESC).get(0));</span>
		}

<span class="nc bnc" id="L1024" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERCOMP))</span>
		{
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CHARACTERCOMP))</span>
			{
<span class="nc" id="L1028">				parseCharacterCompLine(line);</span>
<span class="nc" id="L1029">			}</span>
		}

<span class="nc bnc" id="L1032" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERASSET))</span>
		{
<span class="nc bnc" id="L1034" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CHARACTERASSET))</span>
			{
<span class="nc" id="L1036">				parseCharacterAssetLine(line);</span>
<span class="nc" id="L1037">			}</span>
		}

<span class="nc bnc" id="L1040" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERMAGIC))</span>
		{
<span class="nc bnc" id="L1042" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CHARACTERMAGIC))</span>
			{
<span class="nc" id="L1044">				parseCharacterMagicLine(line);</span>
<span class="nc" id="L1045">			}</span>
		}

<span class="nc bnc" id="L1048" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERDMNOTES))</span>
		{
<span class="nc bnc" id="L1050" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CHARACTERDMNOTES))</span>
			{
<span class="nc" id="L1052">				parseCharacterDmNotesLine(line);</span>
<span class="nc" id="L1053">			}</span>
		}

		/*
		 * #Character Master/Followers
		 * MASTER:Mynex|TYPE:Follower|HITDICE:20|FILE:E$\DnD\dnd-chars\ravenlock.pcg
		 * FOLLOWER:Raven|TYPE:Animal Companion|HITDICE:5|FILE:E$\DnD\dnd-chars\raven.pcg
		 */
<span class="nc bnc" id="L1061" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_MASTER))</span>
		{
<span class="nc bnc" id="L1063" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_MASTER))</span>
			{
<span class="nc" id="L1065">				parseMasterLine(line);</span>
<span class="nc" id="L1066">			}</span>
		}

<span class="nc bnc" id="L1069" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_FOLLOWER))</span>
		{
<span class="nc bnc" id="L1071" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_FOLLOWER))</span>
			{
<span class="nc" id="L1073">				parseFollowerLine(line);</span>
<span class="nc" id="L1074">			}</span>
		}

		/*
		 * Contains information about PC's equipment
		 * Money goes here as well
		 *
		 * #Character Equipment
		 * EQUIPNAME:Longsword|OUTPUTORDER:1|COST:5|WT:5|NOTE:It's very sharp!|&gt;other info&lt;
		 * EQUIPNAME:Backpack|OUTPUTORDER:-1|COST:5|WT:5|NOTE:on my back
		 * EQUIPNAME:Rope (Silk)|OUTPUTORDER:3|COST:5|WT:5
		 */
<span class="nc bnc" id="L1086" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_MONEY))</span>
		{
<span class="nc bnc" id="L1088" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_MONEY))</span>
			{
<span class="nc" id="L1090">				parseMoneyLine(line);</span>
<span class="nc" id="L1091">			}</span>
		}

<span class="nc bnc" id="L1094" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EQUIPNAME))</span>
		{
			// We process the bonuses loaded so far so that natural weapons from 
			// conditional abilities can be found. 
<span class="nc" id="L1098">			thePC.setImporting(false);</span>
<span class="nc" id="L1099">			thePC.setCalcFollowerBonus();</span>
<span class="nc" id="L1100">			thePC.calcActiveBonuses();</span>
<span class="nc" id="L1101">			thePC.setImporting(true);</span>

<span class="nc bnc" id="L1103" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_EQUIPNAME))</span>
			{
<span class="nc" id="L1105">				parseEquipmentLine(line);</span>
<span class="nc" id="L1106">			}</span>
		}

<span class="nc bnc" id="L1109" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EQUIPSET))</span>
		{
			/*
			 * strangely enough this works even if we create a
			 * EquipSet for content whose container EquipSet
			 * has not been created yet
			 * author: Thomas Behr 10-09-02
			 *
			 * Comment from EquipSet author:
			 * It only works because I've already sorted on output
			 * in PCGVer2Creator
			 * author: Jayme Cox 01-16-03
			 */

			//Collections.sort(cache.get(TAG_EQUIPSET), new EquipSetLineComparator());
<span class="nc bnc" id="L1124" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_EQUIPSET))</span>
			{
<span class="nc" id="L1126">				parseEquipmentSetLine(line);</span>
<span class="nc" id="L1127">			}</span>
<span class="nc" id="L1128">			EquipSetMigration.migrateEquipSets(thePC, pcgenVersion);</span>
		}

		/*
		 * CALCEQUIPSET line contains the &quot;working&quot; equipment list
		 */
<span class="nc bnc" id="L1134" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CALCEQUIPSET))</span>
		{
<span class="nc bnc" id="L1136" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CALCEQUIPSET))</span>
			{
<span class="nc" id="L1138">				parseCalcEquipSet(line);</span>
<span class="nc" id="L1139">			}</span>
		}

		/*
		 * #Character Notes Tab
		 */
<span class="nc bnc" id="L1145" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_NOTE))</span>
		{
<span class="nc bnc" id="L1147" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_NOTE))</span>
			{
<span class="nc" id="L1149">				parseNoteLine(line);</span>
<span class="nc" id="L1150">			}</span>
		}

		/*
		 * #Character Bio
		 * CHARACTERNAME:Code Monkey
		 * TABNAME:Code Monkey the Best Ever No Really!
		 * PLAYERNAME:Jason Monkey
		 * HEIGHT:75
		 * WEIGHT:198
		 * AGE:17
		 * GENDER:enum name
		 * HANDED:enum name
		 * SKIN:text
		 * EYECOLOR:text
		 * HAIRCOLOR:text
		 * HAIRSTYLE:text
		 * LOCATION:text
		 * CITY:text
		 * PERSONALITYTRAIT1:text
		 * PERSONALITYTRAIT2:text
		 * SPEECHPATTERN:text
		 * PHOBIAS:text
		 * INTERESTS:text
		 * CATCHPHRASE:text
		 */
<span class="nc bnc" id="L1176" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHARACTERNAME))</span>
		{
<span class="nc" id="L1178">			parseCharacterNameLine(cache.get(IOConstants.TAG_CHARACTERNAME).get(0));</span>
		}

<span class="nc bnc" id="L1181" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_TABNAME))</span>
		{
<span class="nc" id="L1183">			parseTabNameLine(cache.get(IOConstants.TAG_TABNAME).get(0));</span>
		}

<span class="nc bnc" id="L1186" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PLAYERNAME))</span>
		{
<span class="nc" id="L1188">			parsePlayerNameLine(cache.get(IOConstants.TAG_PLAYERNAME).get(0));</span>
		}

<span class="nc bnc" id="L1191" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_HEIGHT))</span>
		{
<span class="nc" id="L1193">			parseHeightLine(cache.get(IOConstants.TAG_HEIGHT).get(0));</span>
		}

<span class="nc bnc" id="L1196" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_WEIGHT))</span>
		{
<span class="nc" id="L1198">			parseWeightLine(cache.get(IOConstants.TAG_WEIGHT).get(0));</span>
		}

<span class="nc bnc" id="L1201" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_AGE))</span>
		{
<span class="nc" id="L1203">			parseAgeLine(cache.get(IOConstants.TAG_AGE).get(0));</span>
		}

<span class="nc bnc" id="L1206" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_GENDER))</span>
		{
<span class="nc" id="L1208">			parseGenderLine(cache.get(IOConstants.TAG_GENDER).get(0));</span>
		}

<span class="nc bnc" id="L1211" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_HANDED))</span>
		{
<span class="nc" id="L1213">			parseHandedLine(cache.get(IOConstants.TAG_HANDED).get(0));</span>
		}

<span class="nc bnc" id="L1216" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SKINCOLOR))</span>
		{
<span class="nc" id="L1218">			parseSkinColorLine(cache.get(IOConstants.TAG_SKINCOLOR).get(0));</span>
		}

<span class="nc bnc" id="L1221" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EYECOLOR))</span>
		{
<span class="nc" id="L1223">			parseEyeColorLine(cache.get(IOConstants.TAG_EYECOLOR).get(0));</span>
		}

<span class="nc bnc" id="L1226" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_HAIRCOLOR))</span>
		{
<span class="nc" id="L1228">			parseHairColorLine(cache.get(IOConstants.TAG_HAIRCOLOR).get(0));</span>
		}

<span class="nc bnc" id="L1231" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_HAIRSTYLE))</span>
		{
<span class="nc" id="L1233">			parseHairStyleLine(cache.get(IOConstants.TAG_HAIRSTYLE).get(0));</span>
		}

<span class="nc bnc" id="L1236" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_LOCATION))</span>
		{
<span class="nc" id="L1238">			parseLocationLine(cache.get(IOConstants.TAG_LOCATION).get(0));</span>
		}

		//this tag is obsolete, but left in for backward-compatibility, replaced by TAG_CITY
<span class="nc bnc" id="L1242" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_RESIDENCE))</span>
		{
<span class="nc" id="L1244">			parseResidenceLine(cache.get(IOConstants.TAG_RESIDENCE).get(0));</span>
		}

<span class="nc bnc" id="L1247" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CITY))</span>
		{
<span class="nc" id="L1249">			parseCityLine(cache.get(IOConstants.TAG_CITY).get(0));</span>
		}

<span class="nc bnc" id="L1252" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_BIRTHDAY))</span>
		{
<span class="nc" id="L1254">			parseBirthdayLine(cache.get(IOConstants.TAG_BIRTHDAY).get(0));</span>
		}

<span class="nc bnc" id="L1257" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_BIRTHPLACE))</span>
		{
<span class="nc" id="L1259">			parseBirthplaceLine(cache.get(IOConstants.TAG_BIRTHPLACE).get(0));</span>
		}

<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PERSONALITYTRAIT1))</span>
		{
<span class="nc bnc" id="L1264" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_PERSONALITYTRAIT1))</span>
			{
<span class="nc" id="L1266">				parsePersonalityTrait1Line(line);</span>
<span class="nc" id="L1267">			}</span>
		}

<span class="nc bnc" id="L1270" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PERSONALITYTRAIT2))</span>
		{
<span class="nc bnc" id="L1272" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_PERSONALITYTRAIT2))</span>
			{
<span class="nc" id="L1274">				parsePersonalityTrait2Line(line);</span>
<span class="nc" id="L1275">			}</span>
		}

<span class="nc bnc" id="L1278" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_SPEECHPATTERN))</span>
		{
<span class="nc" id="L1280">			parseSpeechPatternLine(cache.get(IOConstants.TAG_SPEECHPATTERN).get(0));</span>
		}

<span class="nc bnc" id="L1283" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PHOBIAS))</span>
		{
<span class="nc" id="L1285">			parsePhobiasLine(cache.get(IOConstants.TAG_PHOBIAS).get(0));</span>
		}

<span class="nc bnc" id="L1288" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_INTERESTS))</span>
		{
<span class="nc" id="L1290">			parseInterestsLine(cache.get(IOConstants.TAG_INTERESTS).get(0));</span>
		}

<span class="nc bnc" id="L1293" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CATCHPHRASE))</span>
		{
<span class="nc" id="L1295">			parseCatchPhraseLine(cache.get(IOConstants.TAG_CATCHPHRASE).get(0));</span>
		}

<span class="nc bnc" id="L1298" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PORTRAIT))</span>
		{
<span class="nc" id="L1300">			parsePortraitLine(cache.get(IOConstants.TAG_PORTRAIT).get(0));</span>
		}

<span class="nc bnc" id="L1303" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_PORTRAIT_THUMBNAIL_RECT))</span>
		{
<span class="nc" id="L1305">			parsePortraitThumbnailRectLine(cache.get(IOConstants.TAG_PORTRAIT_THUMBNAIL_RECT).get(0));</span>
		}

		/*
		 * #Character Weapon proficiencies
		 */
<span class="nc bnc" id="L1311" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_WEAPONPROF))</span>
		{
<span class="nc bnc" id="L1313" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_WEAPONPROF))</span>
			{
<span class="nc" id="L1315">				parseWeaponProficienciesLine(line);</span>
<span class="nc" id="L1316">			}</span>

			// This is not reliable during character load, and the warning is 
			// of little value, so I'm disabling the check for now. 
			//checkWeaponProficiencies();
		}

		/*
		 * # Temporary Bonuses
		 */
<span class="nc bnc" id="L1326" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_TEMPBONUS))</span>
		{
<span class="nc bnc" id="L1328" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_TEMPBONUS))</span>
			{
<span class="nc" id="L1330">				parseTempBonusLine(line);</span>
<span class="nc" id="L1331">			}</span>
		}

		/*
		 * # EquipSet Temporary bonuses
		 * Must be done after both EquipSet and TempBonuses are parsed
		 */
<span class="nc bnc" id="L1338" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_EQSETBONUS))</span>
		{
<span class="nc bnc" id="L1340" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_EQSETBONUS))</span>
			{
<span class="nc" id="L1342">				parseEquipSetTempBonusLine(line);</span>
<span class="nc" id="L1343">			}</span>
		}

<span class="nc bnc" id="L1346" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_AGESET))</span>
		{
<span class="nc bnc" id="L1348" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_AGESET))</span>
			{
<span class="nc" id="L1350">				parseAgeSet(line);</span>
<span class="nc" id="L1351">			}</span>
		}

<span class="nc bnc" id="L1354" title="All 2 branches missed.">		if (cache.containsKey(IOConstants.TAG_CHRONICLE_ENTRY))</span>
		{
<span class="nc bnc" id="L1356" title="All 2 branches missed.">			for (final String line : cache.get(IOConstants.TAG_CHRONICLE_ENTRY))</span>
			{
<span class="nc" id="L1358">				parseChronicleEntryLine(line);</span>
<span class="nc" id="L1359">			}</span>
		}

<span class="nc bnc" id="L1362" title="All 2 branches missed.">		if(cache.containsKey(IOConstants.TAG_PREVIEWSHEETVAR))</span>
		{
<span class="nc bnc" id="L1364" title="All 2 branches missed.">			for(final String line : cache.get(IOConstants.TAG_PREVIEWSHEETVAR))</span>
			{
<span class="nc" id="L1366">				parsePreviewSheetVarLine(line);</span>
<span class="nc" id="L1367">			}</span>
		}

<span class="nc" id="L1370">	}</span>

	/*
	 * ###############################################################
	 * System Information methods
	 * ###############################################################
	 */
	private void checkDisplayListsHappy() throws PCGParseException
	{
<span class="nc bnc" id="L1379" title="All 2 branches missed.">		if (!Globals.displayListsHappy())</span>
		{
<span class="nc" id="L1381">			throw new PCGParseException(&quot;parseCampaignLines&quot;, &quot;N/A&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L1382">				LanguageBundle.getString(&quot;Exceptions.PCGenParser.NoCampaignInfo&quot;)); //$NON-NLS-1$</span>
		}
<span class="nc" id="L1384">	}</span>

	/**
	 * Retrieve a list of campaigns named on the supplied lines. 
	 * @param lines The campaign lines from the PCG file.
	 * @param gameModeName The name of the charater's game mode.
	 * @return The list of campaigns.
	 * @throws PCGParseException 
	 */
	private List&lt;Campaign&gt; getCampaignList(List&lt;String&gt; lines, String gameModeName) throws PCGParseException
	{

<span class="nc" id="L1396">		final List&lt;Campaign&gt; campaigns = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1398" title="All 2 branches missed.">		for (final String line : lines)</span>
		{
			PCGTokenizer tokens;
			try
			{
<span class="nc" id="L1403">				tokens = new PCGTokenizer(line);</span>
			}
<span class="nc" id="L1405">			catch (PCGParseException pcgpex)</span>
			{
				/*
				 * Campaigns are critical for characters,
				 * need to stop the load process
				 *
				 * Thomas Behr 14-08-02
				 */
<span class="nc" id="L1413">				throw new PCGParseException(&quot;parseCampaignLines&quot;, line, pcgpex.getMessage(), pcgpex);</span>
<span class="nc" id="L1414">			}</span>

<span class="nc bnc" id="L1416" title="All 2 branches missed.">			for (PCGElement element : tokens.getElements())</span>
			{
<span class="nc" id="L1418">				String sourceKey = SourceMigration.getNewSourceKey(element.getText(), pcgenVersion, gameModeName);</span>
<span class="nc" id="L1419">				final Campaign aCampaign = Globals.getCampaignKeyed(sourceKey);</span>

<span class="nc bnc" id="L1421" title="All 2 branches missed.">				if (aCampaign != null)</span>
				{
<span class="nc" id="L1423">					campaigns.add(aCampaign);</span>
				}
<span class="nc" id="L1425">			}</span>
<span class="nc" id="L1426">		}</span>

<span class="nc" id="L1428">		return campaigns;</span>
	}

	private void parseCatchPhraseLine(final String line)
	{
<span class="nc" id="L1433">		thePC.setPCAttribute(PCStringKey.CATCHPHRASE,</span>
<span class="nc" id="L1434">			EntityEncoder.decode(line.substring(IOConstants.TAG_CATCHPHRASE.length() + 1)));</span>
<span class="nc" id="L1435">	}</span>

	private void parseCharacterAssetLine(final String line)
	{
<span class="nc" id="L1439">		thePC.setStringFor(PCStringKey.ASSETS,</span>
<span class="nc" id="L1440">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERASSET.length() + 1)));</span>
<span class="nc" id="L1441">	}</span>

	private void parseCharacterCompLine(final String line)
	{
<span class="nc" id="L1445">		thePC.setStringFor(PCStringKey.COMPANIONS,</span>
<span class="nc" id="L1446">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERCOMP.length() + 1)));</span>
<span class="nc" id="L1447">	}</span>

	private void parseCharacterDescLine(final String line)
	{
<span class="nc" id="L1451">		thePC.setPCAttribute(PCStringKey.DESCRIPTION,</span>
<span class="nc" id="L1452">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERDESC.length() + 1)));</span>
<span class="nc" id="L1453">	}</span>

	private void parseCharacterMagicLine(final String line)
	{
<span class="nc" id="L1457">		thePC.setStringFor(PCStringKey.MAGIC,</span>
<span class="nc" id="L1458">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERMAGIC.length() + 1)));</span>
<span class="nc" id="L1459">	}</span>

	private void parseCharacterDmNotesLine(final String line)
	{
<span class="nc" id="L1463">		thePC.setStringFor(PCStringKey.GMNOTES,</span>
<span class="nc" id="L1464">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERDMNOTES.length() + 1)));</span>
<span class="nc" id="L1465">	}</span>

	/*
	 * ###############################################################
	 * Character Bio methods
	 * ###############################################################
	 */
	private void parseCharacterNameLine(final String line)
	{
<span class="nc" id="L1474">		thePC.setPCAttribute(PCStringKey.NAME,</span>
<span class="nc" id="L1475">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERNAME.length() + 1)));</span>
<span class="nc" id="L1476">	}</span>

	private void parseCityLine(final String line)
	{
<span class="nc" id="L1480">		thePC.setPCAttribute(PCStringKey.CITY,</span>
<span class="nc" id="L1481">			EntityEncoder.decode(line.substring(IOConstants.TAG_CITY.length() + 1)));</span>
<span class="nc" id="L1482">	}</span>

	private void parseClassAbilitiesLevelLine(final String line, final List&lt;PCLevelInfo&gt; pcLevelInfoList)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L1490">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L1492">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L1494">			final String message =</span>
<span class="nc" id="L1495">					LanguageBundle.getFormattedString(</span>
						&quot;Warnings.PCGenParser.IllegalClassAbility&quot;, //$NON-NLS-1$
<span class="nc" id="L1497">				line, pcgpex.getMessage());</span>
<span class="nc" id="L1498">			warnings.add(message);</span>

<span class="nc" id="L1500">			return;</span>
<span class="nc" id="L1501">		}</span>

<span class="nc" id="L1503">		int level = -1;</span>
<span class="nc" id="L1504">		PCClass aPCClass = null;</span>
		PCGElement element;
<span class="nc" id="L1506">		PCLevelInfo pcl = null;</span>

<span class="nc" id="L1508">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

		// the first element defines the class key name and level
		// eg: Cleric=4
<span class="nc bnc" id="L1512" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L1514">			element = it.next();</span>

<span class="nc" id="L1516">			final int index = element.getText().indexOf('=');</span>

<span class="nc bnc" id="L1518" title="All 2 branches missed.">			if (index &lt; 0)</span>
			{
<span class="nc" id="L1520">				final String message =</span>
<span class="nc" id="L1521">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.InvalidClassLevel&quot;, //$NON-NLS-1$
<span class="nc" id="L1523">					element.getText());</span>
<span class="nc" id="L1524">				warnings.add(message);</span>

<span class="nc" id="L1526">				return;</span>
			}

<span class="nc" id="L1529">			final String classKeyName = EntityEncoder.decode(element.getText().substring(0, index));</span>
<span class="nc" id="L1530">			aPCClass = thePC.getClassKeyed(classKeyName);</span>

<span class="nc bnc" id="L1532" title="All 2 branches missed.">			if (aPCClass == null)</span>
			{
<span class="nc" id="L1534">				final String message =</span>
<span class="nc" id="L1535">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.ClassNotFound&quot;, //$NON-NLS-1$
					classKeyName);
<span class="nc" id="L1538">				warnings.add(message);</span>

<span class="nc" id="L1540">				return;</span>
			}

			try
			{
<span class="nc" id="L1545">				level = Integer.parseInt(element.getText().substring(index + 1));</span>
			}
<span class="nc" id="L1547">			catch (NumberFormatException nfe)</span>
			{
<span class="nc" id="L1549">				final String message =</span>
<span class="nc" id="L1550">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.InvalidClassLevel&quot;, //$NON-NLS-1$
<span class="nc" id="L1552">					element.getText());</span>
<span class="nc" id="L1553">				warnings.add(message);</span>

<span class="nc" id="L1555">				return;</span>
<span class="nc" id="L1556">			}</span>

<span class="nc bnc" id="L1558" title="All 2 branches missed.">			if (level &lt; 1)</span>
			{
<span class="nc" id="L1560">				final String message =</span>
<span class="nc" id="L1561">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.InvalidClassLevel&quot;, //$NON-NLS-1$
<span class="nc" id="L1563">					element.getText());</span>
<span class="nc" id="L1564">				warnings.add(message);</span>

<span class="nc" id="L1566">				return;</span>
			}

<span class="nc bnc" id="L1569" title="All 2 branches missed.">			for (PCLevelInfo info : pcLevelInfoList)</span>
			{
<span class="nc bnc" id="L1571" title="All 4 branches missed.">				if (classKeyName.equalsIgnoreCase(info.getClassKeyName()) &amp;&amp; level == info.getClassLevel())</span>
				{
<span class="nc" id="L1573">					pcl = info;</span>
<span class="nc" id="L1574">					break;</span>
				}
<span class="nc" id="L1576">			}</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">			if (pcl == null)</span>
			{
<span class="nc" id="L1579">				pcl = thePC.addLevelInfo(classKeyName);</span>
<span class="nc" id="L1580">				pcl.setClassLevel(level);</span>
			}
			else
			{
<span class="nc" id="L1584">				thePC.addLevelInfo(pcl);</span>
			}
<span class="nc" id="L1586">			pcl.setSkillPointsRemaining(0);</span>
		}

<span class="nc bnc" id="L1589" title="All 2 branches missed.">		while (it.hasNext())</span>
		{
<span class="nc" id="L1591">			element = it.next();</span>
<span class="nc" id="L1592">			String tag = element.getName();</span>

<span class="nc bnc" id="L1594" title="All 2 branches missed.">			if (IOConstants.TAG_SUBSTITUTIONLEVEL.equals(tag))</span>
			{
<span class="nc" id="L1596">				final String substitutionClassKeyName = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L1597">				SubstitutionClass aSubstitutionClass = aPCClass.getSubstitutionClassKeyed(substitutionClassKeyName);</span>

<span class="nc bnc" id="L1599" title="All 2 branches missed.">				if (aSubstitutionClass == null)</span>
				{
<span class="nc" id="L1601">					final String message =</span>
<span class="nc" id="L1602">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.ClassNotFound&quot;, //$NON-NLS-1$
						substitutionClassKeyName);
<span class="nc" id="L1605">					warnings.add(message);</span>

<span class="nc" id="L1607">					return;</span>
				}
<span class="nc" id="L1609">				SubstitutionLevelSupport.applyLevelArrayModsToLevel(aSubstitutionClass, aPCClass, level, thePC);</span>
<span class="nc" id="L1610">				thePC.setSubstitutionClassName(thePC.getActiveClassLevel(aPCClass, level), substitutionClassKeyName);</span>
<span class="nc" id="L1611">			}</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">			else if (IOConstants.TAG_HITPOINTS.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L1616">					PCClassLevel classLevel = thePC.getActiveClassLevel(aPCClass, level - 1);</span>
<span class="nc" id="L1617">					thePC.setHP(classLevel, Integer.valueOf(element.getText()));</span>
				}
<span class="nc" id="L1619">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L1621">					final String message =</span>
<span class="nc" id="L1622">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidHP&quot;, //$NON-NLS-1$
<span class="nc" id="L1624">						tag, element.getText());</span>
<span class="nc" id="L1625">					warnings.add(message);</span>
<span class="nc" id="L1626">				}</span>
			}
<span class="nc bnc" id="L1628" title="All 2 branches missed.">			else if (IOConstants.TAG_SAVES.equals(tag))</span>
			{
<span class="nc bnc" id="L1630" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L1632">					final String dString = EntityEncoder.decode(child.getText());</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">					if (dString.startsWith(IOConstants.TAG_BONUS + IOConstants.TAG_SEPARATOR))</span>
					{
<span class="nc" id="L1635">						String bonusString = dString.substring(6);</span>
<span class="nc" id="L1636">						int pipeLoc = bonusString.indexOf('|');</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">						if (pipeLoc != -1)</span>
						{
<span class="nc" id="L1639">							CDOMObject target = aPCClass;</span>
<span class="nc" id="L1640">							String potentialInt = bonusString.substring(0, pipeLoc);</span>
							try
							{
<span class="nc" id="L1643">								int bonusLevel = Integer.parseInt(potentialInt);</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">								if (bonusLevel &gt; 0)</span>
								{
<span class="nc" id="L1646">									target = thePC.getActiveClassLevel(aPCClass, bonusLevel);</span>
								}
<span class="nc" id="L1648">								bonusString = bonusString.substring(pipeLoc + 1);</span>
							}
<span class="nc" id="L1650">							catch (NumberFormatException e)</span>
							{
								//OK (no level embedded in file)
<span class="nc" id="L1653">								target = thePC.getActiveClassLevel(aPCClass, level);</span>
<span class="nc" id="L1654">							}</span>
<span class="nc" id="L1655">							BonusAddition.applyBonus(bonusString, &quot;&quot;, thePC, target);</span>
						}
					}
<span class="nc" id="L1658">				}</span>
			}
<span class="nc bnc" id="L1660" title="All 2 branches missed.">			else if (IOConstants.TAG_SPECIALTIES.equals(tag))</span>
			{
<span class="nc bnc" id="L1662" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L1664">					thePC.setAssoc(aPCClass, AssociationKey.SPECIALTY, EntityEncoder.decode(child.getText()));</span>
<span class="nc" id="L1665">				}</span>
			}
<span class="nc bnc" id="L1667" title="All 2 branches missed.">			else if (IOConstants.TAG_SPECIALABILITIES.equals(tag))</span>
			{
<span class="nc bnc" id="L1669" title="All 2 branches missed.">				for (PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L1671">					String specialAbilityName = EntityEncoder.decode(child.getText());</span>
<span class="nc bnc" id="L1672" title="All 6 branches missed.">					if (pcgenVersion[0] &lt;= 5 &amp;&amp; pcgenVersion[1] &lt;= 5 &amp;&amp; pcgenVersion[2] &lt; 6)</span>
					{
<span class="nc bnc" id="L1674" title="All 2 branches missed.">						if (specialAbilityName.equals(&quot;Turn Undead&quot;)) //$NON-NLS-1$</span>
						{
<span class="nc" id="L1676">							parseFeatLine(&quot;FEAT:Turn Undead|TYPE:SPECIAL.TURNUNDEAD|DESC:&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1677">							continue;</span>
						}
<span class="nc bnc" id="L1679" title="All 2 branches missed.">						else if (specialAbilityName.equals(&quot;Rebuke Undead&quot;)) //$NON-NLS-1$</span>
						{
<span class="nc" id="L1681">							parseFeatLine(&quot;FEAT:Rebuke Undead|TYPE:SPECIAL.TURNUNDEAD|DESC:&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1682">							continue;</span>
						}
					}
<span class="nc" id="L1685">					SpecialAbility specialAbility = new SpecialAbility(specialAbilityName);</span>

<span class="nc" id="L1687">					CDOMObject target = thePC.getActiveClassLevel(aPCClass, level);</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">					if (!thePC.hasSpecialAbility(specialAbilityName))</span>
					{
<span class="nc" id="L1691">						thePC.addUserSpecialAbility(specialAbility, target);</span>
					}
<span class="nc" id="L1693">				}</span>
			}
<span class="nc bnc" id="L1695" title="All 2 branches missed.">			else if (tag.equals(IOConstants.TAG_LEVELABILITY))</span>
			{
<span class="nc" id="L1697">				parseLevelAbilityInfo(element, aPCClass, level);</span>
			}
<span class="nc bnc" id="L1699" title="All 2 branches missed.">			else if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L1701">				parseAddTokenInfo(element, thePC.getActiveClassLevel(aPCClass, level));</span>
			}

			//
			// abbrev=score
			//
<span class="nc bnc" id="L1707" title="All 4 branches missed.">			else if (tag.equals(IOConstants.TAG_PRESTAT) || tag.equals(IOConstants.TAG_POSTSTAT))</span>
			{
<span class="nc" id="L1709">				boolean isPre = false;</span>

<span class="nc bnc" id="L1711" title="All 2 branches missed.">				if (tag.equals(IOConstants.TAG_PRESTAT))</span>
				{
<span class="nc" id="L1713">					isPre = true;</span>
				}

<span class="nc" id="L1716">				final int idx = element.getText().indexOf('=');</span>

<span class="nc bnc" id="L1718" title="All 2 branches missed.">				if (idx &gt; 0)</span>
				{
<span class="nc" id="L1720">					String statAbb = element.getText().substring(0, idx);</span>
<span class="nc" id="L1721">					final PCStat pcstat = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L1722">						.silentlyGetConstructedCDOMObject(PCStat.class, statAbb);</span>

<span class="nc bnc" id="L1724" title="All 2 branches missed.">					if (pcstat != null)</span>
					{
						try
						{
<span class="nc" id="L1728">							thePC.saveStatIncrease(pcstat, Integer.parseInt(element.getText().substring(idx + 1)),</span>
								isPre);
						}
<span class="nc" id="L1731">						catch (NumberFormatException nfe)</span>
						{
<span class="nc" id="L1733">							final String msg =</span>
<span class="nc" id="L1734">									LanguageBundle.getFormattedString(</span>
										&quot;Warnings.PCGenParser.InvalidStatMod&quot;, //$NON-NLS-1$
<span class="nc" id="L1736">								tag, element.getText());</span>
<span class="nc" id="L1737">							warnings.add(msg);</span>
<span class="nc" id="L1738">						}</span>
					}
					else
					{
<span class="nc" id="L1742">						final String msg =</span>
<span class="nc" id="L1743">								LanguageBundle.getFormattedString(</span>
									&quot;Warnings.PCGenParser.UnknownStat&quot;, //$NON-NLS-1$
<span class="nc" id="L1745">							tag, element.getText());</span>
<span class="nc" id="L1746">						warnings.add(msg);</span>
					}
<span class="nc" id="L1748">				}</span>
				else
				{
<span class="nc" id="L1751">					final String msg =</span>
<span class="nc" id="L1752">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.MissingEquals&quot;, //$NON-NLS-1$
<span class="nc" id="L1754">						tag, element.getText());</span>
<span class="nc" id="L1755">					warnings.add(msg);</span>
				}
<span class="nc" id="L1757">			}</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">			else if (IOConstants.TAG_SKILLPOINTSGAINED.equals(tag))</span>
			{
<span class="nc" id="L1760">				pcl.setFixedSkillPointsGained(Integer.parseInt(element.getText()));</span>
			}
<span class="nc bnc" id="L1762" title="All 2 branches missed.">			else if (IOConstants.TAG_SKILLPOINTSREMAINING.equals(tag))</span>
			{
<span class="nc" id="L1764">				pcl.setSkillPointsRemaining(Integer.parseInt(element.getText()));</span>
			}
<span class="nc bnc" id="L1766" title="All 2 branches missed.">			else if (IOConstants.TAG_DATA.equals(tag))</span>
			{
				// TODO
<span class="nc" id="L1769">				Logging.debugPrint(tag + &quot; equals + &quot; + IOConstants.TAG_DATA + &quot; TODO: we haven't processed this yet.&quot;);</span>
			}
			else
			{
<span class="nc" id="L1773">				final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.UnknownTag&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L1774">					tag, element.getText());</span>
<span class="nc" id="L1775">				warnings.add(msg);</span>
			}
<span class="nc" id="L1777">		}</span>

		// TODO:
		// process data
		//
		// need to add some consistency checks here to avoid
		// - duplicate entries for one and the same class/level pair
		// - missing entries for a given class/level pair
<span class="nc" id="L1785">	}</span>

	private void parseAddTokenInfo(PCGElement element, CDOMObject cdo)
	{
<span class="nc" id="L1789">		Iterator&lt;PCGElement&gt; it2 = element.getChildren().iterator();</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">		if (!it2.hasNext())</span>
		{
<span class="nc" id="L1792">			warnings.add(cdo.getDisplayName() + &quot;(&quot; + cdo.getClass().getName() + &quot;)\nInvalid save structure in ADD:&quot;);</span>
<span class="nc" id="L1793">			return;</span>
		}
<span class="nc" id="L1795">		PCGElement addType = it2.next();</span>
<span class="nc" id="L1796">		String name = addType.getName();</span>
<span class="nc" id="L1797">		String dString = EntityEncoder.decode(addType.getText());</span>

<span class="nc" id="L1799">		List&lt;PersistentTransitionChoice&lt;?&gt;&gt; addList = cdo.getListFor(ListKey.ADD);</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">		if (addList == null)</span>
		{
<span class="nc" id="L1802">			warnings.add(cdo.getDisplayName() + &quot;(&quot; + cdo.getClass().getName() + &quot;)\nCould not find any ADD: &quot; + name</span>
				+ &quot;|&quot; + dString);
<span class="nc" id="L1804">			return;</span>
		}
<span class="nc" id="L1806">		boolean found = false;</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">		for (PersistentTransitionChoice&lt;?&gt; tc : addList)</span>
		{
<span class="nc" id="L1809">			found |= processTransitionChoice(cdo, it2, name, dString, tc);</span>
<span class="nc" id="L1810">		}</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">		if (!found)</span>
		{
<span class="nc" id="L1813">			warnings.add(cdo.getDisplayName() + &quot;(&quot; + cdo.getClass().getName() + &quot;)\nCould not find matching ADD: &quot;</span>
				+ name + &quot;|&quot; + dString);
		}
<span class="nc" id="L1816">	}</span>

	private &lt;T&gt; boolean processTransitionChoice(CDOMObject cdo, Iterator&lt;PCGElement&gt; it2, String name, String dString,
		PersistentTransitionChoice&lt;T&gt; tc)
	{
<span class="nc" id="L1821">		SelectableSet&lt;? extends T&gt; choices = tc.getChoices();</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">		if (dString.equals(choices.getLSTformat()))</span>
		{
			//Match
<span class="nc bnc" id="L1825" title="All 2 branches missed.">			while (it2.hasNext())</span>
			{
<span class="nc" id="L1827">				String choice = EntityEncoder.decode(it2.next().getText());</span>
<span class="nc" id="L1828">				Object obj = tc.decodeChoice(Globals.getContext(), choice);</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">				if (obj == null)</span>
				{
<span class="nc" id="L1831">					warnings.add(cdo.getDisplayName() + &quot;(&quot; + cdo.getClass().getName() + &quot;)\nCould not decode &quot; + choice</span>
						+ &quot; for ADD: &quot; + name + &quot;|&quot; + dString);
				}
				else
				{
<span class="nc" id="L1836">					tc.restoreChoice(thePC, cdo, tc.castChoice(obj));</span>
				}
<span class="nc" id="L1838">			}</span>
<span class="nc" id="L1839">			return true;</span>
		}
		else
		{
<span class="nc" id="L1843">			return false;</span>
		}
	}

	/*
	 * ###############################################################
	 * Character Class(es) methods
	 * ###############################################################
	 */
	private void parseClassLine(final String line) throws PCGParseException
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L1858">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L1860">		catch (PCGParseException pcgpex)</span>
		{
			/*
			 * Classes are critical for characters,
			 * need to stop the load process
			 *
			 * Thomas Behr 14-08-02
			 */
<span class="nc" id="L1868">			throw new PCGParseException(&quot;parseClassLine&quot;, line, pcgpex.getMessage(), pcgpex); //$NON-NLS-1$</span>
<span class="nc" id="L1869">		}</span>

<span class="nc" id="L1871">		PCClass aPCClass = null;</span>
		String tag;
		PCGElement element;

<span class="nc" id="L1875">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

		// the first element defines the class key name!!!
<span class="nc bnc" id="L1878" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L1880">			element = it.next();</span>

<span class="nc" id="L1882">			String classKey = EntityEncoder.decode(element.getText());</span>
			// First check for an existing class, say from a racial casting ability
<span class="nc" id="L1884">			aPCClass = thePC.getClassKeyed(classKey);</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">			if (aPCClass == null)</span>
			{
<span class="nc" id="L1887">				aPCClass = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class,</span>
					classKey);

<span class="nc bnc" id="L1890" title="All 2 branches missed.">				if (aPCClass != null)</span>
				{
					// Icky: Need to redesign the way classes work!
					// Icky: Having to clone the class here is UGLY!
<span class="nc" id="L1894">					aPCClass = aPCClass.clone();</span>
				}
				else
				{
<span class="nc" id="L1898">					final String msg =</span>
<span class="nc" id="L1899">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.CouldntAddClass&quot;, //$NON-NLS-1$
<span class="nc" id="L1901">						element.getText());</span>
<span class="nc" id="L1902">					warnings.add(msg);</span>

<span class="nc" id="L1904">					return;</span>
				}
			}
		}

<span class="nc" id="L1909">		int level = -1;</span>
<span class="nc" id="L1910">		int skillPool = -1;</span>
<span class="nc" id="L1911">		String subClassKey = Constants.NONE;</span>

<span class="nc bnc" id="L1913" title="All 2 branches missed.">		while (it.hasNext())</span>
		{
<span class="nc" id="L1915">			element = it.next();</span>
<span class="nc" id="L1916">			tag = element.getName();</span>

<span class="nc bnc" id="L1918" title="All 2 branches missed.">			if (IOConstants.TAG_SUBCLASS.equals(tag))</span>
			{
<span class="nc" id="L1920">				subClassKey = EntityEncoder.decode(element.getText());</span>
<span class="nc bnc" id="L1921" title="All 4 branches missed.">				if ((!subClassKey.isEmpty()) &amp;&amp; !subClassKey.equals(Constants.NONE))</span>
				{
<span class="nc" id="L1923">					SubClass sc = aPCClass.getSubClassKeyed(subClassKey);</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">					if (sc == null)</span>
					{
<span class="nc bnc" id="L1926" title="All 2 branches missed.">						if (subClassKey.equals(aPCClass.getKeyName()))</span>
						{
<span class="nc" id="L1928">							subClassKey = Constants.NONE;</span>
						}
						else
						{
<span class="nc" id="L1932">							final String msg =</span>
<span class="nc" id="L1933">									LanguageBundle.getFormattedString(</span>
										&quot;Warnings.PCGenParser.InvalidSubclass&quot;, //$NON-NLS-1$
<span class="nc" id="L1935">								element.getText());</span>
<span class="nc" id="L1936">							warnings.add(msg);</span>
						}
					}
				}
			}

<span class="nc bnc" id="L1942" title="All 2 branches missed.">			if (IOConstants.TAG_LEVEL.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L1946">					level = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L1948">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L1950">					final String msg =</span>
<span class="nc" id="L1951">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidLevel&quot;, //$NON-NLS-1$
<span class="nc" id="L1953">						element.getText());</span>
<span class="nc" id="L1954">					warnings.add(msg);</span>
<span class="nc" id="L1955">				}</span>
			}
<span class="nc bnc" id="L1957" title="All 2 branches missed.">			else if (IOConstants.TAG_SKILLPOOL.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L1961">					skillPool = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L1963">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L1965">					final String msg =</span>
<span class="nc" id="L1966">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidSkillPool&quot;, //$NON-NLS-1$
<span class="nc" id="L1968">						element.getText());</span>
<span class="nc" id="L1969">					warnings.add(msg);</span>
<span class="nc" id="L1970">				}</span>
			}
<span class="nc bnc" id="L1972" title="All 2 branches missed.">			else if (IOConstants.TAG_CANCASTPERDAY.equals(tag))</span>
			{
				// TODO
<span class="nc" id="L1975">				Logging.debugPrint(tag + &quot; equals + &quot; + IOConstants.TAG_CANCASTPERDAY + &quot; TODO: we haven't processed this yet.&quot;);</span>
			}
<span class="nc bnc" id="L1977" title="All 2 branches missed.">			else if (IOConstants.TAG_SPELLBASE.equals(tag))</span>
			{
<span class="nc" id="L1979">				final String spellBase = EntityEncoder.decode(element.getText());</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">				if (!Constants.NONE.equals(spellBase))</span>
				{
<span class="nc" id="L1982">					Globals.getContext().unconditionallyProcess(aPCClass, &quot;SPELLSTAT&quot;, spellBase);</span>
				}
<span class="nc" id="L1984">			}</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">			else if (IOConstants.TAG_PROHIBITED.equals(tag))</span>
			{
<span class="nc" id="L1987">				String prohib = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L1988">				StringTokenizer st = new StringTokenizer(prohib, Constants.COMMA);</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">				while (st.hasMoreTokens())</span>
				{
<span class="nc" id="L1991">					String choice = st.nextToken();</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">					if (!&quot;None&quot;.equalsIgnoreCase(choice))</span>
					{
<span class="nc" id="L1994">						SpellProhibitor prohibSchool = new SpellProhibitor();</span>
<span class="nc" id="L1995">						prohibSchool.setType(ProhibitedSpellType.SCHOOL);</span>
<span class="nc" id="L1996">						prohibSchool.addValue(choice);</span>
<span class="nc" id="L1997">						SpellProhibitor prohibSubSchool = new SpellProhibitor();</span>
<span class="nc" id="L1998">						prohibSubSchool.setType(ProhibitedSpellType.SUBSCHOOL);</span>
<span class="nc" id="L1999">						prohibSubSchool.addValue(choice);</span>
<span class="nc" id="L2000">						thePC.addProhibitedSchool(prohibSchool, aPCClass);</span>
<span class="nc" id="L2001">						thePC.addProhibitedSchool(prohibSubSchool, aPCClass);</span>
					}
<span class="nc" id="L2003">				}</span>
<span class="nc" id="L2004">			}</span>
		}

<span class="nc bnc" id="L2007" title="All 2 branches missed.">		if (level &gt; -1)</span>
		{
<span class="nc" id="L2009">			thePC.addClass(aPCClass);</span>

<span class="nc bnc" id="L2011" title="All 4 branches missed.">			if (StringUtils.isNotBlank(subClassKey) &amp;&amp; !subClassKey.equals(Constants.NONE))</span>
			{
<span class="nc" id="L2013">				SubClassApplication.setSubClassKey(thePC, aPCClass, subClassKey);</span>
			}

<span class="nc bnc" id="L2016" title="All 2 branches missed.">			for (int i = 0; i &lt; level; ++i)</span>
			{
<span class="nc" id="L2018">				thePC.addLevelInfo(aPCClass.getKeyName());</span>
<span class="nc" id="L2019">				aPCClass.addLevel(false, false, thePC, true);</span>

			}
		}

		//Must process ADD after CLASS is added to the PC
<span class="nc bnc" id="L2025" title="All 2 branches missed.">		for (PCGElement e : new PCGTokenizer(line).getElements())</span>
		{
<span class="nc" id="L2027">			tag = e.getName();</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">			if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L2030">				parseAddTokenInfo(e, aPCClass);</span>
			}
<span class="nc" id="L2032">		}</span>

<span class="nc bnc" id="L2034" title="All 2 branches missed.">		if (skillPool &gt; -1)</span>
		{
<span class="nc" id="L2036">			thePC.setSkillPool(aPCClass, skillPool);</span>
		}
<span class="nc" id="L2038">	}</span>

	/**
	 * ###############################################################
	 * Character Deity/Domain methods
	 * ###############################################################
	 * @param line
	 **/
	private void parseDeityLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2052">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2054">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2056">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalDeity&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2057">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2058">			warnings.add(msg);</span>

<span class="nc" id="L2060">			return;</span>
<span class="nc" id="L2061">		}</span>

<span class="nc" id="L2063">		final String deityKey = EntityEncoder.decode(tokens.getElements().get(0).getText());</span>

		Deity aDeity =
<span class="nc" id="L2066">				Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Deity.class, deityKey);</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">		if (aDeity != null)</span>
		{
<span class="nc" id="L2069">			ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
				CControl.DEITYINPUT, aDeity);
		}
<span class="nc bnc" id="L2072" title="All 2 branches missed.">		else if (!Constants.NONE.equals(deityKey))</span>
		{
			// TODO
			// create Deity object from information contained in pcg
			// for now issue a warning
<span class="nc" id="L2077">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.DeityNotFound&quot;, //$NON-NLS-1$</span>
				deityKey);
<span class="nc" id="L2079">			warnings.add(msg);</span>
		}
<span class="nc" id="L2081">	}</span>

	private void parseDomainLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2089">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2091">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2093">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalDomain&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2094">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2095">			warnings.add(msg);</span>

<span class="nc" id="L2097">			return;</span>
<span class="nc" id="L2098">		}</span>

<span class="nc" id="L2100">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

<span class="nc bnc" id="L2102" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2104">			PCGElement element = it.next();</span>

			// the first element defines the domain name
<span class="nc" id="L2107">			final String domainKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2108">			final Domain aDomain = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L2109">				.silentlyGetConstructedCDOMObject(Domain.class, domainKey);</span>

<span class="nc bnc" id="L2111" title="All 4 branches missed.">			if ((aDomain == null) &amp;&amp; (!Constants.NONE.equals(domainKey)))</span>
			{
				// TODO
				// create Domain object from
				// information contained in pcg
				// But for now just issue a warning
<span class="nc" id="L2117">				final String msg = </span>
<span class="nc" id="L2118">						LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.DomainNotFound&quot;, //$NON-NLS-1$</span>
							domainKey);
<span class="nc" id="L2120">				warnings.add(msg);</span>
<span class="nc" id="L2121">			}</span>
<span class="nc bnc" id="L2122" title="All 4 branches missed.">			else if (!thePC.hasDomain(aDomain) &amp;&amp; (!Constants.NONE.equals(domainKey)))</span>
			{
				// PC doesn't have the domain, so create a new
				// one and add it to the PC domain list
<span class="nc" id="L2126">				ClassSource source = null;</span>

<span class="nc" id="L2128">				String fullassoc = null;</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">				while (it.hasNext())</span>
				{
<span class="nc" id="L2131">					element = it.next();</span>
<span class="nc" id="L2132">					String tag = element.getName();</span>

<span class="nc bnc" id="L2134" title="All 2 branches missed.">					if (IOConstants.TAG_SOURCE.equals(tag))</span>
					{
<span class="nc" id="L2136">						source = getDomainSource(sourceElementToString(element));</span>
					}
<span class="nc bnc" id="L2138" title="All 2 branches missed.">					else if (IOConstants.TAG_ASSOCIATEDDATA.equals(tag))</span>
					{
<span class="nc bnc" id="L2140" title="All 2 branches missed.">						if (fullassoc != null)</span>
						{
<span class="nc" id="L2142">							warnings.add(&quot;Found multiple selections for Domain: &quot; + aDomain.getKeyName());</span>
						}
<span class="nc" id="L2144">						fullassoc = EntityEncoder.decode(element.getText());</span>
					}
<span class="nc bnc" id="L2146" title="All 2 branches missed.">					else if (tag.equals(IOConstants.TAG_DOMAINGRANTS))</span>
					{
<span class="nc" id="L2148">						Logging.debugPrint(tag + &quot; equals + &quot; + IOConstants.TAG_DOMAINGRANTS + &quot; - ignoring.&quot;);</span>
					}
<span class="nc bnc" id="L2150" title="All 2 branches missed.">					else if (!tag.equals(IOConstants.TAG_ADDTOKEN))</span>
					{
<span class="nc" id="L2152">						final String msg =</span>
<span class="nc" id="L2153">								LanguageBundle.getFormattedString(</span>
									&quot;Warnings.PCGenParser.UnknownDomainInfo&quot;, //$NON-NLS-1$
<span class="nc" id="L2155">							tag + &quot;:&quot; + element.getText());</span>
<span class="nc" id="L2156">						warnings.add(msg);</span>
					}
<span class="nc" id="L2158">				}</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">				if (source == null)</span>
				{
<span class="nc" id="L2161">					warnings.add(&quot;Domain not added due to no source: &quot; + domainKey);</span>
				}
				else
				{
<span class="nc" id="L2165">					domainInputFacet.importSelection(thePC.getCharID(), aDomain, fullassoc, source);</span>
<span class="nc" id="L2166">					DomainApplication.applyDomain(thePC, aDomain);</span>
				}
				try
				{
					//Must process ADD after DOMAIN is added to the PC
<span class="nc bnc" id="L2171" title="All 2 branches missed.">					for (PCGElement e : new PCGTokenizer(line).getElements())</span>
					{
<span class="nc" id="L2173">						String tag = e.getName();</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">						if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
						{
<span class="nc" id="L2176">							parseAddTokenInfo(e, aDomain);</span>
						}
<span class="nc" id="L2178">					}</span>
				}
<span class="nc" id="L2180">				catch (PCGParseException pcgpex)</span>
				{
<span class="nc" id="L2182">					final String msg =</span>
<span class="nc" id="L2183">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.IllegalDomain&quot;, //$NON-NLS-1$
<span class="nc" id="L2185">						line, pcgpex.getMessage());</span>
<span class="nc" id="L2186">					warnings.add(msg);</span>

<span class="nc" id="L2188">					return;</span>
<span class="nc" id="L2189">				}</span>
<span class="nc" id="L2190">			}</span>
			else
			{
				// PC already has this domain
<span class="nc" id="L2194">				Logging.errorPrintLocalised(&quot;Errors.PCGenParser.DuplicateDomain&quot;, //$NON-NLS-1$</span>
					domainKey);
			}
		}
<span class="nc" id="L2198">	}</span>

	/**
	 * ###############################################################
	 * EquipSet Temp Bonuses
	 * ###############################################################
	 * @param line
	 **/
	private void parseEquipSetTempBonusLine(final String line)
	{
		PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2212">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2214">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2216">			final String msg =</span>
<span class="nc" id="L2217">					LanguageBundle.getFormattedString(</span>
						&quot;Warnings.PCGenParser.IllegalEquipSetTempBonus&quot;, //$NON-NLS-1$
<span class="nc" id="L2219">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2220">			warnings.add(msg);</span>

<span class="nc" id="L2222">			return;</span>
<span class="nc" id="L2223">		}</span>

		String tag;
<span class="nc" id="L2226">		String tagString = null;</span>

<span class="nc bnc" id="L2228" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L2230">			tag = element.getName();</span>

<span class="nc bnc" id="L2232" title="All 2 branches missed.">			if (IOConstants.TAG_EQSETBONUS.equals(tag))</span>
			{
<span class="nc" id="L2234">				tagString = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc" id="L2236">		}</span>

<span class="nc bnc" id="L2238" title="All 2 branches missed.">		if (tagString == null)</span>
		{
<span class="nc" id="L2240">			final String msg =</span>
<span class="nc" id="L2241">					LanguageBundle.getFormattedString(</span>
						&quot;Warnings.PCGenParser.InvalidEquipSetTempBonus&quot;, //$NON-NLS-1$
				line);
<span class="nc" id="L2244">			warnings.add(msg);</span>

<span class="nc" id="L2246">			return;</span>
		}

<span class="nc" id="L2249">		final EquipSet eSet = thePC.getEquipSetByIdPath(tagString);</span>

<span class="nc bnc" id="L2251" title="All 2 branches missed.">		if (eSet == null)</span>
		{
<span class="nc" id="L2253">			return;</span>
		}

		//# EquipSet Temp Bonuses
		//EQSETBONUS:0.2|TEMPBONUS:NAME=Haste|TBTARGET:PC|TEMPBONUS:SPELL=Shield of Faith|TBTARGET:PC
<span class="nc" id="L2258">		final Map&lt;BonusObj, BonusManager.TempBonusInfo&gt; aList = new IdentityHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2260" title="All 2 branches missed.">		for (final PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L2262">			tag = element.getName();</span>

<span class="nc bnc" id="L2264" title="All 2 branches missed.">			if (IOConstants.TAG_TEMPBONUSBONUS.equals(tag))</span>
			{
<span class="nc" id="L2266">				final String aString = EntityEncoder.decode(element.getText());</span>

				// Parse aString looking for
				// TEMPBONUS and TBTARGET pairs
<span class="nc" id="L2270">				StringTokenizer aTok = new StringTokenizer(aString, IOConstants.TAG_SEPARATOR);</span>

<span class="nc bnc" id="L2272" title="All 2 branches missed.">				if (aTok.countTokens() &lt; 2)</span>
				{
<span class="nc" id="L2274">					continue;</span>
				}

<span class="nc" id="L2277">				String sName = aTok.nextToken();</span>
<span class="nc" id="L2278">				String tName = aTok.nextToken();</span>
<span class="nc" id="L2279">				aList.putAll(getBonusFromName(sName, tName));</span>
			}
<span class="nc" id="L2281">		}</span>

<span class="nc" id="L2283">		eSet.setTempBonusList(aList);</span>
<span class="nc" id="L2284">	}</span>

	private void parseCharacterTypeLine(final String line)
	{
<span class="nc" id="L2288">		final StringTokenizer stok = new StringTokenizer(line.substring(IOConstants.TAG_CHARACTERTYPE.length() + 1),</span>
			IOConstants.TAG_END, false);

<span class="nc" id="L2291">		String characterType = stok.nextToken();</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">		if (!SettingsHandler.getGameAsProperty().get().getCharacterTypeList().contains(characterType))</span>
		{
<span class="nc" id="L2294">			String wantedType = characterType;</span>
<span class="nc" id="L2295">			characterType = SettingsHandler.getGameAsProperty().get().getDefaultCharacterType();</span>
<span class="nc" id="L2296">			final String message = &quot;Character type &quot; + wantedType + &quot; not found. Using &quot; + characterType; //$NON-NLS-1$</span>
<span class="nc" id="L2297">			warnings.add(message);</span>
		}
<span class="nc" id="L2299">		ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
			CControl.CHARACTERTYPE, characterType);
<span class="nc" id="L2301">	}</span>

	private void parsePreviewSheetLine(final String line)
	{
<span class="nc" id="L2305">		final StringTokenizer stok = new StringTokenizer(line.substring(IOConstants.TAG_PREVIEWSHEET.length() + 1),</span>
				IOConstants.TAG_END, false);

<span class="nc" id="L2308">		thePC.setPreviewSheet(stok.nextToken());</span>
<span class="nc" id="L2309">	}</span>

	private void parsePreviewSheetVarLine(final String line)
	{
<span class="nc" id="L2313">		final String subLine = line.substring(IOConstants.TAG_PREVIEWSHEETVAR.length() + 1);</span>
<span class="nc" id="L2314">		final StringTokenizer stok = new StringTokenizer(subLine, IOConstants.TAG_SEPARATOR, false);</span>

<span class="nc" id="L2316">		thePC.addPreviewSheetVar(stok.nextToken(), stok.nextToken());</span>
<span class="nc" id="L2317">	}</span>

	/*
	 * ###############################################################
	 * Character Experience methods
	 * ###############################################################
	 */
	private void parseExperienceLine(final String line) throws PCGParseException
	{

		try
		{
<span class="nc" id="L2329">			final StringTokenizer stok = new StringTokenizer(line.substring(IOConstants.TAG_EXPERIENCE.length() + 1),</span>
				IOConstants.TAG_END, false);
<span class="nc" id="L2331">			thePC.setXP(Integer.parseInt(stok.nextToken()));</span>
		}
<span class="nc" id="L2333">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L2335">			throw new PCGParseException(&quot;parseExperienceLine&quot;, line, nfe.getMessage(), nfe); //$NON-NLS-1$</span>
<span class="nc" id="L2336">		}</span>
<span class="nc" id="L2337">	}</span>

	private void parseExperienceTableLine(final String line)
	{
<span class="nc" id="L2341">		final StringTokenizer stok = new StringTokenizer(line.substring(IOConstants.TAG_EXPERIENCETABLE.length() + 1),</span>
			IOConstants.TAG_END, false);

<span class="nc" id="L2344">		String xpTableName = stok.nextToken();</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">		if (!SettingsHandler.getGameAsProperty().get().getXPTableNames().contains(xpTableName))</span>
		{
<span class="nc" id="L2347">			String wantedName = xpTableName;</span>
<span class="nc" id="L2348">			xpTableName = SettingsHandler.getGameAsProperty().get().getDefaultXPTableName();</span>
<span class="nc" id="L2349">			final String message = &quot;XP table &quot; + wantedName + &quot; not found. Using &quot; + xpTableName; //$NON-NLS-1$</span>
<span class="nc" id="L2350">			warnings.add(message);</span>
		}
<span class="nc" id="L2352">		thePC.setXPTable(xpTableName);</span>
<span class="nc" id="L2353">	}</span>

	private void parseEyeColorLine(final String line)
	{
<span class="nc" id="L2357">		thePC.setEyeColor(EntityEncoder.decode(line.substring(IOConstants.TAG_EYECOLOR.length() + 1)));</span>
<span class="nc" id="L2358">	}</span>

	/*
	 * ###############################################################
	 * Character Ability methods
	 * ###############################################################
	 */

	private void parseAbilityLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2372">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2374">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2376">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalAbility&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2377">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2378">			warnings.add(msg);</span>

<span class="nc" id="L2380">			return;</span>
<span class="nc" id="L2381">		}</span>

<span class="nc" id="L2383">		AbilityCategory category = null;</span>
<span class="nc" id="L2384">		Nature nature = Nature.NORMAL;</span>
<span class="nc" id="L2385">		String abilityCat = null;</span>
<span class="nc" id="L2386">		Ability ability = null;</span>
<span class="nc" id="L2387">		String missingCat = null;</span>

<span class="nc" id="L2389">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

		// the first element defines the AbilityCategory key name
<span class="nc bnc" id="L2392" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2394">			final PCGElement element = it.next();</span>

<span class="nc" id="L2396">			final String categoryKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2397">			category = SettingsHandler.getGameAsProperty().get().getAbilityCategory(categoryKey);</span>
<span class="nc bnc" id="L2398" title="All 2 branches missed.">			if (category == null)</span>
			{
<span class="nc" id="L2400">				missingCat = categoryKey;</span>
			}
		}

		// The next element will be the nature
<span class="nc bnc" id="L2405" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2407">			final PCGElement element = it.next();</span>

<span class="nc" id="L2409">			final String natureKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2410">			nature = Nature.valueOf(natureKey);</span>
		}

		// The next element will be the ability's innate category
<span class="nc bnc" id="L2414" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2416">			final PCGElement element = it.next();</span>

<span class="nc" id="L2418">			abilityCat = EntityEncoder.decode(element.getText());</span>
		}

		// The next element will be the ability key
<span class="nc bnc" id="L2422" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2424">			final PCGElement element = it.next();</span>

<span class="nc" id="L2426">			String abilityKey = EntityEncoder.decode(element.getText());</span>
			// Check for an ability that has been updated.
<span class="nc" id="L2428">			CategorisedKey categorisedKey = AbilityMigration.getNewAbilityKey(abilityCat, abilityKey, pcgenVersion,</span>
<span class="nc" id="L2429">				SettingsHandler.getGameAsProperty().get().getName());</span>
<span class="nc" id="L2430">			abilityCat = categorisedKey.getCategory();</span>
<span class="nc" id="L2431">			abilityKey = categorisedKey.getKey();</span>
<span class="nc" id="L2432">			AbilityCategory innateCategory = SettingsHandler.getGameAsProperty().get().getAbilityCategory(abilityCat);</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">			if (innateCategory == null)</span>
			{
<span class="nc" id="L2435">				missingCat = abilityCat;</span>
			}

<span class="nc bnc" id="L2438" title="All 4 branches missed.">			if (innateCategory == null || category == null)</span>
			{
<span class="nc" id="L2440">				final String msg =</span>
<span class="nc" id="L2441">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.AbilityCategoryNotFound&quot;, //$NON-NLS-1$
					abilityKey, missingCat);
<span class="nc" id="L2444">				warnings.add(msg);</span>
<span class="nc" id="L2445">				return;</span>
			}
<span class="nc" id="L2447">			ability = Globals.getContext().getReferenceContext().getManufacturerId(innateCategory)</span>
<span class="nc" id="L2448">				.getActiveObject(abilityKey);</span>
<span class="nc bnc" id="L2449" title="All 2 branches missed.">			if (ability == null)</span>
			{
<span class="nc" id="L2451">				warnings.add(&quot;Unable to Find Ability: &quot; + abilityKey);</span>
<span class="nc" id="L2452">				return;</span>
			}
		}
<span class="nc" id="L2455">		List&lt;String&gt; associations = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2456">		List&lt;BonusObj&gt; bonuses = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2457" title="All 2 branches missed.">		while (it.hasNext())</span>
		{
<span class="nc" id="L2459">			final PCGElement element = it.next();</span>
<span class="nc" id="L2460">			final String tag = element.getName();</span>

<span class="nc bnc" id="L2462" title="All 2 branches missed.">			if (tag.equals(IOConstants.TAG_APPLIEDTO))</span>
			{
<span class="nc" id="L2464">				associations.add(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L2466" title="All 2 branches missed.">			else if (IOConstants.TAG_SAVE.equals(tag))</span>
			{
<span class="nc" id="L2468">				final String saveKey = EntityEncoder.decode(element.getText());</span>

				// TODO - This never gets written to the file
<span class="nc bnc" id="L2471" title="All 4 branches missed.">				if (saveKey.startsWith(IOConstants.TAG_BONUS) &amp;&amp; (saveKey.length() &gt; 6))</span>
				{
<span class="nc" id="L2473">					final BonusObj aBonus = Bonus.newBonus(Globals.getContext(), saveKey.substring(6));</span>

<span class="nc bnc" id="L2475" title="All 2 branches missed.">					if (aBonus != null)</span>
					{
<span class="nc" id="L2477">						bonuses.add(aBonus);</span>
					}
<span class="nc" id="L2479">				}</span>
				else
				{
<span class="nc bnc" id="L2482" title="All 2 branches missed.">					if (Logging.isDebugMode())</span>
					{
<span class="nc" id="L2484">						Logging.debugPrint(&quot;Ignoring SAVE:&quot; + saveKey);</span>
					}
				}
			}
<span class="nc" id="L2488">		}</span>
<span class="nc bnc" id="L2489" title="All 4 branches missed.">		if (ability != null &amp;&amp; category != null)</span>
		{
<span class="nc" id="L2491">			CNAbility cna = null;</span>
<span class="nc" id="L2492">			boolean needError = true;</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">			if (nature == Nature.NORMAL)</span>
			{
				// If we weren't loading an old character who had feats stored as seperate
				// lines, save the feat now.
<span class="nc bnc" id="L2497" title="All 4 branches missed.">				if (!featsPresent || category != AbilityCategory.FEAT)</span>
				{
					try
					{
<span class="nc" id="L2501">						cna = CNAbilityFactory.getCNAbility(category, nature, ability);</span>
					}
<span class="nc" id="L2503">					catch (IllegalArgumentException e)</span>
					{
<span class="nc" id="L2505">						Logging.log(Logging.INFO, &quot;Unabe to parse ability line: &quot; + e.getMessage());</span>
<span class="nc" id="L2506">					}</span>
				}
				else
				{
<span class="nc" id="L2510">					needError = false;</span>
				}
			}
<span class="nc bnc" id="L2513" title="All 2 branches missed.">			else if (nature == Nature.VIRTUAL)</span>
			{
<span class="nc" id="L2515">				cna = CNAbilityFactory.getCNAbility(category, nature, ability);</span>
			}
<span class="nc bnc" id="L2517" title="All 2 branches missed.">			if (cna == null)</span>
			{
<span class="nc bnc" id="L2519" title="All 2 branches missed.">				if (needError)</span>
				{
<span class="nc" id="L2521">					warnings.add(&quot;Unable to build Ability: &quot; + ability);</span>
				}
			}
			else
			{
<span class="nc bnc" id="L2526" title="All 2 branches missed.">				if (ability.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
				{
<span class="nc bnc" id="L2528" title="All 2 branches missed.">					for (String appliedToKey : associations)</span>
					{
<span class="nc" id="L2530">						String[] assoc = appliedToKey.split(Constants.COMMA, -1);</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">						for (String string : assoc)</span>
						{
<span class="nc" id="L2533">							CNAbilitySelection cnas = new CNAbilitySelection(cna, string);</span>
							try
							{
<span class="nc bnc" id="L2536" title="All 2 branches missed.">								if (nature == Nature.VIRTUAL)</span>
								{
<span class="nc" id="L2538">									thePC.addSavedAbility(cnas, UserSelection.getInstance(),</span>
<span class="nc" id="L2539">										UserSelection.getInstance());</span>
								}
								else
								{
<span class="nc" id="L2543">									thePC.addAbility(cnas, UserSelection.getInstance(), UserSelection.getInstance());</span>
								}
							}
<span class="nc" id="L2546">							catch (IllegalArgumentException e)</span>
							{
<span class="nc" id="L2548">								Logging.errorPrint(&quot;PCGVer2Parser.parseAbilityLine failed&quot;, e);</span>

<span class="nc" id="L2550">								warnings.add(cna + &quot; with selection: &quot; + string + &quot; is no longer valid.&quot;);</span>
<span class="nc" id="L2551">							}</span>
						}
<span class="nc" id="L2553">					}</span>
				}
				else
				{
<span class="nc bnc" id="L2557" title="All 2 branches missed.">					if (!associations.isEmpty())</span>
					{
<span class="nc" id="L2559">						warnings.add(cna + &quot; found with selections: &quot; + associations + &quot; but is MULT:NO in the data&quot;);</span>
					}
<span class="nc" id="L2561">					CNAbilitySelection cnas = new CNAbilitySelection(cna);</span>
<span class="nc bnc" id="L2562" title="All 2 branches missed.">					if (nature == Nature.VIRTUAL)</span>
					{
<span class="nc" id="L2564">						thePC.addSavedAbility(cnas, UserSelection.getInstance(), UserSelection.getInstance());</span>
					}
					else
					{
<span class="nc" id="L2568">						thePC.addAbility(cnas, UserSelection.getInstance(), UserSelection.getInstance());</span>
					}
				}
<span class="nc bnc" id="L2571" title="All 2 branches missed.">				for (BonusObj b : bonuses)</span>
				{
<span class="nc" id="L2573">					thePC.addSaveableBonus(b, cna.getAbility());</span>
<span class="nc" id="L2574">				}</span>
			}
		}
<span class="nc" id="L2577">	}</span>

	/*
	 * ###############################################################
	 * Character Feats methods
	 * ###############################################################
	 */
	private void parseFeatLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2590">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2592">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2594">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalFeat&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2595">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2596">			warnings.add(msg);</span>

<span class="nc" id="L2598">			return;</span>
<span class="nc" id="L2599">		}</span>

<span class="nc" id="L2601">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

		// the first element defines the Ability key name
<span class="nc bnc" id="L2604" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L2606">			final PCGElement element = it.next();</span>

<span class="nc" id="L2608">			final String abilityKey = EntityEncoder.decode(element.getText());</span>

			/* First, check to see if the PC already has this ability. If so,
			 * then we just need to mod it. Otherwise we need to create a new
			 * one and add it using non-aggregate (when using aggregate, we
			 * get clones of the PCs actual feats, which don't get saved or
			 * preserved) */
<span class="nc" id="L2615">			Ability anAbility = Globals.getContext().getReferenceContext().getManufacturerId(AbilityCategory.FEAT)</span>
<span class="nc" id="L2616">				.getActiveObject(abilityKey);</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">			if (anAbility == null)</span>
			{
<span class="nc" id="L2619">				final String msg =</span>
<span class="nc" id="L2620">						LanguageBundle.getFormattedString(</span>
							&quot;Warnings.PCGenParser.CouldntAddAbility&quot;, //$NON-NLS-1$
					abilityKey);
<span class="nc" id="L2623">				warnings.add(msg);</span>

<span class="nc" id="L2625">				return;</span>
			}

<span class="nc" id="L2628">			CNAbility pcAbility = CNAbilityFactory.getCNAbility(AbilityCategory.FEAT, Nature.NORMAL, anAbility);</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">			if (!anAbility.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
			{
<span class="nc" id="L2631">				thePC.addAbility(new CNAbilitySelection(pcAbility), UserSelection.getInstance(),</span>
<span class="nc" id="L2632">					UserSelection.getInstance());</span>
			}
<span class="nc" id="L2634">			parseFeatsHandleAppliedToAndSaveTags(it, pcAbility);</span>
<span class="nc" id="L2635">			featsPresent = true;</span>
		}
<span class="nc" id="L2637">	}</span>

	private void parseFeatPoolLine(final String line)
	{
		try
		{
<span class="nc" id="L2643">			double featPool = Double.parseDouble(line.substring(IOConstants.TAG_FEATPOOL.length() + 1));</span>
			// In earlier versions the featpool included the bonus, so we need to counter it
<span class="nc bnc" id="L2645" title="All 2 branches missed.">			if (compareVersionTo(new int[]{5, 11, 1}) &lt; 0)</span>
			{
<span class="nc" id="L2647">				calcFeatPoolAfterLoad = true;</span>
<span class="nc" id="L2648">				baseFeatPool = featPool;</span>
			}
			else
			{
<span class="nc" id="L2652">				thePC.setUserPoolBonus(AbilityCategory.FEAT, new BigDecimal(String.valueOf(featPool)));</span>
			}
		}
<span class="nc" id="L2655">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L2657">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalFeatPool&quot;, //$NON-NLS-1$</span>
				line);
<span class="nc" id="L2659">			warnings.add(msg);</span>
<span class="nc" id="L2660">		}</span>
<span class="nc" id="L2661">	}</span>

	private void parseUserPoolLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2669">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2671">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2673">			final String msg =</span>
<span class="nc" id="L2674">					LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalAbilityPool&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2675">						line, pcgpex.getMessage());</span>
<span class="nc" id="L2676">			warnings.add(msg);</span>

<span class="nc" id="L2678">			return;</span>
<span class="nc" id="L2679">		}</span>

<span class="nc" id="L2681">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>
<span class="nc" id="L2682">		final String cat = EntityEncoder.decode(it.next().getText());</span>
<span class="nc" id="L2683">		final AbilityCategory category = SettingsHandler.getGameAsProperty().get().getAbilityCategory(cat);</span>
		try
		{
<span class="nc" id="L2686">			thePC.setUserPoolBonus(category, new BigDecimal(it.next().getText()));</span>
		}
<span class="nc" id="L2688">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L2690">			final String msg =</span>
<span class="nc" id="L2691">					LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalAbilityPool&quot;, //$NON-NLS-1$</span>
						line);
<span class="nc" id="L2693">			warnings.add(msg);</span>
<span class="nc" id="L2694">		}</span>
<span class="nc" id="L2695">	}</span>

	private void parseFeatsHandleAppliedToAndSaveTags(final Iterator&lt;PCGElement&gt; it, final CNAbility cna)
	{
<span class="nc" id="L2699">		Ability aFeat = cna.getAbility();</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">		while (it.hasNext())</span>
		{
<span class="nc" id="L2702">			final PCGElement element = it.next();</span>
<span class="nc" id="L2703">			final String tag = element.getName();</span>

<span class="nc bnc" id="L2705" title="All 2 branches missed.">			if (IOConstants.TAG_APPLIEDTO.equals(tag))</span>
			{
<span class="nc" id="L2707">				final String appliedToKey = EntityEncoder.decode(element.getText());</span>

<span class="nc bnc" id="L2709" title="All 2 branches missed.">				if (aFeat.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
				{
<span class="nc" id="L2711">					String[] assoc = appliedToKey.split(Constants.COMMA, -1);</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">					for (String string : assoc)</span>
					{
<span class="nc" id="L2714">						CNAbilitySelection cnas = new CNAbilitySelection(cna, string);</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">						if (cna.getNature() == Nature.VIRTUAL)</span>
						{
<span class="nc" id="L2717">							thePC.addSavedAbility(cnas, UserSelection.getInstance(), UserSelection.getInstance());</span>
						}
						else
						{
<span class="nc" id="L2721">							thePC.addAbility(cnas, UserSelection.getInstance(), UserSelection.getInstance());</span>
						}
					}
				}
<span class="nc" id="L2725">			}</span>
<span class="nc bnc" id="L2726" title="All 2 branches missed.">			else if (IOConstants.TAG_SAVE.equals(tag))</span>
			{
<span class="nc" id="L2728">				final String saveKey = EntityEncoder.decode(element.getText());</span>

<span class="nc bnc" id="L2730" title="All 4 branches missed.">				if (saveKey.startsWith(IOConstants.TAG_BONUS) &amp;&amp; (saveKey.length() &gt; 6))</span>
				{
<span class="nc" id="L2732">					final BonusObj aBonus = Bonus.newBonus(Globals.getContext(), saveKey.substring(6));</span>

<span class="nc bnc" id="L2734" title="All 2 branches missed.">					if (aBonus != null)</span>
					{
<span class="nc" id="L2736">						thePC.addSaveableBonus(aBonus, aFeat);</span>
					}
<span class="nc" id="L2738">				}</span>
				else
				{
<span class="nc bnc" id="L2741" title="All 2 branches missed.">					if (Logging.isDebugMode())</span>
					{
<span class="nc" id="L2743">						Logging.debugPrint(&quot;Ignoring SAVE:&quot; + saveKey);</span>
					}
				}
<span class="nc" id="L2746">			}</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">			else if (tag.equals(IOConstants.TAG_LEVELABILITY))</span>
			{
<span class="nc" id="L2749">				parseLevelAbilityInfo(element, aFeat);</span>
			}
<span class="nc bnc" id="L2751" title="All 2 branches missed.">			else if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L2753">				parseAddTokenInfo(element, aFeat);</span>
			}
<span class="nc" id="L2755">		}</span>
<span class="nc" id="L2756">	}</span>

	/*
	 * ###############################################################
	 * Character Follower methods
	 * ###############################################################
	 */
	private void parseFollowerLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L2769">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L2771">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L2773">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalFollower&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L2774">				line, pcgpex.getMessage());</span>
<span class="nc" id="L2775">			warnings.add(msg);</span>

<span class="nc" id="L2777">			return;</span>
<span class="nc" id="L2778">		}</span>

<span class="nc" id="L2780">		final Follower aFollower = new Follower(Constants.EMPTY_STRING, Constants.EMPTY_STRING, null);</span>

<span class="nc bnc" id="L2782" title="All 2 branches missed.">		for (final PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L2784">			final String tag = element.getName();</span>

<span class="nc bnc" id="L2786" title="All 2 branches missed.">			if (IOConstants.TAG_FOLLOWER.equals(tag))</span>
			{
<span class="nc" id="L2788">				aFollower.setName(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L2790" title="All 2 branches missed.">			else if (IOConstants.TAG_TYPE.equals(tag))</span>
			{
<span class="nc" id="L2792">				String cType = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2793">				CompanionList cList = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L2794">					.silentlyGetConstructedCDOMObject(CompanionList.class, cType);</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">				if (cList == null)</span>
				{
<span class="nc" id="L2797">					Logging.errorPrint(&quot;Cannot find CompanionList: &quot; + cType);</span>
				}
				else
				{
<span class="nc" id="L2801">					aFollower.setType(cList);</span>
				}
<span class="nc" id="L2803">			}</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">			else if (IOConstants.TAG_RACE.equals(tag))</span>
			{
<span class="nc" id="L2806">				String raceText = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2807">				Race r = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Race.class,</span>
					raceText);
<span class="nc bnc" id="L2809" title="All 2 branches missed.">				if (r == null)</span>
				{
<span class="nc" id="L2811">					Logging.errorPrint(&quot;Cannot find Race: &quot; + raceText);</span>
				}
				else
				{
<span class="nc" id="L2815">					aFollower.setRace(r);</span>
				}
<span class="nc" id="L2817">			}</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">			else if (IOConstants.TAG_HITDICE.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L2822">					aFollower.setUsedHD(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L2824">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L2827">				}</span>
			}
<span class="nc bnc" id="L2829" title="All 2 branches missed.">			else if (IOConstants.TAG_FILE.equals(tag))</span>
			{
<span class="nc" id="L2831">				String inputFileName = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L2832">				String masterFileName = makeFilenameAbsolute(inputFileName);</span>
<span class="nc bnc" id="L2833" title="All 2 branches missed.">				if (masterFileName == null)</span>
				{
<span class="nc" id="L2835">					final String msg =</span>
<span class="nc" id="L2836">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.CantFindFollower&quot;, //$NON-NLS-1$
						inputFileName);
<span class="nc" id="L2839">					warnings.add(msg);</span>
<span class="nc" id="L2840">				}</span>
				else
				{
<span class="nc" id="L2843">					aFollower.setFileName(masterFileName);</span>
				}
			}
<span class="nc" id="L2846">		}</span>

<span class="nc bnc" id="L2848" title="All 2 branches missed.">		if (!Constants.EMPTY_STRING.equals(aFollower.getFileName())</span>
<span class="nc bnc" id="L2849" title="All 4 branches missed.">			&amp;&amp; !Constants.EMPTY_STRING.equals(aFollower.getName()) &amp;&amp; aFollower.getType() != null</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">			&amp;&amp; !Constants.EMPTY_STRING.equals(aFollower.getType().toString()))</span>
		{
<span class="nc" id="L2852">			thePC.addFollower(aFollower);</span>
		}
<span class="nc" id="L2854">	}</span>

	private void parseGameMode(final String line) throws PCGParseException
	{
<span class="nc" id="L2858">		final String requestedMode = line.substring(IOConstants.TAG_GAMEMODE.length() + 1);</span>

<span class="nc" id="L2860">		final GameMode currentGameMode = SettingsHandler.getGameAsProperty().get();</span>
<span class="nc" id="L2861">		final String currentMode = currentGameMode.getName();</span>

<span class="nc bnc" id="L2863" title="All 2 branches missed.">		if (!requestedMode.equals(currentMode))</span>
		{
<span class="nc" id="L2865">			final String msg = LanguageBundle.getFormattedString(&quot;Exceptions.PCGenParser.WrongGameMode&quot;, //$NON-NLS-1$</span>
				requestedMode, currentMode);
<span class="nc" id="L2867">			throw new PCGParseException(&quot;ParseGameMode&quot;, line, msg); //$NON-NLS-1$</span>
		}
<span class="nc" id="L2869">	}</span>

	private void parseGenderLine(final String line)
	{
<span class="nc" id="L2873">		String genderString = EntityEncoder.decode(line.substring(IOConstants.TAG_GENDER.length() + 1));</span>
		Gender gender;
<span class="nc bnc" id="L2875" title="All 2 branches missed.">		if (&quot;M&quot;.equals(genderString))</span>
		{
<span class="nc" id="L2877">			gender = Gender.Male;</span>
		}
<span class="nc bnc" id="L2879" title="All 2 branches missed.">		else if (&quot;F&quot;.equals(genderString))</span>
		{
<span class="nc" id="L2881">			gender = Gender.Female;</span>
		}
		else
		{
			try
			{
<span class="nc" id="L2887">				gender = Gender.getGenderByName(genderString);</span>
			}
<span class="nc" id="L2889">			catch (IllegalArgumentException e)</span>
			{
<span class="nc" id="L2891">				gender = Gender.getDefaultValue();</span>
<span class="nc" id="L2892">				final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalGender&quot;, //$NON-NLS-1$</span>
					line);
<span class="nc" id="L2894">				warnings.add(msg);</span>

<span class="nc" id="L2896">			}</span>
		}
<span class="nc" id="L2898">		thePC.setGender(gender);</span>
<span class="nc" id="L2899">	}</span>

	/**
	 * # HTML Output Sheet location
	 * 
	 * @param line
	 */
	private void parseHTMLOutputSheetLine(final String line)
	{
<span class="nc" id="L2908">		String aFileName = EntityEncoder.decode(line.substring(IOConstants.TAG_HTMLOUTPUTSHEET.length() + 1));</span>

<span class="nc bnc" id="L2910" title="All 2 branches missed.">		if (aFileName.length() &lt;= 0)</span>
		{
<span class="nc" id="L2912">			aFileName = SettingsHandler.getSelectedCharacterHTMLOutputSheet(thePC);</span>
		}

<span class="nc" id="L2915">		thePC.setSelectedCharacterHTMLOutputSheet(aFileName);</span>
<span class="nc" id="L2916">	}</span>

	private void parseHairColorLine(final String line)
	{
<span class="nc" id="L2920">		HairColorCompat.setCurrentHairColor(thePC.getCharID(), </span>
<span class="nc" id="L2921">				EntityEncoder.decode(line.substring(IOConstants.TAG_HAIRCOLOR.length() + 1)));</span>
<span class="nc" id="L2922">	}</span>

	private void parseHairStyleLine(final String line)
	{
<span class="nc" id="L2926">		String hairStyle = EntityEncoder</span>
<span class="nc" id="L2927">			.decode(line.substring(IOConstants.TAG_HAIRSTYLE.length() + 1));</span>
<span class="nc" id="L2928">		ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
			CControl.HAIRSTYLEINPUT, hairStyle);
<span class="nc" id="L2930">	}</span>

	private void parseHandedLine(final String line)
	{
<span class="nc" id="L2934">		String handedString = EntityEncoder.decode(line.substring(IOConstants.TAG_HANDED.length() + 1));</span>
		Handed handed;
		try
		{
<span class="nc" id="L2938">			handed = HandedCompat.HANDED_MANAGER.convert(handedString);</span>
		}
<span class="nc" id="L2940">		catch (IllegalArgumentException e)</span>
		{
<span class="nc" id="L2942">			handed = HandedCompat.getDefaultHanded();</span>
<span class="nc" id="L2943">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalHandedness&quot;, //$NON-NLS-1$</span>
				line, handed);
<span class="nc" id="L2945">			warnings.add(msg);</span>

<span class="nc" id="L2947">		}</span>
<span class="nc" id="L2948">		HandedCompat.setCurrentHandedness(thePC.getCharID(), handed);</span>
<span class="nc" id="L2949">	}</span>

	private void parseHeightLine(final String line)
	{
		try
		{
<span class="nc" id="L2955">			int height = Integer.parseInt(line.substring(IOConstants.TAG_HEIGHT.length() + 1));</span>
<span class="nc" id="L2956">			HeightCompat.setCurrentHeight(thePC.getCharID(), height);</span>
		}
<span class="nc" id="L2958">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L2960">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalHeight&quot;, //$NON-NLS-1$</span>
				line);
<span class="nc" id="L2962">			warnings.add(msg);</span>
<span class="nc" id="L2963">		}</span>
<span class="nc" id="L2964">	}</span>

	private void parseInterestsLine(final String line)
	{
<span class="nc" id="L2968">		thePC.setPCAttribute(PCStringKey.INTERESTS,</span>
<span class="nc" id="L2969">			EntityEncoder.decode(line.substring(IOConstants.TAG_INTERESTS.length() + 1)));</span>
<span class="nc" id="L2970">	}</span>

	private void parseKitLine(final String line)
	{
<span class="nc" id="L2974">		final StringTokenizer stok =</span>
<span class="nc" id="L2975">				new StringTokenizer(line.substring(IOConstants.TAG_KIT.length() + 1), IOConstants.TAG_SEPARATOR, false);</span>

<span class="nc bnc" id="L2977" title="All 2 branches missed.">		if (stok.countTokens() != 2)</span>
		{
			// TODO This if switch currently does nothing?
<span class="nc" id="L2980">			Logging.debugPrint(stok.countTokens() + &quot; did not equal 2 - TODO we need to deal with this case.&quot;);</span>
		}

		/* final String region = */
<span class="nc" id="L2984">		stok.nextToken(); //TODO: Is this intended to be thrown away? The value is never used.</span>

		/* final String kit = stok.nextToken(); */

<span class="nc" id="L2988">		final Kit aKit = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Kit.class,</span>
<span class="nc" id="L2989">			line.substring(IOConstants.TAG_KIT.length() + 1));</span>

<span class="nc bnc" id="L2991" title="All 2 branches missed.">		if (aKit == null)</span>
		{
<span class="nc" id="L2993">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.KitNotFound&quot;, //$NON-NLS-1$</span>
				line);
<span class="nc" id="L2995">			warnings.add(msg);</span>

<span class="nc" id="L2997">			return;</span>
		}

<span class="nc" id="L3000">		thePC.addKit(aKit);</span>
<span class="nc" id="L3001">	}</span>

	/*
	 * ###############################################################
	 * Character Languages methods
	 * ###############################################################
	 */
	private void parseLanguageLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3014">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3016">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3018">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalLanguage&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L3019">				line, pcgpex.getMessage());</span>
<span class="nc" id="L3020">			warnings.add(msg);</span>

<span class="nc" id="L3022">			return;</span>
<span class="nc" id="L3023">		}</span>

<span class="nc bnc" id="L3025" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3027">			final Language aLang = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L3028">				.silentlyGetConstructedCDOMObject(Language.class, EntityEncoder.decode(element.getText()));</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">			if (aLang == null)</span>
			{
<span class="nc" id="L3031">				final String message = &quot;No longer speaks language: &quot; + element.getText(); //$NON-NLS-1$</span>
<span class="nc" id="L3032">				warnings.add(message);</span>
<span class="nc" id="L3033">				continue;</span>
			}
<span class="nc" id="L3035">			cachedLanguages.add(aLang);</span>
<span class="nc" id="L3036">		}</span>
<span class="nc" id="L3037">	}</span>

	/**
	 * # Load companions with master?
	 * @param line
	 **/
	private void parseLoadCompanionLine(final String line)
	{
<span class="nc" id="L3045">		thePC.setLoadCompanion(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L3046">	}</span>

	private void parseLocationLine(final String line)
	{
<span class="nc" id="L3050">		thePC.setPCAttribute(PCStringKey.LOCATION,</span>
<span class="nc" id="L3051">			EntityEncoder.decode(line.substring(IOConstants.TAG_LOCATION.length() + 1)));</span>
<span class="nc" id="L3052">	}</span>

	private void parseMasterLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3060">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3062">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3064">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalMaster&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L3065">				line, pcgpex.getMessage());</span>
<span class="nc" id="L3066">			warnings.add(msg);</span>

<span class="nc" id="L3068">			return;</span>
<span class="nc" id="L3069">		}</span>

<span class="nc" id="L3071">		final Follower aMaster = new Follower(Constants.EMPTY_STRING, Constants.EMPTY_STRING, null);</span>

<span class="nc bnc" id="L3073" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3075">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3077" title="All 2 branches missed.">			if (IOConstants.TAG_MASTER.equals(tag))</span>
			{
<span class="nc" id="L3079">				aMaster.setName(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3081" title="All 2 branches missed.">			else if (IOConstants.TAG_TYPE.equals(tag))</span>
			{
<span class="nc" id="L3083">				String cType = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3084">				CompanionList cList = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L3085">					.silentlyGetConstructedCDOMObject(CompanionList.class, cType);</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">				if (cList == null)</span>
				{
<span class="nc" id="L3088">					Logging.errorPrint(&quot;Cannot find CompanionList: &quot; + cType);</span>
				}
				else
				{
<span class="nc" id="L3092">					aMaster.setType(cList);</span>
				}
<span class="nc" id="L3094">			}</span>
<span class="nc bnc" id="L3095" title="All 2 branches missed.">			else if (IOConstants.TAG_HITDICE.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3099">					aMaster.setUsedHD(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L3101">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3104">				}</span>
			}
<span class="nc bnc" id="L3106" title="All 2 branches missed.">			else if (IOConstants.TAG_FILE.equals(tag))</span>
			{
<span class="nc" id="L3108">				String inputFileName = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3109">				String masterFileName = makeFilenameAbsolute(inputFileName);</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">				if (masterFileName == null)</span>
				{
<span class="nc" id="L3112">					final String msg =</span>
<span class="nc" id="L3113">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.CantFindMaster&quot;, //$NON-NLS-1$
						inputFileName);
<span class="nc" id="L3116">					warnings.add(msg);</span>
<span class="nc" id="L3117">				}</span>
				else
				{
<span class="nc" id="L3120">					aMaster.setFileName(masterFileName);</span>
				}
<span class="nc" id="L3122">			}</span>
<span class="nc bnc" id="L3123" title="All 2 branches missed.">			else if (IOConstants.TAG_ADJUSTMENT.equals(tag))</span>
			{
<span class="nc" id="L3125">				aMaster.setAdjustment(Integer.parseInt(element.getText()));</span>
			}
<span class="nc" id="L3127">		}</span>

<span class="nc bnc" id="L3129" title="All 4 branches missed.">		if (!Constants.EMPTY_STRING.equals(aMaster.getFileName()) &amp;&amp; !Constants.EMPTY_STRING.equals(aMaster.getName())</span>
<span class="nc bnc" id="L3130" title="All 2 branches missed.">			&amp;&amp; !Constants.EMPTY_STRING.equals(aMaster.getType().toString()))</span>
		{
<span class="nc" id="L3132">			thePC.setMaster(aMaster);</span>
		}
<span class="nc" id="L3134">	}</span>

	/**
	 * Convert the passed in file name to an absolute file name. The file name 
	 * may be relative to the PCG file being loaded, to the PCG directory or 
	 * it may be absolute.
	 * @param inFileName The file name to be converted.
	 * @return The absolute file name, or null if the file cannot be found.
	 */
	private String makeFilenameAbsolute(String inFileName)
	{
		// Is it relative to this character file?
<span class="nc" id="L3146">		File pcFile = new File(thePC.getFileName());</span>
<span class="nc" id="L3147">		File inFile = new File(pcFile.getParentFile(), inFileName);</span>
<span class="nc bnc" id="L3148" title="All 2 branches missed.">		if (inFile.exists())</span>
		{
<span class="nc" id="L3150">			return inFile.getAbsolutePath();</span>
		}

		// Is it relative to the PCG directory?
<span class="nc" id="L3154">		File pcgDir = new File(PCGenSettings.getPcgDir());</span>
<span class="nc" id="L3155">		inFile = new File(pcgDir, inFileName);</span>
<span class="nc bnc" id="L3156" title="All 2 branches missed.">		if (inFile.exists())</span>
		{
<span class="nc" id="L3158">			return inFile.getAbsolutePath();</span>
		}

		// Is it absolute?
<span class="nc" id="L3162">		inFile = new File(inFileName);</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">		if (inFile.exists())</span>
		{
<span class="nc" id="L3165">			return inFile.getAbsolutePath();</span>
		}

		// We can't find it!
<span class="nc" id="L3169">		return null;</span>
	}

	/*
	 * ###############################################################
	 * Character Notes Tab methods
	 * ###############################################################
	 */
	private void parseNoteLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3183">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3185">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3187">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.IllegalNotes&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L3188">				line, pcgpex.getMessage());</span>
<span class="nc" id="L3189">			warnings.add(msg);</span>

<span class="nc" id="L3191">			return;</span>
<span class="nc" id="L3192">		}</span>

<span class="nc" id="L3194">		final NoteItem ni = new NoteItem(-1, -1, Constants.EMPTY_STRING, Constants.EMPTY_STRING);</span>

<span class="nc bnc" id="L3196" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3198">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3200" title="All 2 branches missed.">			if (IOConstants.TAG_NOTE.equals(tag))</span>
			{
<span class="nc" id="L3202">				ni.setName(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3204" title="All 2 branches missed.">			else if (IOConstants.TAG_ID.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3208">					ni.setIdValue(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L3210">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L3212">					ni.setIdValue(-1);</span>

<span class="nc" id="L3214">					final String msg =</span>
<span class="nc" id="L3215">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidNotes&quot;, //$NON-NLS-1$
						line);
<span class="nc" id="L3218">					warnings.add(msg);</span>

<span class="nc" id="L3220">					break;</span>
<span class="nc" id="L3221">				}</span>
			}
<span class="nc bnc" id="L3223" title="All 2 branches missed.">			else if (IOConstants.TAG_PARENTID.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3227">					ni.setParentId(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L3229">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L3231">					ni.setIdValue(-1);</span>

<span class="nc" id="L3233">					final String msg =</span>
<span class="nc" id="L3234">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidNotes&quot;, //$NON-NLS-1$
						line);
<span class="nc" id="L3237">					warnings.add(msg);</span>

<span class="nc" id="L3239">					break;</span>
<span class="nc" id="L3240">				}</span>
			}
<span class="nc bnc" id="L3242" title="All 2 branches missed.">			else if (IOConstants.TAG_VALUE.equals(tag))</span>
			{
<span class="nc" id="L3244">				ni.setValue(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc" id="L3246">		}</span>

<span class="nc bnc" id="L3248" title="All 2 branches missed.">		if (ni.getId() &gt; -1)</span>
		{
<span class="nc" id="L3250">			thePC.addNotesItem(ni);</span>
		}
<span class="nc" id="L3252">	}</span>

	/*
	 * ###############################################################
	 * Character Chronicle Entry methods
	 * ###############################################################
	 */
	private void parseChronicleEntryLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3265">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3267">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3269">			final String msg =</span>
<span class="nc" id="L3270">					LanguageBundle.getFormattedString(</span>
						&quot;Warnings.PCGenParser.IllegalChronicleEntry&quot;, //$NON-NLS-1$
<span class="nc" id="L3272">				line, pcgpex.getMessage());</span>
<span class="nc" id="L3273">			warnings.add(msg);</span>

<span class="nc" id="L3275">			return;</span>
<span class="nc" id="L3276">		}</span>

<span class="nc" id="L3278">		final ChronicleEntry ce = new ChronicleEntry();</span>

<span class="nc bnc" id="L3280" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3282">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3284" title="All 2 branches missed.">			if (IOConstants.TAG_CHRONICLE_ENTRY.equals(tag))</span>
			{
<span class="nc" id="L3286">				ce.setOutputEntry(&quot;Y&quot;.equals(element.getText()));</span>
			}
<span class="nc bnc" id="L3288" title="All 2 branches missed.">			else if (IOConstants.TAG_EXPERIENCE.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3292">					ce.setXpField(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L3294">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L3296">					ce.setXpField(0);</span>

<span class="nc" id="L3298">					final String msg =</span>
<span class="nc" id="L3299">							LanguageBundle.getFormattedString(</span>
								&quot;Warnings.PCGenParser.InvalidChronicleEntry&quot;, //$NON-NLS-1$
						line);
<span class="nc" id="L3302">					warnings.add(msg);</span>

<span class="nc" id="L3304">					break;</span>
<span class="nc" id="L3305">				}</span>
			}
<span class="nc bnc" id="L3307" title="All 2 branches missed.">			else if (IOConstants.TAG_CAMPAIGN.equals(tag))</span>
			{
<span class="nc" id="L3309">				ce.setCampaign(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3311" title="All 2 branches missed.">			else if (IOConstants.TAG_ADVENTURE.equals(tag))</span>
			{
<span class="nc" id="L3313">				ce.setAdventure(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3315" title="All 2 branches missed.">			else if (IOConstants.TAG_PARTY.equals(tag))</span>
			{
<span class="nc" id="L3317">				ce.setParty(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3319" title="All 2 branches missed.">			else if (IOConstants.TAG_DATE.equals(tag))</span>
			{
<span class="nc" id="L3321">				ce.setDate(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3323" title="All 2 branches missed.">			else if (IOConstants.TAG_GM.equals(tag))</span>
			{
<span class="nc" id="L3325">				ce.setGmField(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc bnc" id="L3327" title="All 2 branches missed.">			else if (IOConstants.TAG_CHRONICLE.equals(tag))</span>
			{
<span class="nc" id="L3329">				ce.setChronicle(EntityEncoder.decode(element.getText()));</span>
			}
<span class="nc" id="L3331">		}</span>

<span class="nc" id="L3333">		thePC.addChronicleEntry(ce);</span>
<span class="nc" id="L3334">	}</span>

	/**
	 * # PDF Output Sheet location
	 * @param line
	 **/
	private void parsePDFOutputSheetLine(final String line)
	{
<span class="nc" id="L3342">		String aFileName = EntityEncoder.decode(line.substring(IOConstants.TAG_PDFOUTPUTSHEET.length() + 1));</span>

<span class="nc bnc" id="L3344" title="All 2 branches missed.">		if (aFileName.length() &lt;= 0)</span>
		{
<span class="nc" id="L3346">			aFileName = SettingsHandler.getSelectedCharacterPDFOutputSheet(thePC);</span>
		}

<span class="nc" id="L3349">		thePC.setSelectedCharacterPDFOutputSheet(aFileName);</span>
<span class="nc" id="L3350">	}</span>

	private void parsePersonalityTrait1Line(final String line)
	{
<span class="nc" id="L3354">		thePC.setPCAttribute(PCStringKey.PERSONALITY1,</span>
<span class="nc" id="L3355">			EntityEncoder.decode(line.substring(IOConstants.TAG_PERSONALITYTRAIT1.length() + 1)));</span>
<span class="nc" id="L3356">	}</span>

	private void parsePersonalityTrait2Line(final String line)
	{
<span class="nc" id="L3360">		thePC.setPCAttribute(PCStringKey.PERSONALITY2,</span>
<span class="nc" id="L3361">			EntityEncoder.decode(line.substring(IOConstants.TAG_PERSONALITYTRAIT2.length() + 1)));</span>
<span class="nc" id="L3362">	}</span>

	private void parsePhobiasLine(final String line)
	{
<span class="nc" id="L3366">		thePC.setPCAttribute(PCStringKey.PHOBIAS,</span>
<span class="nc" id="L3367">			EntityEncoder.decode(line.substring(IOConstants.TAG_PHOBIAS.length() + 1)));</span>
<span class="nc" id="L3368">	}</span>

	private void parsePlayerNameLine(final String line)
	{
<span class="nc" id="L3372">		thePC.setPCAttribute(PCStringKey.PLAYERSNAME,</span>
<span class="nc" id="L3373">			EntityEncoder.decode(line.substring(IOConstants.TAG_PLAYERNAME.length() + 1)));</span>
<span class="nc" id="L3374">	}</span>

	private void parsePoolPointsLine(final String line)
	{
		try
		{
<span class="nc" id="L3380">			final int poolPoints = Integer.parseInt(line.substring(IOConstants.TAG_POOLPOINTS.length() + 1));</span>
<span class="nc" id="L3381">			thePC.setPoolAmount(poolPoints);</span>
<span class="nc" id="L3382">			thePC.setCostPool(poolPoints);</span>
		}
<span class="nc" id="L3384">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L3386">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.InvalidPoolPoints&quot;, //$NON-NLS-1$</span>
				line);
<span class="nc" id="L3388">			warnings.add(msg);</span>
<span class="nc" id="L3389">		}</span>
<span class="nc" id="L3390">	}</span>

	private void parsePoolPointsLine2(final String line)
	{
		try
		{
<span class="nc" id="L3396">			thePC.setPointBuyPoints(Integer.parseInt(line.substring(IOConstants.TAG_POOLPOINTSAVAIL.length() + 1)));</span>
		}
<span class="nc" id="L3398">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L3400">			final String msg = LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.InvalidPoolPoints&quot;, //$NON-NLS-1$</span>
				line);
<span class="nc" id="L3402">			warnings.add(msg);</span>
<span class="nc" id="L3403">		}</span>
<span class="nc" id="L3404">	}</span>

	private void parsePortraitLine(final String line)
	{
<span class="nc" id="L3408">		thePC.setPortraitPath(EntityEncoder.decode(line.substring(IOConstants.TAG_PORTRAIT.length() + 1)));</span>
<span class="nc" id="L3409">	}</span>

	private void parsePortraitThumbnailRectLine(final String line)
	{
<span class="nc" id="L3413">		String[] dim = line.substring(IOConstants.TAG_PORTRAIT_THUMBNAIL_RECT.length() + 1).split(&quot;,&quot;);</span>
<span class="nc" id="L3414">		Rectangle rect = new Rectangle(Integer.parseInt(dim[0]), Integer.parseInt(dim[1]), Integer.parseInt(dim[2]),</span>
<span class="nc" id="L3415">			Integer.parseInt(dim[3]));</span>
<span class="nc" id="L3416">		thePC.setPortraitThumbnailRect(rect);</span>
<span class="nc" id="L3417">	}</span>

	private void parseRaceLine(final String line) throws PCGParseException
	{
<span class="nc" id="L3421">		List&lt;PCGElement&gt; elements = new PCGTokenizer(line).getElements();</span>
<span class="nc" id="L3422">		PCGElement raceElement = elements.get(0);</span>
<span class="nc" id="L3423">		String raceName = EntityEncoder.decode(raceElement.getText());</span>
		// Check for a race key that has been updated.
<span class="nc" id="L3425">		raceName = RaceMigration.getNewRaceKey(raceName, pcgenVersion, SettingsHandler.getGameAsProperty().get().getName());</span>
		final Race aRace =
<span class="nc" id="L3427">				Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Race.class, raceName);</span>

<span class="nc bnc" id="L3429" title="All 2 branches missed.">		if (aRace == null)</span>
		{
<span class="nc" id="L3431">			final String msg = LanguageBundle.getFormattedString(&quot;Exceptions.PCGenParser.RaceNotFound&quot;, //$NON-NLS-1$</span>
				raceName);
<span class="nc" id="L3433">			throw new PCGParseException(&quot;parseRaceLine&quot;, line, msg); //$NON-NLS-1$</span>
		}
<span class="nc" id="L3435">		String selection = null;</span>
		//Yes, start at 1, 0 was the race
<span class="nc bnc" id="L3437" title="All 2 branches missed.">		for (int i = 1; i &lt; elements.size(); i++)</span>
		{
<span class="nc" id="L3439">			PCGElement thisElement = elements.get(i);</span>
<span class="nc" id="L3440">			final String aString = thisElement.getName();</span>
<span class="nc bnc" id="L3441" title="All 2 branches missed.">			if (aString.startsWith(IOConstants.TAG_APPLIEDTO))</span>
			{
<span class="nc bnc" id="L3443" title="All 2 branches missed.">				if (selection != null)</span>
				{
<span class="nc" id="L3445">					warnings.add(&quot;Found multiple selections for Race: &quot; + aRace.getKeyName());</span>
				}
<span class="nc" id="L3447">				selection = thisElement.getText();</span>
			}
<span class="nc bnc" id="L3449" title="All 2 branches missed.">			else if (!aString.startsWith(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L3451">				final String msg =</span>
<span class="nc" id="L3452">						LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.UnknownRaceInfo&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L3453">							aString + &quot;:&quot; + thisElement.getText());</span>
<span class="nc" id="L3454">				warnings.add(msg);</span>
			}
		}
<span class="nc" id="L3457">		raceInputFacet.importSelection(thePC.getCharID(), aRace, selection);</span>
<span class="nc" id="L3458">		thePC.setDirty(true);</span>

		//Must process ADD after RACE is added to the PC
<span class="nc bnc" id="L3461" title="All 2 branches missed.">		for (PCGElement e : new PCGTokenizer(line).getElements())</span>
		{
<span class="nc" id="L3463">			String tag = e.getName();</span>
<span class="nc bnc" id="L3464" title="All 2 branches missed.">			if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L3466">				parseAddTokenInfo(e, aRace);</span>
			}
<span class="nc" id="L3468">		}</span>

		// TODO
		// adjust for more information according to
		// PCGVer1Creator.appendRaceLine
<span class="nc" id="L3473">	}</span>

	private void parseFavoredClassLine(final String line)
	{
<span class="nc" id="L3477">		String favClass = EntityEncoder.decode(line.substring(IOConstants.TAG_FAVOREDCLASS.length() + 1));</span>
		PCClass cl =
<span class="nc" id="L3479">				Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class, favClass);</span>
<span class="nc bnc" id="L3480" title="All 2 branches missed.">		if (cl != null)</span>
		{
<span class="nc" id="L3482">			thePC.addFavoredClass(cl, thePC);</span>
		}
<span class="nc" id="L3484">	}</span>

	/*
	 * ###############################################################
	 * Character Region methods
	 * ###############################################################
	 */
	private void parseRegionLine(final String line)
	{
<span class="nc" id="L3493">		final String r = EntityEncoder.decode(line.substring(IOConstants.TAG_REGION.length() + 1));</span>
<span class="nc" id="L3494">		thePC.setRegion(Region.getConstant(r));</span>
<span class="nc" id="L3495">	}</span>

	//this method is obsolete, but left in for backward-compatibility, replaced by parseCityLine()
	private void parseResidenceLine(final String line)
	{
<span class="nc" id="L3500">		thePC.setPCAttribute(PCStringKey.RESIDENCE,</span>
<span class="nc" id="L3501">			EntityEncoder.decode(line.substring(IOConstants.TAG_RESIDENCE.length() + 1)));</span>
<span class="nc" id="L3502">		thePC.setDirty(true); // trigger a save prompt so that the PCG will be updated</span>
<span class="nc" id="L3503">	}</span>

	/*
	 * ###############################################################
	 * Character Skills methods
	 * ###############################################################
	 */
	private void parseSkillLine(final String line)
	{
		final PCGTokenizer tokens;
		try
		{
<span class="nc" id="L3515">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3517">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3519">			final String message =</span>
<span class="nc" id="L3520">					&quot;Illegal Skill line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot; + pcgpex.getMessage();</span>
<span class="nc" id="L3521">			warnings.add(message);</span>
<span class="nc" id="L3522">			return;</span>
<span class="nc" id="L3523">		}</span>
<span class="nc" id="L3524">		Skill aSkill = null;</span>
<span class="nc" id="L3525">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>
		// the first element defines the skill key name!!!
<span class="nc" id="L3527">		String skillKey = &quot;&quot;;</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L3530">			final PCGElement element = it.next();</span>
<span class="nc" id="L3531">			skillKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3532">			aSkill = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Skill.class, skillKey);</span>
		}
<span class="nc bnc" id="L3534" title="All 2 branches missed.">		while (it.hasNext())</span>
		{
<span class="nc" id="L3536">			final PCGElement element = it.next();</span>
<span class="nc" id="L3537">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3539" title="All 2 branches missed.">			if (IOConstants.TAG_SYNERGY.equals(tag))</span>
			{
				// TODO
				// for now it's ok to ignore it!
<span class="nc" id="L3543">				Logging.debugPrint(tag + &quot; equals &quot; + IOConstants.TAG_SYNERGY + &quot; OK to ignore.&quot;);</span>
			}
<span class="nc bnc" id="L3545" title="All 2 branches missed.">			else if (IOConstants.TAG_OUTPUTORDER.equals(tag))</span>
			{
<span class="nc" id="L3547">				int outputindex = 0;</span>
				try
				{
<span class="nc" id="L3550">					outputindex = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L3552">				catch (NumberFormatException nfe)</span>
				{
					// This is not critical.
					// Maybe warn the user?
<span class="nc" id="L3556">				}</span>

<span class="nc bnc" id="L3558" title="All 2 branches missed.">				if (aSkill != null)</span>
				{
<span class="nc" id="L3560">					thePC.setSkillOrder(aSkill, outputindex);</span>
				}
<span class="nc" id="L3562">			}</span>
<span class="nc bnc" id="L3563" title="All 2 branches missed.">			else if (IOConstants.TAG_CLASSBOUGHT.equals(tag))</span>
			{
<span class="nc" id="L3565">				PCGElement childClass = null;</span>
<span class="nc" id="L3566">				PCGElement childRanks = null;</span>
<span class="nc bnc" id="L3567" title="All 2 branches missed.">				for (PCGElement child : element.getChildren())</span>
				{
<span class="nc bnc" id="L3569" title="All 2 branches missed.">					if (IOConstants.TAG_CLASS.equals(child.getName()))</span>
					{
<span class="nc" id="L3571">						childClass = child;</span>
					}
<span class="nc bnc" id="L3573" title="All 2 branches missed.">					else if (IOConstants.TAG_RANKS.equals(child.getName()))</span>
					{
<span class="nc" id="L3575">						childRanks = child;</span>
					}
<span class="nc" id="L3577">				}</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">				if (childClass == null)</span>
				{
<span class="nc" id="L3580">					final String message = &quot;Invalid class/ranks specification: &quot; + line;</span>
<span class="nc" id="L3581">					warnings.add(message);</span>

<span class="nc" id="L3583">					continue;</span>
				}
<span class="nc bnc" id="L3585" title="All 2 branches missed.">				if (childRanks == null)</span>
				{
<span class="nc" id="L3587">					final String message = &quot;Invalid class/ranks specification: &quot; + line;</span>
<span class="nc" id="L3588">					warnings.add(message);</span>
<span class="nc" id="L3589">					continue;</span>
				}
				//None for a class is a special key word.  It is used when a familiar inherits a skill from its master
<span class="nc" id="L3592">				PCClass aPCClass = null;</span>
<span class="nc bnc" id="L3593" title="All 2 branches missed.">				if (!childClass.getText().equals(&quot;None&quot;)) //$NON-NLS-1$</span>
				{
<span class="nc" id="L3595">					final String childClassKey = EntityEncoder.decode(childClass.getText());</span>
<span class="nc" id="L3596">					aPCClass = thePC.getClassKeyed(childClassKey);</span>
<span class="nc bnc" id="L3597" title="All 2 branches missed.">					if (aPCClass == null)</span>
					{
<span class="nc" id="L3599">						final String message = &quot;Could not find class: &quot; + childClassKey;</span>
<span class="nc" id="L3600">						warnings.add(message);</span>
<span class="nc" id="L3601">						continue;</span>
					}
				}
<span class="nc bnc" id="L3604" title="All 2 branches missed.">				if (aSkill == null)</span>
				{
					// We only need to report this if the skill had ranks.
<span class="nc" id="L3607">					final String message = &quot;Could not add skill: &quot; + skillKey;</span>
<span class="nc" id="L3608">					warnings.add(message);</span>
<span class="nc" id="L3609">					return;</span>
				}
				try
				{
<span class="nc" id="L3613">					double ranks = Double.parseDouble(childRanks.getText());</span>
<span class="nc" id="L3614">					SkillRankControl.modRanks(ranks, aPCClass, true, thePC, aSkill);</span>
				}
<span class="nc" id="L3616">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L3618">					final String message = &quot;Invalid ranks specification: &quot; + childRanks.getText();</span>
<span class="nc" id="L3619">					warnings.add(message);</span>

<span class="nc" id="L3621">					continue;</span>
<span class="nc" id="L3622">				}</span>
<span class="nc" id="L3623">			}</span>
<span class="nc bnc" id="L3624" title="All 4 branches missed.">			else if (aSkill != null &amp;&amp; IOConstants.TAG_ASSOCIATEDDATA.equals(tag))</span>
			{
<span class="nc" id="L3626">				String key = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3627">				ChoiceManagerList&lt;Object&gt; controller =</span>
<span class="nc" id="L3628">						ChooserUtilities.getConfiguredController(aSkill, thePC, null, new ArrayList&lt;&gt;());</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">				if (controller != null)</span>
				{
<span class="nc" id="L3631">					String[] assoc = key.split(Constants.COMMA, -1);</span>
<span class="nc bnc" id="L3632" title="All 2 branches missed.">					for (String string : assoc)</span>
					{
<span class="nc" id="L3634">						controller.restoreChoice(thePC, aSkill, string);</span>
					}
<span class="nc" id="L3636">				}</span>
				else
				{
<span class="nc" id="L3639">					warnings.add(&quot;Failed to find choose controller for skill &quot; + aSkill);</span>
				}
<span class="nc" id="L3641">			}</span>
<span class="nc bnc" id="L3642" title="All 4 branches missed.">			else if (aSkill != null &amp;&amp; tag.equals(IOConstants.TAG_LEVELABILITY))</span>
			{
<span class="nc" id="L3644">				parseLevelAbilityInfo(element, aSkill);</span>
			}
<span class="nc bnc" id="L3646" title="All 4 branches missed.">			else if (aSkill != null &amp;&amp; tag.equals(IOConstants.TAG_ADDTOKEN))</span>
			{
<span class="nc" id="L3648">				parseAddTokenInfo(element, aSkill);</span>
			}
<span class="nc" id="L3650">		}</span>
<span class="nc" id="L3651">	}</span>

	/**
	 * # Skills Output order
	 * @param line
	 **/
	private void parseSkillsOutputOrderLine(final String line)
	{
		try
		{
<span class="nc" id="L3661">			int orderNum = Integer.parseInt(line.substring(IOConstants.TAG_SKILLSOUTPUTORDER.length() + 1));</span>
<span class="nc" id="L3662">			SkillsOutputOrder order = SkillsOutputOrder.values()[orderNum];</span>
			// setting is correct in some  6.1.8-dev characters
<span class="nc bnc" id="L3664" title="All 2 branches missed.">			if (compareVersionTo(new int[]{6, 1, 9}) &lt; 0)</span>
			{
<span class="nc" id="L3666">				order = SkillsOutputOrder.NAME_ASC;</span>
			}

<span class="nc" id="L3669">			thePC.setSkillsOutputOrder(order);</span>
		}
<span class="nc" id="L3671">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L3673">			final String message = &quot;Illegal Skills Output Order line ignored: &quot; + line;</span>
<span class="nc" id="L3674">			warnings.add(message);</span>
<span class="nc" id="L3675">		}</span>
<span class="nc" id="L3676">	}</span>

	/**
	 * # Skills Filter
	 * @param line
	 **/
	private void parseSkillFilterLine(final String line)
	{
		try
		{
<span class="nc" id="L3686">			int value = Integer.parseInt(line.substring(IOConstants.TAG_SKILLFILTER.length() + 1));</span>
<span class="nc" id="L3687">			thePC.setSkillFilter(SkillFilter.getByValue(value));</span>
		}
<span class="nc" id="L3689">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L3691">			final String message = &quot;Illegal Skill Filter line ignored: &quot; + line;</span>
<span class="nc" id="L3692">			warnings.add(message);</span>
<span class="nc" id="L3693">		}</span>
<span class="nc" id="L3694">	}</span>

	private void parseSkinColorLine(final String line)
	{
<span class="nc" id="L3698">		String color = EntityEncoder</span>
<span class="nc" id="L3699">			.decode(line.substring(IOConstants.TAG_SKINCOLOR.length() + 1));</span>
<span class="nc" id="L3700">		ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
			CControl.SKINCOLORINPUT, color);
<span class="nc" id="L3702">	}</span>

	private void parseSpeechPatternLine(final String line)
	{
<span class="nc" id="L3706">		thePC.setPCAttribute(PCStringKey.SPEECHTENDENCY,</span>
<span class="nc" id="L3707">			EntityEncoder.decode(line.substring(IOConstants.TAG_SPEECHPATTERN.length() + 1)));</span>
<span class="nc" id="L3708">	}</span>

	/*
	 * ###############################################################
	 * Spell Book Information methods
	 * ###############################################################
	 */
	/*
	 * #Spell Book Information
	 * SPELLBOOK:bookname|TYPE:spellbooktype
	 */
	private void parseSpellBookLines(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3725">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3727">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3729">			final String message =</span>
<span class="nc" id="L3730">					&quot;Illegal Spell book ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot; + pcgpex.getMessage();</span>
<span class="nc" id="L3731">			warnings.add(message);</span>

<span class="nc" id="L3733">			return;</span>
<span class="nc" id="L3734">		}</span>

<span class="nc" id="L3736">		SpellBook aSpellBook = null;</span>

<span class="nc bnc" id="L3738" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3740">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3742" title="All 2 branches missed.">			if (IOConstants.TAG_SPELLBOOK.equals(tag))</span>
			{
<span class="nc" id="L3744">				final String bookName = EntityEncoder.decode(element.getText());</span>

<span class="nc" id="L3746">				aSpellBook = new SpellBook(bookName, SpellBook.TYPE_PREPARED_LIST);</span>
<span class="nc" id="L3747">			}</span>
<span class="nc bnc" id="L3748" title="All 2 branches missed.">			else if (IOConstants.TAG_TYPE.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3752">					aSpellBook.setType(Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L3754">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3757">					final String message = &quot;Spell book &quot; + aSpellBook.getName() + &quot; had an illegal type: &quot;</span>
<span class="nc" id="L3758">						+ element.getText() + &quot; in line &quot; + line;</span>
<span class="nc" id="L3759">					warnings.add(message);</span>
<span class="nc" id="L3760">				}</span>
			}
<span class="nc bnc" id="L3762" title="All 2 branches missed.">			else if (IOConstants.TAG_AUTOADDKNOWN.equals(tag))</span>
			{
<span class="nc bnc" id="L3764" title="All 2 branches missed.">				if (IOConstants.VALUE_Y.equals(element.getText()))</span>
				{
<span class="nc" id="L3766">					thePC.setSpellBookNameToAutoAddKnown(aSpellBook.getName());</span>
				}
			}
<span class="nc" id="L3769">		}</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">		if (aSpellBook == null)</span>
		{
<span class="nc" id="L3772">			warnings.add(&quot;Internal Error: Did not build Spell Book from SPELLBOOK line&quot;);</span>
		}
		else
		{
<span class="nc" id="L3776">			thePC.addSpellBook(aSpellBook);</span>
		}
<span class="nc" id="L3778">	}</span>

	/*
	 * ###############################################################
	 * Character Spells Information methods
	 * ###############################################################
	 */
	private void parseSpellLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L3791">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L3793">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L3795">			final String message =</span>
<span class="nc" id="L3796">					&quot;Illegal Spell line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot; + pcgpex.getMessage();</span>
<span class="nc" id="L3797">			warnings.add(message);</span>

<span class="nc" id="L3799">			return;</span>
<span class="nc" id="L3800">		}</span>

<span class="nc" id="L3802">		Spell aSpell = null;</span>
<span class="nc" id="L3803">		PCClass aPCClass = null;</span>
<span class="nc" id="L3804">		PObject source = null;</span>

<span class="nc" id="L3806">		String spellBook = null;</span>

<span class="nc" id="L3808">		int times = 1;</span>
<span class="nc" id="L3809">		int spellLevel = 0;</span>
<span class="nc" id="L3810">		int numPages = 0;</span>

<span class="nc" id="L3812">		final List&lt;Ability&gt; metaFeats = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3814">		int ppCost = -1;</span>

<span class="nc bnc" id="L3816" title="All 2 branches missed.">		for (final PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L3818">			final String tag = element.getName();</span>

<span class="nc bnc" id="L3820" title="All 2 branches missed.">			if (IOConstants.TAG_SPELLNAME.equals(tag))</span>
			{
<span class="nc" id="L3822">				String spellName = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3823">				spellName = SpellMigration.getNewSpellKey(spellName, pcgenVersion, SettingsHandler.getGameAsProperty().get().getName());</span>

				// either NULL (no spell) a Spell instance,
<span class="nc" id="L3826">				aSpell = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Spell.class,</span>
					spellName);

<span class="nc bnc" id="L3829" title="All 2 branches missed.">				if (aSpell == null)</span>
				{
<span class="nc" id="L3831">					final String message = &quot;Could not find spell named: &quot; + spellName;</span>
<span class="nc" id="L3832">					warnings.add(message);</span>

<span class="nc" id="L3834">					return;</span>
				}
<span class="nc" id="L3836">			}</span>
<span class="nc bnc" id="L3837" title="All 2 branches missed.">			else if (IOConstants.TAG_TIMES.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3841">					times = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L3843">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3846">				}</span>
			}
<span class="nc bnc" id="L3848" title="All 2 branches missed.">			else if (IOConstants.TAG_CLASS.equals(tag))</span>
			{
<span class="nc" id="L3850">				final String classKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L3851">				aPCClass = thePC.getClassKeyed(classKey);</span>

<span class="nc bnc" id="L3853" title="All 2 branches missed.">				if (aPCClass == null)</span>
				{
<span class="nc" id="L3855">					final String message = &quot;Invalid class specification: &quot; + classKey;</span>
<span class="nc" id="L3856">					warnings.add(message);</span>

<span class="nc" id="L3858">					return;</span>
				}
<span class="nc" id="L3860">			}</span>
<span class="nc bnc" id="L3861" title="All 2 branches missed.">			else if (IOConstants.TAG_SPELL_BOOK.equals(tag))</span>
			{
<span class="nc" id="L3863">				spellBook = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L3865" title="All 2 branches missed.">			else if (IOConstants.TAG_SPELLLEVEL.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3869">					spellLevel = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L3871">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3874">				}</span>
			}
<span class="nc bnc" id="L3876" title="All 2 branches missed.">			else if (IOConstants.TAG_SPELLPPCOST.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3880">					ppCost = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L3882">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3885">				}</span>
			}
<span class="nc bnc" id="L3887" title="All 2 branches missed.">			else if (IOConstants.TAG_SPELLNUMPAGES.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L3891">					numPages = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L3893">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can do about it
<span class="nc" id="L3896">				}</span>
			}
<span class="nc bnc" id="L3898" title="All 2 branches missed.">			else if (IOConstants.TAG_SOURCE.equals(tag))</span>
			{
<span class="nc" id="L3900">				String typeName = Constants.EMPTY_STRING;</span>
<span class="nc" id="L3901">				String objectKey = Constants.EMPTY_STRING;</span>

<span class="nc bnc" id="L3903" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L3905">					final String childTag = child.getName();</span>

<span class="nc bnc" id="L3907" title="All 2 branches missed.">					if (IOConstants.TAG_TYPE.equals(childTag))</span>
					{
<span class="nc" id="L3909">						typeName = child.getText().toUpperCase();</span>
					}
<span class="nc bnc" id="L3911" title="All 2 branches missed.">					else if (IOConstants.TAG_NAME.equals(childTag))</span>
					{
<span class="nc" id="L3913">						objectKey = child.getText();</span>
					}
<span class="nc" id="L3915">				}</span>

<span class="nc bnc" id="L3917" title="All 2 branches missed.">				if (IOConstants.TAG_DOMAIN.equals(typeName))</span>
				{
<span class="nc" id="L3919">					Domain domain = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L3920">						.silentlyGetConstructedCDOMObject(DOMAIN_CLASS, objectKey);</span>
<span class="nc" id="L3921">					ClassSource cs = thePC.getDomainSource(domain);</span>

<span class="nc bnc" id="L3923" title="All 2 branches missed.">					if (cs == null)</span>
					{
<span class="nc" id="L3925">						final String message = &quot;Could not find domain: &quot; + objectKey;</span>
<span class="nc" id="L3926">						warnings.add(message);</span>

<span class="nc" id="L3928">						return;</span>
					}
<span class="nc" id="L3930">					source = domain;</span>
<span class="nc" id="L3931">				}</span>
				else
				{
					// it's either the class, sub-class or a cast-as class
					// first see if it's the class
<span class="nc" id="L3936">					ClassSpellList csl = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L3937">						.silentlyGetConstructedCDOMObject(ClassSpellList.class, objectKey);</span>
<span class="nc bnc" id="L3938" title="All 6 branches missed.">					if (((aPCClass != null) &amp;&amp; objectKey.equals(aPCClass.getKeyName()))</span>
<span class="nc bnc" id="L3939" title="All 2 branches missed.">						|| (aPCClass != null &amp;&amp; thePC.getSpellLists(aPCClass).contains(csl)))</span>
					{
<span class="nc" id="L3941">						source = aPCClass;</span>
					}
					else
					{
<span class="nc" id="L3945">						source = thePC.getClassKeyed(objectKey); // see if PC has the class</span>
					}
				}
<span class="nc" id="L3948">			}</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">			else if (IOConstants.TAG_FEATLIST.equals(tag))</span>
			{
<span class="nc bnc" id="L3951" title="All 2 branches missed.">				for (PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L3953">					final String featKey = EntityEncoder.decode(child.getText());</span>
<span class="nc" id="L3954">					final Ability anAbility = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L3955">						.getManufacturerId(AbilityCategory.FEAT).getActiveObject(featKey);</span>

<span class="nc bnc" id="L3957" title="All 2 branches missed.">					if (anAbility != null)</span>
					{
<span class="nc" id="L3959">						metaFeats.add(anAbility);</span>
					}
<span class="nc" id="L3961">				}</span>
			}
<span class="nc" id="L3963">		}</span>

<span class="nc bnc" id="L3965" title="All 4 branches missed.">		if ((aPCClass == null) || (spellBook == null))</span>
		{
<span class="nc" id="L3967">			final String message = &quot;Illegal Spell line ignored: &quot; + line;</span>
<span class="nc" id="L3968">			warnings.add(message);</span>

<span class="nc" id="L3970">			return;</span>
		}

		/*
		 * this can only happen if the source type was NOT DOMAIN!
		 */
<span class="nc bnc" id="L3976" title="All 2 branches missed.">		if (source == null)</span>
		{
<span class="nc" id="L3978">			source = aPCClass;</span>
		}

		//		if (obj instanceof List)
		//		{
		//			// find the instance of Spell in this class
		//			// best suited to this spell
		//			for (final Spell spell : (ArrayList&lt;Spell&gt;) obj)
		//			{
		//				// valid spell has a non-negative spell level
		//				if ((spell != null)
		//					&amp;&amp; (SpellLevel.getFirstLevelForKey(spell,
		//						thePC.getSpellLists(source), thePC) &gt;= 0))
		//				{
		//					aSpell = spell;
		//					break;
		//				}
		//			}
		//			if (aSpell == null)
		//			{
		//				Logging.errorPrint(&quot;Could not resolve spell &quot; + obj.toString());
		//			}
		//		}

		//		if (aSpell == null)
		//		{
		//			final String message =
		//					&quot;Could not find spell named: &quot; + String.valueOf(obj);
		//			warnings.add(message);
		//
		//			return;
		//		}

		// just to make sure the spellbook is present
<span class="nc" id="L4012">		thePC.addSpellBook(spellBook);</span>
<span class="nc" id="L4013">		final SpellBook book = thePC.getSpellBookByName(spellBook);</span>

<span class="nc" id="L4015">		thePC.calculateKnownSpellsForClassLevel(aPCClass);</span>
<span class="nc" id="L4016">		final Integer[] spellLevels = SpellLevel.levelForKey(aSpell, thePC.getSpellLists(source), thePC);</span>
<span class="nc" id="L4017">		boolean found = false;</span>

<span class="nc bnc" id="L4019" title="All 2 branches missed.">		for (final Integer level : spellLevels)</span>
		{
<span class="nc" id="L4021">			final int metmagicLevels = totalAddedLevelsFromMetamagic(metaFeats);</span>

<span class="nc bnc" id="L4023" title="All 4 branches missed.">			if (spellLevel &gt; 0 &amp;&amp; spellLevel != (level + metmagicLevels))</span>
			{
				// Skip spell in class lists that does not match level the character
				// knows it.
<span class="nc" id="L4027">				continue;</span>
			}

<span class="nc bnc" id="L4030" title="All 2 branches missed.">			if (level &lt; 0)</span>
			{
<span class="nc" id="L4032">				Collection&lt;CDOMReference&lt;Spell&gt;&gt; mods = source.getListMods(Spell.SPELLS);</span>
<span class="nc bnc" id="L4033" title="All 2 branches missed.">				if (mods == null)</span>
				{
<span class="nc" id="L4035">					continue;</span>
				}
<span class="nc bnc" id="L4037" title="All 2 branches missed.">				for (CDOMReference&lt;Spell&gt; ref : mods)</span>
				{
<span class="nc" id="L4039">					Collection&lt;Spell&gt; refSpells = ref.getContainedObjects();</span>
<span class="nc" id="L4040">					Collection&lt;AssociatedPrereqObject&gt; assocs = source.getListAssociations(Spell.SPELLS, ref);</span>
<span class="nc bnc" id="L4041" title="All 2 branches missed.">					for (Spell sp : refSpells)</span>
					{
<span class="nc bnc" id="L4043" title="All 2 branches missed.">						if (aSpell.getKeyName().equals(sp.getKeyName()))</span>
						{
<span class="nc bnc" id="L4045" title="All 2 branches missed.">							for (AssociatedPrereqObject apo : assocs)</span>
							{
<span class="nc" id="L4047">								String sb = apo.getAssociation(AssociationKey.SPELLBOOK);</span>
<span class="nc bnc" id="L4048" title="All 2 branches missed.">								if (spellBook.equals(sb))</span>
								{
<span class="nc" id="L4050">									found = true;</span>
<span class="nc" id="L4051">									break;</span>
								}
<span class="nc" id="L4053">							}</span>
						}
<span class="nc" id="L4055">					}</span>
<span class="nc" id="L4056">				}</span>
<span class="nc" id="L4057">				continue;</span>
			}

<span class="nc" id="L4060">			found = true;</span>

			// do not load auto knownspells into default spellbook
<span class="nc bnc" id="L4063" title="All 2 branches missed.">			if (spellBook.equals(Globals.getDefaultSpellBook())</span>
<span class="nc bnc" id="L4064" title="All 2 branches missed.">				&amp;&amp; thePC.getSpellSupport(aPCClass).isAutoKnownSpell(aSpell, level, false, thePC)</span>
<span class="nc bnc" id="L4065" title="All 2 branches missed.">				&amp;&amp; thePC.getAutoSpells())</span>
			{
<span class="nc" id="L4067">				continue;</span>
			}

<span class="nc" id="L4070">			CharacterSpell aCharacterSpell = thePC.getCharacterSpellForSpell(aPCClass, aSpell, source);</span>

			// PC does not have that spell on that classes list
			// so we'll need to add it to the list
<span class="nc bnc" id="L4074" title="All 2 branches missed.">			if (aCharacterSpell == null)</span>
			{
<span class="nc" id="L4076">				aCharacterSpell = new CharacterSpell(source, aSpell);</span>
<span class="nc" id="L4077">				aCharacterSpell.addInfo(level, times, spellBook);</span>
<span class="nc" id="L4078">				thePC.addCharacterSpell(aPCClass, aCharacterSpell);</span>
			}

<span class="nc" id="L4081">			SpellInfo aSpellInfo = null;</span>

<span class="nc bnc" id="L4083" title="All 4 branches missed.">			if (source.getKeyName().equals(aPCClass.getKeyName()) || !spellBook.equals(Globals.getDefaultSpellBook()))</span>
			{
<span class="nc" id="L4085">				aSpellInfo = aCharacterSpell.getSpellInfoFor(spellBook, spellLevel);</span>

				// This doesn't make sense. What does the
				// metaFeats list have to do with this?
<span class="nc bnc" id="L4089" title="All 4 branches missed.">				if ((aSpellInfo == null) || !metaFeats.isEmpty())</span>
				{
<span class="nc" id="L4091">					aSpellInfo = aCharacterSpell.addInfo(spellLevel, times, spellBook);</span>
				}
			}

<span class="nc bnc" id="L4095" title="All 2 branches missed.">			if (aSpellInfo != null)</span>
			{
<span class="nc bnc" id="L4097" title="All 2 branches missed.">				if (!metaFeats.isEmpty())</span>
				{
<span class="nc" id="L4099">					aSpellInfo.addFeatsToList(metaFeats);</span>
				}
<span class="nc" id="L4101">				aSpellInfo.setActualPPCost(ppCost);</span>
<span class="nc" id="L4102">				aSpellInfo.setNumPages(numPages);</span>
<span class="nc" id="L4103">				book.setNumPagesUsed(book.getNumPagesUsed() + numPages);</span>
<span class="nc" id="L4104">				book.setNumSpells(book.getNumSpells() + 1);</span>
			}
		}
		// end sindex for loop

<span class="nc bnc" id="L4109" title="All 2 branches missed.">		if (!found)</span>
		{
<span class="nc" id="L4111">			final String message = &quot;Could not find spell &quot; + aSpell.getDisplayName() + &quot; in &quot; + shortClassName(source)</span>
<span class="nc" id="L4112">				+ &quot; &quot; + source.getDisplayName();</span>
<span class="nc" id="L4113">			warnings.add(message);</span>
		}
<span class="nc" id="L4115">	}</span>

	private int totalAddedLevelsFromMetamagic(List&lt;Ability&gt; metaFeats)
	{
<span class="nc" id="L4119">		int addedLevels = 0;</span>

<span class="nc bnc" id="L4121" title="All 2 branches missed.">		for (Ability ability : metaFeats)</span>
		{
<span class="nc" id="L4123">			Integer featAddSpellLevel = ability.get(IntegerKey.ADD_SPELL_LEVEL);</span>
<span class="nc bnc" id="L4124" title="All 2 branches missed.">			if (featAddSpellLevel != null)</span>
			{
<span class="nc" id="L4126">				addedLevels += featAddSpellLevel;</span>
			}
<span class="nc" id="L4128">		}</span>
<span class="nc" id="L4129">		return addedLevels;</span>
	}

	/*
	 * ###############################################################
	 * Spell List Information methods
	 * ###############################################################
	 */
	/*
	 * #Spell List Information
	 * SPELLLIST:sourceclassname|spelllistentry|spelllistentry
	 */
	private void parseSpellListLines(final String line)
	{
<span class="nc" id="L4143">		final String subLine = line.substring(IOConstants.TAG_SPELLLIST.length() + 1);</span>
<span class="nc" id="L4144">		final StringTokenizer stok = new StringTokenizer(subLine, IOConstants.TAG_SEPARATOR, false);</span>

<span class="nc" id="L4146">		final String classKey = stok.nextToken();</span>
<span class="nc" id="L4147">		final PCClass aClass = thePC.getClassKeyed(classKey);</span>

<span class="nc" id="L4149">		AbstractReferenceContext refContext = Globals.getContext().getReferenceContext();</span>
<span class="nc bnc" id="L4150" title="All 4 branches missed.">		while ((aClass != null) &amp;&amp; stok.hasMoreTokens())</span>
		{
<span class="nc" id="L4152">			final String tok = stok.nextToken();</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">			if (tok.startsWith(&quot;CLASS.&quot;))</span>
			{
<span class="nc" id="L4155">				ClassSpellList csl =</span>
<span class="nc" id="L4156">						refContext.silentlyGetConstructedCDOMObject(ClassSpellList.class, tok.substring(6));</span>
<span class="nc" id="L4157">				thePC.addClassSpellList(csl, aClass);</span>
<span class="nc" id="L4158">			}</span>
<span class="nc bnc" id="L4159" title="All 2 branches missed.">			else if (tok.startsWith(&quot;DOMAIN.&quot;))</span>
			{
<span class="nc" id="L4161">				DomainSpellList dsl =</span>
<span class="nc" id="L4162">						refContext.silentlyGetConstructedCDOMObject(DomainSpellList.class, tok.substring(7));</span>
<span class="nc" id="L4163">				thePC.addClassSpellList(dsl, aClass);</span>
<span class="nc" id="L4164">			}</span>
			else
			{
				/*
				 * This is 5.14-ish, but have to try anyway:
				 */
<span class="nc" id="L4170">				ClassSpellList csl = refContext.silentlyGetConstructedCDOMObject(ClassSpellList.class, tok);</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">				if (csl == null)</span>
				{
<span class="nc" id="L4173">					DomainSpellList dsl = refContext.silentlyGetConstructedCDOMObject(DomainSpellList.class, tok);</span>
<span class="nc bnc" id="L4174" title="All 2 branches missed.">					if (dsl != null)</span>
					{
<span class="nc" id="L4176">						thePC.addClassSpellList(dsl, aClass);</span>
					}
<span class="nc" id="L4178">				}</span>
				else
				{
<span class="nc" id="L4181">					thePC.addClassSpellList(csl, aClass);</span>
				}
			}
<span class="nc" id="L4184">		}</span>
<span class="nc" id="L4185">	}</span>

	/*
	 * ###############################################################
	 * Character Attributes methods
	 * ###############################################################
	 */
	private void parseStatLine(final String line) throws PCGParseException
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4198">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4200">		catch (PCGParseException pcgpex)</span>
		{
			/*
			 * Ability scores are critical for characters,
			 * need to stop the load process
			 *
			 * Thomas Behr 09-09-02
			 */
<span class="nc" id="L4208">			throw new PCGParseException(&quot;parseStatLine&quot;, line, pcgpex.getMessage(), pcgpex); //$NON-NLS-1$</span>
<span class="nc" id="L4209">		}</span>

<span class="nc" id="L4211">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

<span class="nc bnc" id="L4213" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L4215">			PCGElement element = it.next();</span>
<span class="nc" id="L4216">			final String statName = element.getText();</span>
			PCStat stat =
<span class="nc" id="L4218">					Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCStat.class, statName);</span>

<span class="nc bnc" id="L4220" title="All 6 branches missed.">			if ((stat != null) &amp;&amp; seenStats.add(statName.toUpperCase()) &amp;&amp; (it.hasNext()))</span>
			{
<span class="nc" id="L4222">				element = it.next();</span>

				try
				{
<span class="nc" id="L4226">					thePC.setStat(stat, Integer.parseInt(element.getText()));</span>
				}
<span class="nc" id="L4228">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L4230">					throw new PCGParseException(&quot;parseStatLine&quot;, line, nfe.getMessage(), nfe); //$NON-NLS-1$</span>
<span class="nc" id="L4231">				}</span>
			}
			else
			{
<span class="nc" id="L4235">				final String message = &quot;Invalid attribute specification. &quot; + &quot;Cannot load character.&quot;;</span>
<span class="nc" id="L4236">				throw new PCGParseException(&quot;parseStatLine&quot;, line, message, null); //$NON-NLS-1$</span>
			}
<span class="nc" id="L4238">		}</span>
		else
		{
<span class="nc" id="L4241">			final String message = &quot;Invalid attribute specification. &quot; + &quot;Cannot load character.&quot;;</span>
<span class="nc" id="L4242">			throw new PCGParseException(&quot;parseStatLine&quot;, line, message, null); //$NON-NLS-1$</span>
		}
<span class="nc" id="L4244">	}</span>

	private void parseTabNameLine(final String line)
	{
<span class="nc" id="L4248">		thePC.setPCAttribute(PCStringKey.TABNAME,</span>
<span class="nc" id="L4249">			EntityEncoder.decode(line.substring(IOConstants.TAG_TABNAME.length() + 1)));</span>
<span class="nc" id="L4250">	}</span>

	/*
	 * ###############################################################
	 * Character Templates methods
	 * ###############################################################
	 */
	private void parseTemplateLine(final String line) throws PCGParseException
	{
<span class="nc bnc" id="L4259" title="All 2 branches missed.">		if (line.charAt(IOConstants.TAG_TEMPLATESAPPLIED.length() + 1) == '[')</span>
		{
			final PCGTokenizer tokens;

			try
			{
<span class="nc" id="L4265">				tokens = new PCGTokenizer(line);</span>
			}
<span class="nc" id="L4267">			catch (PCGParseException pcgpex)</span>
			{
<span class="nc" id="L4269">				final String message = &quot;Illegal Template line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot;</span>
<span class="nc" id="L4270">					+ pcgpex.getMessage();</span>
<span class="nc" id="L4271">				warnings.add(message);</span>

<span class="nc" id="L4273">				return;</span>
<span class="nc" id="L4274">			}</span>

<span class="nc" id="L4276">			PCTemplate aPCTemplate = null;</span>

<span class="nc" id="L4278">			Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

<span class="nc bnc" id="L4280" title="All 2 branches missed.">			if (it.hasNext())</span>
			{
<span class="nc" id="L4282">				final PCGElement element = it.next();</span>

<span class="nc" id="L4284">				String assoc = null;</span>
				//Must deal with APPLIEDTO first (before item is added to the PC)
<span class="nc bnc" id="L4286" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L4288">					String childTag = child.getName();</span>
<span class="nc bnc" id="L4289" title="All 2 branches missed.">					if (IOConstants.TAG_NAME.equals(childTag))</span>
					{
<span class="nc" id="L4291">						aPCTemplate = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4292">							.silentlyGetConstructedCDOMObject(PCTemplate.class, EntityEncoder.decode(child.getText()));</span>

<span class="nc bnc" id="L4294" title="All 2 branches missed.">						if (aPCTemplate == null)</span>
						{
<span class="nc" id="L4296">							break;</span>
						}
					}
<span class="nc bnc" id="L4299" title="All 2 branches missed.">					else if (IOConstants.TAG_APPLIEDTO.equals(childTag))</span>
					{
<span class="nc" id="L4301">						assoc = child.getText();</span>
					}
<span class="nc" id="L4303">				}</span>

<span class="nc bnc" id="L4305" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L4307">					final String childTag = child.getName();</span>

<span class="nc bnc" id="L4309" title="All 2 branches missed.">					if (IOConstants.TAG_NAME.equals(childTag))</span>
					{
<span class="nc bnc" id="L4311" title="All 2 branches missed.">						if (aPCTemplate == null)</span>
						{
<span class="nc" id="L4313">							break;</span>
						}
<span class="nc" id="L4315">						addKeyedTemplate(aPCTemplate, assoc);</span>
					}
<span class="nc bnc" id="L4317" title="All 2 branches missed.">					else if (IOConstants.TAG_CHOSENFEAT.equals(childTag))</span>
					{
<span class="nc" id="L4319">						String mapKey = null;</span>
<span class="nc" id="L4320">						String mapValue = null;</span>

<span class="nc bnc" id="L4322" title="All 2 branches missed.">						for (PCGElement subChild : child.getChildren())</span>
						{
<span class="nc" id="L4324">							final String subChildTag = subChild.getName();</span>

<span class="nc bnc" id="L4326" title="All 2 branches missed.">							if (IOConstants.TAG_MAPKEY.equals(subChildTag))</span>
							{
<span class="nc" id="L4328">								mapKey = subChild.getText();</span>
							}
<span class="nc bnc" id="L4330" title="All 2 branches missed.">							else if (IOConstants.TAG_MAPVALUE.equals(subChildTag))</span>
							{
<span class="nc" id="L4332">								mapValue = subChild.getText();</span>
							}
<span class="nc" id="L4334">						}</span>

<span class="nc bnc" id="L4336" title="All 4 branches missed.">						if ((mapKey != null) &amp;&amp; (mapValue != null))</span>
						{
<span class="nc" id="L4338">							String feat = EntityEncoder.decode(mapValue);</span>
<span class="nc" id="L4339">							PCTemplate subt =</span>
<span class="nc" id="L4340">									Compatibility.getTemplateFor(aPCTemplate, EntityEncoder.decode(mapKey), feat);</span>
<span class="nc bnc" id="L4341" title="All 2 branches missed.">							if (subt != null)</span>
							{
								CNAbilitySelection as = CNAbilitySelection
<span class="nc" id="L4344">									.getAbilitySelectionFromPersistentFormat(Globals.getContext(), feat);</span>
<span class="nc" id="L4345">								thePC.addTemplateFeat(subt, as);</span>
							}
						}
<span class="nc" id="L4348">					}</span>
<span class="nc bnc" id="L4349" title="All 2 branches missed.">					else if (IOConstants.TAG_CHOSENTEMPLATE.equals(childTag))</span>
					{
<span class="nc bnc" id="L4351" title="All 2 branches missed.">						for (PCGElement subChild : child.getChildren())</span>
						{
<span class="nc" id="L4353">							final String subChildTag = subChild.getName();</span>

<span class="nc bnc" id="L4355" title="All 2 branches missed.">							if (IOConstants.TAG_NAME.equals(subChildTag))</span>
							{
<span class="nc" id="L4357">								final String ownedTemplateKey = EntityEncoder.decode(subChild.getText());</span>
<span class="nc" id="L4358">								final PCTemplate ownedTemplate = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4359">									.silentlyGetConstructedCDOMObject(PCTemplate.class, ownedTemplateKey);</span>
<span class="nc bnc" id="L4360" title="All 2 branches missed.">								if (ownedTemplate != null)</span>
								{
<span class="nc" id="L4362">									thePC.setTemplatesAdded(aPCTemplate, ownedTemplate);</span>
								}
							}
<span class="nc" id="L4365">						}</span>
					}
					//Add handled below, AppliedTo handled in the first loop
<span class="nc bnc" id="L4368" title="All 4 branches missed.">					else if (!IOConstants.TAG_ADDTOKEN.equals(childTag) &amp;&amp; !IOConstants.TAG_APPLIEDTO.equals(childTag))</span>
					{
<span class="nc" id="L4370">						final String msg =</span>
<span class="nc" id="L4371">								LanguageBundle.getFormattedString(</span>
									&quot;Warnings.PCGenParser.UnknownTemplateInfo&quot;, //$NON-NLS-1$
<span class="nc" id="L4373">							childTag + &quot;:&quot; + child.getText());</span>
<span class="nc" id="L4374">						warnings.add(msg);</span>
					}
<span class="nc" id="L4376">				}</span>
			}
			//Must process ADD after Template is added to the PC
<span class="nc bnc" id="L4379" title="All 2 branches missed.">			for (PCGElement e : new PCGTokenizer(line).getElements())</span>
			{
<span class="nc" id="L4381">				String tag = e.getName();</span>
<span class="nc bnc" id="L4382" title="All 2 branches missed.">				if (tag.equals(IOConstants.TAG_ADDTOKEN))</span>
				{
<span class="nc" id="L4384">					parseAddTokenInfo(e, aPCTemplate);</span>
				}
<span class="nc" id="L4386">			}</span>
<span class="nc" id="L4387">		}</span>
		else
		{
<span class="nc" id="L4390">			String key = EntityEncoder.decode(line.substring(IOConstants.TAG_TEMPLATESAPPLIED.length() + 1));</span>
			PCTemplate aPCTemplate =
<span class="nc" id="L4392">					Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCTemplate.class, key);</span>
<span class="nc" id="L4393">			addKeyedTemplate(aPCTemplate, null);</span>
		}
<span class="nc" id="L4395">	}</span>

	/**
	 * # Use temporary mods/bonuses?
	 * 
	 * @param line
	 */
	private void parseUseTempModsLine(final String line)
	{
<span class="nc" id="L4404">		thePC.setUseTempMods(line.endsWith(IOConstants.VALUE_Y));</span>
<span class="nc" id="L4405">	}</span>

	private void parseVFeatLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4413">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4415">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L4417">			final String message =</span>
<span class="nc" id="L4418">					&quot;Illegal VFeat line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot; + pcgpex.getMessage();</span>
<span class="nc" id="L4419">			warnings.add(message);</span>

<span class="nc" id="L4421">			return;</span>
<span class="nc" id="L4422">		}</span>

<span class="nc" id="L4424">		final Iterator&lt;PCGElement&gt; it = tokens.getElements().iterator();</span>

		// the first element defines the Feat key name
<span class="nc bnc" id="L4427" title="All 2 branches missed.">		if (it.hasNext())</span>
		{
<span class="nc" id="L4429">			final PCGElement element = it.next();</span>

<span class="nc" id="L4431">			final String abilityKey = EntityEncoder.decode(element.getText());</span>
<span class="nc" id="L4432">			Ability anAbility = Globals.getContext().getReferenceContext().getManufacturerId(AbilityCategory.FEAT)</span>
<span class="nc" id="L4433">				.getActiveObject(abilityKey);</span>

<span class="nc bnc" id="L4435" title="All 2 branches missed.">			if (anAbility == null)</span>
			{
<span class="nc" id="L4437">				final String message = &quot;Could not add vfeat: &quot; + abilityKey;</span>
<span class="nc" id="L4438">				warnings.add(message);</span>

<span class="nc" id="L4440">				return;</span>
			}
<span class="nc" id="L4442">			CNAbility cna = CNAbilityFactory.getCNAbility(AbilityCategory.FEAT, Nature.VIRTUAL, anAbility);</span>
<span class="nc" id="L4443">			parseFeatsHandleAppliedToAndSaveTags(it, cna);</span>
<span class="nc" id="L4444">			thePC.setDirty(true);</span>
		}
<span class="nc" id="L4446">	}</span>

	/**
	 * Parses the version information from a PCG file.
	 * @param line The line containing version information
	 * @throws PCGParseException if the line is not a valid version line
	 */
	void parseVersionLine(final String line) throws PCGParseException
	{
<span class="fc" id="L4455">		int[] version = {0, 0, 0};</span>

		// Check to make sure that this is a version line
<span class="fc bfc" id="L4458" title="All 2 branches covered.">		if (!line.startsWith(IOConstants.TAG_VERSION + IOConstants.TAG_END))</span>
		{
<span class="fc" id="L4460">			throw new PCGParseException(&quot;parseVersionLine&quot;, line, &quot;Not a Version Line.&quot;); //$NON-NLS-1$</span>
		}

		// extract the tokens from the version line
<span class="fc" id="L4464">		String[] tokens = line.substring(IOConstants.TAG_VERSION.length() + 1).split(&quot;[ \\.-]&quot;, 4); //$NON-NLS-1$</span>

<span class="pc bpc" id="L4466" title="1 of 4 branches missed.">		for (int idx = 0; idx &lt; 3 &amp;&amp; idx &lt; tokens.length; idx++)</span>
		{

			try
			{
<span class="fc" id="L4471">				version[idx] = Integer.parseInt(tokens[idx]);</span>
			}
<span class="fc" id="L4473">			catch (NumberFormatException e)</span>
			{
<span class="pc bpc" id="L4475" title="1 of 4 branches missed.">				if (idx == 2 &amp;&amp; (tokens[idx].startsWith(&quot;RC&quot;)))</span>
				{
<span class="fc" id="L4477">					pcgenVersionSuffix = tokens[2];</span>
				}
				else
				{
					// Something in the first 3 digits was not an integer
<span class="fc" id="L4482">					throw new PCGParseException(&quot;parseVersionLine&quot;, line, &quot;Invalid PCGen version.&quot;, e); //$NON-NLS-1$</span>
				}
<span class="fc" id="L4484">			}</span>
		}
<span class="fc bfc" id="L4486" title="All 2 branches covered.">		if (tokens.length == 4)</span>
		{
<span class="fc" id="L4488">			pcgenVersionSuffix = tokens[3];</span>
		}
<span class="fc" id="L4490">		pcgenVersion = version;</span>
<span class="fc" id="L4491">	}</span>

	/*
	 * ###############################################################
	 * Character Weapon proficiencies methods
	 * ###############################################################
	 */
	private void parseWeaponProficienciesLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4504">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4506">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L4508">			final String message = &quot;Illegal Weapon proficiencies line ignored: &quot; + line + Constants.LINE_SEPARATOR</span>
<span class="nc" id="L4509">				+ &quot;Error: &quot; + pcgpex.getMessage();</span>
<span class="nc" id="L4510">			warnings.add(message);</span>

<span class="nc" id="L4512">			return;</span>
<span class="nc" id="L4513">		}</span>

<span class="nc" id="L4515">		CDOMObject source = null;</span>
<span class="nc" id="L4516">		boolean hadSource = false;</span>

<span class="nc bnc" id="L4518" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc bnc" id="L4520" title="All 2 branches missed.">			if (IOConstants.TAG_SOURCE.equals(element.getName()))</span>
			{
<span class="nc" id="L4522">				hadSource = true;</span>
<span class="nc" id="L4523">				String type = Constants.EMPTY_STRING;</span>
<span class="nc" id="L4524">				String key = Constants.EMPTY_STRING;</span>

<span class="nc bnc" id="L4526" title="All 2 branches missed.">				for (final PCGElement child : element.getChildren())</span>
				{
<span class="nc" id="L4528">					final String tag = child.getName();</span>

<span class="nc bnc" id="L4530" title="All 2 branches missed.">					if (IOConstants.TAG_TYPE.equals(tag))</span>
					{
<span class="nc" id="L4532">						type = child.getText().toUpperCase();</span>
					}
<span class="nc bnc" id="L4534" title="All 2 branches missed.">					else if (IOConstants.TAG_NAME.equals(tag))</span>
					{
<span class="nc" id="L4536">						key = child.getText();</span>
					}
<span class="nc" id="L4538">				}</span>

<span class="nc bnc" id="L4540" title="All 4 branches missed.">				if (Constants.EMPTY_STRING.equals(type) || Constants.EMPTY_STRING.equals(key))</span>
				{
<span class="nc" id="L4542">					final String message = &quot;Illegal Weapon proficiencies line ignored: &quot; + line;</span>
<span class="nc" id="L4543">					warnings.add(message);</span>

<span class="nc" id="L4545">					return;</span>
				}

<span class="nc bnc" id="L4548" title="All 4 branches missed.">				switch (type)</span>
				{
<span class="nc" id="L4550">					case IOConstants.TAG_RACE -&gt; source = thePC.getRace();</span>
					case TAG_PCTEMPLATE -&gt; {
<span class="nc" id="L4552">						PCTemplate template = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4553">						                             .silentlyGetConstructedCDOMObject(PCTemplate.class, key);</span>
<span class="nc bnc" id="L4554" title="All 2 branches missed.">						if (thePC.hasTemplate(template))</span>
						{
<span class="nc" id="L4556">							source = template;</span>
						}
						else
						{
<span class="nc" id="L4560">							warnings.add(&quot;PC does not have Template: &quot; + key);</span>
						}
<span class="nc" id="L4562">					}</span>
<span class="nc" id="L4563">					case IOConstants.TAG_PCCLASS -&gt; source = thePC.getClassKeyed(key);</span>
				}

<span class="nc bnc" id="L4566" title="All 2 branches missed.">				if (source == null)</span>
				{
<span class="nc" id="L4568">					final String message = &quot;Invalid source specification: &quot; + line;</span>
<span class="nc" id="L4569">					warnings.add(message);</span>
<span class="nc" id="L4570">				}</span>

				break;
			}
<span class="nc" id="L4574">		}</span>

<span class="nc" id="L4576">		final PCGElement element = tokens.getElements().get(0);</span>

<span class="nc" id="L4578">		boolean processed = false;</span>
<span class="nc bnc" id="L4579" title="All 2 branches missed.">		if (source != null)</span>
		{
<span class="nc" id="L4581">			List&lt;PersistentTransitionChoice&lt;?&gt;&gt; adds = source.getListFor(ListKey.ADD);</span>
<span class="nc bnc" id="L4582" title="All 2 branches missed.">			if (adds != null)</span>
			{
<span class="nc bnc" id="L4584" title="All 2 branches missed.">				for (PersistentTransitionChoice&lt;?&gt; ptc : adds)</span>
				{
<span class="nc bnc" id="L4586" title="All 2 branches missed.">					if (ptc.getChoiceClass().equals(WeaponProf.class))</span>
					{
<span class="nc bnc" id="L4588" title="All 2 branches missed.">						for (PCGElement child : element.getChildren())</span>
						{
<span class="nc" id="L4590">							WeaponProf wp = getWeaponProf(child.getText());</span>
<span class="nc" id="L4591">							Set c = Collections.singleton(wp);</span>
<span class="nc" id="L4592">							ptc.act(c, source, thePC);</span>
<span class="nc" id="L4593">						}</span>
<span class="nc" id="L4594">						processed = true;</span>
<span class="nc" id="L4595">						break;</span>
					}
<span class="nc" id="L4597">				}</span>
			}
		}
<span class="nc bnc" id="L4600" title="All 4 branches missed.">		if (hadSource &amp;&amp; !processed)</span>
		{
<span class="nc" id="L4602">			final String message = &quot;Unable to apply WeaponProfs: &quot; + line;</span>
<span class="nc" id="L4603">			warnings.add(message);</span>
		}
<span class="nc" id="L4605">	}</span>

	private void parseWeightLine(final String line)
	{
		try
		{
<span class="nc" id="L4611">			thePC.setWeight(</span>
<span class="nc" id="L4612">				Integer.parseInt(line.substring(IOConstants.TAG_WEIGHT.length() + 1)));</span>
		}
<span class="nc" id="L4614">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L4616">			final String message = &quot;Illegal Weight line ignored: &quot; + line;</span>
<span class="nc" id="L4617">			warnings.add(message);</span>
<span class="nc" id="L4618">		}</span>
<span class="nc" id="L4619">	}</span>

	private static String shortClassName(final Object o)
	{
<span class="nc" id="L4623">		final Class&lt;?&gt; objClass = o.getClass();</span>
<span class="nc" id="L4624">		final String pckName = objClass.getPackage().getName();</span>

<span class="nc" id="L4626">		return objClass.getName().substring(pckName.length() + 1);</span>
	}

	private WeaponProf getWeaponProf(final String aString)
	{
<span class="nc" id="L4631">		WeaponProf wp = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(WeaponProf.class,</span>
<span class="nc" id="L4632">			EntityEncoder.decode(aString));</span>
<span class="nc bnc" id="L4633" title="All 2 branches missed.">		if (wp == null)</span>
		{
<span class="nc bnc" id="L4635" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L4637">				final String message = &quot;Unable to find Weapon Proficiency in Rules Data:&quot; + aString;</span>
<span class="nc" id="L4638">				Logging.debugPrint(message);</span>
			}
		}
<span class="nc" id="L4641">		return wp;</span>
	}

	/**
	 * ###############################################################
	 * Character EquipSet Stuff
	 * ###############################################################
	 * @param line
	 **/
	private void parseCalcEquipSet(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4656">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4658">		catch (PCGParseException pcgpex)</span>
		{
			/*
			 * EquipSet is not critical for characters,
			 * no need to stop the load process
			 */
<span class="nc" id="L4664">			final String message = &quot;Illegal Calc EquipSet line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot;</span>
<span class="nc" id="L4665">				+ pcgpex.getMessage();</span>
<span class="nc" id="L4666">			warnings.add(message);</span>

<span class="nc" id="L4668">			return;</span>
<span class="nc" id="L4669">		}</span>

<span class="nc" id="L4671">		final String calcEQId = EntityEncoder.decode(tokens.getElements().get(0).getText());</span>

<span class="nc" id="L4673">		thePC.setCalcEquipSetId(calcEQId);</span>
<span class="nc" id="L4674">	}</span>

	/*
	 * ###############################################################
	 * Character Description/Bio/History methods
	 * ###############################################################
	 */
	private void parseCharacterBioLine(final String line)
	{
<span class="nc" id="L4683">		thePC.setPCAttribute(PCStringKey.BIO,</span>
<span class="nc" id="L4684">			EntityEncoder.decode(line.substring(IOConstants.TAG_CHARACTERBIO.length() + 1)));</span>
<span class="nc" id="L4685">	}</span>

	private void parseEquipmentLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4693">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4695">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L4697">			final String message = &quot;Illegal Equipment line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot;</span>
<span class="nc" id="L4698">				+ pcgpex.getMessage();</span>
<span class="nc" id="L4699">			warnings.add(message);</span>

<span class="nc" id="L4701">			return;</span>
<span class="nc" id="L4702">		}</span>

		String itemKey;
		Equipment aEquip;

		PCGElement element;

		// the first element defines the item key name
<span class="nc" id="L4710">		element = tokens.getElements().get(0);</span>
<span class="nc" id="L4711">		itemKey = EntityEncoder.decode(element.getText());</span>
		// Check for an equipment key that has been updated.
<span class="nc" id="L4713">		itemKey = EquipmentMigration.getNewEquipmentKey(itemKey, pcgenVersion, SettingsHandler.getGameAsProperty().get().getName());</span>

		// might be dynamically created container
<span class="nc" id="L4716">		aEquip = thePC.getEquipmentNamed(itemKey);</span>

<span class="nc bnc" id="L4718" title="All 2 branches missed.">		if (aEquip == null)</span>
		{
			// Must load custom equipment from the .pcg file
			// before we check the Global list (which may get
			// loaded from customEquipment.lst) as equipment
			// in the PC's .pcg may contain additional info
			// such as Charges on a wand, etc
			//
			// Make sure that we are not picking up custom items!
<span class="nc" id="L4727">			aEquip = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Equipment.class,</span>
				itemKey);
<span class="nc bnc" id="L4729" title="All 2 branches missed.">			if (aEquip != null)</span>
			{
<span class="nc bnc" id="L4731" title="All 2 branches missed.">				if (aEquip.isType(Constants.TYPE_CUSTOM))</span>
				{
<span class="nc" id="L4733">					aEquip = null;</span>
				}
				else
				{
					// standard item
<span class="nc" id="L4738">					aEquip = aEquip.clone();</span>
				}
			}
<span class="nc bnc" id="L4741" title="All 2 branches missed.">			if (line.contains(IOConstants.TAG_CUSTOMIZATION))</span>
			{
				// might be customized item
<span class="nc bnc" id="L4744" title="All 2 branches missed.">				for (PCGElement pcgElement : tokens.getElements())</span>
				{
<span class="nc" id="L4746">					element = pcgElement;</span>

<span class="nc bnc" id="L4748" title="All 2 branches missed.">					if (IOConstants.TAG_CUSTOMIZATION.equals(element.getName()))</span>
					{
<span class="nc" id="L4750">						String baseItemKey = Constants.EMPTY_STRING;</span>
<span class="nc" id="L4751">						String customProperties = Constants.EMPTY_STRING;</span>

<span class="nc bnc" id="L4753" title="All 2 branches missed.">						for (PCGElement child : element.getChildren())</span>
						{
<span class="nc" id="L4755">							final String childTag = child.getName();</span>

<span class="nc bnc" id="L4757" title="All 2 branches missed.">							if (IOConstants.TAG_BASEITEM.equals(childTag))</span>
							{
<span class="nc" id="L4759">								baseItemKey = EntityEncoder.decode(child.getText());</span>
								// Check for an equipment key that has been updated.
<span class="nc" id="L4761">								baseItemKey = EquipmentMigration.getNewEquipmentKey(baseItemKey, pcgenVersion,</span>
<span class="nc" id="L4762">									SettingsHandler.getGameAsProperty().get().getName());</span>
							}
<span class="nc bnc" id="L4764" title="All 2 branches missed.">							else if (IOConstants.TAG_DATA.equals(childTag))</span>
							{
<span class="nc" id="L4766">								customProperties = EntityEncoder.decode(child.getText());</span>
							}
<span class="nc" id="L4768">						}</span>

<span class="nc bnc" id="L4770" title="All 4 branches missed.">						if (aEquip != null &amp;&amp; baseItemKey.equals(aEquip.getBaseItemName()))</span>
						{
							// We clear out any eqmods that the base item has as the
							// EQMODs on the saved item override them.
<span class="nc" id="L4774">							EquipmentHead head = aEquip.getEquipmentHeadReference(1);</span>
<span class="nc bnc" id="L4775" title="All 2 branches missed.">							if (head != null)</span>
							{
<span class="nc" id="L4777">								head.removeListFor(ListKey.EQMOD);</span>
<span class="nc" id="L4778">								head.removeListFor(ListKey.EQMOD_INFO);</span>
							}
<span class="nc" id="L4780">							aEquip.setBase();</span>
<span class="nc" id="L4781">							aEquip.load(customProperties, &quot;$&quot;, &quot;=&quot;, thePC);</span>
<span class="nc" id="L4782">							aEquip.setToCustomSize(thePC);</span>
<span class="nc" id="L4783">						}</span>
						else
						{
							// Make sure that we are not picking up custom items!
<span class="nc" id="L4787">							Equipment aEquip2 = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4788">								.silentlyGetConstructedCDOMObject(Equipment.class, baseItemKey);</span>
<span class="nc bnc" id="L4789" title="All 2 branches missed.">							if (aEquip2 != null)</span>
							{
								// Make sure we are not getting a custom item
<span class="nc bnc" id="L4792" title="All 2 branches missed.">								if (aEquip2.isType(Constants.TYPE_CUSTOM))</span>
								{
									// TODO
<span class="nc" id="L4795">									Logging.debugPrint(aEquip2.getName() + &quot; is custom equipment. TODO - need to implement?&quot;);</span>
                                }
								else
								{
									// standard item
<span class="nc" id="L4800">									aEquip = aEquip2.clone();</span>
									// We clear out any eqmods that the base item has as
									// the
									// EQMODs on the saved item override them.
<span class="nc" id="L4804">									EquipmentHead head = aEquip.getEquipmentHeadReference(1);</span>
<span class="nc bnc" id="L4805" title="All 2 branches missed.">									if (head != null)</span>
									{
<span class="nc" id="L4807">										head.removeListFor(ListKey.EQMOD);</span>
<span class="nc" id="L4808">										head.removeListFor(ListKey.EQMOD_INFO);</span>
									}
<span class="nc" id="L4810">									aEquip.setBase();</span>
<span class="nc" id="L4811">									aEquip.load(customProperties, &quot;$&quot;, &quot;=&quot;, thePC);</span>
<span class="nc" id="L4812">									aEquip.setToCustomSize(thePC);</span>
<span class="nc" id="L4813">									aEquip.remove(StringKey.OUTPUT_NAME);</span>
<span class="nc bnc" id="L4814" title="All 2 branches missed.">									if (!aEquip.isType(Constants.TYPE_CUSTOM))</span>
									{
<span class="nc" id="L4816">										aEquip.addType(Type.CUSTOM);</span>
									}
<span class="nc" id="L4818">									Globals.getContext().getReferenceContext().importObject(aEquip.clone());</span>
								}
							}
						}

<span class="nc" id="L4823">						break;</span>
					}
<span class="nc" id="L4825">				}</span>

			}

<span class="nc bnc" id="L4829" title="All 2 branches missed.">			if (aEquip == null)</span>
			{
<span class="nc" id="L4831">				final String msg =</span>
<span class="nc" id="L4832">						LanguageBundle.getFormattedString(&quot;Warnings.PCGenParser.EquipmentNotFound&quot;, //$NON-NLS-1$</span>
					itemKey);
<span class="nc" id="L4834">				warnings.add(msg);</span>

<span class="nc" id="L4836">				return;</span>
			}

<span class="nc" id="L4839">			thePC.addEquipment(aEquip);</span>
		}

<span class="nc bnc" id="L4842" title="All 2 branches missed.">		for (PCGElement pcgElement : tokens.getElements())</span>
		{
<span class="nc" id="L4844">			element = pcgElement;</span>
<span class="nc" id="L4845">			String tag = element.getName();</span>

<span class="nc bnc" id="L4847" title="All 2 branches missed.">			if (IOConstants.TAG_QUANTITY.equals(tag))</span>
			{
<span class="nc" id="L4849">				float oldQty = aEquip.getQty();</span>
<span class="nc" id="L4850">				aEquip.setQty(element.getText());</span>
<span class="nc" id="L4851">				thePC.updateEquipmentQty(aEquip, oldQty, aEquip.getQty());</span>
<span class="nc" id="L4852">			}</span>
<span class="nc bnc" id="L4853" title="All 2 branches missed.">			else if (IOConstants.TAG_OUTPUTORDER.equals(tag))</span>
			{
<span class="nc" id="L4855">				int index = 0;</span>

				try
				{
<span class="nc" id="L4859">					index = Integer.parseInt(element.getText());</span>
				}
<span class="nc" id="L4861">				catch (NumberFormatException nfe)</span>
				{
					// nothing we can or have to do about this
<span class="nc" id="L4864">					Logging.errorPrint(&quot;Tag output order came back as not a proper number.&quot;);</span>
<span class="nc" id="L4865">				}</span>

<span class="nc" id="L4867">				aEquip.setOutputIndex(index);</span>
<span class="nc bnc" id="L4868" title="All 2 branches missed.">				if (aEquip.isAutomatic())</span>
				{
<span class="nc" id="L4870">					thePC.cacheOutputIndex(aEquip);</span>
				}
<span class="nc" id="L4872">			}</span>
<span class="nc bnc" id="L4873" title="All 2 branches missed.">			else if (IOConstants.TAG_COST.equals(tag))</span>
			{
				// TODO This else if switch currently does nothing?
<span class="nc" id="L4876">				Logging.debugPrint(tag + &quot; equals &quot; + IOConstants.TAG_COST + &quot; TODO We need to implement this.&quot;);</span>
			}
<span class="nc bnc" id="L4878" title="All 2 branches missed.">			else if (IOConstants.TAG_WT.equals(tag))</span>
			{
				// TODO This else if switch currently does nothing?
<span class="nc" id="L4881">				Logging.debugPrint(tag + &quot; equals &quot; + IOConstants.TAG_WT + &quot; TODO We need to implement this.&quot;);</span>
			}
<span class="nc bnc" id="L4883" title="All 2 branches missed.">			else if (IOConstants.TAG_NOTE.equals(tag))</span>
			{
<span class="nc" id="L4885">				aEquip.setNote(element.getText());</span>
			}
<span class="nc" id="L4887">		}</span>
<span class="nc" id="L4888">	}</span>

	private void parseEquipmentSetLine(final String line)
	{
		final PCGTokenizer tokens;

		try
		{
<span class="nc" id="L4896">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L4898">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L4900">			final String message = &quot;Illegal EquipSet line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot;</span>
<span class="nc" id="L4901">				+ pcgpex.getMessage();</span>
<span class="nc" id="L4902">			warnings.add(message);</span>

<span class="nc" id="L4904">			return;</span>
<span class="nc" id="L4905">		}</span>

<span class="nc" id="L4907">		String setName = null;</span>
<span class="nc" id="L4908">		String setID = null;</span>
<span class="nc" id="L4909">		String itemKey = null;</span>
<span class="nc" id="L4910">		String setNote = null;</span>
<span class="nc" id="L4911">		Float itemQuantity = null;</span>
<span class="nc" id="L4912">		boolean useTempMods = false;</span>

<span class="nc bnc" id="L4914" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L4916">			final String tag = element.getName();</span>

<span class="nc bnc" id="L4918" title="All 2 branches missed.">			if (IOConstants.TAG_EQUIPSET.equals(tag))</span>
			{
<span class="nc" id="L4920">				setName = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L4922" title="All 2 branches missed.">			else if (IOConstants.TAG_ID.equals(tag))</span>
			{
<span class="nc" id="L4924">				setID = element.getText();</span>
			}
<span class="nc bnc" id="L4926" title="All 2 branches missed.">			else if (IOConstants.TAG_VALUE.equals(tag))</span>
			{
<span class="nc" id="L4928">				itemKey = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L4930" title="All 2 branches missed.">			else if (IOConstants.TAG_QUANTITY.equals(tag))</span>
			{
				try
				{
<span class="nc" id="L4934">					itemQuantity = Float.valueOf(element.getText());</span>
				}
<span class="nc" id="L4936">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L4938">					itemQuantity = 0.0f;</span>
<span class="nc" id="L4939">				}</span>
			}
<span class="nc bnc" id="L4941" title="All 2 branches missed.">			else if (IOConstants.TAG_NOTE.equals(tag))</span>
			{
<span class="nc" id="L4943">				setNote = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L4945" title="All 2 branches missed.">			else if (IOConstants.TAG_USETEMPMODS.equals(tag))</span>
			{
<span class="nc" id="L4947">				useTempMods = element.getText().endsWith(IOConstants.VALUE_Y);</span>
			}
<span class="nc" id="L4949">		}</span>

<span class="nc bnc" id="L4951" title="All 6 branches missed.">		if ((setName == null) || Constants.EMPTY_STRING.equals(setName) || (setID == null)</span>
<span class="nc bnc" id="L4952" title="All 2 branches missed.">			|| Constants.EMPTY_STRING.equals(setID))</span>
		{
<span class="nc" id="L4954">			final String message = &quot;Illegal EquipSet line ignored: &quot; + line;</span>
<span class="nc" id="L4955">			warnings.add(message);</span>

<span class="nc" id="L4957">			return;</span>
		}

		final EquipSet aEquipSet;

<span class="nc" id="L4962">		aEquipSet = new EquipSet(setID, setName);</span>

<span class="nc bnc" id="L4964" title="All 2 branches missed.">		if (setNote != null)</span>
		{
<span class="nc" id="L4966">			aEquipSet.setNote(setNote);</span>
		}

<span class="nc bnc" id="L4969" title="All 2 branches missed.">		if (itemKey != null)</span>
		{
<span class="nc" id="L4971">			aEquipSet.setValue(itemKey);</span>
<span class="nc" id="L4972">			Equipment eqI = thePC.getEquipmentNamed(itemKey);</span>

<span class="nc bnc" id="L4974" title="All 2 branches missed.">			if (eqI == null)</span>
			{
<span class="nc" id="L4976">				eqI = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Equipment.class,</span>
					itemKey);
			}

<span class="nc bnc" id="L4980" title="All 2 branches missed.">			if (eqI == null)</span>
			{
<span class="nc" id="L4982">				final String message = &quot;Could not find equipment: &quot; + itemKey;</span>
<span class="nc" id="L4983">				warnings.add(message);</span>

<span class="nc" id="L4985">				return;</span>
			}
<span class="nc" id="L4987">			Equipment aEquip = eqI.clone();</span>

<span class="nc bnc" id="L4989" title="All 2 branches missed.">			if (itemQuantity != null)</span>
			{
<span class="nc" id="L4991">				aEquipSet.setQty(itemQuantity);</span>
<span class="nc" id="L4992">				aEquip.setQty(itemQuantity);</span>
<span class="nc" id="L4993">				aEquip.setNumberCarried(itemQuantity);</span>
			}

			// if the idPath is longer than 3
			// it's inside a container
<span class="nc bnc" id="L4998" title="All 2 branches missed.">			if ((new StringTokenizer(setID, &quot;.&quot;)).countTokens() &gt; 3) //$NON-NLS-1$</span>
			{
				// get parent EquipSet
<span class="nc" id="L5001">				final EquipSet aEquipSet2 = thePC.getEquipSetByIdPath(aEquipSet.getParentIdPath());</span>

				// get the container
<span class="nc" id="L5004">				Equipment aEquip2 = null;</span>

<span class="nc bnc" id="L5006" title="All 2 branches missed.">				if (aEquipSet2 != null)</span>
				{
<span class="nc" id="L5008">					aEquip2 = aEquipSet2.getItem();</span>
				}

				// add the child to container
<span class="nc bnc" id="L5012" title="All 2 branches missed.">				if (aEquip2 != null)</span>
				{
<span class="nc" id="L5014">					aEquip2.insertChild(thePC, aEquip);</span>
<span class="nc" id="L5015">					aEquip.setParent(aEquip2);</span>
				}
			}

<span class="nc" id="L5019">			aEquipSet.setItem(aEquip);</span>
		}

<span class="nc" id="L5022">		aEquipSet.setUseTempMods(useTempMods);</span>

<span class="nc" id="L5024">		thePC.addEquipSet(aEquipSet);</span>
<span class="nc" id="L5025">	}</span>

	/*
	 * ###############################################################
	 * Character Equipment methods
	 * ###############################################################
	 */
	private void parseMoneyLine(final String line)
	{
<span class="nc" id="L5034">		BigDecimal bd = new BigDecimal(</span>
<span class="nc" id="L5035">			line.substring(IOConstants.TAG_MONEY.length() + 1));</span>
<span class="nc" id="L5036">		ChannelUtilities.setControlledChannel(thePC.getCharID(),</span>
			CControl.GOLDINPUT, bd);
<span class="nc" id="L5038">	}</span>

	/**
	 * ###############################################################
	 * Temporary Bonuses
	 * ###############################################################
	 * @param line
	 **/
	private void parseTempBonusLine(final String line)
	{
		PCGTokenizer tokens;

		try
		{
<span class="nc" id="L5052">			tokens = new PCGTokenizer(line);</span>
		}
<span class="nc" id="L5054">		catch (PCGParseException pcgpex)</span>
		{
<span class="nc" id="L5056">			final String message = &quot;Illegal TempBonus line ignored: &quot; + line + Constants.LINE_SEPARATOR + &quot;Error: &quot;</span>
<span class="nc" id="L5057">				+ pcgpex.getMessage();</span>
<span class="nc" id="L5058">			warnings.add(message);</span>

<span class="nc" id="L5060">			return;</span>
<span class="nc" id="L5061">		}</span>

<span class="nc" id="L5063">		String cTag = null;</span>
<span class="nc" id="L5064">		String tName = null;</span>
<span class="nc" id="L5065">		boolean active = true;</span>

<span class="nc bnc" id="L5067" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L5069">			final String tag = element.getName();</span>

<span class="nc bnc" id="L5071" title="All 2 branches missed.">			if (IOConstants.TAG_TEMPBONUS.equals(tag))</span>
			{
<span class="nc" id="L5073">				cTag = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L5075" title="All 2 branches missed.">			else if (IOConstants.TAG_TEMPBONUSTARGET.equals(tag))</span>
			{
<span class="nc" id="L5077">				tName = EntityEncoder.decode(element.getText());</span>
			}
<span class="nc bnc" id="L5079" title="All 2 branches missed.">			else if (IOConstants.TAG_TEMPBONUSACTIVE.equals(tag))</span>
			{
<span class="nc" id="L5081">				active = element.getText().endsWith(IOConstants.VALUE_Y);</span>
			}
<span class="nc" id="L5083">		}</span>

<span class="nc bnc" id="L5085" title="All 4 branches missed.">		if ((cTag == null) || (tName == null))</span>
		{
<span class="nc" id="L5087">			warnings.add(&quot;Illegal TempBonus line ignored: &quot; + line);</span>

<span class="nc" id="L5089">			return;</span>
		}

<span class="nc" id="L5092">		final StringTokenizer aTok = new StringTokenizer(cTag, &quot;=&quot;, false); //$NON-NLS-1$</span>

<span class="nc bnc" id="L5094" title="All 2 branches missed.">		if (aTok.countTokens() &lt; 2)</span>
		{
<span class="nc" id="L5096">			return;</span>
		}

<span class="nc" id="L5099">		final String cType = aTok.nextToken();</span>
<span class="nc" id="L5100">		final String cKey = aTok.nextToken();</span>

<span class="nc" id="L5102">		Equipment aEq = null;</span>

<span class="nc bnc" id="L5104" title="All 2 branches missed.">		if (!tName.equals(IOConstants.TAG_PC))</span>
		{
			// bonus is applied to an equipment item
			// so create a new one and add to PC
<span class="nc" id="L5108">			final Equipment eq = thePC.getEquipmentNamed(tName);</span>

<span class="nc bnc" id="L5110" title="All 2 branches missed.">			if (eq == null)</span>
			{
<span class="nc" id="L5112">				return;</span>
			}

<span class="nc" id="L5115">			aEq = eq.clone();</span>

			//aEq.setWeight(&quot;0&quot;);
<span class="nc" id="L5118">			aEq.resetTempBonusList();</span>
		}

<span class="nc bnc" id="L5121" title="All 2 branches missed.">		for (PCGElement element : tokens.getElements())</span>
		{
<span class="nc" id="L5123">			final String tag = element.getName();</span>

			final String bonus;
<span class="nc bnc" id="L5126" title="All 2 branches missed.">			if (IOConstants.TAG_TEMPBONUSBONUS.equals(tag))</span>
			{
<span class="nc" id="L5128">				bonus = EntityEncoder.decode(element.getText());</span>
			}
			else
			{
				continue;
			}

<span class="nc bnc" id="L5135" title="All 2 branches missed.">			if (bonus.length() &lt;= 0)</span>
			{
<span class="nc" id="L5137">				continue;</span>
			}

<span class="nc" id="L5140">			BonusObj newB = null;</span>
<span class="nc" id="L5141">			Object creator = null;</span>
<span class="nc" id="L5142">			LoadContext context = Globals.getContext();</span>
			// Check the Creator type so we know what
			// type of object to set as the creator
<span class="nc bnc" id="L5145" title="All 8 branches missed.">            switch (cType)</span>
            {
                case IOConstants.TAG_FEAT:
<span class="nc bnc" id="L5148" title="All 2 branches missed.">                    for (AbilityCategory aCat : SettingsHandler.getGameAsProperty().get().getAllAbilityCategories())</span>
                    {
                        Ability a =
<span class="nc" id="L5151">                                Globals.getContext().getReferenceContext().getManufacturerId(aCat).getActiveObject(cKey);</span>
<span class="nc bnc" id="L5152" title="All 2 branches missed.">                        if (a != null)</span>
                        {
<span class="nc" id="L5154">                            newB = Bonus.newBonus(context, bonus);</span>
<span class="nc" id="L5155">                            creator = a;</span>
<span class="nc" id="L5156">                            break;</span>
                        }
<span class="nc" id="L5158">                    }</span>
<span class="nc" id="L5159">                    break;</span>
                case IOConstants.TAG_EQUIPMENT:
<span class="nc" id="L5161">                    Equipment aEquip = thePC.getEquipmentNamed(cKey);</span>

<span class="nc bnc" id="L5163" title="All 2 branches missed.">                    if (aEquip == null)</span>
                    {
<span class="nc" id="L5165">                        aEquip = context.getReferenceContext().silentlyGetConstructedCDOMObject(Equipment.class, cKey);</span>
                    }

<span class="nc bnc" id="L5168" title="All 2 branches missed.">                    if (aEquip != null)</span>
                    {
<span class="nc" id="L5170">                        newB = Bonus.newBonus(context, bonus);</span>
<span class="nc" id="L5171">                        creator = aEquip;</span>
                    }
                    break;
                case IOConstants.TAG_CLASS:
<span class="nc" id="L5175">                    final PCClass aClass = thePC.getClassKeyed(cKey);</span>

<span class="nc bnc" id="L5177" title="All 2 branches missed.">                    if (aClass == null)</span>
                    {
<span class="nc" id="L5179">                        continue;</span>
                    }

<span class="nc" id="L5182">                    int idx = bonus.indexOf('|');</span>
<span class="nc" id="L5183">                    newB = Bonus.newBonus(context, bonus.substring(idx + 1));</span>
<span class="nc" id="L5184">                    creator = aClass;</span>
<span class="nc" id="L5185">                    break;</span>
                case IOConstants.TAG_TEMPLATE:
<span class="nc" id="L5187">                    PCTemplate aTemplate =</span>
<span class="nc" id="L5188">                            context.getReferenceContext().silentlyGetConstructedCDOMObject(PCTemplate.class, cKey);</span>

<span class="nc bnc" id="L5190" title="All 2 branches missed.">                    if (aTemplate != null)</span>
                    {
<span class="nc" id="L5192">                        newB = Bonus.newBonus(context, bonus);</span>
<span class="nc" id="L5193">                        creator = aTemplate;</span>
                    }
                    break;
                case IOConstants.TAG_SKILL:
<span class="nc" id="L5197">                    Skill aSkill = context.getReferenceContext().silentlyGetConstructedCDOMObject(Skill.class, cKey);</span>

<span class="nc bnc" id="L5199" title="All 2 branches missed.">                    if (aSkill != null)</span>
                    {
<span class="nc" id="L5201">                        newB = Bonus.newBonus(context, bonus);</span>
<span class="nc" id="L5202">                        creator = aSkill;</span>
                    }
                    break;
                case IOConstants.TAG_SPELL:
<span class="nc" id="L5206">                    final Spell aSpell = context.getReferenceContext().silentlyGetConstructedCDOMObject(Spell.class, cKey);</span>

<span class="nc bnc" id="L5208" title="All 2 branches missed.">                    if (aSpell != null)</span>
                    {
<span class="nc" id="L5210">                        newB = Bonus.newBonus(context, bonus);</span>
<span class="nc" id="L5211">                        creator = aSpell;</span>
                    }
                    break;
                case IOConstants.TAG_NAME:
<span class="nc" id="L5215">                    newB = Bonus.newBonus(context, bonus);</span>
                    //newB.setCreatorObject(thePC);
                    break;
            }

<span class="nc bnc" id="L5220" title="All 2 branches missed.">			if (newB == null)</span>
			{
<span class="nc" id="L5222">				return;</span>
			}

			TempBonusInfo tempBonusInfo;
			// Check to see if the target was the PC or an Item
<span class="nc bnc" id="L5227" title="All 2 branches missed.">			if (tName.equals(IOConstants.TAG_PC))</span>
			{
<span class="nc" id="L5229">				thePC.setApplied(newB, true);</span>
<span class="nc" id="L5230">				tempBonusInfo = thePC.addTempBonus(newB, creator, thePC);</span>
			}
			else
			{
<span class="nc" id="L5234">				thePC.setApplied(newB, true);</span>
<span class="nc" id="L5235">				aEq.addTempBonus(newB);</span>
<span class="nc" id="L5236">				tempBonusInfo = thePC.addTempBonus(newB, creator, aEq);</span>
			}

<span class="nc bnc" id="L5239" title="All 2 branches missed.">			if (!active)</span>
			{
<span class="nc" id="L5241">				String bonusName = BonusDisplay.getBonusDisplayName(tempBonusInfo);</span>
<span class="nc" id="L5242">				thePC.setTempBonusFilter(bonusName);</span>
			}
<span class="nc" id="L5244">		}</span>

<span class="nc bnc" id="L5246" title="All 2 branches missed.">		if (aEq != null)</span>
		{
<span class="nc" id="L5248">			aEq.setAppliedName(cKey);</span>
<span class="nc" id="L5249">			thePC.addTempBonusItemList(aEq);</span>
		}

<span class="nc" id="L5252">	}</span>

	/*
	 * currently source is either empty or
	 * PCCLASS|classname|classlevel (means it's a chosen special ability)
	 * PCCLASS=classname|classlevel (means it's a defined special ability)
	 * DEITY=deityname|totallevels
	 */
	private static String sourceElementToString(final PCGElement source)
	{
<span class="nc" id="L5262">		String type = Constants.EMPTY_STRING;</span>
<span class="nc" id="L5263">		String name = Constants.EMPTY_STRING;</span>
<span class="nc" id="L5264">		String level = Constants.EMPTY_STRING;</span>
<span class="nc" id="L5265">		String defined = Constants.EMPTY_STRING;</span>

<span class="nc bnc" id="L5267" title="All 2 branches missed.">		for (PCGElement child : source.getChildren())</span>
		{
<span class="nc" id="L5269">			final String tag = child.getName();</span>

<span class="nc bnc" id="L5271" title="All 2 branches missed.">			if (IOConstants.TAG_TYPE.equals(tag))</span>
			{
<span class="nc" id="L5273">				type = child.getText();</span>
			}
<span class="nc bnc" id="L5275" title="All 2 branches missed.">			else if (IOConstants.TAG_NAME.equals(tag))</span>
			{
<span class="nc" id="L5277">				name = child.getText();</span>
			}
<span class="nc bnc" id="L5279" title="All 2 branches missed.">			else if (IOConstants.TAG_LEVEL.equals(tag))</span>
			{
<span class="nc" id="L5281">				level = child.getText();</span>
			}
<span class="nc bnc" id="L5283" title="All 2 branches missed.">			else if (IOConstants.TAG_DEFINED.equals(tag))</span>
			{
<span class="nc" id="L5285">				defined = child.getText().toUpperCase();</span>
			}
<span class="nc" id="L5287">		}</span>

		//TODO:gorm - guestimate good starting buffer size
<span class="nc" id="L5290">		final StringBuilder buffer = new StringBuilder(1000);</span>
<span class="nc" id="L5291">		buffer.append(type);</span>
<span class="nc bnc" id="L5292" title="All 2 branches missed.">		buffer.append((IOConstants.VALUE_Y.equals(defined)) ? '=' : '|');</span>
<span class="nc" id="L5293">		buffer.append(name);</span>

<span class="nc bnc" id="L5295" title="All 2 branches missed.">		if (!Constants.EMPTY_STRING.equals(level))</span>
		{
<span class="nc" id="L5297">			buffer.append('|');</span>
<span class="nc" id="L5298">			buffer.append(level);</span>
		}

<span class="nc" id="L5301">		return buffer.toString();</span>
	}

	/*
	 * ###############################################################
	 * Inner classes
	 * ###############################################################
	 */
	private static final class PCGElement
	{
		private final String name;
		private List&lt;PCGElement&gt; children;
		private String text;

		private PCGElement(final String aName)
<span class="nc" id="L5316">		{</span>
<span class="nc" id="L5317">			this.name = aName;</span>
<span class="nc" id="L5318">		}</span>

		/**
		 * Returns a string representation of the element.  This string is
		 * written in XML format.
		 * @return An XML formatted string.
		 */
		@Override
		public String toString()
		{
			//TODO:gorm - optimize StringBuilder size
<span class="nc" id="L5329">			final StringBuilder buffer = new StringBuilder(1000);</span>
<span class="nc" id="L5330">			buffer.append('&lt;').append(getName()).append('&gt;').append(IOConstants.LINE_SEP);</span>
<span class="nc" id="L5331">			buffer.append(&quot;&lt;text&gt;&quot;).append(getText()) //$NON-NLS-1$</span>
<span class="nc" id="L5332">				.append(&quot;&lt;/text&gt;&quot;).append(IOConstants.LINE_SEP); //$NON-NLS-1$</span>

<span class="nc bnc" id="L5334" title="All 2 branches missed.">			for (PCGElement child : getChildren())</span>
			{
<span class="nc" id="L5336">				buffer.append(child).append(IOConstants.LINE_SEP);</span>
<span class="nc" id="L5337">			}</span>

<span class="nc" id="L5339">			buffer.append(&quot;&lt;/&quot;).append(getName()).append('&gt;'); //$NON-NLS-1$</span>

<span class="nc" id="L5341">			return buffer.toString();</span>
		}

		/**
		 * Returns all the children of this element.
		 * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: This has a side effect of initializing the children
		 * list for the element.
		 * @return A {@code List} of children
		 */
		public List&lt;PCGElement&gt; getChildren()
		{
<span class="nc bnc" id="L5352" title="All 2 branches missed.">			if (children == null)</span>
			{
<span class="nc" id="L5354">				this.children = new ArrayList&lt;&gt;(0);</span>
			}

<span class="nc" id="L5357">			return children;</span>
		}

		private String getName()
		{
<span class="nc" id="L5362">			return name;</span>
		}

		private String getText()
		{
<span class="nc bnc" id="L5367" title="All 2 branches missed.">			return (text != null) ? text : Constants.EMPTY_STRING;</span>
		}

		private void addContent(final PCGElement child)
		{
<span class="nc bnc" id="L5372" title="All 2 branches missed.">			if (children == null)</span>
			{
<span class="nc" id="L5374">				this.children = new ArrayList&lt;&gt;(0);</span>
			}

<span class="nc" id="L5377">			children.add(child);</span>
<span class="nc" id="L5378">		}</span>

		private void addContent(final String argText)
		{
<span class="nc" id="L5382">			text = argText;</span>
<span class="nc" id="L5383">		}</span>
	}

	private static final class PCGTokenizer
	{
		private final List&lt;PCGElement&gt; elements;
		private final String innerDelimiter;
		private final String nestedStartDelimiter;
		private final String nestedStopDelimiter;
		private final String outerDelimiter;
		private final char nestedStartDelimiterChar;
		private final char nestedStopDelimiterChar;

		/**
		 * Constructor
		 * @param line
		 * @throws PCGParseException
		 */
		private PCGTokenizer(final String line) throws PCGParseException
		{
<span class="nc" id="L5403">			this(line, &quot;:|[]&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5404">		}</span>

		/**
		 * Constructor
		 * @param line           a String to tokenize
		 * @param delimiters     a FOUR-character String specifying the four needed delimiters:
		 *                       &lt;ol&gt;
		 *                           &lt;li&gt;the inner delimiter for a PCGElement&lt;/li&gt;
		 *                           &lt;li&gt;the outer delimiter for a PCGElement&lt;/li&gt;
		 *                           &lt;li&gt;the start delimiter for nested PCGElements&lt;/li&gt;
		 *                           &lt;li&gt;the stop delimiter for nested PCGElement&lt;/li&gt;
		 *                       &lt;/ol&gt;
		 * @throws PCGParseException
		 */
		private PCGTokenizer(final String line, final String delimiters) throws PCGParseException
<span class="nc" id="L5419">		{</span>
<span class="nc" id="L5420">			final char[] dels = delimiters.toCharArray();</span>

<span class="nc" id="L5422">			this.innerDelimiter = String.valueOf(dels[0]);</span>
<span class="nc" id="L5423">			this.outerDelimiter = String.valueOf(dels[1]);</span>
<span class="nc" id="L5424">			this.nestedStartDelimiter = String.valueOf(dels[2]);</span>
<span class="nc" id="L5425">			this.nestedStopDelimiter = String.valueOf(dels[3]);</span>

<span class="nc" id="L5427">			this.nestedStartDelimiterChar = nestedStartDelimiter.charAt(0);</span>
<span class="nc" id="L5428">			this.nestedStopDelimiterChar = nestedStopDelimiter.charAt(0);</span>

<span class="nc" id="L5430">			this.elements = new ArrayList&lt;&gt;(0);</span>

<span class="nc" id="L5432">			tokenizeLine(line);</span>
<span class="nc" id="L5433">		}</span>

		private List&lt;PCGElement&gt; getElements()
		{
<span class="nc" id="L5437">			return elements;</span>
		}

		private void checkSyntax(final String line) throws PCGParseException
		{
<span class="nc" id="L5442">			final char[] chars = line.toCharArray();</span>

<span class="nc" id="L5444">			int delimCount = 0;</span>

<span class="nc bnc" id="L5446" title="All 2 branches missed.">			for (char aChar : chars)</span>
			{
<span class="nc bnc" id="L5448" title="All 2 branches missed.">				if (aChar == nestedStartDelimiterChar)</span>
				{
<span class="nc" id="L5450">					++delimCount;</span>
				}
<span class="nc bnc" id="L5452" title="All 2 branches missed.">				else if (aChar == nestedStopDelimiterChar)</span>
				{
<span class="nc" id="L5454">					--delimCount;</span>
				}
			}

<span class="nc bnc" id="L5458" title="All 2 branches missed.">			if (delimCount &lt; 0)</span>
			{
<span class="nc" id="L5460">				final String message = &quot;Missing &quot; + nestedStartDelimiter;</span>
<span class="nc" id="L5461">				throw new PCGParseException(&quot;PCGTokenizer::checkSyntax&quot;, line, message);</span>
			}
<span class="nc bnc" id="L5463" title="All 2 branches missed.">			else if (delimCount &gt; 0)</span>
			{
<span class="nc" id="L5465">				final String message = &quot;Missing &quot; + nestedStopDelimiter;</span>
<span class="nc" id="L5466">				throw new PCGParseException(&quot;PCGTokenizer::checkSyntax&quot;, line, message);</span>
			}
<span class="nc" id="L5468">		}</span>

		private void tokenizeLine(final String line) throws PCGParseException
		{
<span class="nc" id="L5472">			checkSyntax(line);</span>

<span class="nc" id="L5474">			final PCGElement root = new PCGElement(&quot;root&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5475">			tokenizeLine(root, line);</span>
<span class="nc" id="L5476">			elements.addAll(root.getChildren());</span>
<span class="nc" id="L5477">		}</span>

		private void tokenizeLine(final PCGElement parent, final String line) throws PCGParseException
		{
<span class="nc" id="L5481">			final String dels = outerDelimiter + nestedStartDelimiter + nestedStopDelimiter;</span>
<span class="nc" id="L5482">			final StringTokenizer tokens = new StringTokenizer(line, dels, true);</span>

<span class="nc" id="L5484">			int nestedDepth = 0;</span>
<span class="nc" id="L5485">			String tag = null;</span>
<span class="nc" id="L5486">			final StringBuilder buffer = new StringBuilder(1000);</span>

<span class="nc bnc" id="L5488" title="All 2 branches missed.">			while (tokens.hasMoreTokens())</span>
			{
<span class="nc" id="L5490">				String token = tokens.nextToken().trim();</span>

<span class="nc bnc" id="L5492" title="All 2 branches missed.">				if (token.equals(outerDelimiter))</span>
				{
<span class="nc bnc" id="L5494" title="All 2 branches missed.">					if (nestedDepth == 0)</span>
					{
<span class="nc bnc" id="L5496" title="All 2 branches missed.">						if (buffer.length() &gt; 0)</span>
						{
<span class="nc" id="L5498">							token = buffer.toString();</span>

<span class="nc" id="L5500">							int index = token.indexOf(innerDelimiter);</span>

<span class="nc bnc" id="L5502" title="All 2 branches missed.">							if (index &gt;= 0)</span>
							{
<span class="nc" id="L5504">								buffer.delete(0, buffer.length());</span>

<span class="nc" id="L5506">								final PCGElement element = new PCGElement(token.substring(0, index));</span>
<span class="nc" id="L5507">								element.addContent(token.substring(index + 1));</span>
<span class="nc" id="L5508">								parent.addContent(element);</span>
<span class="nc" id="L5509">							}</span>
							else
							{
<span class="nc" id="L5512">								final String message = &quot;Malformed PCG element: &quot; + token;</span>
<span class="nc" id="L5513">								throw new PCGParseException(&quot;PCGTokenizer::tokenizeLine&quot;, line, message);</span>
							}
<span class="nc" id="L5515">						}</span>
					}
					else
					{
<span class="nc" id="L5519">						buffer.append(token);</span>
					}
				}
<span class="nc bnc" id="L5522" title="All 2 branches missed.">				else if (token.equals(nestedStartDelimiter))</span>
				{
<span class="nc bnc" id="L5524" title="All 2 branches missed.">					if (nestedDepth == 0)</span>
					{
<span class="nc" id="L5526">						token = buffer.toString();</span>

<span class="nc" id="L5528">						int index = token.indexOf(innerDelimiter);</span>

<span class="nc bnc" id="L5530" title="All 4 branches missed.">						if ((index &gt;= 0) &amp;&amp; (index == (token.length() - 1)))</span>
						{
<span class="nc" id="L5532">							buffer.delete(0, buffer.length());</span>

<span class="nc" id="L5534">							tag = token.substring(0, index);</span>
						}
						else
						{
<span class="nc" id="L5538">							final String message = &quot;Malformed PCG element: &quot; + token;</span>
<span class="nc" id="L5539">							throw new PCGParseException(&quot;PCGTokenizer::tokenizeLine&quot;, line, message);</span>
						}
<span class="nc" id="L5541">					}</span>
					else
					{
<span class="nc" id="L5544">						buffer.append(token);</span>
					}

<span class="nc" id="L5547">					++nestedDepth;</span>
				}
<span class="nc bnc" id="L5549" title="All 2 branches missed.">				else if (token.equals(nestedStopDelimiter))</span>
				{
<span class="nc" id="L5551">					--nestedDepth;</span>

<span class="nc bnc" id="L5553" title="All 2 branches missed.">					if (nestedDepth == 0)</span>
					{
<span class="nc" id="L5555">						final PCGElement element = new PCGElement(tag);</span>
<span class="nc" id="L5556">						tokenizeLine(element, buffer.toString());</span>
<span class="nc" id="L5557">						parent.addContent(element);</span>
<span class="nc" id="L5558">						buffer.delete(0, buffer.length());</span>
<span class="nc" id="L5559">					}</span>
					else
					{
<span class="nc" id="L5562">						buffer.append(token);</span>
					}
				}
				else
				{
<span class="nc" id="L5567">					buffer.append(token);</span>
				}
<span class="nc" id="L5569">			}</span>

<span class="nc bnc" id="L5571" title="All 2 branches missed.">			if (buffer.length() &gt; 0)</span>
			{
<span class="nc" id="L5573">				final String token = buffer.toString();</span>

<span class="nc" id="L5575">				final int index = token.indexOf(innerDelimiter);</span>

<span class="nc bnc" id="L5577" title="All 2 branches missed.">				if (index &gt;= 0)</span>
				{
<span class="nc" id="L5579">					buffer.delete(0, buffer.length());</span>

<span class="nc" id="L5581">					final PCGElement element = new PCGElement(token.substring(0, index));</span>
<span class="nc" id="L5582">					element.addContent(token.substring(index + 1));</span>
<span class="nc" id="L5583">					parent.addContent(element);</span>
<span class="nc" id="L5584">				}</span>
				else
				{
<span class="nc" id="L5587">					final String message = &quot;Malformed PCG element: &quot; + token;</span>
<span class="nc" id="L5588">					throw new PCGParseException(&quot;PCGTokenizer::tokenizeLine&quot;, line, message);</span>
				}
			}
<span class="nc" id="L5591">		}</span>
	}

	/**
	 * Returns the version of the application that wrote the file
	 * @return An {@code int} array containing the 3 digit version
	 */
	int[] getPcgenVersion()
	{
<span class="fc" id="L5600">		return pcgenVersion;</span>
	}

	/**
	 * Compare the PCG version with a supplied version number 
	 * @param inVer The version to compare with the PCG version. Must have at least 3 elements.
	 * @return the value 0 if the PCG version is equal to the supplied version; a 
	 * value less than 0 if the PCG version is less than the supplied version; 
	 * and a value greater than 0 if the PCG version is greater than the supplied version.
	 */
	int compareVersionTo(int[] inVer)
	{
<span class="fc" id="L5612">		return CoreUtility.compareVersions(pcgenVersion, inVer);</span>
	}

	/**
	 * Returns any extra version info after the regular version number.
	 * @return String extra version information
	 */
	String getPcgenVersionSuffix()
	{
<span class="fc" id="L5621">		return pcgenVersionSuffix;</span>
	}

	private void parseLevelAbilityInfo(final PCGElement element, final CDOMObject pObj)
	{
<span class="nc" id="L5626">		parseLevelAbilityInfo(element, pObj, -9);</span>
<span class="nc" id="L5627">	}</span>

	private void parseLevelAbilityInfo(final PCGElement element, final CDOMObject pObj, final int level)
	{
<span class="nc" id="L5631">		final Iterator&lt;PCGElement&gt; it2 = element.getChildren().iterator();</span>

<span class="nc bnc" id="L5633" title="All 2 branches missed.">		if (it2.hasNext())</span>
		{
<span class="nc" id="L5635">			final String dString = EntityEncoder.decode(it2.next().getText());</span>

			PersistentTransitionChoice&lt;?&gt; ptc;
<span class="nc" id="L5638">			ptc = Compatibility.processOldAdd(Globals.getContext(), dString);</span>

<span class="nc bnc" id="L5640" title="All 2 branches missed.">			if (ptc == null)</span>
			{
<span class="nc" id="L5642">				warnings.add(pObj.getDisplayName() + &quot;(&quot; + pObj.getClass().getName()</span>
					+ &quot;)\nCould not process LevelAbility: &quot; + dString);
<span class="nc" id="L5644">				return;</span>
			}

<span class="nc" id="L5647">			CDOMObject target = pObj;</span>
<span class="nc bnc" id="L5648" title="All 2 branches missed.">			if (pObj instanceof PCClass)</span>
			{
<span class="nc" id="L5650">				target = thePC.getActiveClassLevel(((PCClass) pObj), level);</span>
			}
<span class="nc bnc" id="L5652" title="All 2 branches missed.">			for (PersistentTransitionChoice&lt;?&gt; tptc : target.getSafeListFor(ListKey.ADD))</span>
			{
<span class="nc bnc" id="L5654" title="All 2 branches missed.">				if (tptc.equals(ptc))</span>
				{
<span class="nc bnc" id="L5656" title="All 2 branches missed.">					while (it2.hasNext())</span>
					{
<span class="nc" id="L5658">						final String choice = EntityEncoder.decode(it2.next().getText());</span>
<span class="nc" id="L5659">						thePC.addAssoc(tptc, AssociationListKey.ADD, choice);</span>
<span class="nc" id="L5660">					}</span>
				}
<span class="nc" id="L5662">			}</span>
		}
<span class="nc" id="L5664">	}</span>

	/**
	 * @return the baseFeatPool
	 */
	@Override
	public double getBaseFeatPool()
	{
<span class="nc" id="L5672">		return baseFeatPool;</span>
	}

	/**
	 * @return the calcFeatPoolAfterLoad
	 */
	@Override
	public boolean isCalcFeatPoolAfterLoad()
	{
<span class="nc" id="L5681">		return calcFeatPoolAfterLoad;</span>
	}

<span class="fc" id="L5684">	private static final Class&lt;Language&gt; LANGUAGE_CLASS = Language.class;</span>

	private void resolveLanguages()
	{
<span class="nc" id="L5688">		CNAbility langbonus = thePC.getBonusLanguageAbility();</span>
<span class="nc" id="L5689">		int currentBonusLang = thePC.getDetailedAssociationCount(langbonus);</span>
<span class="nc bnc" id="L5690" title="All 2 branches missed.">		boolean foundLang = currentBonusLang &gt; 0;</span>

<span class="nc" id="L5692">		Set&lt;Language&gt; foundLanguages = new HashSet&lt;&gt;(thePC.getLanguageSet());</span>
		//Captures Auto (AUTO:LANG) and Persistent choices (ADD ex ability and CHOOSE)
<span class="nc" id="L5694">		cachedLanguages.removeAll(foundLanguages);</span>

<span class="nc" id="L5696">		HashMapToList&lt;Language, Object&gt; langSources = new HashMapToList&lt;&gt;();</span>
<span class="nc" id="L5697">		Map&lt;Object, Integer&gt; actorLimit = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L5698">		Map&lt;PersistentTransitionChoice, CDOMObject&gt; ptcSources = new IdentityHashMap&lt;&gt;();</span>

<span class="nc" id="L5700">		List&lt;? extends CDOMObject&gt; abilities = thePC.getCDOMObjectList();</span>
<span class="nc bnc" id="L5701" title="All 2 branches missed.">		for (CDOMObject a : abilities)</span>
		{
<span class="nc" id="L5703">			List&lt;PersistentTransitionChoice&lt;?&gt;&gt; addList = a.getListFor(ListKey.ADD);</span>
<span class="nc bnc" id="L5704" title="All 2 branches missed.">			if (addList != null)</span>
			{
<span class="nc bnc" id="L5706" title="All 2 branches missed.">				for (PersistentTransitionChoice&lt;?&gt; ptc : addList)</span>
				{
<span class="nc" id="L5708">					SelectableSet&lt;?&gt; ss = ptc.getChoices();</span>
<span class="nc bnc" id="L5709" title="All 4 branches missed.">					if (ss.getName().equals(&quot;LANGUAGE&quot;) &amp;&amp; LANGUAGE_CLASS.equals(ss.getChoiceClass()))</span>
					{
<span class="nc" id="L5711">						Collection&lt;Language&gt; selected = (Collection&lt;Language&gt;) ss.getSet(thePC);</span>
<span class="nc bnc" id="L5712" title="All 2 branches missed.">						for (Language l : selected)</span>
						{
<span class="nc bnc" id="L5714" title="All 2 branches missed.">							if (cachedLanguages.contains(l))</span>
							{
<span class="nc" id="L5716">								String source = SourceFormat.getFormattedString(a, Globals.getSourceDisplay(), true);</span>
<span class="nc" id="L5717">								int choiceCount = ptc.getCount().resolve(thePC, source).intValue();</span>
<span class="nc bnc" id="L5718" title="All 2 branches missed.">								if (choiceCount &gt; 0)</span>
								{
<span class="nc" id="L5720">									langSources.addToListFor(l, ptc);</span>
<span class="nc" id="L5721">									ptcSources.put(ptc, a);</span>
<span class="nc" id="L5722">									actorLimit.put(ptc, choiceCount);</span>
								}
							}
<span class="nc" id="L5725">						}</span>
					}
<span class="nc" id="L5727">				}</span>
			}
<span class="nc" id="L5729">		}</span>
<span class="nc bnc" id="L5730" title="All 2 branches missed.">		if (!foundLang)</span>
		{
<span class="nc" id="L5732">			Set&lt;Language&gt; bonusAllowed = thePC.getLanguageBonusSelectionList();</span>
<span class="nc" id="L5733">			int count = thePC.getBonusLanguageCount();</span>
<span class="nc" id="L5734">			int choiceCount = count - currentBonusLang;</span>
<span class="nc bnc" id="L5735" title="All 2 branches missed.">			if (choiceCount &gt; 0)</span>
			{
<span class="nc bnc" id="L5737" title="All 2 branches missed.">				for (Language l : bonusAllowed)</span>
				{
<span class="nc bnc" id="L5739" title="All 2 branches missed.">					if (cachedLanguages.contains(l))</span>
					{
<span class="nc" id="L5741">						langSources.addToListFor(l, langbonus);</span>
<span class="nc" id="L5742">						actorLimit.put(langbonus, choiceCount);</span>
					}
<span class="nc" id="L5744">				}</span>
			}
		}
		//Try to match them up as best as possible (this matches things with only one possible location...)
<span class="nc bnc" id="L5748" title="All 2 branches missed.">		boolean acted = !cachedLanguages.isEmpty();</span>
<span class="nc bnc" id="L5749" title="All 2 branches missed.">		while (acted)</span>
		{
<span class="nc" id="L5751">			acted = false;</span>
<span class="nc bnc" id="L5752" title="All 2 branches missed.">			for (Language l : langSources.getKeySet())</span>
			{
<span class="nc" id="L5754">				List&lt;Object&gt; actors = langSources.getListFor(l);</span>
<span class="nc bnc" id="L5755" title="All 4 branches missed.">				if ((actors != null) &amp;&amp; (actors.size() == 1))</span>
				{
<span class="nc" id="L5757">					Object actor = actors.get(0);</span>
<span class="nc" id="L5758">					acted = true;</span>
<span class="nc" id="L5759">					processRemoval(langbonus, langSources, actorLimit, ptcSources, l, actor);</span>
				}
<span class="nc" id="L5761">			}</span>
<span class="nc bnc" id="L5762" title="All 6 branches missed.">			if (!acted &amp;&amp; !langSources.isEmpty() &amp;&amp; !actorLimit.isEmpty())</span>
			{
				//pick one
<span class="nc" id="L5765">				Language l = langSources.getKeySet().iterator().next();</span>
<span class="nc" id="L5766">				Object source = langSources.getListFor(l).get(0);</span>
<span class="nc" id="L5767">				processRemoval(langbonus, langSources, actorLimit, ptcSources, l, source);</span>
<span class="nc" id="L5768">				acted = true;</span>
<span class="nc" id="L5769">			}</span>
		}

<span class="nc bnc" id="L5772" title="All 2 branches missed.">		for (Language l : cachedLanguages)</span>
		{
<span class="nc" id="L5774">			warnings.add(&quot;Unable to find source: &quot; + &quot;Character no longer speaks language: &quot; + l.getDisplayName());</span>
<span class="nc" id="L5775">		}</span>
<span class="nc" id="L5776">	}</span>

	private void processRemoval(CNAbility langbonus, HashMapToList&lt;Language, Object&gt; sources,
		Map&lt;Object, Integer&gt; actorLimit, Map&lt;PersistentTransitionChoice, CDOMObject&gt; ptcSources, Language l,
		Object actor)
	{
<span class="nc" id="L5782">		Integer limit = actorLimit.get(actor);</span>
		//apply
<span class="nc" id="L5784">		processActor(langbonus, ptcSources, l, actor);</span>
<span class="nc" id="L5785">		cachedLanguages.remove(l);</span>
<span class="nc" id="L5786">		sources.removeListFor(l);</span>
		//Remove this sources from all languages (may create more items with only one source)
<span class="nc bnc" id="L5788" title="All 2 branches missed.">		if (limit == 1)</span>
		{
<span class="nc bnc" id="L5790" title="All 2 branches missed.">			for (Language lang : sources.getKeySet())</span>
			{
<span class="nc" id="L5792">				sources.removeFromListFor(lang, actor);</span>
<span class="nc" id="L5793">			}</span>
			//Used up
<span class="nc" id="L5795">			actorLimit.remove(actor);</span>
		}
		else
		{
			//Use a slot
<span class="nc" id="L5800">			actorLimit.put(actor, limit - 1);</span>
		}
<span class="nc" id="L5802">	}</span>

	private void processActor(CNAbility langbonus, Map&lt;PersistentTransitionChoice, CDOMObject&gt; ptcSources, Language l,
		Object actor)
	{
<span class="nc bnc" id="L5807" title="All 2 branches missed.">		if (actor instanceof CNAbility)</span>
		{
<span class="nc" id="L5809">			thePC.addSavedAbility(new CNAbilitySelection(langbonus, l.getKeyName()), UserSelection.getInstance(),</span>
<span class="nc" id="L5810">				UserSelection.getInstance());</span>
		}
<span class="nc bnc" id="L5812" title="All 2 branches missed.">		else if (actor instanceof PersistentTransitionChoice)</span>
		{
<span class="nc" id="L5814">			PersistentTransitionChoice&lt;Language&gt; ptc = (PersistentTransitionChoice&lt;Language&gt;) actor;</span>
<span class="nc" id="L5815">			ptc.restoreChoice(thePC, ptcSources.get(ptc), l);</span>
<span class="nc" id="L5816">		}</span>
		else
		{
<span class="nc" id="L5819">			warnings.add(&quot;Internal Error: Language actor of &quot; + actor.getClass() + &quot; is not understood&quot;);</span>
		}
<span class="nc" id="L5821">	}</span>

	/**
	 * Set the source of the domain. See getDomainSource() for details.
	 * This method should NOT be called outside of file i/o routines!
	 * @param aSource the source to be set
	 **/
	public ClassSource getDomainSource(String aSource)
	{
<span class="nc" id="L5830">		final StringTokenizer aTok = new StringTokenizer(aSource, &quot;|&quot;, false);</span>

<span class="nc bnc" id="L5832" title="All 2 branches missed.">		if (aTok.countTokens() &lt; 2)</span>
		{
<span class="nc" id="L5834">			Logging.errorPrint(&quot;Invalid Domain Source:&quot; + aSource);</span>
<span class="nc" id="L5835">			return null;</span>
		}

<span class="nc" id="L5838">		aTok.nextToken(); //Throw away &quot;PCClass&quot;</span>

<span class="nc" id="L5840">		String classString = aTok.nextToken();</span>
<span class="nc" id="L5841">		PCClass cl = thePC.getClassKeyed(classString);</span>
<span class="nc bnc" id="L5842" title="All 2 branches missed.">		if (cl == null)</span>
		{
<span class="nc" id="L5844">			Logging.errorPrint(&quot;Invalid Class in Domain Source:&quot; + aSource);</span>
<span class="nc" id="L5845">			return null;</span>
		}
		ClassSource cs;
<span class="nc bnc" id="L5848" title="All 2 branches missed.">		if (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L5850">			int level = Integer.parseInt(aTok.nextToken());</span>
<span class="nc" id="L5851">			cs = new ClassSource(cl, level);</span>
<span class="nc" id="L5852">		}</span>
		else
		{
<span class="nc" id="L5855">			cs = new ClassSource(cl);</span>
		}
<span class="nc" id="L5857">		return cs;</span>
	}

	private void insertDefaultClassSpellLists()
	{
<span class="nc bnc" id="L5862" title="All 2 branches missed.">		for (PCClass pcc : thePC.getClassList())</span>
		{
<span class="nc" id="L5864">			thePC.addDefaultSpellList(pcc);</span>
<span class="nc" id="L5865">		}</span>
<span class="nc" id="L5866">	}</span>

	public PCAlignment getNoAlignment()
	{
<span class="nc" id="L5870">		return Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCAlignment.class,</span>
			Constants.NONE);
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>