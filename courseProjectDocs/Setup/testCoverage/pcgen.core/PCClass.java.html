<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PCClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">PCClass.java</span></div><h1>PCClass.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Bryan McRoberts &lt;merton_monk@yahoo.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.StringJoiner;
import java.util.StringTokenizer;
import java.util.TreeMap;

import pcgen.cdom.base.AssociatedPrereqObject;
import pcgen.cdom.base.CDOMListObject;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.CDOMObjectUtilities;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.TransitionChoice;
import pcgen.cdom.content.HitDie;
import pcgen.cdom.content.KnownSpellIdentifier;
import pcgen.cdom.content.LevelCommandFactory;
import pcgen.cdom.enumeration.FactKey;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.MapKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.StringKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.enumeration.VariableKey;
import pcgen.cdom.helper.ArmorProfProvider;
import pcgen.cdom.helper.ClassSource;
import pcgen.cdom.helper.ShieldProfProvider;
import pcgen.cdom.helper.WeaponProfProvider;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.cdom.list.DomainList;
import pcgen.cdom.reference.CDOMDirectSingleRef;
import pcgen.cdom.reference.CDOMSingleRef;
import pcgen.core.analysis.AddObjectActions;
import pcgen.core.analysis.DomainApplication;
import pcgen.core.analysis.ExchangeLevelApplication;
import pcgen.core.analysis.SizeUtilities;
import pcgen.core.analysis.SkillRankControl;
import pcgen.core.analysis.StatApplication;
import pcgen.core.analysis.SubClassApplication;
import pcgen.core.analysis.SubstitutionClassApplication;
import pcgen.core.bonus.Bonus;
import pcgen.core.bonus.BonusObj;
import pcgen.core.pclevelinfo.PCLevelInfo;
import pcgen.core.pclevelinfo.PCLevelInfoStat;
import pcgen.core.prereq.PrereqHandler;
import pcgen.core.prereq.Prerequisite;
import pcgen.core.spell.Spell;
import pcgen.core.utils.MessageType;
import pcgen.core.utils.ShowMessageDelegate;
import pcgen.facade.core.InfoFacade;
import pcgen.persistence.PersistenceLayerException;
import pcgen.persistence.lst.output.prereq.PrerequisiteWriter;
import pcgen.persistence.lst.prereq.PreParserFactory;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.util.Logging;
import pcgen.util.enumeration.AttackType;

import org.apache.commons.lang3.StringUtils;


<span class="fc" id="L84">public class PCClass extends PObject implements InfoFacade, Cloneable</span>
{

	public static final CDOMReference&lt;DomainList&gt; ALLOWED_DOMAINS;

	static
	{
<span class="fc" id="L91">		DomainList dl = new DomainList();</span>
<span class="fc" id="L92">		dl.setName(&quot;*Allowed&quot;);</span>
<span class="fc" id="L93">		ALLOWED_DOMAINS = CDOMDirectSingleRef.getRef(dl);</span>
<span class="fc" id="L94">	}</span>

	/*
	 * TYPESAFETY This is definitely something that needs to NOT be a String,
	 * but it gets VERY complicated to do that, since the keys are widely used
	 * in the variable processor.
	 */
	/*
	 * ALLCLASSLEVELS Must be in all PCClassLevels, since this is the master
	 * index of what this PCClassLevel was created from. Best for debugging, and
	 * not necessarily creation on the fly?
	 */
	/*
	 * REFACTOR This brings up a FASCINATING point, in that the Class Key today
	 * is used in variable processing. How is that to be handled going forward -
	 * so that PCClassLevels are actually what is checked and NOT the PCClass?
	 * What needs to be done to teach the system to iterate over all
	 * PCClassLevels that implement this key?
	 */
<span class="fc" id="L113">	private String classKey = null;</span>

	/**
	 * Returns the abbreviation for this class.
	 *
	 * @return The abbreviation string.
	 */
	/*
	 * FINALPCCLASSANDLEVEL This is required in PCClassLevel and should be present in
	 * PCClass for PCClassLevel creation (in the factory)
	 */
	public final String getAbbrev()
	{
<span class="nc" id="L126">		FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;Abb&quot;);</span>
<span class="nc" id="L127">		String abb = getResolved(fk);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">		if (abb == null)</span>
		{
<span class="nc" id="L130">			String name = getDisplayName();</span>
<span class="nc" id="L131">			abb = name.substring(0, Math.min(3, name.length()));</span>
		}
<span class="nc" id="L133">		return abb;</span>
	}

	/**
	 * Return the qualified key, usually used as the source in a
	 * getVariableValue call. Overriden here to return CLASS:keyname
	 *
	 * @return The qualified key of the object
	 */
	/*
	 * PCCLASSANDLEVEL Since the classKey is generally the universal index of whether
	 * two PCClassLevels are off of the same base, classKey will be populated into
	 * each PCClassLevel.  This method must therefore also be in both PCClass and
	 * PCClassLevel
	 */
	@Override
	public String getQualifiedKey()
	{
<span class="fc bfc" id="L151" title="All 2 branches covered.">		if (classKey == null)</span>
		{
<span class="fc" id="L153">			classKey = &quot;CLASS:&quot; + getKeyName(); //$NON-NLS-1$</span>

		}
<span class="fc" id="L156">		return classKey;</span>
	}

	/**
	 * Returns the total bonus to the specified bonus type and name.
	 *
	 * &lt;p&gt;
	 * This method checks only bonuses associated with the class. It makes sure
	 * to return bonuses that are active only to the max level specified. What
	 * that means is that bonuses specified on class level lines will have a
	 * level parameter associated with them. Only bonuses specified on the level
	 * specified or lower will be totalled.
	 *
	 * @param argType
	 *            Bonus type e.g. &lt;code&gt;BONUS:&lt;b&gt;DOMAIN&lt;/b&gt;&lt;/code&gt;
	 * @param argMname
	 *            Bonus name e.g. &lt;code&gt;BONUS:DOMAIN|&lt;b&gt;NUMBER&lt;/b&gt;&lt;/code&gt;
	 * @param asLevel
	 *            The maximum level to apply bonuses for.
	 * @param aPC
	 *            The &lt;tt&gt;PlayerCharacter&lt;/tt&gt; bonuses are being calculated
	 *            for.
	 *
	 * @return Total bonus value.
	 */
	/*
	 * REFACTOR There is potentially redundant information here - level and PC...
	 * is this ever out of sync or can this method be removed/made private??
	 */
	public double getBonusTo(final String argType, final String argMname, final int asLevel, final PlayerCharacter aPC)
	{
<span class="nc" id="L187">		double i = 0;</span>

<span class="nc" id="L189">		List&lt;BonusObj&gt; rawBonusList = getRawBonusList(aPC);</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">		for (int lvl = 1; lvl &lt; asLevel; lvl++)</span>
		{
<span class="nc" id="L193">			rawBonusList.addAll(aPC.getActiveClassLevel(this, lvl).getRawBonusList(aPC));</span>
		}
<span class="nc bnc" id="L195" title="All 4 branches missed.">		if ((asLevel == 0) || rawBonusList.isEmpty())</span>
		{
<span class="nc" id="L197">			return 0;</span>
		}

<span class="nc" id="L200">		final String type = argType.toUpperCase();</span>
<span class="nc" id="L201">		final String mname = argMname.toUpperCase();</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (final BonusObj bonus : rawBonusList)</span>
		{
<span class="nc" id="L205">			final StringTokenizer breakOnPipes =</span>
<span class="nc" id="L206">					new StringTokenizer(bonus.toString().toUpperCase(), Constants.PIPE, false);</span>
<span class="nc" id="L207">			final String theType = breakOnPipes.nextToken();</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">			if (!theType.equals(type))</span>
			{
<span class="nc" id="L211">				continue;</span>
			}

<span class="nc" id="L214">			final String str = breakOnPipes.nextToken();</span>
<span class="nc" id="L215">			final StringTokenizer breakOnCommas = new StringTokenizer(str, Constants.COMMA, false);</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">			while (breakOnCommas.hasMoreTokens())</span>
			{
<span class="nc" id="L219">				final String theName = breakOnCommas.nextToken();</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">				if (theName.equals(mname))</span>
				{
<span class="nc" id="L223">					final String aString = breakOnPipes.nextToken();</span>
<span class="nc" id="L224">					final List&lt;Prerequisite&gt; localPreReqList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">					if (bonus.hasPrerequisites())</span>
					{
<span class="nc" id="L227">						localPreReqList.addAll(bonus.getPrerequisiteList());</span>
					}

					// TODO: This code should be removed after the 5.8 release
					// as the prereqs are processed by the bonus loading code.
<span class="nc bnc" id="L232" title="All 2 branches missed.">					while (breakOnPipes.hasMoreTokens())</span>
					{
<span class="nc" id="L234">						final String bString = breakOnPipes.nextToken();</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">						if (PreParserFactory.isPreReqString(bString))</span>
						{
<span class="nc" id="L238">							Logging.debugPrint(</span>
							&quot;Why is this prerequisite '&quot; + bString + &quot;' parsed in '&quot; //$NON-NLS-1$//$NON-NLS-2$
<span class="nc" id="L240">							+ getClass().getName()</span>
							+ &quot;.getBonusTo(String,String,int)' rather than in the persistence layer?&quot;); //$NON-NLS-1$
							try
							{
<span class="nc" id="L244">								final PreParserFactory factory = PreParserFactory.getInstance();</span>
<span class="nc" id="L245">								localPreReqList.add(factory.parse(bString));</span>
							}
<span class="nc" id="L247">							catch (PersistenceLayerException ple)</span>
							{
<span class="nc" id="L249">								Logging.errorPrint(ple.getMessage(), ple);</span>
<span class="nc" id="L250">							}</span>
						}
<span class="nc" id="L252">					}</span>

					// must meet criteria for bonuses before adding them in
					// TODO: This is a hack to avoid VARs etc in class defs
					// being qualified for when Bypass class prereqs is
					// selected.
					// Should we be passing in the BonusObj here to allow it to
					// be referenced in Qualifies statements?
<span class="nc bnc" id="L260" title="All 2 branches missed.">					if (PrereqHandler.passesAll(localPreReqList, aPC, null))</span>
					{
<span class="nc" id="L262">						final double j = aPC.getVariableValue(aString, getQualifiedKey()).doubleValue();</span>
<span class="nc" id="L263">						i += j;</span>
					}
				}
<span class="nc" id="L266">			}</span>
<span class="nc" id="L267">		}</span>

<span class="nc" id="L269">		return i;</span>
	}

	/**
	 * Identify if this class has a cap on the number of levels it is
	 * possible to take.
	 * @return true if a cap on levels exists, false otherwise.
	 */
	public final boolean hasMaxLevel()
	{
<span class="nc" id="L279">		Integer ll = get(IntegerKey.LEVEL_LIMIT);</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">		return ll != null &amp;&amp; ll != Constants.NO_LEVEL_LIMIT;</span>
	}

	/*
	 * REFACTOR This is BAD that this is referring to PCLevelInfo - that gets
	 * VERY confusing as far as object interaction. Can we get rid of
	 * PCLevelInfo altogether?
	 */
	public final int getSkillPool(final PlayerCharacter aPC)
	{
<span class="nc" id="L290">		int returnValue = 0;</span>
		// //////////////////////////////////
		// Using this method will return skills for level 0 even when there is
		// no information
		// Byngl - December 28, 2004
		// for (int i = 0; i &lt;= level; i++)
		// {
		// final PCLevelInfo pcl = aPC.getLevelInfoFor(getKeyName(), i);
		//
		// if ((pcl != null) &amp;&amp; pcl.getClassKeyName().equals(getKeyName()))
		// {
		// returnValue += pcl.getSkillPointsRemaining();
		// }
		// }
<span class="nc bnc" id="L304" title="All 2 branches missed.">		for (PCLevelInfo pcl : aPC.getLevelInfo())</span>
		{
<span class="nc bnc" id="L306" title="All 2 branches missed.">			if (pcl.getClassKeyName().equals(getKeyName()))</span>
			{
<span class="nc" id="L308">				returnValue += pcl.getSkillPointsRemaining();</span>
			}
<span class="nc" id="L310">		}</span>
		// //////////////////////////////////

<span class="nc" id="L313">		return returnValue;</span>
	}

	/*
	 * FINALPCCLASSANDLEVEL This is required in PCClassLevel and should be present in
	 * PCClass for PCClassLevel creation (in the factory)
	 */
	public final String getSpellBaseStat()
	{
<span class="nc" id="L322">		Boolean useStat = get(ObjectKey.USE_SPELL_SPELL_STAT);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (useStat == null)</span>
		{
<span class="nc" id="L325">			return &quot;None&quot;;</span>
		}
<span class="nc bnc" id="L327" title="All 2 branches missed.">		else if (useStat)</span>
		{
<span class="nc" id="L329">			return &quot;SPELL&quot;;</span>
		}
<span class="nc" id="L331">		Boolean otherCaster = get(ObjectKey.CASTER_WITHOUT_SPELL_STAT);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">		if (otherCaster)</span>
		{
<span class="nc" id="L334">			return &quot;OTHER&quot;;</span>
		}
<span class="nc" id="L336">		CDOMSingleRef&lt;PCStat&gt; ss = get(ObjectKey.SPELL_STAT);</span>
		//TODO This could be null, do we need to worry about it?
<span class="nc" id="L338">		return ss.get().getKeyName();</span>
	}

	/*
	 * FINALPCCLASSANDLEVEL This is required in PCClassLevel and should be present in
	 * PCClass for PCClassLevel creation (in the factory)
	 */
	public final String getSpellType()
	{
<span class="nc" id="L347">		FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;SpellType&quot;);</span>
<span class="nc" id="L348">		String castInfo = getResolved(fk);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">		return StringUtils.isEmpty(castInfo) ? Constants.NONE : castInfo;</span>
	}

	/*
	 * FINALPCCLASSONLY This is really an item that the PCClass knows, and then the
	 * selected subClass, if any, is structured into the PCClassLevel during the
	 * construction of the PCClassLevel
	 */
	public final SubClass getSubClassKeyed(final String aKey)
	{
<span class="nc" id="L359">		List&lt;SubClass&gt; subClassList = getListFor(ListKey.SUB_CLASS);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">		if (subClassList == null)</span>
		{
<span class="nc" id="L362">			return null;</span>
		}

<span class="nc bnc" id="L365" title="All 2 branches missed.">		for (SubClass subClass : subClassList)</span>
		{
<span class="nc bnc" id="L367" title="All 2 branches missed.">			if (subClass.getKeyName().equals(aKey))</span>
			{
<span class="nc" id="L369">				return subClass;</span>
			}
<span class="nc" id="L371">		}</span>

<span class="nc" id="L373">		return null;</span>
	}

	/*
	 * FINALPCCLASSONLY This is really an item that the PCClass knows, and then the
	 * selected substitutionClass, if any, is structured into the PCClassLevel
	 * during the construction of the PCClassLevel
	 */
	public final SubstitutionClass getSubstitutionClassKeyed(final String aKey)
	{
<span class="nc" id="L383">		List&lt;SubstitutionClass&gt; substitutionClassList = getListFor(ListKey.SUBSTITUTION_CLASS);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (substitutionClassList == null)</span>
		{
<span class="nc" id="L386">			return null;</span>
		}

<span class="nc bnc" id="L389" title="All 2 branches missed.">		for (SubstitutionClass sc : substitutionClassList)</span>
		{
<span class="nc bnc" id="L391" title="All 2 branches missed.">			if (sc.getKeyName().equals(aKey))</span>
			{
<span class="nc" id="L393">				return sc;</span>
			}
<span class="nc" id="L395">		}</span>

<span class="nc" id="L397">		return null;</span>
	}

	public void setLevel(final int newLevel, final PlayerCharacter aPC)
	{
<span class="nc" id="L402">		final int curLevel = aPC.getLevel(this);</span>

<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (newLevel &gt;= 0)</span>
		{
<span class="nc" id="L406">			aPC.setLevelWithoutConsequence(this, newLevel);</span>
		}

<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (newLevel == 1)</span>
		{
<span class="nc bnc" id="L411" title="All 4 branches missed.">			if (newLevel &gt; curLevel || aPC.isImporting())</span>
			{
<span class="nc" id="L413">				addFeatPoolBonus(aPC);</span>
			}
		}

<span class="nc bnc" id="L417" title="All 2 branches missed.">		if (!aPC.isImporting())</span>
		{
<span class="nc" id="L419">			aPC.calcActiveBonuses();</span>
			//Need to do this again if caching is re-integrated
			//aPC.getSpellTracker().buildSpellLevelMap(newLevel);
		}

<span class="nc bnc" id="L424" title="All 6 branches missed.">		if ((newLevel == 1) &amp;&amp; !aPC.isImporting() &amp;&amp; (curLevel == 0))</span>
		{
<span class="nc" id="L426">			SubClassApplication.checkForSubClass(aPC, this);</span>
<span class="nc" id="L427">			aPC.setSpellLists(this);</span>
		}

<span class="nc bnc" id="L430" title="All 4 branches missed.">		if (!aPC.isImporting() &amp;&amp; (curLevel &lt; newLevel))</span>
		{
<span class="nc" id="L432">			SubstitutionClassApplication.checkForSubstitutionClass(this, newLevel, aPC);</span>
		}

<span class="nc" id="L435">		aPC.getClassSet()</span>
<span class="nc" id="L436">		   .forEach(aPC::calculateKnownSpellsForClassLevel);</span>
<span class="nc" id="L437">	}</span>

	/**
	 * Add the bonus to the character's feat pool that is granted by the class.
	 * NB: LEVELSPERFEAT is now handled via PLayerCHaracter.getNumFeatsFromLevels()
	 * rather than bonuses. Only the standard feat progression for the gamemode is
	 * handled here.
	 * @param aPC The character to bonus.
	 */
	void addFeatPoolBonus(final PlayerCharacter aPC)
	{
<span class="nc" id="L448">		Integer mLevPerFeat = get(IntegerKey.LEVELS_PER_FEAT);</span>
		int startLevel;
		int rangeLevel;
		int divisor;
<span class="nc bnc" id="L452" title="All 2 branches missed.">		if (mLevPerFeat == null)</span>
		{
<span class="nc" id="L454">			String aString = Globals.getBonusFeatString();</span>
<span class="nc" id="L455">			StringTokenizer aTok = new StringTokenizer(aString, &quot;|&quot;, false);</span>
<span class="nc" id="L456">			startLevel = Integer.parseInt(aTok.nextToken());</span>
<span class="nc" id="L457">			rangeLevel = Integer.parseInt(aTok.nextToken());</span>
<span class="nc" id="L458">			divisor = rangeLevel;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">			if (divisor &gt; 0)</span>
			{
<span class="nc" id="L461">				StringBuilder aBuf = new StringBuilder(&quot;FEAT|PCPOOL|&quot;).append(&quot;max(CL&quot;);</span>
				// Make sure we only take off the startlevel value once
<span class="nc bnc" id="L463" title="All 2 branches missed.">				if (this == aPC.getClassKeyed(aPC.getLevelInfoClassKeyName(0)))</span>
				{
<span class="nc" id="L465">					aBuf.append(&quot;-&quot;).append(startLevel);</span>
<span class="nc" id="L466">					aBuf.append(&quot;+&quot;).append(rangeLevel);</span>
				}
<span class="nc" id="L468">				aBuf.append(&quot;,0)/&quot;).append(divisor);</span>
				//						Logging.debugPrint(&quot;Feat bonus for &quot; + this + &quot; is &quot;
				//							+ aBuf.toString());
<span class="nc" id="L471">				BonusObj bon = Bonus.newBonus(Globals.getContext(), aBuf.toString());</span>
<span class="nc" id="L472">				aPC.addBonus(bon, this);</span>
			}
		}
<span class="nc" id="L475">	}</span>

	/*
	 * FINALPCCLASSANDLEVEL This is required in PCClassLevel and should be present in
	 * PCClass for PCClassLevel creation (in the factory)
	 */
	/*
	 * FUTUREREFACTOR This would really be nice to have initilized when the LST files
	 * are read in, which is possible because the ClassTypes are all defined as part
	 * of the GameMode... however the problem is that the order of the ISMONSTER tag
	 * and the TYPE tags cannot be defined - .MODs and .COPYs make it impossible to
	 * guarantee an order.  Therefore, this must wait for a two-pass design in the
	 * import system - thpr 10/4/06
	 */
	public boolean isMonster()
	{
<span class="fc" id="L491">		Boolean mon = get(ObjectKey.IS_MONSTER);</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">		if (mon != null)</span>
		{
<span class="nc" id="L494">			return mon;</span>
		}

<span class="fc" id="L497">		ClassType aClassType = SettingsHandler.getGameAsProperty().get().getClassTypeByName(getClassType());</span>

<span class="pc bpc" id="L499" title="3 of 4 branches missed.">		if ((aClassType != null) &amp;&amp; aClassType.isMonster())</span>
		{
<span class="nc" id="L501">			return true;</span>
		}
		else
		{
<span class="fc bfc" id="L505" title="All 2 branches covered.">			for (Type type : getTrueTypeList(false))</span>
			{
<span class="fc" id="L507">				aClassType = SettingsHandler.getGameAsProperty().get().getClassTypeByName(type.toString());</span>
<span class="pc bpc" id="L508" title="3 of 4 branches missed.">				if ((aClassType != null) &amp;&amp; aClassType.isMonster())</span>
				{
<span class="nc" id="L510">					return true;</span>
				}
<span class="fc" id="L512">			}</span>
		}
<span class="fc" id="L514">		return false;</span>
	}

	@Override
	public String getPCCText()
	{
<span class="nc" id="L520">		StringJoiner txt = new StringJoiner(&quot;\t&quot;);</span>
<span class="nc" id="L521">		txt.add(&quot;CLASS:&quot; + getDisplayName());</span>
<span class="nc" id="L522">		txt.add(PrerequisiteWriter.prereqsToString(this));</span>
<span class="nc" id="L523">		Globals.getContext().unparse(this).forEach(txt::add);</span>

		// now all the level-based stuff
<span class="nc" id="L526">		final String lineSep = System.getProperty(&quot;line.separator&quot;);</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">		for (Map.Entry&lt;Integer, PCClassLevel&gt; me : levelMap.entrySet())</span>
		{
<span class="nc" id="L530">			txt.add(lineSep + me.getKey());</span>
<span class="nc" id="L531">			txt.add(PrerequisiteWriter.prereqsToString(me.getValue()));</span>
<span class="nc" id="L532">			Globals.getContext().unparse(me.getValue()).forEach(txt::add);</span>
<span class="nc" id="L533">		}</span>

<span class="nc" id="L535">		return txt.toString();</span>
	}

	/*
	 * FINALPCCLASSONLY This is really an item that the PCClass knows, and then the
	 * selected subClass, if any, is structured into the PCClassLevel during the
	 * construction of the PCClassLevel
	 */
	public final void addSubClass(final SubClass sClass)
	{
<span class="nc" id="L545">		sClass.put(ObjectKey.LEVEL_HITDIE, get(ObjectKey.LEVEL_HITDIE));</span>
<span class="nc" id="L546">		addToListFor(ListKey.SUB_CLASS, sClass);</span>
<span class="nc" id="L547">	}</span>

	/*
	 * PCCLASSONLY This is really an item that the PCClass knows, and then the
	 * selected substitutionClass, if any, is structured into the PCClassLevel
	 * during the construction of the PCClassLevel
	 */
	public final void addSubstitutionClass(final SubstitutionClass sClass)
	{
<span class="nc" id="L556">		sClass.put(ObjectKey.LEVEL_HITDIE, get(ObjectKey.LEVEL_HITDIE));</span>
<span class="nc" id="L557">		addToListFor(ListKey.SUBSTITUTION_CLASS, sClass);</span>
<span class="nc" id="L558">	}</span>

	/**
	 * returns the value at which another attack is gained attackCycle of 4
	 * means a second attack is gained at a BAB of +5/+1
	 *
	 * @param at the AttackType
	 * @return int
	 */
	/*
	 * PCCLASSANDLEVEL Some derivative of this will likely need to exist in both
	 * PCClass (since it's a tag) and PCClassLevel (since there will have to be
	 * some method of detecting what the BAB of a given PCClassLevel is and then
	 * grouping those in the proper groups (see
	 * PlayerCharacter.getAttackString()) to determine what the final attack
	 * bonuses are.
	 */
	public int attackCycle(final AttackType at)
	{
<span class="nc bnc" id="L577" title="All 2 branches missed.">		for (Map.Entry&lt;AttackType, Integer&gt; me : getMapFor(MapKey.ATTACK_CYCLE).entrySet())</span>
		{
<span class="nc bnc" id="L579" title="All 2 branches missed.">			if (at == me.getKey())</span>
			{
<span class="nc" id="L581">				return me.getValue();</span>
			}
<span class="nc" id="L583">		}</span>
<span class="nc" id="L584">		return SettingsHandler.getGameAsProperty().get().getBabAttCyc();</span>
	}

	public int baseAttackBonus(final PlayerCharacter aPC)
	{
<span class="nc bnc" id="L589" title="All 2 branches missed.">		if (aPC.getLevel(this) == 0)</span>
		{
<span class="nc" id="L591">			return 0;</span>
		}

<span class="nc" id="L594">		return (int) getBonusTo(&quot;COMBAT&quot;, &quot;BASEAB&quot;, aPC.getLevel(this), aPC);</span>
	}

	/**
	 * -2 means that the spell itself indicates what stat should be used,
	 * otherwise this method returns an index into the global list of stats for
	 * which stat the bonus spells are based upon.
	 *
	 * @return int Index of the class' spell stat, or -2 if spell based
	 */
	/*
	 * REFACTOR Why is this returning an INT and not a PCStat or something like
	 * that? or why is the user not just using getSpellBaseStat and processing
	 * the response by itself??
	 */
	public PCStat baseSpellStat()
	{
<span class="nc bnc" id="L611" title="All 2 branches missed.">		if (getSafe(ObjectKey.USE_SPELL_SPELL_STAT))</span>
		{
<span class="nc" id="L613">			return null;</span>
		}
<span class="nc bnc" id="L615" title="All 2 branches missed.">		if (getSafe(ObjectKey.CASTER_WITHOUT_SPELL_STAT))</span>
		{
<span class="nc" id="L617">			return null;</span>
		}
<span class="nc" id="L619">		CDOMSingleRef&lt;PCStat&gt; ss = get(ObjectKey.SPELL_STAT);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">		if (ss != null)</span>
		{
<span class="nc" id="L622">			return ss.get();</span>
		}
<span class="nc bnc" id="L624" title="All 2 branches missed.">		if (Logging.isDebugMode())</span>
		{
<span class="nc" id="L626">			Logging.debugPrint(&quot;Found Class: &quot; + getDisplayName() + &quot; that did not have any SPELLSTAT defined&quot;);</span>
		}
<span class="nc" id="L628">		return null;</span>
	}

	/**
	 * Returns the stat to use for bonus spells.
	 *
	 * &lt;p&gt;
	 * The method checks to see if a BONUSSPELLSTAT: has been set for the class.
	 * If it is set to a stat that stat is returned. If it is set to None null is
	 * returned. If it is set to Default then the BASESPELLSTAT is returned.
	 *
	 * @return the stat to use for bonus spells.
	 */
	public PCStat bonusSpellStat()
	{
<span class="nc" id="L643">		Boolean hbss = get(ObjectKey.HAS_BONUS_SPELL_STAT);</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">		if (hbss == null)</span>
		{
<span class="nc" id="L646">			return baseSpellStat();</span>
		}
<span class="nc bnc" id="L648" title="All 2 branches missed.">		else if (hbss)</span>
		{
<span class="nc" id="L650">			CDOMSingleRef&lt;PCStat&gt; bssref = get(ObjectKey.BONUS_SPELL_STAT);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">			if (bssref != null)</span>
			{
<span class="nc" id="L653">				return bssref.get();</span>
			}
		}
<span class="nc" id="L656">		return null;</span>
	}

	@Override
	public PCClass clone()
	{
<span class="nc" id="L662">		PCClass aClass = null;</span>

		try
		{
<span class="nc" id="L666">			aClass = (PCClass) super.clone();</span>

<span class="nc" id="L668">			List&lt;KnownSpellIdentifier&gt; ksl = getListFor(ListKey.KNOWN_SPELLS);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">			if (ksl != null)</span>
			{
<span class="nc" id="L671">				aClass.removeListFor(ListKey.KNOWN_SPELLS);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">				for (KnownSpellIdentifier ksi : ksl)</span>
				{
<span class="nc" id="L674">					aClass.addToListFor(ListKey.KNOWN_SPELLS, ksi);</span>
<span class="nc" id="L675">				}</span>
			}
<span class="nc" id="L677">			Map&lt;AttackType, Integer&gt; acmap = getMapFor(MapKey.ATTACK_CYCLE);</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">			if (acmap != null &amp;&amp; !acmap.isEmpty())</span>
			{
<span class="nc" id="L680">				aClass.removeMapFor(MapKey.ATTACK_CYCLE);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">				for (Map.Entry&lt;AttackType, Integer&gt; me : acmap.entrySet())</span>
				{
<span class="nc" id="L683">					aClass.addToMapFor(MapKey.ATTACK_CYCLE, me.getKey(), me.getValue());</span>
<span class="nc" id="L684">				}</span>
			}

<span class="nc" id="L687">			aClass.levelMap = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">			for (Map.Entry&lt;Integer, PCClassLevel&gt; me : levelMap.entrySet())</span>
			{
<span class="nc" id="L690">				aClass.levelMap.put(me.getKey(), me.getValue().clone());</span>
<span class="nc" id="L691">			}</span>
		}
<span class="nc" id="L693">		catch (CloneNotSupportedException exc)</span>
		{
<span class="nc" id="L695">			ShowMessageDelegate.showMessageDialog(exc.getMessage(), Constants.APPLICATION_NAME, MessageType.ERROR);</span>
<span class="nc" id="L696">		}</span>

<span class="nc" id="L698">		return aClass;</span>
	}

	/*
	 * PCCLASSLEVELONLY Since this is really only something that will be done
	 * within a PlayerCharacter (real processing) it is only required in
	 * PCClassLevel.
	 *
	 * As a side note, I'm not sure what I think of accessing the ClassTypes and
	 * using one of those to set the response to this request. Should this be
	 * done when a PCClassLevel is built? Is that possible? How does that
	 * interact with a PlayerCharacter being reimported if those rules change?
	 */
	public boolean hasXPPenalty()
	{
<span class="nc bnc" id="L713" title="All 2 branches missed.">		for (Type type : getTrueTypeList(false))</span>
		{
<span class="nc" id="L715">			final ClassType aClassType = SettingsHandler.getGameAsProperty().get().getClassTypeByName(type.toString());</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">			if ((aClassType != null) &amp;&amp; !aClassType.getXPPenalty())</span>
			{
<span class="nc" id="L718">				return false;</span>
			}
<span class="nc" id="L720">		}</span>
<span class="nc" id="L721">		return true;</span>
	}

	/**
	 * Get the unarmed Damage for this class at the given level.
	 *
	 * @param aLevel the given level.
	 * @param aPC the PC with the level.
	 * @param adjustForPCSize whether to adjust the result for the PC's size.
	 * @return the unarmed damage string
	 */
	public String getUdamForLevel(int aLevel, final PlayerCharacter aPC, boolean adjustForPCSize)
	{
<span class="nc" id="L734">		aLevel += (int) aPC.getTotalBonusTo(&quot;UDAM&quot;, &quot;CLASS.&quot; + getKeyName());</span>
<span class="nc" id="L735">		return getUDamForEffLevel(aLevel, aPC, adjustForPCSize);</span>
	}

	/**
	 * Get the unarmed Damage for this class at the given level.
	 *
	 * @param aLevel the given level.
	 * @param aPC the PC with the level.
	 * @param adjustForPCSize whether to adjust the result for the PC's size.
	 * @return the unarmed damage string
	 */
	String getUDamForEffLevel(int aLevel, final PlayerCharacter aPC, boolean adjustForPCSize)
	{
<span class="nc bnc" id="L748" title="All 2 branches missed.">		int pcSize = adjustForPCSize ? aPC.sizeInt() : aPC.racialSizeInt();</span>

		//
		// Check &quot;Unarmed Strike&quot;, then default to &quot;1d3&quot;
		//
		String aDamage;

<span class="nc" id="L755">		AbstractReferenceContext ref = Globals.getContext().getReferenceContext();</span>
<span class="nc" id="L756">		final Equipment eq = ref.silentlyGetConstructedCDOMObject(Equipment.class, &quot;KEY_Unarmed Strike&quot;);</span>

<span class="nc bnc" id="L758" title="All 2 branches missed.">		if (eq != null)</span>
		{
<span class="nc" id="L760">			aDamage = eq.getDamage(aPC);</span>
		}
		else
		{
<span class="nc" id="L764">			aDamage = &quot;1d3&quot;;</span>
		}

		// resize the damage as if it were a weapon
<span class="nc bnc" id="L768" title="All 2 branches missed.">		if (adjustForPCSize)</span>
		{
<span class="nc" id="L770">			int defSize = SizeUtilities.getDefaultSizeAdjustment().get(IntegerKey.SIZEORDER);</span>
<span class="nc" id="L771">			aDamage = Globals.adjustDamage(aDamage, pcSize - defSize);</span>
		}

		//
		// Check the UDAM list for monk-like damage
		//
<span class="nc" id="L777">		List&lt;CDOMObject&gt; classObjects = new ArrayList&lt;&gt;();</span>
		//Negative increment to start at highest level until an UDAM is found
<span class="nc bnc" id="L779" title="All 2 branches missed.">		for (int i = aLevel; i &gt;= 1; i--)</span>
		{
<span class="nc" id="L781">			classObjects.add(aPC.getActiveClassLevel(this, i));</span>
		}
<span class="nc" id="L783">		classObjects.add(this);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">		for (CDOMObject cdo : classObjects)</span>
		{
<span class="nc" id="L786">			List&lt;String&gt; udam = cdo.getListFor(ListKey.UNARMED_DAMAGE);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">			if (udam != null)</span>
			{
<span class="nc bnc" id="L789" title="All 2 branches missed.">				if (udam.size() == 1)</span>
				{
<span class="nc" id="L791">					aDamage = udam.get(0);</span>
				}
				else
				{
<span class="nc" id="L795">					aDamage = udam.get(pcSize);</span>
				}
<span class="nc" id="L797">				break;</span>
			}
<span class="nc" id="L799">		}</span>
<span class="nc" id="L800">		return aDamage;</span>
	}

	/**
	 * Adds a level of this class to the character.
	 *
	 * TODO: Split the PlayerCharacter code out of PCClass (i.e. the level
	 * property). Then have a joining class assigned to PlayerCharacter that
	 * maps PCClass and number of levels in the class.
	 *
	 *
	 * @param argLevelMax
	 *            True if we should only allow extra levels if there are still
	 *            levels in this class to take. (i.e. a lot of prestige classes
	 *            stop at level 10, so if this is true it would not allow an
	 *            11th level of the class to be added
	 * @param bSilent
	 *            True if we are not to show any dialog boxes about errors or
	 *            questions.
	 * @param aPC
	 *            The character we are adding the level to.
	 * @param ignorePrereqs
	 *            True if prereqs for the level should be ignored. Used in
	 *            situations such as when the character is being loaded.
	 * @return true or false
	 */
	/*
	 * REFACTOR Clearly this is part of the PCClass factory method that produces
	 * PCClassLevels combined with some other work that will need to be done to
	 * extract some of the complicated gunk out of here that goes out and puts
	 * information into PCLevelInfo and PlayerCharacter.
	 */
	public boolean addLevel(final boolean argLevelMax, final boolean bSilent, final PlayerCharacter aPC,
		final boolean ignorePrereqs)
	{

		// Check to see if we can add a level of this class to the
		// current character
<span class="nc" id="L838">		final int newLevel = aPC.getLevel(this) + 1;</span>
<span class="nc" id="L839">		boolean levelMax = argLevelMax;</span>

<span class="nc" id="L841">		aPC.setAllowInteraction(false);</span>
<span class="nc" id="L842">		aPC.setLevelWithoutConsequence(this, newLevel);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">		if (!ignorePrereqs)</span>
		{
			// When loading a character, classes are added before feats, so
			// this test would always fail on loading if feats are required
<span class="nc" id="L847">			boolean doReturn = false;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">			if (!qualifies(aPC, this))</span>
			{
<span class="nc" id="L850">				doReturn = true;</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">				if (!bSilent)</span>
				{
<span class="nc" id="L853">					ShowMessageDelegate.showMessageDialog(&quot;This character does not qualify for level &quot; + newLevel,</span>
						Constants.APPLICATION_NAME, MessageType.ERROR);
				}
			}
<span class="nc" id="L857">			aPC.setLevelWithoutConsequence(this, newLevel - 1);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">			if (doReturn)</span>
			{
<span class="nc" id="L860">				return false;</span>
			}
		}
<span class="nc" id="L863">		aPC.setAllowInteraction(true);</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">		if (isMonster())</span>
		{
<span class="nc" id="L867">			levelMax = false;</span>
		}

<span class="nc bnc" id="L870" title="All 6 branches missed.">		if (hasMaxLevel() &amp;&amp; (newLevel &gt; getSafe(IntegerKey.LEVEL_LIMIT)) &amp;&amp; levelMax)</span>
		{
<span class="nc bnc" id="L872" title="All 2 branches missed.">			if (!bSilent)</span>
			{
<span class="nc" id="L874">				ShowMessageDelegate.showMessageDialog(</span>
<span class="nc" id="L875">					&quot;This class cannot be raised above level &quot; + Integer.toString(getSafe(IntegerKey.LEVEL_LIMIT)),</span>
					Constants.APPLICATION_NAME, MessageType.ERROR);
			}

<span class="nc" id="L879">			return false;</span>
		}

		// Add the level to the current character
<span class="nc" id="L883">		int total = aPC.getTotalLevels();</span>

		// No longer need this since the race now sets a bonus itself and Templates
		// are not able to reassign their feats.  There was nothing else returned in
		// this number
		//		if (total == 0) {
		//			aPC.setFeats(aPC.getInitialFeats());
		//		}
<span class="nc" id="L891">		setLevel(newLevel, aPC);</span>

		// the level has now been added to the character,
		// so now assign the attributes of this class level to the
		// character...
<span class="nc" id="L896">		PCClassLevel classLevel = aPC.getActiveClassLevel(this, newLevel);</span>

		// Make sure that if this Class adds a new domain that
		// we record where that domain came from
<span class="nc" id="L900">		final int dnum = aPC.getMaxCharacterDomains(this, aPC) - aPC.getDomainCount();</span>

<span class="nc bnc" id="L902" title="All 4 branches missed.">		if (dnum &gt; 0 &amp;&amp; !aPC.hasDefaultDomainSource())</span>
		{
<span class="nc" id="L904">			aPC.setDefaultDomainSource(new ClassSource(this, newLevel));</span>
		}

		// Don't roll the hit points if the gui is not being used.
		// This is so GMGen can add classes to a person without pcgen flipping
		// out
<span class="nc bnc" id="L910" title="All 2 branches missed.">		if (Globals.getUseGUI())</span>
		{
			final int levels =
<span class="nc bnc" id="L913" title="All 2 branches missed.">					SettingsHandler.isHPMaxAtFirstClassLevel() ? aPC.totalNonMonsterLevels() : aPC.getTotalLevels();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">			final boolean isFirst = levels == 1;</span>

<span class="nc" id="L916">			aPC.rollHP(this, aPC.getLevel(this), isFirst);</span>
		}

<span class="nc bnc" id="L919" title="All 2 branches missed.">		if (!aPC.isImporting())</span>
		{
<span class="nc" id="L921">			DomainApplication.addDomainsUpToLevel(this, newLevel, aPC);</span>
		}

<span class="nc" id="L924">		int levelUpStats = 0;</span>

		// Add any bonus feats or stats that will be gained from this level
		// i.e. a bonus feat every 3 levels
<span class="nc bnc" id="L928" title="All 2 branches missed.">		if (aPC.getTotalLevels() &gt; total)</span>
		{
<span class="nc" id="L930">			boolean processBonusStats = true;</span>
<span class="nc" id="L931">			total = aPC.getTotalLevels();</span>

<span class="nc bnc" id="L933" title="All 2 branches missed.">			if (isMonster())</span>
			{
				// If we have less levels that the races monster levels
				// then we can not give a stat bonus (i.e. an Ogre has
				// 4 levels of Giant, so it does not get a stat increase at
				// 4th level because that is already taken into account in
				// its racial stat modifiers, but it will get one at 8th
<span class="nc" id="L940">				LevelCommandFactory lcf = aPC.getRace().get(ObjectKey.MONSTER_CLASS);</span>
<span class="nc" id="L941">				int monLevels = 0;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">				if (lcf != null)</span>
				{
<span class="nc" id="L944">					monLevels = lcf.getLevelCount().resolve(aPC, &quot;&quot;).intValue();</span>
				}

<span class="nc bnc" id="L947" title="All 2 branches missed.">				if (total &lt;= monLevels)</span>
				{
<span class="nc" id="L949">					processBonusStats = false;</span>
				}
			}

<span class="nc bnc" id="L953" title="All 2 branches missed.">			if (!aPC.isImporting())</span>
			{
				// We do not want to do these
				// calculations a second time when are
				// importing a character. The feat
				// number and the stat point pool are
				// already saved in the import file.

				//if (processBonusFeats) {
				//	final double bonusFeats = aPC.getBonusFeatsForNewLevel(this);
				//	if (bonusFeats &gt; 0) {
				//		aPC.adjustFeats(bonusFeats);
				//	}
				//}

<span class="nc bnc" id="L968" title="All 2 branches missed.">				if (processBonusStats)</span>
				{
<span class="nc" id="L970">					final int bonusStats = Globals.getBonusStatsForLevel(total, aPC);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">					if (bonusStats &gt; 0)</span>
					{
<span class="nc" id="L973">						aPC.setPoolAmount(aPC.getPoolAmount() + bonusStats);</span>

<span class="nc bnc" id="L975" title="All 4 branches missed.">						if (!bSilent &amp;&amp; SettingsHandler.getShowStatDialogAtLevelUp())</span>
						{
<span class="nc" id="L977">							levelUpStats = StatApplication.askForStatIncrease(aPC, bonusStats, true);</span>
						}
					}
				}
			}
		}

<span class="nc" id="L984">		int spMod = getSkillPointsForLevel(aPC, classLevel, total);</span>

		PCLevelInfo pcl;

<span class="nc bnc" id="L988" title="All 2 branches missed.">		if (aPC.getLevelInfoSize() &gt; 0)</span>
		{
<span class="nc" id="L990">			pcl = aPC.getLevelInfo(aPC.getLevelInfoSize() - 1);</span>

<span class="nc bnc" id="L992" title="All 2 branches missed.">			if (pcl != null)</span>
			{
<span class="nc" id="L994">				pcl.setClassLevel(aPC.getLevel(this));</span>
<span class="nc" id="L995">				pcl.setSkillPointsGained(aPC, spMod);</span>
<span class="nc" id="L996">				pcl.setSkillPointsRemaining(pcl.getSkillPointsGained(aPC));</span>
			}
		}

<span class="nc" id="L1000">		Integer currentPool = aPC.getSkillPool(this);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">		int newSkillPool = spMod + (currentPool == null ? 0 : currentPool);</span>
<span class="nc" id="L1002">		aPC.setSkillPool(this, newSkillPool);</span>

<span class="nc bnc" id="L1004" title="All 2 branches missed.">		if (!aPC.isImporting())</span>
		{
			//
			// Ask for stat increase after skill points have been calculated
			//
<span class="nc bnc" id="L1009" title="All 2 branches missed.">			if (levelUpStats &gt; 0)</span>
			{
<span class="nc" id="L1011">				StatApplication.askForStatIncrease(aPC, levelUpStats, false);</span>
			}

<span class="nc bnc" id="L1014" title="All 2 branches missed.">			if (newLevel == 1)</span>
			{
<span class="nc" id="L1016">				AddObjectActions.doBaseChecks(this, aPC);</span>
<span class="nc" id="L1017">				CDOMObjectUtilities.addAdds(this, aPC);</span>
<span class="nc" id="L1018">				CDOMObjectUtilities.checkRemovals(this, aPC);</span>
			}

<span class="nc bnc" id="L1021" title="All 2 branches missed.">			for (TransitionChoice&lt;Kit&gt; kit : classLevel.getSafeListFor(ListKey.KIT_CHOICE))</span>
			{
<span class="nc" id="L1023">				kit.act(kit.driveChoice(aPC), classLevel, aPC);</span>
<span class="nc" id="L1024">			}</span>
		}

		// this is a monster class, so don't worry about experience
<span class="nc bnc" id="L1028" title="All 2 branches missed.">		if (isMonster())</span>
		{
<span class="nc" id="L1030">			return true;</span>
		}

<span class="nc bnc" id="L1033" title="All 2 branches missed.">		if (!aPC.isImporting())</span>
		{
<span class="nc" id="L1035">			CDOMObjectUtilities.checkRemovals(this, aPC);</span>
<span class="nc" id="L1036">			final int minxp = aPC.minXPForECL();</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">			if (aPC.getXP() &lt; minxp)</span>
			{
<span class="nc" id="L1039">				aPC.setXP(minxp);</span>
			}
<span class="nc bnc" id="L1041" title="All 2 branches missed.">			else if (aPC.getXP() &gt;= aPC.minXPForNextECL())</span>
			{
<span class="nc bnc" id="L1043" title="All 2 branches missed.">				if (!bSilent)</span>
				{
<span class="nc" id="L1045">					ShowMessageDelegate.showMessageDialog(SettingsHandler.getGameAsProperty().get().getLevelUpMessage(),</span>
						Constants.APPLICATION_NAME, MessageType.INFORMATION);
				}
			}
		}

		//
		// Allow exchange of classes only when assign 1st level
		//
<span class="nc bnc" id="L1054" title="All 6 branches missed.">		if (containsKey(ObjectKey.EXCHANGE_LEVEL) &amp;&amp; (aPC.getLevel(this) == 1) &amp;&amp; !aPC.isImporting())</span>
		{
<span class="nc" id="L1056">			ExchangeLevelApplication.exchangeLevels(aPC, this);</span>
		}
<span class="nc" id="L1058">		return true;</span>
	}

	public int getSkillPointsForLevel(final PlayerCharacter aPC, PCClassLevel classLevel, int characterLevel)
	{
		// Update Skill Points. Modified 20 Nov 2002 by sage_sam
		// for bug #629643
		//final int spMod;
<span class="nc" id="L1066">		int spMod = aPC.recalcSkillPointMod(this, characterLevel);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">		if (classLevel.get(ObjectKey.DONTADD_SKILLPOINTS) != null)</span>
		{
<span class="nc" id="L1069">			spMod = 0;</span>
		}
<span class="nc" id="L1071">		return spMod;</span>
	}

	/*
	 * DELETEMETHOD I hope this can be deleted, since minus level support will not
	 * work the same way in the new PCClass/PCClassLevel world. If nothing else, it
	 * is massively a REFACTOR item to put this into the PlayerCharacter that is
	 * doing the removal.
	 */
	void doMinusLevelMods(final PlayerCharacter aPC, final int oldLevel)
	{
<span class="nc" id="L1082">		PCClassLevel pcl = aPC.getActiveClassLevel(this, oldLevel);</span>
<span class="nc" id="L1083">		CDOMObjectUtilities.removeAdds(pcl, aPC);</span>
<span class="nc" id="L1084">		CDOMObjectUtilities.restoreRemovals(pcl, aPC);</span>
<span class="nc" id="L1085">	}</span>

	void subLevel(final PlayerCharacter aPC)
	{

<span class="nc bnc" id="L1090" title="All 2 branches missed.">		if (aPC != null)</span>
		{
<span class="nc" id="L1092">			int total = aPC.getTotalLevels();</span>

<span class="nc" id="L1094">			int oldLevel = aPC.getLevel(this);</span>
<span class="nc" id="L1095">			int spMod = 0;</span>
<span class="nc" id="L1096">			final PCLevelInfo pcl = aPC.getLevelInfoFor(getKeyName(), oldLevel);</span>

<span class="nc bnc" id="L1098" title="All 2 branches missed.">			if (pcl != null)</span>
			{
<span class="nc" id="L1100">				spMod = pcl.getSkillPointsGained(aPC);</span>
			}
			else
			{
<span class="nc" id="L1104">				Logging.errorPrint(&quot;ERROR: could not find class/level info for &quot; + getDisplayName() + &quot;/&quot; + oldLevel);</span>
			}

<span class="nc" id="L1107">			final int newLevel = oldLevel - 1;</span>

<span class="nc bnc" id="L1109" title="All 2 branches missed.">			if (oldLevel &gt; 0)</span>
			{
<span class="nc" id="L1111">				PCClassLevel classLevel = aPC.getActiveClassLevel(this, oldLevel - 1);</span>
<span class="nc" id="L1112">				aPC.removeHP(classLevel);</span>
			}

			//			aPC.adjustFeats(-aPC.getBonusFeatsForNewLevel(this));
<span class="nc" id="L1116">			setLevel(newLevel, aPC);</span>
<span class="nc" id="L1117">			aPC.removeKnownSpellsForClassLevel(this);</span>

<span class="nc" id="L1119">			doMinusLevelMods(aPC, newLevel + 1);</span>

<span class="nc" id="L1121">			DomainApplication.removeDomainsForLevel(this, newLevel + 1, aPC);</span>

<span class="nc bnc" id="L1123" title="All 2 branches missed.">			if (newLevel == 0)</span>
			{
<span class="nc" id="L1125">				SubClassApplication.setSubClassKey(aPC, this, Constants.NONE);</span>

				//
				// Remove all skills associated with this class
				//
<span class="nc bnc" id="L1130" title="All 2 branches missed.">				for (Skill skill : aPC.getSkillSet())</span>
				{
<span class="nc" id="L1132">					SkillRankControl.setZeroRanks(this, aPC, skill);</span>
<span class="nc" id="L1133">				}</span>

<span class="nc" id="L1135">				Integer currentPool = aPC.getSkillPool(this);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">				spMod = currentPool == null ? 0 : currentPool;</span>
			}

<span class="nc bnc" id="L1139" title="All 4 branches missed.">			if (!isMonster() &amp;&amp; (total &gt; aPC.getTotalLevels()))</span>
			{
<span class="nc" id="L1141">				total = aPC.getTotalLevels();</span>

				// Roll back any stat changes that were made as part of the
				// level

<span class="nc" id="L1146">				final List&lt;PCLevelInfoStat&gt; moddedStats = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">				if (pcl.getModifiedStats(true) != null)</span>
				{
<span class="nc" id="L1149">					moddedStats.addAll(pcl.getModifiedStats(true));</span>
				}
<span class="nc bnc" id="L1151" title="All 2 branches missed.">				if (pcl.getModifiedStats(false) != null)</span>
				{
<span class="nc" id="L1153">					moddedStats.addAll(pcl.getModifiedStats(false));</span>
				}
<span class="nc bnc" id="L1155" title="All 2 branches missed.">				if (!moddedStats.isEmpty())</span>
				{
<span class="nc bnc" id="L1157" title="All 2 branches missed.">					for (PCLevelInfoStat statToRollback : moddedStats)</span>
					{
<span class="nc bnc" id="L1159" title="All 2 branches missed.">						for (PCStat aStat : aPC.getStatSet())</span>
						{
<span class="nc bnc" id="L1161" title="All 2 branches missed.">							if (aStat.equals(statToRollback.getStat()))</span>
							{
<span class="nc" id="L1163">								aPC.setStat(aStat, aPC.getStat(aStat) - statToRollback.getStatMod());</span>
<span class="nc" id="L1164">								break;</span>
							}
<span class="nc" id="L1166">						}</span>
<span class="nc" id="L1167">					}</span>
				}
			}

<span class="nc" id="L1171">			aPC.setLevelWithoutConsequence(this, newLevel);</span>

<span class="nc bnc" id="L1173" title="All 4 branches missed.">			if (isMonster() || (total != 0))</span>
			{
<span class="nc" id="L1175">				Integer currentPool = aPC.getSkillPool(this);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">				int newSkillPool = (currentPool == null ? 0 : currentPool) - spMod;</span>
<span class="nc" id="L1177">				aPC.setSkillPool(this, newSkillPool);</span>
<span class="nc" id="L1178">				aPC.setDirty(true);</span>
			}

<span class="nc bnc" id="L1181" title="All 2 branches missed.">			if (aPC.getLevel(this) == 0)</span>
			{
<span class="nc" id="L1183">				aPC.removeClass(this);</span>
			}

<span class="nc" id="L1186">			aPC.validateCharacterDomains();</span>

<span class="nc bnc" id="L1188" title="All 2 branches missed.">			if (!aPC.isImporting())</span>
			{
<span class="nc" id="L1190">				final int maxxp = aPC.minXPForNextECL();</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">				if (aPC.getXP() &gt;= maxxp)</span>
				{
<span class="nc" id="L1193">					aPC.setXP(Math.max(maxxp - 1, 0));</span>
				}
			}
<span class="nc" id="L1196">		}</span>
		else
		{
<span class="nc" id="L1199">			Logging.errorPrint(&quot;No current pc in subLevel()? How did this happen?&quot;);</span>

<span class="nc" id="L1201">			return;</span>
		}
<span class="nc" id="L1203">	}</span>

	/*
	 * REFACTOR Some derivative of this method will be in PCClass only as part
	 * of the factory creation of a PCClassLevel... or perhaps in PCClassLevel
	 * so it can steal some information from other PCClassLevels of that
	 * PCClass. Either way, this will be far from its current form in the final
	 * solution.
	 */
	/*
	 * CONSIDER Why does this not inherit classSkillChoices?
	 */
	public void inheritAttributesFrom(final PCClass otherClass)
	{
<span class="nc" id="L1217">		Boolean hbss = otherClass.get(ObjectKey.HAS_BONUS_SPELL_STAT);</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		if (hbss != null)</span>
		{
<span class="nc" id="L1220">			put(ObjectKey.HAS_BONUS_SPELL_STAT, hbss);</span>
<span class="nc" id="L1221">			CDOMSingleRef&lt;PCStat&gt; bss = otherClass.get(ObjectKey.BONUS_SPELL_STAT);</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">			if (bss != null)</span>
			{
<span class="nc" id="L1224">				put(ObjectKey.BONUS_SPELL_STAT, bss);</span>
			}
		}

<span class="nc" id="L1228">		Boolean usbs = otherClass.get(ObjectKey.USE_SPELL_SPELL_STAT);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">		if (usbs != null)</span>
		{
<span class="nc" id="L1231">			put(ObjectKey.USE_SPELL_SPELL_STAT, usbs);</span>
		}
<span class="nc" id="L1233">		Boolean cwss = otherClass.get(ObjectKey.CASTER_WITHOUT_SPELL_STAT);</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">		if (cwss != null)</span>
		{
<span class="nc" id="L1236">			put(ObjectKey.CASTER_WITHOUT_SPELL_STAT, cwss);</span>
		}
<span class="nc" id="L1238">		CDOMSingleRef&lt;PCStat&gt; ss = otherClass.get(ObjectKey.SPELL_STAT);</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">		if (ss != null)</span>
		{
<span class="nc" id="L1241">			put(ObjectKey.SPELL_STAT, ss);</span>
		}

<span class="nc" id="L1244">		TransitionChoice&lt;CDOMListObject&lt;Spell&gt;&gt; slc = otherClass.get(ObjectKey.SPELLLIST_CHOICE);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">		if (slc != null)</span>
		{
<span class="nc" id="L1247">			put(ObjectKey.SPELLLIST_CHOICE, slc);</span>
		}

<span class="nc" id="L1250">		List&lt;QualifiedObject&lt;CDOMReference&lt;Equipment&gt;&gt;&gt; e = otherClass.getListFor(ListKey.EQUIPMENT);</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">		if (e != null)</span>
		{
<span class="nc" id="L1253">			addAllToListFor(ListKey.EQUIPMENT, e);</span>
		}

<span class="nc" id="L1256">		List&lt;WeaponProfProvider&gt; wp = otherClass.getListFor(ListKey.WEAPONPROF);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">		if (wp != null)</span>
		{
<span class="nc" id="L1259">			addAllToListFor(ListKey.WEAPONPROF, wp);</span>
		}
<span class="nc" id="L1261">		QualifiedObject&lt;Boolean&gt; otherWP = otherClass.get(ObjectKey.HAS_DEITY_WEAPONPROF);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (otherWP != null)</span>
		{
<span class="nc" id="L1264">			put(ObjectKey.HAS_DEITY_WEAPONPROF, otherWP);</span>
		}

<span class="nc" id="L1267">		List&lt;ArmorProfProvider&gt; ap = otherClass.getListFor(ListKey.AUTO_ARMORPROF);</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">		if (ap != null)</span>
		{
<span class="nc" id="L1270">			addAllToListFor(ListKey.AUTO_ARMORPROF, ap);</span>
		}

<span class="nc" id="L1273">		List&lt;ShieldProfProvider&gt; sp = otherClass.getListFor(ListKey.AUTO_SHIELDPROF);</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">		if (sp != null)</span>
		{
<span class="nc" id="L1276">			addAllToListFor(ListKey.AUTO_SHIELDPROF, sp);</span>
		}

<span class="nc" id="L1279">		List&lt;BonusObj&gt; bonusList = otherClass.getListFor(ListKey.BONUS);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">		if (bonusList != null)</span>
		{
<span class="nc" id="L1282">			addAllToListFor(ListKey.BONUS, bonusList);</span>
		}
		try
		{
<span class="nc" id="L1286">			ownBonuses(this);</span>
		}
<span class="nc" id="L1288">		catch (CloneNotSupportedException ce)</span>
		{
<span class="nc" id="L1290">			Logging.errorPrint(&quot;failed to clone&quot;, ce);</span>
<span class="nc" id="L1291">		}</span>

<span class="nc bnc" id="L1293" title="All 2 branches missed.">		for (VariableKey vk : otherClass.getVariableKeys())</span>
		{
<span class="nc" id="L1295">			put(vk, otherClass.get(vk));</span>
<span class="nc" id="L1296">		}</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">		if (otherClass.containsListFor(ListKey.CSKILL))</span>
		{
<span class="nc" id="L1300">			removeListFor(ListKey.CSKILL);</span>
<span class="nc" id="L1301">			addAllToListFor(ListKey.CSKILL, otherClass.getListFor(ListKey.CSKILL));</span>
		}

<span class="nc bnc" id="L1304" title="All 2 branches missed.">		if (otherClass.containsListFor(ListKey.LOCALCCSKILL))</span>
		{
<span class="nc" id="L1306">			removeListFor(ListKey.LOCALCCSKILL);</span>
<span class="nc" id="L1307">			addAllToListFor(ListKey.LOCALCCSKILL, otherClass.getListFor(ListKey.LOCALCCSKILL));</span>
		}

<span class="nc" id="L1310">		removeListFor(ListKey.KIT_CHOICE);</span>
<span class="nc" id="L1311">		addAllToListFor(ListKey.KIT_CHOICE, otherClass.getSafeListFor(ListKey.KIT_CHOICE));</span>

<span class="nc" id="L1313">		removeListFor(ListKey.SAB);</span>
<span class="nc" id="L1314">		addAllToListFor(ListKey.SAB, otherClass.getSafeListFor(ListKey.SAB));</span>

		/*
		 * TODO Does this need to have things from the Class Level objects?
		 * I don't think so based on deferred processing of levels...
		 */

<span class="nc" id="L1321">		addAllToListFor(ListKey.DAMAGE_REDUCTION, otherClass.getListFor(ListKey.DAMAGE_REDUCTION));</span>

<span class="nc bnc" id="L1323" title="All 2 branches missed.">		for (CDOMReference&lt;Vision&gt; ref : otherClass.getSafeListMods(Vision.VISIONLIST))</span>
		{
<span class="nc bnc" id="L1325" title="All 2 branches missed.">			for (AssociatedPrereqObject apo : otherClass.getListAssociations(Vision.VISIONLIST, ref))</span>
			{
<span class="nc" id="L1327">				putToList(Vision.VISIONLIST, ref, apo);</span>
<span class="nc" id="L1328">			}</span>
<span class="nc" id="L1329">		}</span>

		/*
		 * TODO This is a clone problem, but works for now - thpr 10/3/08
		 */
<span class="nc bnc" id="L1334" title="All 2 branches missed.">		if (otherClass instanceof SubClass)</span>
		{
<span class="nc" id="L1336">			levelMap.clear();</span>
<span class="nc" id="L1337">			copyLevelsFrom(otherClass);</span>
		}

<span class="nc" id="L1340">		addAllToListFor(ListKey.NATURAL_WEAPON, otherClass.getListFor(ListKey.NATURAL_WEAPON));</span>

<span class="nc" id="L1342">		put(ObjectKey.LEVEL_HITDIE, otherClass.get(ObjectKey.LEVEL_HITDIE));</span>
<span class="nc" id="L1343">	}</span>

<span class="fc" id="L1345">	private SortedMap&lt;Integer, PCClassLevel&gt; levelMap = new TreeMap&lt;&gt;();</span>

	public PCClassLevel getOriginalClassLevel(int lvl)
	{
<span class="fc bfc" id="L1349" title="All 2 branches covered.">		if (!levelMap.containsKey(lvl))</span>
		{
<span class="fc" id="L1351">			PCClassLevel classLevel = new PCClassLevel();</span>
<span class="fc" id="L1352">			classLevel.put(IntegerKey.LEVEL, lvl);</span>
<span class="fc" id="L1353">			classLevel.setName(getDisplayName() + &quot;(&quot; + lvl + &quot;)&quot;);</span>
<span class="fc" id="L1354">			classLevel.put(StringKey.QUALIFIED_KEY, getQualifiedKey());</span>
<span class="fc" id="L1355">			classLevel.put(ObjectKey.SOURCE_CAMPAIGN, get(ObjectKey.SOURCE_CAMPAIGN));</span>
<span class="fc" id="L1356">			classLevel.put(StringKey.SOURCE_PAGE, get(StringKey.SOURCE_PAGE));</span>
<span class="fc" id="L1357">			classLevel.put(StringKey.SOURCE_LONG, get(StringKey.SOURCE_LONG));</span>
<span class="fc" id="L1358">			classLevel.put(StringKey.SOURCE_SHORT, get(StringKey.SOURCE_SHORT));</span>
<span class="fc" id="L1359">			classLevel.put(StringKey.SOURCE_WEB, get(StringKey.SOURCE_WEB));</span>
<span class="fc" id="L1360">			classLevel.put(ObjectKey.SOURCE_DATE, get(ObjectKey.SOURCE_DATE));</span>
<span class="fc" id="L1361">			classLevel.put(ObjectKey.TOKEN_PARENT, this);</span>
<span class="fc" id="L1362">			levelMap.put(lvl, classLevel);</span>
		}
<span class="fc" id="L1364">		return levelMap.get(lvl);</span>
	}

	public boolean hasOriginalClassLevel(int lvl)
	{
<span class="nc" id="L1369">		return levelMap.containsKey(lvl);</span>
	}

	public Collection&lt;PCClassLevel&gt; getOriginalClassLevelCollection()
	{
<span class="nc" id="L1374">		return Collections.unmodifiableCollection(levelMap.values());</span>
	}

	public void copyLevelsFrom(PCClass cl)
	{
<span class="nc bnc" id="L1379" title="All 2 branches missed.">		for (Map.Entry&lt;Integer, PCClassLevel&gt; me : cl.levelMap.entrySet())</span>
		{
			try
			{
<span class="nc" id="L1383">				PCClassLevel lvl = me.getValue().clone();</span>
<span class="nc" id="L1384">				lvl.put(StringKey.QUALIFIED_KEY, getQualifiedKey());</span>
<span class="nc" id="L1385">				lvl.put(ObjectKey.SOURCE_CAMPAIGN, get(ObjectKey.SOURCE_CAMPAIGN));</span>
<span class="nc" id="L1386">				lvl.put(StringKey.SOURCE_PAGE, get(StringKey.SOURCE_PAGE));</span>
<span class="nc" id="L1387">				lvl.put(StringKey.SOURCE_LONG, get(StringKey.SOURCE_LONG));</span>
<span class="nc" id="L1388">				lvl.put(StringKey.SOURCE_SHORT, get(StringKey.SOURCE_SHORT));</span>
<span class="nc" id="L1389">				lvl.put(StringKey.SOURCE_WEB, get(StringKey.SOURCE_WEB));</span>
<span class="nc" id="L1390">				lvl.put(ObjectKey.SOURCE_DATE, get(ObjectKey.SOURCE_DATE));</span>
<span class="nc" id="L1391">				lvl.put(ObjectKey.TOKEN_PARENT, this);</span>
<span class="nc" id="L1392">				lvl.setName(getDisplayName() + &quot;(&quot; + lvl.get(IntegerKey.LEVEL) + &quot;)&quot;);</span>
<span class="nc" id="L1393">				lvl.ownBonuses(this);</span>
<span class="nc" id="L1394">				levelMap.put(me.getKey(), lvl);</span>
			}
<span class="nc" id="L1396">			catch (CloneNotSupportedException e)</span>
			{
<span class="nc" id="L1398">				Logging.errorPrint(e.getLocalizedMessage(), e);</span>
<span class="nc" id="L1399">			}</span>
<span class="nc" id="L1400">		}</span>
<span class="nc" id="L1401">	}</span>

	/**
	 * Clear any data from the class levels. Primarily for use by the Classes 
	 * LST editor. 
	 */
	public void clearClassLevels()
	{
<span class="nc" id="L1409">		levelMap.clear();</span>
<span class="nc" id="L1410">	}</span>

	public String getFullKey()
	{
<span class="fc" id="L1414">		return getKeyName();</span>
	}

	@Override
	public void ownBonuses(Object owner) throws CloneNotSupportedException
	{
<span class="nc" id="L1420">		super.ownBonuses(owner);</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">		for (PCClassLevel pcl : this.getOriginalClassLevelCollection())</span>
		{
<span class="nc" id="L1423">			pcl.ownBonuses(owner);</span>
<span class="nc" id="L1424">		}</span>
<span class="nc" id="L1425">	}</span>

	@Override
	public boolean qualifies(PlayerCharacter aPC, Object owner)
	{
<span class="nc bnc" id="L1430" title="All 2 branches missed.">		if (Globals.checkRule(RuleConstants.CLASSPRE))</span>
		{
<span class="nc" id="L1432">			return true;</span>
		}

<span class="nc" id="L1435">		return super.qualifies(aPC, owner);</span>
	}

	public String getBaseStat()
	{
<span class="nc" id="L1440">		return getSpellBaseStat();</span>
	}

	public String getHD()
	{
<span class="nc" id="L1445">		HitDie hd = getSafe(ObjectKey.LEVEL_HITDIE);</span>
<span class="nc" id="L1446">		return String.valueOf(hd.getDie());</span>
	}

	public String[] getTypes()
	{
<span class="nc" id="L1451">		String type = getType();</span>
<span class="nc" id="L1452">		return type.split(&quot;\\.&quot;);</span>
	}

	public String getClassType()
	{
<span class="fc" id="L1457">		FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;ClassType&quot;);</span>
<span class="fc" id="L1458">		return getResolved(fk);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>