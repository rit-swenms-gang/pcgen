<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VariableProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">VariableProcessor.java</span></div><h1>VariableProcessor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004 (C) Chris Ward &lt;frugal@purplewombat.co.uk&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package pcgen.core;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

import pcgen.core.character.CachedVariable;
import pcgen.core.character.CharacterSpell;
import pcgen.core.utils.CoreUtility;
import pcgen.io.ExportHandler;
import pcgen.util.Logging;
import pcgen.util.PJEP;
import pcgen.util.PjepPool;

/**
 * {@code VariableProcessor} is the base class for PCGen variable
 * processors. These are classes that convert a formula or variable
 * into a value and are used extensively both in defintions of objects
 * and for output to output sheets.
 *
 *
 */
public abstract class VariableProcessor
{
	/** A simple mathematical operation. */
<span class="nc" id="L48">	private enum MATH_OP</span>
	{
<span class="nc" id="L50">		PLUS, MINUS, MULTIPLY, DIVIDE</span>
	}

    /** The current indenting to be used for debug output of jep evaluations. */
<span class="fc" id="L54">	private String jepIndent = &quot;&quot;;</span>
	protected PlayerCharacter pc;

	private int cachePaused;
	private int serial;

<span class="fc" id="L60">	private final Map&lt;String, CachedVariable&lt;String&gt;&gt; sVariableCache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L61">	private final Map&lt;String, CachedVariable&lt;Float&gt;&gt; fVariableCache = new HashMap&lt;&gt;();</span>

	protected Float convertToFloat(String element, String foo)
	{
<span class="nc" id="L65">		Float d = null;</span>
		try
		{
<span class="nc" id="L68">			d = Float.valueOf(foo);</span>
		}
<span class="nc" id="L70">		catch (NumberFormatException nfe)</span>
		{
			// What we got back was not a number
<span class="nc" id="L73">		}</span>

<span class="nc" id="L75">		Float retVal = null;</span>
<span class="nc bnc" id="L76" title="All 4 branches missed.">		if (d != null &amp;&amp; !d.isNaN())</span>
		{
<span class="nc" id="L78">			retVal = d;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L81">				Logging.debugPrint(jepIndent + &quot;export variable for: '&quot;</span>
						+ element + &quot;' = &quot; + d);
			}
		}

<span class="nc" id="L86">		return retVal;</span>
	}

	/**
	 * {@code CachableResult} encapsulates a result returned from JEP processing
	 * allowing us to retrieve both the result and its cachability.
	 */
	private static class CachableResult
	{
		final Float result;
		final boolean cachable;

		CachableResult(Float result, boolean cachable)
<span class="nc" id="L99">		{</span>
<span class="nc" id="L100">			this.result = result;</span>
<span class="nc" id="L101">			this.cachable = cachable; // unreliable!</span>
<span class="nc" id="L102">		}</span>
	}

	/**
	 * Create a new Variable Processor instance.
	 * @param pc The character the processor is for.
	 */
	public VariableProcessor(PlayerCharacter pc)
<span class="fc" id="L110">	{</span>
<span class="fc" id="L111">		this.pc = pc;</span>
<span class="fc" id="L112">	}</span>

	/**
	 * Evaluates a variable for this character.
	 * e.g: getVariableValue(&quot;3+CHA&quot;,&quot;CLASS:Cleric&quot;) for Turn Undead
	 *
	 * @param aSpell     This is specifically to compute bonuses to CASTERLEVEL
	 *                   for a specific spell.
	 * @param varString  The variable to be evaluated
	 * @param src        The source within which the variable is evaluated
	 * @param spellLevelTemp The temporary spell level
	 * @return The value of the variable
	 */
	public Float getVariableValue(CharacterSpell aSpell, String varString, String src, int spellLevelTemp)
	{
<span class="nc" id="L127">		Float result = getJepOnlyVariableValue(aSpell, varString, src, spellLevelTemp);</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (null == result)</span>
		{
<span class="nc" id="L131">			result = processBrokenParser(aSpell, varString, src, spellLevelTemp);</span>

<span class="nc" id="L133">			String cacheString = makeCacheString(aSpell, varString, src, spellLevelTemp);</span>

<span class="nc" id="L135">			addCachedVariable(cacheString, result);</span>
		}

<span class="nc" id="L138">		return result;</span>
	}

	/**
	 * Evaluates a JEP variable for this character.
	 * e.g: getJepOnlyVariableValue(&quot;3+CHA&quot;,&quot;CLASS:Cleric&quot;) for Turn Undead
	 *
	 * @param aSpell  This is specifically to compute bonuses to CASTERLEVEL for a specific spell.
	 * @param varString The variable to be evaluated
	 * @param src     The source within which the variable is evaluated
	 * @param spellLevelTemp The temporary spell level
	 * @return The value of the variable, or null if the formula is not JEP
	 */
	public Float getJepOnlyVariableValue(final CharacterSpell aSpell, String varString, String src, int spellLevelTemp)
	{
		// First try to just parse it as a number.
		try
		{
<span class="nc" id="L156">			return Float.valueOf(varString);</span>
		}
<span class="nc" id="L158">		catch (NumberFormatException e)</span>
		{
			// Nothing to handle here, we're attempting to see if varString was a
			// number, If we got here it wasn't
		}

<span class="nc" id="L164">		String cacheString = makeCacheString(aSpell, varString, src, spellLevelTemp);</span>

<span class="nc" id="L166">		Float total = getCachedVariable(cacheString);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">		if (total != null)</span>
		{
<span class="nc" id="L169">			return total;</span>
		}

<span class="nc" id="L172">		CachableResult cRes = processJepFormula(aSpell, varString, src);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (cRes != null)</span>
		{
<span class="nc bnc" id="L175" title="All 2 branches missed.">			if (cRes.cachable)</span>
			{
<span class="nc" id="L177">				addCachedVariable(cacheString, cRes.result);</span>
			}
<span class="nc" id="L179">			return cRes.result;</span>
		}
<span class="nc" id="L181">		return null;</span>
	}

	private String makeCacheString(CharacterSpell aSpell, String varString, String src, int spellLevelTemp)
	{
<span class="nc" id="L186">		StringBuilder cS = new StringBuilder(varString).append('#').append(src);</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">		if (aSpell != null)</span>
		{
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (aSpell.getSpell() != null)</span>
			{
<span class="nc" id="L192">				cS.append(aSpell.getSpell().getKeyName());</span>
			}
<span class="nc" id="L194">			cS.append(aSpell.getFixedCasterLevel());</span>
		}

<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (spellLevelTemp &gt; 0)</span>
		{
<span class="nc" id="L199">			cS.append(spellLevelTemp);</span>
		}

<span class="nc" id="L202">		return cS.toString();</span>
	}

	/**
	 * Evaluate the variable using the old non-JEP variable parser. Use of this
	 * parser is being phased out.
	 *
	 * @param aSpell  This is specifically to compute bonuses to CASTERLEVEL for a specific spell.
	 * @param aString The variable to be evaluated
	 * @param src     The source within which the variable is evaluated
	 * @param spellLevelTemp The temporary spell level
	 * @return The value of the variable
	 */
	private Float processBrokenParser(final CharacterSpell aSpell, String aString, String src, int spellLevelTemp)
	{
<span class="nc" id="L217">		Float total = (float) 0.0;</span>
<span class="nc" id="L218">		aString = aString.toUpperCase();</span>
<span class="nc" id="L219">		src = src.toUpperCase();</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">		while (aString.lastIndexOf('(') &gt;= 0)</span>
		{
<span class="nc" id="L223">			final int x = CoreUtility.innerMostStringStart(aString);</span>
<span class="nc" id="L224">			final int y = CoreUtility.innerMostStringEnd(aString);</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (y &lt; x)</span>
			{
<span class="nc" id="L228">				Logging.errorPrint(&quot;Missing closing parenthesis: &quot; + aString);</span>

<span class="nc" id="L230">				return total;</span>
			}

<span class="nc" id="L233">			final String bString = aString.substring(x + 1, y);</span>
<span class="nc" id="L234">			aString = aString.substring(0, x) + getVariableValue(aSpell, bString, src, spellLevelTemp)</span>
<span class="nc" id="L235">				+ aString.substring(y + 1);</span>
<span class="nc" id="L236">		}</span>

<span class="nc" id="L238">		final String delimiter = &quot;+-/*&quot;;</span>
<span class="nc" id="L239">		String valString = &quot;&quot;;</span>
<span class="nc" id="L240">		MATH_OP mode = MATH_OP.PLUS;</span>
<span class="nc" id="L241">		MATH_OP nextMode = MATH_OP.PLUS;</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (aString.startsWith(&quot;.IF.&quot;))</span>
		{
<span class="nc" id="L245">			final StringTokenizer aTok = new StringTokenizer(aString.substring(4), &quot;.&quot;, true);</span>
<span class="nc" id="L246">			StringBuilder bString = new StringBuilder();</span>
<span class="nc" id="L247">			Float val1 = null; // first value</span>
<span class="nc" id="L248">			Float val2 = null; // other value in comparison</span>
<span class="nc" id="L249">			Float valt = null; // value if comparison is true</span>
			final Float valf; // value if comparison is false
<span class="nc" id="L251">			int comp = 0;</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">			while (aTok.hasMoreTokens())</span>
			{
<span class="nc" id="L255">				final String cString = aTok.nextToken();</span>

<span class="nc bnc" id="L257" title="All 8 branches missed.">				if (&quot;GT&quot;.equals(cString) || &quot;GTEQ&quot;.equals(cString) || &quot;EQ&quot;.equals(cString) || &quot;LTEQ&quot;.equals(cString)</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">					|| &quot;LT&quot;.equals(cString))</span>
				{
					// Truncate final . character
<span class="nc" id="L261">					val1 = getVariableValue(aSpell, bString.substring(0, bString.length() - 1), src, spellLevelTemp); </span>
<span class="nc" id="L262">					aTok.nextToken(); // discard next . character</span>
<span class="nc" id="L263">					bString = new StringBuilder();</span>

<span class="nc bnc" id="L265" title="All 6 branches missed.">					switch (cString)</span>
					{
<span class="nc" id="L267">						case &quot;LT&quot; -&gt; comp = 1;</span>
<span class="nc" id="L268">						case &quot;LTEQ&quot; -&gt; comp = 2;</span>
<span class="nc" id="L269">						case &quot;EQ&quot; -&gt; comp = 3;</span>
<span class="nc" id="L270">						case &quot;GT&quot; -&gt; comp = 4;</span>
<span class="nc" id="L271">						case &quot;GTEQ&quot; -&gt; comp = 5;</span>
<span class="nc" id="L272">					}</span>
				}
<span class="nc bnc" id="L274" title="All 2 branches missed.">				else if (&quot;THEN&quot;.equals(cString))</span>
				{
					// Truncate final . character
<span class="nc" id="L277">					val2 = getVariableValue(aSpell, bString.substring(0, bString.length() - 1), src, spellLevelTemp); </span>
<span class="nc" id="L278">					aTok.nextToken(); // discard next . character</span>
<span class="nc" id="L279">					bString = new StringBuilder();</span>
				}
<span class="nc bnc" id="L281" title="All 2 branches missed.">				else if (&quot;ELSE&quot;.equals(cString))</span>
				{
					// Truncate final . character
<span class="nc" id="L284">					valt = getVariableValue(aSpell, bString.substring(0, bString.length() - 1), src, spellLevelTemp);</span>
<span class="nc" id="L285">					aTok.nextToken(); // discard next . character</span>
<span class="nc" id="L286">					bString = new StringBuilder();</span>
				}
				else
				{
<span class="nc" id="L290">					bString.append(cString);</span>
				}
<span class="nc" id="L292">			}</span>

<span class="nc bnc" id="L294" title="All 6 branches missed.">			if ((val1 != null) &amp;&amp; (val2 != null) &amp;&amp; (valt != null))</span>
			{
<span class="nc" id="L296">				valf = getVariableValue(aSpell, bString.toString(), src, spellLevelTemp);</span>
<span class="nc" id="L297">				total = valt;</span>

<span class="nc bnc" id="L299" title="All 6 branches missed.">				switch (comp)</span>
				{
					case 1: // LT

<span class="nc bnc" id="L303" title="All 2 branches missed.">						if (val1.doubleValue() &gt;= val2.doubleValue())</span>
						{
<span class="nc" id="L305">							total = valf;</span>
						}

						break;

					case 2: // LTEQ

<span class="nc bnc" id="L312" title="All 2 branches missed.">						if (val1.doubleValue() &gt; val2.doubleValue())</span>
						{
<span class="nc" id="L314">							total = valf;</span>
						}

						break;

					case 3: // EQ

<span class="nc bnc" id="L321" title="All 2 branches missed.">						if (!CoreUtility.doublesEqual(val1.doubleValue(), val2.doubleValue()))</span>
						{
<span class="nc" id="L323">							total = valf;</span>
						}

						break;

					case 4: // GT

<span class="nc bnc" id="L330" title="All 2 branches missed.">						if (val1.doubleValue() &lt;= val2.doubleValue())</span>
						{
<span class="nc" id="L332">							total = valf;</span>
						}

						break;

					case 5: // GTEQ

<span class="nc bnc" id="L339" title="All 2 branches missed.">						if (val1.doubleValue() &lt; val2.doubleValue())</span>
						{
<span class="nc" id="L341">							total = valf;</span>
						}

						break;

					default:
<span class="nc" id="L347">						Logging.errorPrint(&quot;ERROR - badly formed statement:&quot; + aString + ':' + val1.toString() + ':'</span>
<span class="nc" id="L348">							+ val2.toString() + ':' + comp);</span>

<span class="nc" id="L350">						return (float) 0.0;</span>
				}

<span class="nc" id="L353">				return total;</span>
			}
		}

<span class="nc bnc" id="L357" title="All 2 branches missed.">		for (int i = 0; i &lt; aString.length(); ++i)</span>
		{
<span class="nc" id="L359">			valString += aString.substring(i, i + 1);</span>

<span class="nc" id="L361">			if (</span>
			// end of string
<span class="nc bnc" id="L363" title="All 2 branches missed.">			(i == (aString.length() - 1))</span>

				// have found one of +, -, *, /
<span class="nc bnc" id="L366" title="All 2 branches missed.">				|| (delimiter.lastIndexOf(aString.charAt(i)) &gt; -1))</span>
			{
<span class="nc bnc" id="L368" title="All 4 branches missed.">				if ((valString.length() == 1) &amp;&amp; (delimiter.lastIndexOf(aString.charAt(i)) &gt; -1))</span>
				{
<span class="nc" id="L370">					continue;</span>
				}

<span class="nc bnc" id="L373" title="All 2 branches missed.">				if (delimiter.lastIndexOf(aString.charAt(i)) &gt; -1)</span>
				{
<span class="nc" id="L375">					valString = valString.substring(0, valString.length() - 1);</span>
				}

<span class="nc" id="L378">				final Float tmp = lookupVariable(valString, src, aSpell);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">				if (tmp != null)</span>
				{
<span class="nc" id="L381">					valString = tmp.toString();</span>
				}

<span class="nc bnc" id="L384" title="All 5 branches missed.">				switch (aString.charAt(i))</span>
				{
<span class="nc" id="L386">					case '+' -&gt; nextMode = MATH_OP.PLUS;</span>
<span class="nc" id="L387">					case '-' -&gt; nextMode = MATH_OP.MINUS;</span>
<span class="nc" id="L388">					case '*' -&gt; nextMode = MATH_OP.MULTIPLY;</span>
<span class="nc" id="L389">					case '/' -&gt; nextMode = MATH_OP.DIVIDE;</span>
				}

<span class="nc bnc" id="L392" title="All 2 branches missed.">				if (!valString.isEmpty())</span>
				{
<span class="nc" id="L394">					float valFloat = 0.0f;</span>
					try
					{
<span class="nc" id="L397">						valFloat = Float.parseFloat(valString);</span>
					}
<span class="nc" id="L399">					catch (NumberFormatException exc)</span>
					{
						// Don't care, as it's just zero
						//Logging.debugPrint(&quot;Will use default for total: &quot; + total, exc);
<span class="nc" id="L403">					}</span>

<span class="nc bnc" id="L405" title="All 5 branches missed.">					switch (mode)</span>
					{
<span class="nc" id="L407">						case PLUS -&gt; total += valFloat;</span>
<span class="nc" id="L408">						case MINUS -&gt; total -= valFloat;</span>
<span class="nc" id="L409">						case MULTIPLY -&gt; total *= valFloat;</span>
<span class="nc" id="L410">						case DIVIDE -&gt; total /= valFloat;</span>
<span class="nc" id="L411">						default -&gt; Logging.errorPrint(</span>
								&quot;In PlayerCharacter.getVariableValue the mode &quot; + mode + &quot; is unsupported.&quot;);
					}
				}

<span class="nc" id="L416">				mode = nextMode;</span>
<span class="nc" id="L417">				nextMode = MATH_OP.PLUS;</span>
<span class="nc" id="L418">				valString = &quot;&quot;;</span>
			}
		}

<span class="nc" id="L422">		return total;</span>
	}

	/**
	 * Evaluate the forumla using the JEP parser. This will always be tried before
	 * using the old non-JEP parser and null will be returned if the forumla is not
	 * a recognised JEP formula.
	 *
	 * @param spell  This is specifically to compute bonuses to CASTERLEVEL for a specific spell.
	 * @param formula The formula to be evaluated
	 * @param src     The source within which the variable is evaluated
	 * @return The value of the variable encapsulated in a CachableResult
	 */
	private CachableResult processJepFormula(final CharacterSpell spell, final String formula, final String src)
	{
<span class="nc" id="L437">		final String DEBUG_FORMULA_PREFIX = &quot;CLASSLEVEL&quot;;</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">		if (Logging.isLoggable(Logging.DEBUG) &amp;&amp; formula.startsWith(DEBUG_FORMULA_PREFIX))</span>
		{
<span class="nc" id="L440">			Logging.debugPrint(jepIndent + &quot;getJepVariable: &quot; + formula);</span>
		}
<span class="nc" id="L442">		jepIndent += &quot;    &quot;;</span>
<span class="nc" id="L443">		PJEP parser = null;</span>

		try
		{
<span class="nc" id="L447">			parser = PjepPool.getInstance().aquire(this, src);</span>
<span class="nc" id="L448">			parser.parseExpression(formula);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">			if (parser.hasError())</span>
			{
<span class="nc bnc" id="L451" title="All 4 branches missed.">				if (Logging.isLoggable(Logging.DEBUG) &amp;&amp; formula.startsWith(DEBUG_FORMULA_PREFIX))</span>
				{
<span class="nc" id="L453">					Logging.debugPrint(jepIndent + &quot;not a JEP expression: &quot; + formula);</span>
				}
<span class="nc" id="L455">				return null;</span>
			}

<span class="nc bnc" id="L458" title="All 2 branches missed.">			for (final String element : (Iterable&lt;String&gt;) parser.getSymbolTable().keySet())</span>
			{
<span class="nc bnc" id="L460" title="All 8 branches missed.">				if (&quot;e&quot;.equals(element) || &quot;FALSE&quot;.equals(element) || &quot;pi&quot;.equals(element) || &quot;TRUE&quot;.equals(element))</span>
				{
<span class="nc" id="L462">					continue;</span>
				}

<span class="nc" id="L465">				Float d = lookupVariable(element, src, spell);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">				if (d != null)</span>
				{
<span class="nc" id="L468">					parser.addVariable(element, d.doubleValue());</span>
				} else
				{
					// we could not get a value for all of the variables, so it must not have been a JEP function
					// after all...
<span class="nc" id="L473">					return null;</span>
				}
<span class="nc" id="L475">			}</span>

<span class="nc" id="L477">			final Object result = parser.getValueAsObject();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">			if (result != null)</span>
			{
<span class="nc bnc" id="L480" title="All 4 branches missed.">				if (Logging.isLoggable(Logging.DEBUG) &amp;&amp; formula.startsWith(DEBUG_FORMULA_PREFIX))</span>
				{
<span class="nc" id="L482">					Logging.debugPrint(jepIndent + &quot;Result '&quot; + formula + &quot;' = &quot; + result);</span>
				}
				try
				{
<span class="nc" id="L486">					return new CachableResult(Float.valueOf(result.toString()), parser.isResultCachable());</span>
				}
<span class="nc" id="L488">				catch (NumberFormatException nfe)</span>
				{
<span class="nc bnc" id="L490" title="All 4 branches missed.">					if (Logging.isLoggable(Logging.DEBUG) &amp;&amp; formula.startsWith(DEBUG_FORMULA_PREFIX))</span>
					{
<span class="nc" id="L492">						Logging.debugPrint(jepIndent + &quot;Result '&quot; + formula + &quot;' = &quot; + result + &quot; was not a number...&quot;);</span>
					}
<span class="nc" id="L494">					return null;</span>
				}
			}
<span class="nc bnc" id="L497" title="All 2 branches missed.">			if (parser.hasError())</span>
			{
<span class="nc" id="L499">				Logging.errorPrint(&quot;Failed to process formula &quot; + formula + &quot; due to error: &quot; + parser.getErrorInfo());</span>
			}
<span class="nc bnc" id="L501" title="All 4 branches missed.">			if (Logging.isLoggable(Logging.DEBUG) &amp;&amp; formula.startsWith(DEBUG_FORMULA_PREFIX))</span>
			{
<span class="nc" id="L503">				Logging.debugPrint(jepIndent + &quot;Result '&quot; + formula + &quot;' was null...&quot;);</span>
			}
<span class="nc" id="L505">			return null;</span>
		}
		finally
		{
<span class="nc bnc" id="L509" title="All 4 branches missed.">			if (jepIndent != null &amp;&amp; jepIndent.length() &gt;= 4)</span>
			{
<span class="nc" id="L511">				jepIndent = jepIndent.substring(4);</span>
			}
<span class="nc" id="L513">			PjepPool.getInstance().release(parser);</span>
		}
	}

	abstract Float getInternalVariable(CharacterSpell aSpell, String valString, String src);

	/**
	 * Get a value for the term as evaluated in the context of the PC that
	 * owns this VariableEvaluator (getPc()) the term itself and the source
	 * of the term e.g. RACE:Halfling.  If the term is CASTERLEVEL the
	 * Spell parameter is also used, if not it is ignored and may be null.  
	 * 
	 * @param term
	 *          The string to be evaluated
	 * @param src
	 *          The source of the term
	 * @param spell
	 *          A spell which is only used if the term is related to CASTERLEVEL
	 * 
	 * @return a Float value for this term
	 */
	public Float lookupVariable(String term, String src, CharacterSpell spell)
	{
<span class="nc" id="L536">		Float retVal = null;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">		if (pc.hasVariable(term))</span>
		{
<span class="nc" id="L539">			final Float value = pc.getVariable(term, true);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L542">				Logging.debugPrint(jepIndent + &quot;variable for: '&quot; + term</span>
						+ &quot;' = &quot; + value);
			}
<span class="nc" id="L545">			retVal = (float) value.doubleValue();</span>
		}

<span class="nc bnc" id="L548" title="All 2 branches missed.">		if (retVal == null)</span>
		{
<span class="nc" id="L550">			retVal = getInternalVariable(spell, term, src);</span>
		}

<span class="nc bnc" id="L553" title="All 2 branches missed.">		if (retVal == null)</span>
		{
<span class="nc" id="L555">			final String evReturn = getExportVariable(term);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			if (evReturn != null)</span>
			{
<span class="nc" id="L558">				retVal = convertToFloat(term, evReturn);</span>
			}
		}

<span class="nc" id="L562">		return retVal;</span>
	}

	/**
	 * Attempt to retrieve a cached value of a variable.
	 *
	 * @param lookup The name of the variable to be checked.
	 * @return The value of the variable
	 */
	public Float getCachedVariable(final String lookup)
	{
<span class="nc bnc" id="L573" title="All 2 branches missed.">		if (isCachePaused())</span>
		{
<span class="nc" id="L575">			return null;</span>
		}

<span class="nc" id="L578">		final CachedVariable&lt;Float&gt; cached = fVariableCache.get(lookup);</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">		if (cached != null)</span>
		{
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if (cached.getSerial() &gt;= getSerial())</span>
			{
<span class="nc" id="L584">				return cached.getValue();</span>
			}
<span class="nc" id="L586">			fVariableCache.remove(lookup);</span>
		}
<span class="nc" id="L588">		return null;</span>
	}

	/**
	 * Add a new variable to the cache.
	 *
	 * @param lookup The name of the variable to be added.
	 * @param value The value of the variable
	 */
	public void addCachedVariable(final String lookup, final Float value)
	{
<span class="nc bnc" id="L599" title="All 2 branches missed.">		if (isCachePaused())</span>
		{
<span class="nc" id="L601">			return;</span>
		}
<span class="nc" id="L603">		final CachedVariable&lt;Float&gt; cached = new CachedVariable&lt;&gt;();</span>
<span class="nc" id="L604">		cached.setSerial(getSerial());</span>
<span class="nc" id="L605">		cached.setValue(value);</span>
		//		if (lookup.equals(&quot;floor(SCORE/2)-5#STAT:CHA&quot;))
		//		{
		//			Logging.errorPrint(&quot;At &quot; + cached.getSerial() + &quot; caching &quot; + lookup + &quot; of &quot; + value);
		//		}

<span class="nc" id="L611">		fVariableCache.put(lookup, cached);</span>
<span class="nc" id="L612">	}</span>

	/**
	 * Restart caching of variable values. Used after caching has
	 * been paused by a call to pauseCache.
	 */
	public void restartCache()
	{
<span class="nc" id="L620">		serial = cachePaused;</span>
<span class="nc" id="L621">		cachePaused = 0;</span>
<span class="nc" id="L622">	}</span>

	/**
	 * Pause caching of variable values. Normally used when making temporary
	 * changes to a character.
	 */
	public void pauseCache()
	{
<span class="nc" id="L630">		cachePaused = serial;</span>
<span class="nc" id="L631">	}</span>

	/**
	 * Identify if the cache is current paused or not.
	 * @return True if the cache is currently paused, false otherwise.
	 */
	public boolean isCachePaused()
	{
<span class="nc bnc" id="L639" title="All 2 branches missed.">		return cachePaused &gt; 0;</span>
	}

	/**
	 * Retrieve the current cache serial. This value identifies the currency
	 * of the cache and can be compared against the serial of entries in the
	 * cache to detemrine if they have expired.
	 *
	 * @return The current cache serial.
	 */
	public int getSerial()
	{
<span class="nc" id="L651">		return serial;</span>
	}

	/**
	 * Set the current cache serial. This value identifies the currency
	 * of the cache and is generally set to match the PC's serial value.
	 * @param serial The new serial value to set.
	 */
	public void setSerial(int serial)
	{
<span class="fc" id="L661">		this.serial = serial;</span>
<span class="fc" id="L662">	}</span>

	/**
	 * Retrieve a value from the cache. This method will not return
	 * expired values, but instead removes them from the cache if
	 * they are found.
	 *
	 * @param lookup The name of the variable (or the formula) to retrieve.
	 * @return String The value of the variable, or null if a current value is not present in the cache.
	 */
	String getCachedString(final String lookup)
	{
<span class="nc bnc" id="L674" title="All 2 branches missed.">		if (isCachePaused())</span>
		{
<span class="nc" id="L676">			return null;</span>
		}

<span class="nc" id="L679">		final CachedVariable&lt;String&gt; cached = sVariableCache.get(lookup);</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">		if (cached != null)</span>
		{
<span class="nc bnc" id="L683" title="All 2 branches missed.">			if (cached.getSerial() &gt;= getSerial())</span>
			{
<span class="nc" id="L685">				return cached.getValue();</span>
			}
<span class="nc" id="L687">			sVariableCache.remove(lookup);</span>
		}
<span class="nc" id="L689">		return null;</span>
	}

	/**
	 * Add a value to the cache. If the cache is paused, the value will
	 * not be added.
	 *
	 * @param lookup The name of the variable (or the formula) to cache.
	 * @param value  The value of the variable or formula.
	 */
	public void addCachedString(final String lookup, final String value)
	{
<span class="nc bnc" id="L701" title="All 2 branches missed.">		if (isCachePaused())</span>
		{
<span class="nc" id="L703">			return;</span>
		}
<span class="nc" id="L705">		final CachedVariable&lt;String&gt; cached = new CachedVariable&lt;&gt;();</span>
<span class="nc" id="L706">		cached.setSerial(getSerial());</span>
<span class="nc" id="L707">		cached.setValue(value);</span>

<span class="nc" id="L709">		sVariableCache.put(lookup, cached);</span>
<span class="nc" id="L710">	}</span>

	/**
	 * Returns a float value representing a variable used by the
	 * export process, for example, any token that is used in an outputsheet.
	 *
	 * @param valString   The name of the token to process. i.e. &quot;LOCK.CON&quot;
	 * @return   The evaluated value of valString as a String.
	 */
	public String getExportVariable(String valString)
	{
<span class="nc" id="L721">		final StringWriter sWriter = new StringWriter();</span>
<span class="nc" id="L722">		final BufferedWriter aWriter = new BufferedWriter(sWriter);</span>
<span class="nc" id="L723">		final ExportHandler aExport = ExportHandler.createExportHandler(new File(&quot;&quot;));</span>
<span class="nc" id="L724">		aExport.replaceTokenSkipMath(pc, valString, aWriter);</span>
<span class="nc" id="L725">		sWriter.flush();</span>

		try
		{
<span class="nc" id="L729">			aWriter.flush();</span>
		}
<span class="nc" id="L731">		catch (IOException e)</span>
		{
<span class="nc" id="L733">			Logging.errorPrint(&quot;Couldn't flush the StringWriter used in PlayerCharacter.getVariableValue.&quot;, e);</span>
<span class="nc" id="L734">		}</span>

<span class="nc" id="L736">		final String bString = sWriter.toString();</span>

		String result;
		try
		{
			// Float values
<span class="nc" id="L742">			result = String.valueOf(Float.parseFloat(bString));</span>
		}
<span class="nc" id="L744">		catch (NumberFormatException e)</span>
		{
			// String values
<span class="nc" id="L747">			result = bString;</span>
<span class="nc" id="L748">		}</span>
<span class="nc" id="L749">		return result;</span>
	}

	/**
	 * Retrieve the PlayerCharacter object that this VariableProcessor
	 * instance serves.
	 *
	 * @return The PlayerCharacter instance.
	 */
	public PlayerCharacter getPc()
	{
<span class="nc" id="L760">		return pc;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>