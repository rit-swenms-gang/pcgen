<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RollingMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">RollingMethods.java</span></div><h1>RollingMethods.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Mario Bonassin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
package pcgen.core;

import java.util.Arrays;
import java.util.Stack;
import java.util.Vector;
import java.util.stream.IntStream;

import pcgen.base.util.RandomUtil;
import pcgen.util.Logging;

import org.nfunk.jep.JEP;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.List;
import org.nfunk.jep.function.PostfixMathCommand;

public final class RollingMethods
{

	private RollingMethods()
	{
	}

	/**
	 * Roll &lt;var&gt;times&lt;/var&gt; number of dice with &lt;var&gt;sides&lt;/var&gt;
	 * shape.
	 *
	 * @param times int how many dice to roll?
	 * @param sides int what shape dice?
	 *
	 * @return int dice total
	 */
	public static int roll(final int times, final int sides)
	{
<span class="fc" id="L52">		return roll(times, sides, times, 0);</span>
	}

	/**
	 * One random number between 1 and &lt;var&gt;sides&lt;/var&gt;, good, for
	 * example, for rolling percentage dice.
	 *
	 * @param sides int what shape die?
	 *
	 * @return int die roll
	 */
	public static int roll(final int sides)
	{
<span class="fc" id="L65">		return RandomUtil.getRandomInt(sides) + 1;</span>
	}

	/**
	 * Roll &lt;var&gt;times&lt;/var&gt; dice with &lt;var&gt;sides&lt;/var&gt; shape,
	 * sort them, and return the sum of only those listed in
	 * &lt;var&gt;keep&lt;/var&gt; (0-indexed).
	 *
	 * @param times int how many dice to roll?
	 * @param sides int what shape dice?
	 * @param keep int[] which dice to keep (0-indexed)?
	 *
	 * @return int dice total
	 */
	public static int roll(int times, final int sides, final int[] keep)
	{
		// return roll (times, sides, keep, 0, 0);
<span class="fc" id="L82">		int[] ints = IntStream.generate(() -&gt; RandomUtil.getRandomInt(sides)).limit(times).sorted().toArray();</span>
		// keep the +1 at the end
<span class="fc" id="L84">		return Arrays.stream(keep).reduce(keep.length, (a, aKeep) -&gt; a + ints[aKeep]);</span>
	}

	private static int getLeftIndex(final StringBuilder expression, int startIndex)
	{
<span class="nc" id="L89">		int startIndex1 = startIndex;</span>
<span class="nc" id="L90">		int parenth = 0;</span>
		char c;
		do
		{
<span class="nc" id="L94">			startIndex1--;</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (startIndex1 &gt;= 0)</span>
			{
<span class="nc" id="L97">				c = expression.charAt(startIndex1);</span>
			}
			else
			{
				break;
			}
<span class="nc bnc" id="L103" title="All 2 branches missed.">			if (c == ')')</span>
			{
<span class="nc" id="L105">				parenth++;</span>
			}
<span class="nc bnc" id="L107" title="All 2 branches missed.">			else if (c == '(')</span>
			{
<span class="nc" id="L109">				parenth--;</span>
			}
		}
<span class="nc bnc" id="L112" title="All 12 branches missed.">		while ((parenth &gt; 0) || (c == 'd') || (c == '*') || (c == '/') || (c == ' ') || Character.isDigit(c));</span>
<span class="nc" id="L113">		return startIndex1 + 1;</span>
	}

	private static int getRightIndex(final StringBuilder expression, int startIndex)
	{
<span class="nc" id="L118">		int startIndex1 = startIndex;</span>
<span class="nc" id="L119">		int parenth = 0;</span>
		char c;
		do
		{
<span class="nc" id="L123">			startIndex1++;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">			if (startIndex1 &lt; expression.length())</span>
			{
<span class="nc" id="L126">				c = expression.charAt(startIndex1);</span>
			}
			else
			{
				break;
			}
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if (c == '(')</span>
			{
<span class="nc" id="L134">				parenth++;</span>
			}
<span class="nc bnc" id="L136" title="All 2 branches missed.">			else if (c == ')')</span>
			{
<span class="nc" id="L138">				parenth--;</span>
			}
		}
<span class="nc bnc" id="L141" title="All 10 branches missed.">		while ((parenth &gt; 0) || (c == '*') || (c == '/') || (c == ' ') || Character.isDigit(c));</span>
<span class="nc" id="L142">		return startIndex1;</span>
	}

	/**
	 * Takes many forms including &quot;2d6-2&quot; and returns the result
	 * Whitespace is ignored; case insensitive;  Most simple math
	 * operations (including exponentiation) are supported
	 * Functions builtin include max, min, roll
	 *  Add new functions to DiceExpressionFunctions
	 *
	 * @param method String formatted string representing dice roll
	 *
	 * @return int dice total
	 */
	public static int roll(final String method)
	{
<span class="fc" id="L158">		int r = 0;</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		if (method.length() &lt;= 0)</span>
		{
<span class="nc" id="L162">			return r;</span>
		}
<span class="fc" id="L164">		final StringBuilder expression = new StringBuilder(method.replaceAll(&quot;d%&quot;, &quot;1d100&quot;));</span>
<span class="fc" id="L165">		int index = expression.lastIndexOf(&quot;d&quot;);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		while (index != -1)</span>
		{
<span class="nc" id="L168">			expression.insert(getRightIndex(expression, index), ')');</span>
<span class="nc" id="L169">			expression.setCharAt(index, ',');</span>
<span class="nc" id="L170">			expression.insert(getLeftIndex(expression, index), &quot;roll(&quot;);</span>
<span class="nc" id="L171">			index = expression.lastIndexOf(&quot;d&quot;, index + 4);</span>
		}
<span class="fc" id="L173">		String exp = expression.toString();</span>
<span class="fc" id="L174">		exp = exp.replaceAll(&quot;\\[&quot;, &quot;list(&quot;).replaceAll(&quot;\\]&quot;, &quot;)&quot;);</span>
<span class="fc" id="L175">		final JEP jep = new JEP();</span>
<span class="fc" id="L176">		jep.addStandardFunctions();</span>
<span class="fc" id="L177">		jep.addFunction(&quot;roll&quot;, new Roll());</span>
<span class="fc" id="L178">		jep.addFunction(&quot;top&quot;, new Top());</span>
<span class="fc" id="L179">		jep.addFunction(&quot;reroll&quot;, new Reroll());</span>
<span class="fc" id="L180">		jep.addFunction(&quot;list&quot;, new List());</span>
<span class="fc" id="L181">		jep.parseExpression(exp);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		if (!jep.hasError())</span>
		{
<span class="fc" id="L184">			r = (int) jep.getValue();</span>
		}
		else
		{
<span class="nc" id="L188">			Logging.errorPrint(&quot;Bad dice: &quot; + expression + &quot;:&quot; + jep.getErrorInfo());</span>
		}
<span class="fc" id="L190">		return r;</span>
	}

	/**
	 * Roll {{@code times}} 1d{{@code sides}}, reroll any result &lt;= {{@code reroll}}.
	 * Add together the highest {{@code numToKeep}} dice then add {{@code modifier}}
	 * and return the result.
	 *
	 * @param times
	 * @param sides
	 * @param numToKeep
	 * @param reroll
	 * @return the result of the die roll
	 */
	private static int roll(final int times, final int sides, final int numToKeep, final int reroll)
	{
<span class="fc" id="L206">		return IntStream.generate(() -&gt; roll(sides - reroll) + reroll).limit(times).sorted().skip(times - numToKeep)</span>
<span class="fc" id="L207">			.sum();</span>
	}

	/**
	 * 
	 * &lt;p&gt;This class forms the basis for the dJEP extensions to the JEP library.
	 * It evaluates a {@code ROLL} token, which is an operator that comes
	 * in precedence between multiplicative and additive operators.&lt;/p&gt;
	 * 
	 * &lt;p&gt;The class receives two parameters, the number of rolls and the number of
	 * faces per die, as in &quot;3d6,&quot; or whatever.  It initializes a random number
	 * generator, which must be a subclass of {@code edu.cornell.lassp.houle.RngPack.RandomElement}.
	 * A default randomizer class is provided that wraps the java.util.Random class.
	 * The class used may be changed via setRandomClassName.&lt;/p&gt;
	 * 
	 * &lt;p&gt;The class provides very minimal retrieval of individual rolls, via the
	 * {@code getRolls()} method.&lt;/p&gt;
	 */
	private static final class Roll extends PostfixMathCommand
	{

		/**
		 * 
		 * &lt;p&gt;The default (and only) constructor.  Sets the number
		 * of parameters for the JEP package, and calls {@code setRandom()} to
		 * initialize the randomizer.&lt;/p&gt;
		 */
		private Roll()
<span class="fc" id="L235">		{</span>
<span class="fc" id="L236">			numberOfParameters = -1;</span>
<span class="fc" id="L237">		}</span>

		/**
		 * &lt;p&gt;The run command for the JEP framework.  This receives the arguments
		 * to the operator as a stack, pops off the two it needs, does type checking,
		 * rolls the dice on the randomizer, and pushes the result back onto the stack.
		 * Logging is performed if it is turned on.&lt;/p&gt;
		 */
		@SuppressWarnings({&quot;UseOfObsoleteCollectionType&quot;, &quot;PMD.ReplaceVectorWithList&quot;})
		@Override
		public void run(final Stack stack) throws ParseException
		{
			// check the stack
<span class="fc" id="L250">			checkStack(stack);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">			if (curNumberOfParameters &lt; 2)</span>
			{
<span class="nc" id="L253">				throw new ParseException(&quot;Too few parameters&quot;);</span>
			}
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">			if (curNumberOfParameters &gt; 4)</span>
			{
<span class="nc" id="L257">				throw new ParseException(&quot;Too many parameters&quot;);</span>
			}

<span class="fc" id="L260">			int numToKeep = 0;</span>
<span class="fc" id="L261">			int[] keep = null;</span>
<span class="fc" id="L262">			int reroll = 0;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">			while (curNumberOfParameters &gt; 2)</span>
			{
<span class="fc" id="L265">				final Object param = stack.pop();</span>
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">				if ((param instanceof Top.TopRolls) &amp;&amp; (numToKeep == 0))</span>
				{
<span class="fc" id="L268">					numToKeep = ((Top.TopRolls) param).getRolls();</span>
				}
<span class="pc bpc" id="L270" title="2 of 4 branches missed.">				else if ((param instanceof Reroll.Rerolls) &amp;&amp; (reroll == 0))</span>
				{
<span class="fc" id="L272">					reroll = ((Reroll.Rerolls) param).getRolls();</span>
				}
<span class="nc bnc" id="L274" title="All 4 branches missed.">				else if ((param instanceof final Vector vec) &amp;&amp; (curNumberOfParameters == 3))</span>
				{
<span class="nc bnc" id="L276" title="All 2 branches missed.">					if (numToKeep != 0)</span>
					{
<span class="nc" id="L278">						throw new ParseException(&quot;Redundant Arugments&quot;);</span>
					}
<span class="nc bnc" id="L280" title="All 2 branches missed.">					if (reroll != 0)</span>
					{
<span class="nc" id="L282">						throw new ParseException(</span>
							&quot;Reroll not compatable with &quot; + &quot;older syntax, use top(NUMBER) instead&quot;);
					}
<span class="nc" id="L285">					keep = new int[vec.size()];</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">					for (int x = 0; x &lt; vec.size(); x++)</span>
					{
<span class="nc" id="L288">						keep[x] = ((int) Math.round((Double) vec.get(x))) - 1;</span>
					}
				}
				else
				{
<span class="nc" id="L293">					throw new ParseException(&quot;Invalid parameter type&quot;);</span>
				}
<span class="fc" id="L295">				curNumberOfParameters--;</span>
<span class="fc" id="L296">			}</span>

			// get the parameter from the stack
<span class="fc" id="L299">			Object faces = stack.pop();</span>
<span class="fc" id="L300">			final Object numberOfRolls = stack.pop();</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">			if (faces instanceof Vector)</span>
			{
<span class="nc" id="L303">				final java.util.List vec = (java.util.List) faces;</span>
<span class="nc" id="L304">				faces = vec.get(RandomUtil.getRandomInt(vec.size()));</span>
			}
			// check whether the argument is of the right type
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">			if ((faces instanceof Double) &amp;&amp; (numberOfRolls instanceof Double))</span>
			{
				// calculate the result
				//Integer.MAX_VALUE
<span class="fc" id="L311">				final double dRolls = (Double) numberOfRolls;</span>
<span class="fc" id="L312">				final double dFaces = (Double) faces;</span>
<span class="pc bpc" id="L313" title="2 of 4 branches missed.">				if ((dRolls &gt; Integer.MAX_VALUE) || (dFaces &gt; Integer.MAX_VALUE))</span>
				{
<span class="nc" id="L315">					throw new ParseException(&quot;Values greater than &quot; + Integer.MAX_VALUE + &quot; not allowed.&quot;);</span>
				}
<span class="fc" id="L317">				int iRolls = (int) Math.round((Double) numberOfRolls);</span>
<span class="fc" id="L318">				int iFaces = (int) Math.round((Double) faces);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">				if (numToKeep == 0)</span>
				{
<span class="fc" id="L321">					numToKeep = iRolls;</span>
				}
				double result;
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">				if (keep == null)</span>
				{
<span class="fc" id="L326">					result = roll(iRolls, iFaces, numToKeep, reroll);</span>
				}
				else
				{
<span class="nc" id="L330">					result = roll(iRolls, iFaces, keep);</span>
				}
				// push the result on the inStack
<span class="fc" id="L333">				stack.push(result);</span>
<span class="fc" id="L334">			}</span>
			else
			{
<span class="nc" id="L337">				throw new ParseException(&quot;Invalid parameter type&quot;);</span>
			}
<span class="fc" id="L339">		}</span>

	}

	private static final class Top extends PostfixMathCommand
	{

		private Top()
<span class="fc" id="L347">		{</span>
<span class="fc" id="L348">			numberOfParameters = 1;</span>
<span class="fc" id="L349">		}</span>

		@Override
		public void run(final Stack stack) throws ParseException
		{
<span class="fc" id="L354">			final Object param = stack.pop();</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">			if (param instanceof Double)</span>
			{
<span class="fc" id="L357">				final double dRolls = (Double) param;</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">				if (dRolls &gt; Integer.MAX_VALUE)</span>
				{
<span class="nc" id="L360">					throw new ParseException(&quot;Values greater than &quot; + Integer.MAX_VALUE + &quot; not allowed.&quot;);</span>
				}
<span class="fc" id="L362">				final int iRolls = (int) Math.round(dRolls);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">				if (iRolls &gt; 0)</span>
				{
<span class="fc" id="L365">					stack.push(new TopRolls(iRolls));</span>
				}
				else
				{
<span class="nc" id="L369">					throw new ParseException(&quot;Values less than 1 are not allowed&quot;);</span>
				}
<span class="fc" id="L371">			}</span>
			else
			{
<span class="nc" id="L374">				throw new ParseException(&quot;Invalid parameter type&quot;);</span>
			}
<span class="fc" id="L376">		}</span>

		static final class TopRolls
		{

			private final Integer rolls;

			private TopRolls(final Integer rolls)
<span class="fc" id="L384">			{</span>
<span class="fc" id="L385">				this.rolls = rolls;</span>
<span class="fc" id="L386">			}</span>

			public Integer getRolls()
			{
<span class="fc" id="L390">				return rolls;</span>
			}

		}
	}

	private static final class Reroll extends PostfixMathCommand
	{

		private Reroll()
<span class="fc" id="L400">		{</span>
<span class="fc" id="L401">			numberOfParameters = 1;</span>
<span class="fc" id="L402">		}</span>

		@Override
		public void run(final Stack stack) throws ParseException
		{
<span class="fc" id="L407">			final Object param = stack.pop();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">			if (param instanceof Double)</span>
			{
<span class="fc" id="L410">				final double dRolls = (Double) param;</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">				if (dRolls &gt; Integer.MAX_VALUE)</span>
				{
<span class="nc" id="L413">					throw new ParseException(&quot;Values greater than &quot; + Integer.MAX_VALUE + &quot; not allowed.&quot;);</span>
				}
<span class="fc" id="L415">				final int iRolls = (int) Math.round(dRolls);</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">				if (iRolls &gt; 0)</span>
				{
<span class="fc" id="L418">					stack.push(new Rerolls(iRolls));</span>
				}
				else
				{
<span class="nc" id="L422">					throw new ParseException(&quot;Values less than 1 are not allowed&quot;);</span>
				}
<span class="fc" id="L424">			}</span>
			else
			{
<span class="nc" id="L427">				throw new ParseException(&quot;Invalid parameter type&quot;);</span>
			}
<span class="fc" id="L429">		}</span>

		static final class Rerolls
		{

			private final Integer rolls;

			private Rerolls(final Integer rolls)
<span class="fc" id="L437">			{</span>
<span class="fc" id="L438">				this.rolls = rolls;</span>
<span class="fc" id="L439">			}</span>

			public Integer getRolls()
			{
<span class="fc" id="L443">				return rolls;</span>
			}

		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>