<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlayerCharacter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">PlayerCharacter.java</span></div><h1>PlayerCharacter.java</h1><pre class="source lang-java linenums">/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core;

import java.awt.Rectangle;
import java.math.BigDecimal;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;

import pcgen.base.formula.Formula;
import pcgen.base.formula.base.FormulaManager;
import pcgen.base.formula.inst.NEPFormula;
import pcgen.base.solver.SolverManager;
import pcgen.base.util.HashMapToList;
import pcgen.base.util.IdentityList;
import pcgen.cdom.base.AssociatedPrereqObject;
import pcgen.cdom.base.BonusContainer;
import pcgen.cdom.base.CDOMList;
import pcgen.cdom.base.CDOMListObject;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.CDOMObjectUtilities;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.Category;
import pcgen.cdom.base.ChooseDriver;
import pcgen.cdom.base.ChooseInformation;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.TransitionChoice;
import pcgen.cdom.content.AbilitySelection;
import pcgen.cdom.content.CNAbility;
import pcgen.cdom.content.CNAbilityFactory;
import pcgen.cdom.content.HitDie;
import pcgen.cdom.content.LevelCommandFactory;
import pcgen.cdom.content.Processor;
import pcgen.cdom.content.RollMethod;
import pcgen.cdom.enumeration.AssociationKey;
import pcgen.cdom.enumeration.AssociationListKey;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.enumeration.EquipmentLocation;
import pcgen.cdom.enumeration.FactKey;
import pcgen.cdom.enumeration.FormulaKey;
import pcgen.cdom.enumeration.Gender;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.MapKey;
import pcgen.cdom.enumeration.Nature;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.PCStringKey;
import pcgen.cdom.enumeration.Region;
import pcgen.cdom.enumeration.SkillCost;
import pcgen.cdom.enumeration.SkillFilter;
import pcgen.cdom.enumeration.SkillsOutputOrder;
import pcgen.cdom.enumeration.StringKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.enumeration.VariableKey;
import pcgen.cdom.facet.ActiveSpellsFacet;
import pcgen.cdom.facet.AddFacet;
import pcgen.cdom.facet.AddedBonusFacet;
import pcgen.cdom.facet.AddedTemplateFacet;
import pcgen.cdom.facet.AgeSetKitFacet;
import pcgen.cdom.facet.AppliedBonusFacet;
import pcgen.cdom.facet.AutoEquipmentFacet;
import pcgen.cdom.facet.AutoLanguageGrantedFacet;
import pcgen.cdom.facet.AvailableSpellFacet;
import pcgen.cdom.facet.BonusActiviationFacet;
import pcgen.cdom.facet.BonusChangeFacet;
import pcgen.cdom.facet.BonusSkillRankChangeFacet;
import pcgen.cdom.facet.CalcBonusFacet;
import pcgen.cdom.facet.CheckBonusFacet;
import pcgen.cdom.facet.ClassSpellListFacet;
import pcgen.cdom.facet.ConditionalAbilityFacet;
import pcgen.cdom.facet.ConditionallyGrantedAbilityFacet;
import pcgen.cdom.facet.ConditionallyGrantedAvailableSpellFacet;
import pcgen.cdom.facet.ConditionallyGrantedKnownSpellFacet;
import pcgen.cdom.facet.DeityWeaponProfFacet;
import pcgen.cdom.facet.DirectAbilityFacet;
import pcgen.cdom.facet.DomainSpellCountFacet;
import pcgen.cdom.facet.EquipSetFacet;
import pcgen.cdom.facet.EquipmentFacet;
import pcgen.cdom.facet.EquippedEquipmentFacet;
import pcgen.cdom.facet.FacetLibrary;
import pcgen.cdom.facet.GlobalModifierFacet;
import pcgen.cdom.facet.GrantedAbilityFacet;
import pcgen.cdom.facet.HitPointFacet;
import pcgen.cdom.facet.KitChoiceFacet;
import pcgen.cdom.facet.KitFacet;
import pcgen.cdom.facet.KnownSpellFacet;
import pcgen.cdom.facet.LevelInfoFacet;
import pcgen.cdom.facet.MasterFacet;
import pcgen.cdom.facet.NoteItemFacet;
import pcgen.cdom.facet.PlayerCharacterTrackingFacet;
import pcgen.cdom.facet.PrimaryWeaponFacet;
import pcgen.cdom.facet.RemoveFacet;
import pcgen.cdom.facet.SaveableBonusFacet;
import pcgen.cdom.facet.SavedAbilitiesFacet;
import pcgen.cdom.facet.ScopeFacet;
import pcgen.cdom.facet.SecondaryWeaponFacet;
import pcgen.cdom.facet.SkillCostFacet;
import pcgen.cdom.facet.SkillOutputOrderFacet;
import pcgen.cdom.facet.SkillPoolFacet;
import pcgen.cdom.facet.SkillRankFacet;
import pcgen.cdom.facet.SolverManagerFacet;
import pcgen.cdom.facet.SourcedEquipmentFacet;
import pcgen.cdom.facet.SpellBookFacet;
import pcgen.cdom.facet.SpellListFacet;
import pcgen.cdom.facet.SpellProhibitorFacet;
import pcgen.cdom.facet.SpellSupportFacet;
import pcgen.cdom.facet.StartingLanguageFacet;
import pcgen.cdom.facet.StatBonusFacet;
import pcgen.cdom.facet.StatCalcFacet;
import pcgen.cdom.facet.StatValueFacet;
import pcgen.cdom.facet.SubClassFacet;
import pcgen.cdom.facet.SubstitutionClassFacet;
import pcgen.cdom.facet.TargetTrackingFacet;
import pcgen.cdom.facet.TemplateFeatFacet;
import pcgen.cdom.facet.UserEquipmentFacet;
import pcgen.cdom.facet.VariableStoreFacet;
import pcgen.cdom.facet.XPTableFacet;
import pcgen.cdom.facet.analysis.AgeSetFacet;
import pcgen.cdom.facet.analysis.ChangeProfFacet;
import pcgen.cdom.facet.analysis.CharacterSpellResistanceFacet;
import pcgen.cdom.facet.analysis.FavoredClassFacet;
import pcgen.cdom.facet.analysis.FollowerLimitFacet;
import pcgen.cdom.facet.analysis.LegalDeityFacet;
import pcgen.cdom.facet.analysis.LevelFacet;
import pcgen.cdom.facet.analysis.LevelTableFacet;
import pcgen.cdom.facet.analysis.LoadFacet;
import pcgen.cdom.facet.analysis.MovementResultFacet;
import pcgen.cdom.facet.analysis.NonAbilityFacet;
import pcgen.cdom.facet.analysis.NonStatStatFacet;
import pcgen.cdom.facet.analysis.NonStatToStatFacet;
import pcgen.cdom.facet.analysis.QualifyFacet;
import pcgen.cdom.facet.analysis.ResultFacet;
import pcgen.cdom.facet.analysis.SpecialAbilityFacet;
import pcgen.cdom.facet.analysis.StatLockFacet;
import pcgen.cdom.facet.analysis.UnlockedStatFacet;
import pcgen.cdom.facet.analysis.VariableFacet;
import pcgen.cdom.facet.base.AbstractStorageFacet;
import pcgen.cdom.facet.fact.AllowDebtFacet;
import pcgen.cdom.facet.fact.ChronicleEntryFacet;
import pcgen.cdom.facet.fact.FactFacet;
import pcgen.cdom.facet.fact.FollowerFacet;
import pcgen.cdom.facet.fact.GenderFacet;
import pcgen.cdom.facet.fact.IgnoreCostFacet;
import pcgen.cdom.facet.fact.PortraitThumbnailRectFacet;
import pcgen.cdom.facet.fact.PreviewSheetFacet;
import pcgen.cdom.facet.fact.RegionFacet;
import pcgen.cdom.facet.fact.SkillFilterFacet;
import pcgen.cdom.facet.fact.WeightFacet;
import pcgen.cdom.facet.fact.XPFacet;
import pcgen.cdom.facet.input.AddLanguageFacet;
import pcgen.cdom.facet.input.AutoEquipmentListFacet;
import pcgen.cdom.facet.input.AutoLanguageListFacet;
import pcgen.cdom.facet.input.AutoListArmorProfFacet;
import pcgen.cdom.facet.input.AutoListShieldProfFacet;
import pcgen.cdom.facet.input.AutoListWeaponProfFacet;
import pcgen.cdom.facet.input.BonusWeaponProfFacet;
import pcgen.cdom.facet.input.CampaignFacet;
import pcgen.cdom.facet.input.DomainInputFacet;
import pcgen.cdom.facet.input.GlobalAddedSkillCostFacet;
import pcgen.cdom.facet.input.LocalAddedSkillCostFacet;
import pcgen.cdom.facet.input.MonsterCSkillFacet;
import pcgen.cdom.facet.input.ProhibitedSchoolFacet;
import pcgen.cdom.facet.input.RaceInputFacet;
import pcgen.cdom.facet.input.TemplateInputFacet;
import pcgen.cdom.facet.input.UserSpecialAbilityFacet;
import pcgen.cdom.facet.model.ArmorProfProviderFacet;
import pcgen.cdom.facet.model.BioSetFacet;
import pcgen.cdom.facet.model.CheckFacet;
import pcgen.cdom.facet.model.ClassFacet;
import pcgen.cdom.facet.model.CompanionModFacet;
import pcgen.cdom.facet.model.DomainFacet;
import pcgen.cdom.facet.model.ExpandedCampaignFacet;
import pcgen.cdom.facet.model.LanguageFacet;
import pcgen.cdom.facet.model.RaceFacet;
import pcgen.cdom.facet.model.ShieldProfProviderFacet;
import pcgen.cdom.facet.model.SizeFacet;
import pcgen.cdom.facet.model.SkillFacet;
import pcgen.cdom.facet.model.StatFacet;
import pcgen.cdom.facet.model.TemplateFacet;
import pcgen.cdom.facet.model.WeaponProfModelFacet;
import pcgen.cdom.formula.MonitorableVariableStore;
import pcgen.cdom.helper.CNAbilitySelection;
import pcgen.cdom.helper.ClassSource;
import pcgen.cdom.helper.ProfProvider;
import pcgen.cdom.helper.SAProcessor;
import pcgen.cdom.helper.SAtoStringProcessor;
import pcgen.cdom.helper.SpringHelper;
import pcgen.cdom.identifier.SpellSchool;
import pcgen.cdom.inst.CodeControl;
import pcgen.cdom.inst.EquipmentHead;
import pcgen.cdom.inst.GlobalModifiers;
import pcgen.cdom.inst.ObjectCache;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.cdom.list.AbilityList;
import pcgen.cdom.list.ClassSpellList;
import pcgen.cdom.list.CompanionList;
import pcgen.cdom.list.DomainSpellList;
import pcgen.cdom.reference.CDOMGroupRef;
import pcgen.cdom.reference.CDOMSingleRef;
import pcgen.cdom.util.CControl;
import pcgen.cdom.util.ControlUtilities;
import pcgen.core.BonusManager.TempBonusInfo;
import pcgen.core.analysis.BonusCalc;
import pcgen.core.analysis.ChooseActivation;
import pcgen.core.analysis.DomainApplication;
import pcgen.core.analysis.RaceUtilities;
import pcgen.core.analysis.SkillModifier;
import pcgen.core.analysis.SkillRankControl;
import pcgen.core.analysis.SpellCountCalc;
import pcgen.core.analysis.SpellLevel;
import pcgen.core.analysis.StatAnalysis;
import pcgen.core.bonus.BonusObj;
import pcgen.core.bonus.BonusPair;
import pcgen.core.bonus.BonusUtilities;
import pcgen.core.character.CharacterSpell;
import pcgen.core.character.CompanionMod;
import pcgen.core.character.EquipSet;
import pcgen.core.character.EquipSlot;
import pcgen.core.character.Follower;
import pcgen.core.character.SpellBook;
import pcgen.core.character.SpellInfo;
import pcgen.core.chooser.ChoiceManagerList;
import pcgen.core.chooser.ChooserUtilities;
import pcgen.core.display.CharacterDisplay;
import pcgen.core.display.SkillDisplay;
import pcgen.core.pclevelinfo.PCLevelInfo;
import pcgen.core.spell.Spell;
import pcgen.core.utils.CoreUtility;
import pcgen.core.utils.MessageType;
import pcgen.core.utils.ShowMessageDelegate;
import pcgen.io.exporttoken.EqToken;
import pcgen.output.channel.ChannelUtilities;
import pcgen.output.channel.compat.AlignmentCompat;
import pcgen.persistence.lst.GlobalModifierLoader;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.rules.context.LoadContext;
import pcgen.rules.context.VariableContext;
import pcgen.system.PCGenSettings;
import pcgen.util.Delta;
import pcgen.util.Logging;
import pcgen.util.enumeration.AttackType;
import pcgen.util.enumeration.Load;

import org.jetbrains.annotations.TestOnly;

public class PlayerCharacter implements Cloneable, VariableContainer
{

	// Constants for use in getBonus
	private static String lastVariable;
	// This marker is static so that the spells allocated to it can also be found in the cloned character.
<span class="fc" id="L277">	private static final CDOMObject GRANTED_SPELL_CACHE = new ObjectCache();</span>

	private final CharID id;
	private final SAtoStringProcessor SA_TO_STRING_PROC;
	private final SAProcessor SA_PROC;
	private final CharacterDisplay display;

	/*
	 * Note &quot;pure&quot; here means no getDirty call, and absolutely no other stuff in
	 * the method. Also any method is not used elsewhere in PlayerCharacter
	 */
	//The following facets are write-only isolated (dirty in a set is allowed)
<span class="pc" id="L289">	private final AllowDebtFacet allowDebtFacet = FacetLibrary.getFacet(AllowDebtFacet.class);</span>
<span class="pc" id="L290">	private final ChronicleEntryFacet chronicleEntryFacet = FacetLibrary.getFacet(ChronicleEntryFacet.class);</span>
<span class="pc" id="L291">	private final IgnoreCostFacet ignoreCostFacet = FacetLibrary.getFacet(IgnoreCostFacet.class);</span>
<span class="pc" id="L292">	private final GenderFacet genderFacet = FacetLibrary.getFacet(GenderFacet.class);</span>
<span class="pc" id="L293">	private final WeightFacet weightFacet = FacetLibrary.getFacet(WeightFacet.class);</span>
<span class="pc" id="L294">	private final AddLanguageFacet addLangFacet = FacetLibrary.getFacet(AddLanguageFacet.class);</span>
<span class="pc" id="L295">	private final AutoLanguageListFacet autoLangListFacet = FacetLibrary.getFacet(AutoLanguageListFacet.class);</span>
<span class="pc" id="L296">	private final AutoListArmorProfFacet armorProfListFacet = FacetLibrary.getFacet(AutoListArmorProfFacet.class);</span>
<span class="pc" id="L297">	private final AutoListShieldProfFacet shieldProfListFacet = FacetLibrary.getFacet(AutoListShieldProfFacet.class);</span>
<span class="pc" id="L298">	private final AutoListWeaponProfFacet alWeaponProfFacet = FacetLibrary.getFacet(AutoListWeaponProfFacet.class);</span>
<span class="pc" id="L299">	private final RegionFacet regionFacet = FacetLibrary.getFacet(RegionFacet.class);</span>
<span class="pc" id="L300">	private final NoteItemFacet noteItemFacet = FacetLibrary.getFacet(NoteItemFacet.class);</span>
<span class="pc" id="L301">	private final GlobalAddedSkillCostFacet globalAddedSkillCostFacet =</span>
<span class="pc" id="L302">			FacetLibrary.getFacet(GlobalAddedSkillCostFacet.class);</span>
<span class="pc" id="L303">	private final LocalAddedSkillCostFacet localAddedSkillCostFacet =</span>
<span class="pc" id="L304">			FacetLibrary.getFacet(LocalAddedSkillCostFacet.class);</span>
<span class="pc" id="L305">	private final PreviewSheetFacet previewSheetFacet = FacetLibrary.getFacet(PreviewSheetFacet.class);</span>
<span class="pc" id="L306">	private final SkillFilterFacet skillFilterFacet = FacetLibrary.getFacet(SkillFilterFacet.class);</span>

	//The following facets are pure delegation (no exceptions) - could be considered &quot;complete&quot;
<span class="pc" id="L309">	private final AddedTemplateFacet addedTemplateFacet = FacetLibrary.getFacet(AddedTemplateFacet.class);</span>
<span class="pc" id="L310">	private final BonusWeaponProfFacet wpBonusFacet = FacetLibrary.getFacet(BonusWeaponProfFacet.class);</span>
<span class="pc" id="L311">	private final ClassSpellListFacet classSpellListFacet = FacetLibrary.getFacet(ClassSpellListFacet.class);</span>
<span class="pc" id="L312">	private final DomainSpellCountFacet domainSpellCountFacet = FacetLibrary.getFacet(DomainSpellCountFacet.class);</span>
<span class="pc" id="L313">	private final LegalDeityFacet legalDeityFacet = FacetLibrary.getFacet(LegalDeityFacet.class);</span>
<span class="pc" id="L314">	private final MonsterCSkillFacet monCSkillFacet = FacetLibrary.getFacet(MonsterCSkillFacet.class);</span>
<span class="pc" id="L315">	private final NonAbilityFacet nonAbilityFacet = FacetLibrary.getFacet(NonAbilityFacet.class);</span>
<span class="pc" id="L316">	private final QualifyFacet qualifyFacet = FacetLibrary.getFacet(QualifyFacet.class);</span>
<span class="pc" id="L317">	private final SkillOutputOrderFacet skillOutputOrderFacet = FacetLibrary.getFacet(SkillOutputOrderFacet.class);</span>
<span class="pc" id="L318">	private final SkillPoolFacet skillPoolFacet = FacetLibrary.getFacet(SkillPoolFacet.class);</span>
<span class="pc" id="L319">	private final SkillRankFacet skillRankFacet = FacetLibrary.getFacet(SkillRankFacet.class);</span>
<span class="pc" id="L320">	private final StartingLanguageFacet startingLangFacet = FacetLibrary.getFacet(StartingLanguageFacet.class);</span>
<span class="pc" id="L321">	private final StatCalcFacet statCalcFacet = FacetLibrary.getFacet(StatCalcFacet.class);</span>
<span class="pc" id="L322">	private final StatLockFacet statLockFacet = FacetLibrary.getFacet(StatLockFacet.class);</span>
<span class="pc" id="L323">	private final StatValueFacet statValueFacet = FacetLibrary.getFacet(StatValueFacet.class);</span>
<span class="pc" id="L324">	private final SubClassFacet subClassFacet = FacetLibrary.getFacet(SubClassFacet.class);</span>
<span class="pc" id="L325">	private final SubstitutionClassFacet substitutionClassFacet = FacetLibrary.getFacet(SubstitutionClassFacet.class);</span>
<span class="pc" id="L326">	private final UnlockedStatFacet unlockedStatFacet = FacetLibrary.getFacet(UnlockedStatFacet.class);</span>
<span class="pc" id="L327">	private final NonStatStatFacet nonStatStatFacet = FacetLibrary.getFacet(NonStatStatFacet.class);</span>
<span class="pc" id="L328">	private final NonStatToStatFacet nonStatToStatFacet = FacetLibrary.getFacet(NonStatToStatFacet.class);</span>
<span class="pc" id="L329">	private final TemplateFeatFacet templateFeatFacet = FacetLibrary.getFacet(TemplateFeatFacet.class);</span>
<span class="pc" id="L330">	private final SavedAbilitiesFacet svAbilityFacet = FacetLibrary.getFacet(SavedAbilitiesFacet.class);</span>

	/*
	 * Note &quot;minimal&quot; here means getDirty is allowed on a set, it may be used in
	 * clone(), but no other calls are made in any methods. Also any delegation
	 * method is not used elsewhere in PlayerCharacter except clone() or an
	 * otherwise pure delegation method. Also allowed is pure binary connections
	 * between two facets in a get (A &amp;&amp; B)
	 */
	//The following facets are &quot;minimal&quot; delegation
<span class="pc" id="L340">	private final XPFacet xpFacet = FacetLibrary.getFacet(XPFacet.class);</span>
<span class="pc" id="L341">	private final XPTableFacet xpTableFacet = FacetLibrary.getFacet(XPTableFacet.class);</span>

	//The following are model facets that are only set or getCDOMObjectList or getBonusContainer (nearly isolated)
<span class="pc" id="L344">	private final CheckFacet checkFacet = FacetLibrary.getFacet(CheckFacet.class);</span>
<span class="pc" id="L345">	private final CompanionModFacet companionModFacet = FacetLibrary.getFacet(CompanionModFacet.class);</span>
<span class="pc" id="L346">	private final CampaignFacet campaignFacet = FacetLibrary.getFacet(CampaignFacet.class);</span>
<span class="pc" id="L347">	private final ExpandedCampaignFacet expandedCampaignFacet = FacetLibrary.getFacet(ExpandedCampaignFacet.class);</span>
<span class="pc" id="L348">	private final AgeSetFacet ageSetFacet = FacetLibrary.getFacet(AgeSetFacet.class);</span>

	//The following are other facets
<span class="pc" id="L351">	private final DomainFacet domainFacet = FacetLibrary.getFacet(DomainFacet.class);</span>
<span class="pc" id="L352">	private final DomainInputFacet domainInputFacet = FacetLibrary.getFacet(DomainInputFacet.class);</span>
<span class="pc" id="L353">	private final TemplateFacet templateFacet = FacetLibrary.getFacet(TemplateFacet.class);</span>
<span class="pc" id="L354">	private final TemplateInputFacet templateInputFacet = FacetLibrary.getFacet(TemplateInputFacet.class);</span>
<span class="pc" id="L355">	private final RaceFacet raceFacet = FacetLibrary.getFacet(RaceFacet.class);</span>
<span class="pc" id="L356">	private final RaceInputFacet raceInputFacet = FacetLibrary.getFacet(RaceInputFacet.class);</span>
<span class="pc" id="L357">	private final StatFacet statFacet = FacetLibrary.getFacet(StatFacet.class);</span>
<span class="pc" id="L358">	private final StatBonusFacet statBonusFacet = FacetLibrary.getFacet(StatBonusFacet.class);</span>
<span class="pc" id="L359">	private final CheckBonusFacet checkBonusFacet = FacetLibrary.getFacet(CheckBonusFacet.class);</span>
<span class="pc" id="L360">	private final SkillFacet skillFacet = FacetLibrary.getFacet(SkillFacet.class);</span>
<span class="pc" id="L361">	private final ClassFacet classFacet = FacetLibrary.getFacet(ClassFacet.class);</span>
<span class="pc" id="L362">	private final BioSetFacet bioSetFacet = FacetLibrary.getFacet(BioSetFacet.class);</span>
<span class="pc" id="L363">	private final UserEquipmentFacet userEquipmentFacet = FacetLibrary.getFacet(UserEquipmentFacet.class);</span>
<span class="pc" id="L364">	private final EquipmentFacet equipmentFacet = FacetLibrary.getFacet(EquipmentFacet.class);</span>
<span class="pc" id="L365">	private final EquippedEquipmentFacet equippedFacet = FacetLibrary.getFacet(EquippedEquipmentFacet.class);</span>
<span class="pc" id="L366">	private final SourcedEquipmentFacet activeEquipmentFacet = FacetLibrary.getFacet(SourcedEquipmentFacet.class);</span>
<span class="pc" id="L367">	private final ConditionallyGrantedAbilityFacet cabFacet =</span>
<span class="pc" id="L368">			FacetLibrary.getFacet(ConditionallyGrantedAbilityFacet.class);</span>
<span class="pc" id="L369">	private final ConditionallyGrantedKnownSpellFacet cKnSpellFacet =</span>
<span class="pc" id="L370">			FacetLibrary.getFacet(ConditionallyGrantedKnownSpellFacet.class);</span>
<span class="pc" id="L371">	private final ConditionallyGrantedAvailableSpellFacet cAvSpellFacet =</span>
<span class="pc" id="L372">			FacetLibrary.getFacet(ConditionallyGrantedAvailableSpellFacet.class);</span>
<span class="pc" id="L373">	private final ConditionalAbilityFacet conditionalFacet = FacetLibrary.getFacet(ConditionalAbilityFacet.class);</span>
<span class="pc" id="L374">	private final GrantedAbilityFacet grantedAbilityFacet = FacetLibrary.getFacet(GrantedAbilityFacet.class);</span>
<span class="pc" id="L375">	private final DirectAbilityFacet directAbilityFacet = FacetLibrary.getFacet(DirectAbilityFacet.class);</span>
<span class="pc" id="L376">	private final KitFacet kitFacet = FacetLibrary.getFacet(KitFacet.class);</span>
<span class="pc" id="L377">	private final ArmorProfProviderFacet armorProfFacet = FacetLibrary.getFacet(ArmorProfProviderFacet.class);</span>
<span class="pc" id="L378">	private final ShieldProfProviderFacet shieldProfFacet = FacetLibrary.getFacet(ShieldProfProviderFacet.class);</span>
<span class="pc" id="L379">	private final CharacterSpellResistanceFacet srFacet = FacetLibrary.getFacet(CharacterSpellResistanceFacet.class);</span>
<span class="pc" id="L380">	private final WeaponProfModelFacet weaponProfFacet = FacetLibrary.getFacet(WeaponProfModelFacet.class);</span>
<span class="pc" id="L381">	private final MasterFacet masterFacet = FacetLibrary.getFacet(MasterFacet.class);</span>
<span class="pc" id="L382">	private final AutoEquipmentListFacet autoListEquipmentFacet = FacetLibrary.getFacet(AutoEquipmentListFacet.class);</span>
<span class="pc" id="L383">	private final FollowerFacet followerFacet = FacetLibrary.getFacet(FollowerFacet.class);</span>

<span class="pc" id="L385">	private final LanguageFacet languageFacet = FacetLibrary.getFacet(LanguageFacet.class);</span>
<span class="pc" id="L386">	private final UserSpecialAbilityFacet userSpecialAbilityFacet =</span>
<span class="pc" id="L387">			FacetLibrary.getFacet(UserSpecialAbilityFacet.class);</span>
<span class="pc" id="L388">	private final SpecialAbilityFacet specialAbilityFacet = FacetLibrary.getFacet(SpecialAbilityFacet.class);</span>
<span class="pc" id="L389">	private final PrimaryWeaponFacet primaryWeaponFacet = FacetLibrary.getFacet(PrimaryWeaponFacet.class);</span>
<span class="pc" id="L390">	private final SecondaryWeaponFacet secondaryWeaponFacet = FacetLibrary.getFacet(SecondaryWeaponFacet.class);</span>

<span class="pc" id="L392">	private final AutoLanguageGrantedFacet condLangFacet = FacetLibrary.getFacet(AutoLanguageGrantedFacet.class);</span>

<span class="pc" id="L394">	private final SkillCostFacet skillCostFacet = FacetLibrary.getFacet(SkillCostFacet.class);</span>
<span class="pc" id="L395">	private final ProhibitedSchoolFacet prohibitedSchoolFacet = FacetLibrary.getFacet(ProhibitedSchoolFacet.class);</span>
<span class="pc" id="L396">	private final SpellProhibitorFacet spellProhibitorFacet = FacetLibrary.getFacet(SpellProhibitorFacet.class);</span>

<span class="pc" id="L398">	private ObjectCache cache = new ObjectCache();</span>
<span class="pc" id="L399">	private AssociationSupport assocSupt = new AssociationSupport();</span>
<span class="pc" id="L400">	private BonusManager bonusManager = new BonusManager(this);</span>
<span class="pc" id="L401">	private final BonusChangeFacet bonusChangeFacet = FacetLibrary.getFacet(BonusChangeFacet.class);</span>
<span class="pc" id="L402">	private final EquipSetFacet equipSetFacet = FacetLibrary.getFacet(EquipSetFacet.class);</span>

<span class="pc" id="L404">	private final HitPointFacet hitPointFacet = FacetLibrary.getFacet(HitPointFacet.class);</span>
<span class="pc" id="L405">	private final KnownSpellFacet knownSpellFacet = FacetLibrary.getFacet(KnownSpellFacet.class);</span>

<span class="pc" id="L407">	private final LevelFacet levelFacet = FacetLibrary.getFacet(LevelFacet.class);</span>
<span class="pc" id="L408">	private final LevelTableFacet levelTableFacet = FacetLibrary.getFacet(LevelTableFacet.class);</span>
<span class="pc" id="L409">	private final SizeFacet sizeFacet = FacetLibrary.getFacet(SizeFacet.class);</span>
<span class="pc" id="L410">	private final FactFacet factFacet = FacetLibrary.getFacet(FactFacet.class);</span>
<span class="pc" id="L411">	private final FavoredClassFacet favClassFacet = FacetLibrary.getFacet(FavoredClassFacet.class);</span>
<span class="pc" id="L412">	private final VariableFacet variableFacet = FacetLibrary.getFacet(VariableFacet.class);</span>
<span class="pc" id="L413">	private final FollowerLimitFacet followerLimitFacet = FacetLibrary.getFacet(FollowerLimitFacet.class);</span>
<span class="pc" id="L414">	private final AvailableSpellFacet availSpellFacet = FacetLibrary.getFacet(AvailableSpellFacet.class);</span>
<span class="pc" id="L415">	private final MovementResultFacet moveResultFacet = FacetLibrary.getFacet(MovementResultFacet.class);</span>
<span class="pc" id="L416">	private final AutoEquipmentFacet autoEquipFacet = FacetLibrary.getFacet(AutoEquipmentFacet.class);</span>
<span class="pc" id="L417">	private final SpellBookFacet spellBookFacet = FacetLibrary.getFacet(SpellBookFacet.class);</span>
<span class="pc" id="L418">	private final LoadFacet loadFacet = FacetLibrary.getFacet(LoadFacet.class);</span>
<span class="pc" id="L419">	private final AppliedBonusFacet appliedBonusFacet = FacetLibrary.getFacet(AppliedBonusFacet.class);</span>
<span class="pc" id="L420">	private final AddedBonusFacet addedBonusFacet = FacetLibrary.getFacet(AddedBonusFacet.class);</span>
<span class="pc" id="L421">	private final SaveableBonusFacet saveableBonusFacet = FacetLibrary.getFacet(SaveableBonusFacet.class);</span>
<span class="pc" id="L422">	private final SpellSupportFacet spellSupportFacet = FacetLibrary.getFacet(SpellSupportFacet.class);</span>
<span class="pc" id="L423">	private final ActiveSpellsFacet activeSpellsFacet = FacetLibrary.getFacet(ActiveSpellsFacet.class);</span>
<span class="pc" id="L424">	private final SpellListFacet spellListFacet = FacetLibrary.getFacet(SpellListFacet.class);</span>
<span class="pc" id="L425">	private final ChangeProfFacet changeProfFacet = FacetLibrary.getFacet(ChangeProfFacet.class);</span>
<span class="pc" id="L426">	private final TargetTrackingFacet astocnasFacet = FacetLibrary.getFacet(TargetTrackingFacet.class);</span>

<span class="pc" id="L428">	private final PortraitThumbnailRectFacet portraitThumbnailRectFacet =</span>
<span class="pc" id="L429">			FacetLibrary.getFacet(PortraitThumbnailRectFacet.class);</span>
<span class="pc" id="L430">	private final BonusSkillRankChangeFacet bonusSkillRankChangeFacet =</span>
<span class="pc" id="L431">			FacetLibrary.getFacet(BonusSkillRankChangeFacet.class);</span>

<span class="pc" id="L433">	private final LevelInfoFacet levelInfoFacet = FacetLibrary.getFacet(LevelInfoFacet.class);</span>
<span class="pc" id="L434">	private final SolverManagerFacet solverManagerFacet = FacetLibrary.getFacet(SolverManagerFacet.class);</span>

<span class="pc" id="L436">	private final ResultFacet resultFacet = FacetLibrary.getFacet(ResultFacet.class);</span>

<span class="pc" id="L438">	private final ScopeFacet scopeFacet = FacetLibrary.getFacet(ScopeFacet.class);</span>
<span class="pc" id="L439">	private final VariableStoreFacet variableStoreFacet = FacetLibrary.getFacet(VariableStoreFacet.class);</span>

	private ClassSource defaultDomainSource;

<span class="pc" id="L443">	private final Map&lt;String, Integer&gt; autoEquipOutputOrderCache = new HashMap&lt;&gt;();</span>

	// Temporary Bonuses
<span class="pc" id="L446">	private final List&lt;Equipment&gt; tempBonusItemList = new ArrayList&lt;&gt;();</span>

<span class="pc" id="L448">	private String calcEquipSetId = EquipSet.DEFAULT_SET_PATH;</span>

	// whether to add auto known spells each level
<span class="pc" id="L451">	private boolean autoKnownSpells = true;</span>

	// whether higher level spell slots should be used for lower levels
<span class="pc" id="L454">	private boolean useHigherKnownSlots = SettingsHandler.isUseHigherLevelSlotsDefault();</span>
<span class="pc" id="L455">	private boolean useHigherPreppedSlots = SettingsHandler.isUseHigherLevelSlotsDefault();</span>

	// should we also load companions on master load?
<span class="pc" id="L458">	private boolean autoLoadCompanion = false;</span>

	// Should we resize the gear automatically?
<span class="pc" id="L461">	private boolean autoResize = PCGenSettings.getInstance().getBoolean(PCGenSettings.OPTION_AUTO_RESIZE_EQUIP, true);</span>

	// output sheet locations
<span class="pc" id="L464">	private String outputSheetHTML = Constants.EMPTY_STRING;</span>
<span class="pc" id="L465">	private String outputSheetPDF = Constants.EMPTY_STRING;</span>
<span class="pc" id="L466">	private boolean[] ageSetKitSelections = new boolean[Constants.NUMBER_OF_AGESET_KIT_SELECTIONS];</span>
<span class="pc" id="L467">	private boolean dirtyFlag = false;</span>
<span class="pc" id="L468">	private int serial = 0;</span>
<span class="pc" id="L469">	private boolean importing = false;</span>

	// Should temp mods/bonuses be used/saved?
<span class="pc" id="L472">	private boolean useTempMods = true;</span>

<span class="pc" id="L474">	private int costPool = 0;</span>
<span class="pc" id="L475">	private int currentEquipSetNumber = 0;</span>

	// pool of stats allowed to distribute
<span class="pc" id="L478">	private int poolAmount = 0;</span>

	// order in which the skills will be output.
<span class="pc" id="L481">	private SkillsOutputOrder skillsOutputOrder = SkillsOutputOrder.NAME_ASC;</span>

<span class="pc" id="L483">	private int spellLevelTemp = 0;</span>
	private final VariableProcessor variableProcessor;

	// used by point buy. Total number of points for method, not points
	// remaining
<span class="pc" id="L488">	private int pointBuyPoints = -1;</span>

<span class="pc" id="L490">	private boolean processLevelAbilities = true;</span>
<span class="pc" id="L491">	private boolean allowInteraction = true;</span>

	/**
	 * This map stores any user bonuses (entered through the GUI) to the
	 * corresponding ability pool.
	 */
	private Map&lt;Category&lt;Ability&gt;, BigDecimal&gt; theUserPoolBonuses;

	// /////////////////////////////////////
	// operations

<span class="pc" id="L502">	private final CNAbility bonusLanguageAbility =</span>
<span class="pc" id="L503">			CNAbilityFactory.getCNAbility(AbilityCategory.LANGBONUS, Nature.VIRTUAL, Globals.getContext()</span>
<span class="pc" id="L504">				.getReferenceContext().getManufacturerId(AbilityCategory.LANGBONUS).getActiveObject(&quot;*LANGBONUS&quot;));</span>
	private final CodeControl controller;
<span class="pc" id="L506">	private Map&lt;String, String&gt; previewSheetVars = new HashMap&lt;&gt;();</span>

	/**
	 * Constructor.
	 */
	public PlayerCharacter()
	{
<span class="fc" id="L513">		this(Collections.emptyList());</span>
<span class="fc" id="L514">	}</span>

	/**
	 * Constructor.
	 *
	 * @param from
	 */
	private PlayerCharacter(PlayerCharacter from)
<span class="nc" id="L522">	{</span>
<span class="nc" id="L523">		LoadContext context = Globals.getContext();</span>
<span class="nc" id="L524">		id = CharID.getID(context.getDataSetID());</span>

<span class="nc" id="L526">		display = new CharacterDisplay(id);</span>
<span class="nc" id="L527">		SA_TO_STRING_PROC = new SAtoStringProcessor(this);</span>
<span class="nc" id="L528">		SA_PROC = new SAProcessor(this);</span>
<span class="nc" id="L529">		PlayerCharacterTrackingFacet trackingFacet = FacetLibrary.getFacet(PlayerCharacterTrackingFacet.class);</span>
<span class="nc" id="L530">		trackingFacet.associatePlayerCharacter(id, this);</span>

<span class="nc" id="L532">		variableProcessor = new VariableProcessorPC(this);</span>
<span class="nc" id="L533">		controller = from.controller;</span>

<span class="nc" id="L535">		theUserPoolBonuses = new HashMap&lt;&gt;(from.theUserPoolBonuses);</span>
<span class="nc" id="L536">	}</span>

	/**
	 * Constructor.
	 *
	 * @param loadedCampaigns The currently loaded campaign objects.
	 */
	public PlayerCharacter(Collection&lt;Campaign&gt; loadedCampaigns)
<span class="fc" id="L544">	{</span>
<span class="fc" id="L545">		LoadContext context = Globals.getContext();</span>
<span class="fc" id="L546">		id = CharID.getID(context.getDataSetID());</span>
<span class="fc" id="L547">		AbstractReferenceContext refContext = context.getReferenceContext();</span>
<span class="fc" id="L548">		controller = refContext.constructNowIfNecessary(CodeControl.class, &quot;Controller&quot;);</span>
<span class="fc" id="L549">		doFormulaSetup(context);</span>

<span class="fc" id="L551">		display = new CharacterDisplay(id);</span>
<span class="fc" id="L552">		SA_TO_STRING_PROC = new SAtoStringProcessor(this);</span>
<span class="fc" id="L553">		SA_PROC = new SAProcessor(this);</span>
<span class="fc" id="L554">		PlayerCharacterTrackingFacet trackingFacet = FacetLibrary.getFacet(PlayerCharacterTrackingFacet.class);</span>
<span class="fc" id="L555">		trackingFacet.associatePlayerCharacter(id, this);</span>

<span class="fc" id="L557">		variableProcessor = new VariableProcessorPC(this);</span>

<span class="fc bfc" id="L559" title="All 2 branches covered.">		for (int i = 0; i &lt; Constants.NUMBER_OF_AGESET_KIT_SELECTIONS; i++)</span>
		{
<span class="fc" id="L561">			ageSetKitSelections[i] = false;</span>
		}
<span class="fc" id="L563">		GlobalModifiers gameMode =</span>
<span class="fc" id="L564">				refContext.constructNowIfNecessary(GlobalModifiers.class, GlobalModifierLoader.GLOBAL_MODIFIERS);</span>
<span class="fc" id="L565">		GlobalModifierFacet globalModifierFacet = FacetLibrary.getFacet(GlobalModifierFacet.class);</span>
<span class="fc" id="L566">		globalModifierFacet.set(id, gameMode);</span>

		//Do BioSet first, since required by Race
<span class="fc" id="L569">		bioSetFacet.set(id, SettingsHandler.getGameAsProperty().get().getBioSet());</span>
		//Set Race before Stat/Check due to Default object in Pathfinder/RSRD
<span class="fc" id="L571">		setRace(RaceUtilities.getUnselectedRace());</span>

<span class="fc" id="L573">		statFacet.addAll(id, refContext.getSortkeySortedCDOMObjects(PCStat.class));</span>
<span class="fc" id="L574">		checkFacet.addAll(id, refContext.getSortkeySortedCDOMObjects(PCCheck.class));</span>
<span class="fc" id="L575">		campaignFacet.addAll(id, loadedCampaigns);</span>

<span class="fc" id="L577">		setXPTable(SettingsHandler.getGameAsProperty().get().getDefaultXPTableName());</span>
<span class="fc" id="L578">		ChannelUtilities.setControlledChannel(id, CControl.CHARACTERTYPE,</span>
<span class="fc" id="L579">			SettingsHandler.getGameAsProperty().get()</span>
<span class="fc" id="L580">				.getDefaultCharacterType());</span>
<span class="fc" id="L581">		setPreviewSheet(SettingsHandler.getGameAsProperty().get().getDefaultPreviewSheet());</span>

<span class="fc" id="L583">		setName(Constants.EMPTY_STRING);</span>
<span class="fc" id="L584">		setUserPoolBonus(AbilityCategory.FEAT, BigDecimal.ZERO);</span>
<span class="fc" id="L585">		rollStats(SettingsHandler.getGameAsProperty().get().getRollMethod());</span>
<span class="fc" id="L586">		addSpellBook(new SpellBook(Globals.getDefaultSpellBook(), SpellBook.TYPE_KNOWN_SPELLS));</span>
<span class="fc" id="L587">		addSpellBook(new SpellBook(Constants.INNATE_SPELL_BOOK_NAME, SpellBook.TYPE_INNATE_SPELLS));</span>
<span class="fc" id="L588">	}</span>

	/**
	 * Set the Weapon proficiency of one piece of Equipment to the same as the
	 * Proficiency in another piece of Equipment.  For some bizarre reason, as
	 * well as setting the proficiency,  this zeros out the Weight and cost of
	 * the equipment.
	 *
	 * @param  equip  the Weapon to get the proficiency from
	 * @param  eqm    the weapon to set the proficiency in
	 */
	private static void setProf(final Equipment equip, final Equipment eqm)
	{
<span class="nc" id="L601">		eqm.put(ObjectKey.WEAPON_PROF, equip.get(ObjectKey.WEAPON_PROF));</span>
		// In case this is used somewhere it shouldn't be used,
		// set weight and cost to 0
<span class="nc" id="L604">		eqm.put(ObjectKey.WEIGHT, BigDecimal.ZERO);</span>
<span class="nc" id="L605">		eqm.put(ObjectKey.CURRENT_COST, BigDecimal.ZERO);</span>
<span class="nc" id="L606">	}</span>

	private void doFormulaSetup(LoadContext context)
	{
<span class="fc" id="L610">		VariableContext variableContext = context.getVariableContext();</span>
<span class="fc" id="L611">		FormulaManager formulaManager = variableContext.getPCFormulaManager();</span>
<span class="fc" id="L612">		MonitorableVariableStore varStore = new MonitorableVariableStore();</span>
<span class="fc" id="L613">		scopeFacet.set(id, formulaManager.getScopeInstanceFactory());</span>
<span class="fc" id="L614">		variableStoreFacet.set(id, varStore);</span>
<span class="fc" id="L615">		solverManagerFacet.set(id, variableContext.generateSolverManager(varStore));</span>
<span class="fc" id="L616">		ChannelUtilities.watchChannel(this, CControl.AGEINPUT, ageSetFacet);</span>
<span class="fc" id="L617">		ChannelUtilities.watchChannel(this, CControl.AGEINPUT, FacetLibrary.getFacet(AgeSetKitFacet.class));</span>
<span class="fc" id="L618">		ChannelUtilities.addListenerToChannel(this, CControl.AGEINPUT, x -&gt; {</span>
<span class="nc" id="L619">			setDirty(true);</span>
<span class="nc" id="L620">			calcActiveBonuses();</span>
<span class="nc" id="L621">		});</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">		if (isFeatureEnabled(CControl.ALIGNMENTFEATURE))</span>
		{
<span class="nc" id="L624">			ChannelUtilities.setDirtyOnChannelChange(this, CControl.ALIGNMENTINPUT);</span>
		}
<span class="fc" id="L626">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.CHARACTERTYPE);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">		if (isFeatureEnabled(CControl.DOMAINFEATURE))</span>
		{
<span class="fc" id="L629">			deityWatchSetup(context);</span>
		}
<span class="fc" id="L631">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.GOLDINPUT);</span>
<span class="fc" id="L632">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.HAIRSTYLEINPUT);</span>
<span class="fc" id="L633">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.HAIRCOLORINPUT);</span>
<span class="fc" id="L634">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.HANDEDINPUT);</span>
<span class="fc" id="L635">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.HEIGHTINPUT);</span>
<span class="fc" id="L636">		ChannelUtilities.setDirtyOnChannelChange(this, CControl.SKINCOLORINPUT);</span>
<span class="fc" id="L637">	}</span>

	private void deityWatchSetup(LoadContext context)
	{
<span class="fc" id="L641">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, activeSpellsFacet);</span>
<span class="fc" id="L642">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(AddFacet.class));</span>
<span class="fc" id="L643">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(DeityWeaponProfFacet.class));</span>
<span class="fc" id="L644">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(KitChoiceFacet.class));</span>
<span class="fc" id="L645">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(RemoveFacet.class));</span>
<span class="fc" id="L646">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(BonusActiviationFacet.class), 1000);</span>
<span class="fc" id="L647">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, FacetLibrary.getFacet(CalcBonusFacet.class), 5000);</span>
<span class="fc" id="L648">		ChannelUtilities.watchChannel(this, CControl.DEITYINPUT, moveResultFacet, 2000);</span>
<span class="fc" id="L649">	}</span>

	@Override
	public String toString()
	{
<span class="nc" id="L654">		return &quot;PlayerCharacter [name=&quot; + getName() + &quot; @ &quot; + getFileName() + &quot; serial=&quot; + serial + ']';</span>
	}

	public void setWeight(int value)
	{
<span class="nc" id="L659">		boolean didChange = weightFacet.set(id, value);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (didChange)</span>
		{
<span class="nc" id="L662">			setDirty(true);</span>
		}
<span class="nc" id="L664">	}</span>

	/**
	 * Sets player character information
	 *
	 * @param attr which attribute to set
	 * @param value the value to set it to
	 */
	public void setPCAttribute(PCStringKey attr, String value)
	{
<span class="nc" id="L674">		setStringFor(attr, value);</span>
<span class="nc" id="L675">	}</span>

	/**
	 * Set the current EquipSet that is used to Bonus/Equip calculations.
	 *
	 * @param eqSetId The equipSet to be used for Bonus Calculations and output
	 */
	public void setCalcEquipSetId(final String eqSetId)
	{
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (calcEquipSetId != eqSetId)</span>
		{
<span class="nc" id="L686">			calcEquipSetId = eqSetId;</span>
<span class="nc" id="L687">			EquipSet equipSet = getEquipSetByIdPath(eqSetId);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">			if (equipSet != null)</span>
			{
<span class="nc" id="L690">				setCurrentEquipSetName(equipSet.getName());</span>
			}
<span class="nc" id="L692">			setDirty(true);</span>
		}
<span class="nc" id="L694">	}</span>

	/**
	 * Get the id for the equipment set being used for calculation.
	 *
	 * @return id
	 */
	public String getCalcEquipSetId()
	{
<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (equipSetFacet.isEmpty(id))</span>
		{
<span class="nc" id="L705">			return calcEquipSetId;</span>
		}

<span class="nc bnc" id="L708" title="All 2 branches missed.">		if (getEquipSetByIdPath(calcEquipSetId) == null)</span>
		{
			// PC does not have that equipset ID
			// so we need to find one they do have
<span class="nc bnc" id="L712" title="All 2 branches missed.">			for (EquipSet eSet : equipSetFacet.getSet(id))</span>
			{
<span class="nc bnc" id="L714" title="All 2 branches missed.">				if (eSet.getParentIdPath().equals(Constants.EQUIP_SET_ROOT_ID))</span>
				{
<span class="nc" id="L716">					calcEquipSetId = eSet.getIdPath();</span>

<span class="nc" id="L718">					return calcEquipSetId;</span>
				}
<span class="nc" id="L720">			}</span>
		}

<span class="nc" id="L723">		return calcEquipSetId;</span>
	}

	/**
	 * Set's current equipmentList to selected output EquipSet then loops
	 * through all the equipment and sets the correct status of each (equipped,
	 * carried, etc).
	 */
	public void setCalcEquipmentList()
	{
<span class="nc" id="L733">		setCalcEquipmentList(false);</span>
<span class="nc" id="L734">	}</span>

	/**
	 * Set's current equipmentList to selected output EquipSet then loops
	 * through all the equipment and sets the correct status of each (equipped,
	 * carried, etc). Boolean parameter useTempBonuses controls whether or
	 * not the temporary bonuses associated with equipment are applied.
	 *
	 * @param useTempBonuses whether to apply Temporary bonuses from equipment.
	 */
	public void setCalcEquipmentList(final boolean useTempBonuses)
	{
		// First we get the EquipSet that is going to be used
		// to calculate everything from
<span class="nc" id="L748">		final String calcId = getCalcEquipSetId();</span>
<span class="nc" id="L749">		final EquipSet eSet = getEquipSetByIdPath(calcId);</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">		if (eSet == null)</span>
		{
<span class="nc bnc" id="L753" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L755">				Logging.debugPrint(&quot;No EquipSet has been selected for calculations yet.&quot;); //$NON-NLS-1$</span>
			}
<span class="nc" id="L757">			return;</span>
		}

		// set PC's equipmentList to new one
		/*
		 * TODO This &quot;global reset&quot; directly followed by testing in the
		 * EquipSets and re-adding items as local equipment is something that
		 * needs to be cleaned up
		 */
<span class="nc" id="L766">		equipmentFacet.removeAll(id);</span>

		// get all the PC's EquipSet's
<span class="nc" id="L769">		final List&lt;EquipSet&gt; pcEquipSetList = new ArrayList&lt;&gt;(getEquipSet());</span>

<span class="nc bnc" id="L771" title="All 2 branches missed.">		if (pcEquipSetList.isEmpty())</span>
		{
<span class="nc" id="L773">			equippedFacet.reset(id);</span>
<span class="nc" id="L774">			return;</span>
		}

		// make sure EquipSet's are in sorted order
		// (important for Containers contents)
<span class="nc" id="L779">		Collections.sort(pcEquipSetList);</span>

		// loop through all the EquipSet's and create equipment
		// then set status to equipped and add to PC's equipment list
<span class="nc bnc" id="L783" title="All 2 branches missed.">		for (EquipSet es : pcEquipSetList)</span>
		{
<span class="nc bnc" id="L785" title="All 4 branches missed.">			if (es.getItem() == null || !es.isPartOf(calcId))</span>
			{
<span class="nc" id="L787">				continue;</span>
			}

<span class="nc" id="L790">			es.equipItem(this);</span>
<span class="nc" id="L791">			es.addNoteToItem();</span>

<span class="nc" id="L793">			addLocalEquipment(es.getItem());</span>
<span class="nc" id="L794">		}</span>

		// loop through all equipment and make sure that
		// containers contents are updated
<span class="nc bnc" id="L798" title="All 2 branches missed.">		for (Equipment eq : getEquipmentSet())</span>
		{
<span class="nc bnc" id="L800" title="All 2 branches missed.">			if (eq.isContainer())</span>
			{
<span class="nc" id="L802">				eq.updateContainerContentsString(this);</span>
			}

			// also make sure the masterList output order is
			// preserved as this equipmentList is a modified
			// clone of the original
<span class="nc" id="L808">			final Equipment anEquip = getEquipmentNamed(eq.getName());</span>

<span class="nc bnc" id="L810" title="All 2 branches missed.">			if (anEquip != null)</span>
			{
<span class="nc" id="L812">				eq.setOutputIndex(anEquip.getOutputIndex());</span>
			}
<span class="nc" id="L814">		}</span>

		// if temporary bonuses, read the bonus equipList
<span class="nc bnc" id="L817" title="All 2 branches missed.">		if (useTempBonuses)</span>
		{
<span class="nc bnc" id="L819" title="All 2 branches missed.">			for (Equipment eq : tempBonusItemList)</span>
			{
				// make sure that this EquipSet is the one
				// this temporary bonus item comes from
				// to make sure we keep them together
<span class="nc" id="L824">				final Equipment anEquip = getEquipmentNamed(eq.getName(), getEquipmentSet());</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">				if (anEquip == null)</span>
				{
<span class="nc" id="L828">					continue;</span>
				}

<span class="nc" id="L831">				eq.setQty(anEquip.getQty());</span>
<span class="nc" id="L832">				eq.setNumberCarried(anEquip.getCarried());</span>

<span class="nc bnc" id="L834" title="All 2 branches missed.">				if (anEquip.isEquipped())</span>
				{
<span class="nc bnc" id="L836" title="All 2 branches missed.">					if (eq.isWeapon())</span>
					{
<span class="nc" id="L838">						eq.put(IntegerKey.SLOTS, 0);</span>
<span class="nc" id="L839">						eq.put(ObjectKey.CURRENT_COST, BigDecimal.ZERO);</span>
<span class="nc" id="L840">						eq.put(ObjectKey.WEIGHT, BigDecimal.ZERO);</span>
<span class="nc" id="L841">						eq.setLocation(anEquip.getLocation());</span>
					}
					else
					{
						// replace the orig item with the bonus item
<span class="nc" id="L846">						eq.setLocation(anEquip.getLocation());</span>
<span class="nc" id="L847">						removeLocalEquipment(anEquip);</span>
<span class="nc" id="L848">						anEquip.setIsEquipped(false, this);</span>
<span class="nc" id="L849">						anEquip.setLocation(EquipmentLocation.NOT_CARRIED);</span>
<span class="nc" id="L850">						anEquip.setNumberCarried(0.0f);</span>
					}

<span class="nc" id="L853">					eq.setIsEquipped(true, this);</span>
<span class="nc" id="L854">					eq.setNumberEquipped(1);</span>
				}
				else
				{
<span class="nc" id="L858">					eq.put(ObjectKey.CURRENT_COST, BigDecimal.ZERO);</span>
<span class="nc" id="L859">					eq.put(ObjectKey.WEIGHT, BigDecimal.ZERO);</span>
<span class="nc" id="L860">					eq.setLocation(EquipmentLocation.EQUIPPED_TEMPBONUS);</span>
<span class="nc" id="L861">					eq.setIsEquipped(false, this);</span>
				}

				// Adding this type to be correctly treated by Merge
<span class="nc" id="L865">				eq.addType(Type.TEMPORARY);</span>
<span class="nc" id="L866">				addLocalEquipment(eq);</span>
<span class="nc" id="L867">			}</span>
		}

		// all done!
<span class="nc" id="L871">		equippedFacet.reset(id);</span>
<span class="nc" id="L872">	}</span>

	/**
	 * Apply the bonus from a follower to the master pc.
	 */
	public void setCalcFollowerBonus()
	{
<span class="nc" id="L879">		setDirty(true);</span>

<span class="nc bnc" id="L881" title="All 2 branches missed.">		for (Follower aF : getFollowerList())</span>
		{
<span class="nc" id="L883">			final CompanionList cList = aF.getType();</span>
<span class="nc" id="L884">			final String rType = cList.getKeyName();</span>
<span class="nc" id="L885">			final Race fRace = aF.getRace();</span>

<span class="nc bnc" id="L887" title="All 2 branches missed.">			for (CompanionMod cm : Globals.getContext().getReferenceContext().getManufacturerId(cList).getAllObjects())</span>
			{
<span class="nc" id="L889">				final String aType = cm.getType();</span>
<span class="nc bnc" id="L890" title="All 4 branches missed.">				if (aType.equalsIgnoreCase(rType) &amp;&amp; cm.appliesToRace(fRace))</span>
				{
					// Found race and type of follower
					// so add bonus to the master
<span class="nc" id="L894">					companionModFacet.add(id, cm);</span>
				}
<span class="nc" id="L896">			}</span>
<span class="nc" id="L897">		}</span>
<span class="nc" id="L898">	}</span>

	/**
	 * Get a class, represented by a given key, from among those possessed by this pc.
	 *
	 * @param key the class's key
	 * @return PCClass
	 */
	public PCClass getClassKeyed(final String key)
	{
<span class="nc bnc" id="L908" title="All 2 branches missed.">		for (PCClass aClass : getClassSet())</span>
		{
<span class="nc bnc" id="L910" title="All 2 branches missed.">			if (aClass.getKeyName().equalsIgnoreCase(key))</span>
			{
<span class="nc" id="L912">				return aClass;</span>
			}
<span class="nc" id="L914">		}</span>

<span class="nc" id="L916">		return null;</span>
	}

	/**
	 * Get the class list.
	 *
	 * @return classList
	 */
	public List&lt;PCClass&gt; getClassList()
	{
		/*
		 * TODO This is a discussion we have to have about where items are sorted
		 */
<span class="nc" id="L929">		return new ArrayList&lt;&gt;(getClassSet());</span>
	}

	/**
	 * Gets the Set of PCClass objects for this Character.
	 * @return a set of PCClass objects
	 */
	public Set&lt;PCClass&gt; getClassSet()
	{
<span class="fc" id="L938">		return classFacet.getSet(id);</span>
	}

	/**
	 * Set the cost pool, which is the number of points the character has spent.
	 *
	 * @param i the number of points spent
	 */
	public void setCostPool(final int i)
	{
<span class="nc" id="L948">		costPool = i;</span>
<span class="nc" id="L949">	}</span>

	/**
	 * Get the cost pool, which is the number of points the character has spent.
	 *
	 * @return costPool
	 */
	public int getCostPool()
	{
<span class="nc" id="L958">		return costPool;</span>
	}

	/**
	 * Set the current equipment set name.
	 *
	 * @param aName the name of the new current equipment set
	 */
	public void setCurrentEquipSetName(final String aName)
	{
<span class="nc" id="L968">		setStringFor(PCStringKey.CURRENT_EQUIP_SET_NAME, aName);</span>
<span class="nc" id="L969">	}</span>

	/**
	 * Sets the character changed since last save.
	 * NB: This is not a 'safe' call - its use should be considered carefully and in
	 * particular it should not be called from a method used as part of PlayerCharacter
	 * cloning as this can mean conditional abilities get dropped when they are actually
	 * qualified for, just not at that point in the clone.
	 *
	 * @param dirtyState the new &quot;dirty&quot; value (may be false to indicate no change)
	 */
	public void setDirty(final boolean dirtyState)
	{
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">		if (dirtyState)</span>
		{
<span class="fc" id="L984">			serial++;</span>
<span class="fc" id="L985">			cache = new ObjectCache();</span>
<span class="fc" id="L986">			variableProcessor.setSerial(serial);</span>
<span class="fc" id="L987">			cabFacet.update(id);</span>
<span class="fc" id="L988">			cAvSpellFacet.update(id);</span>
<span class="fc" id="L989">			cKnSpellFacet.update(id);</span>
<span class="fc" id="L990">			condLangFacet.update(id);</span>
<span class="fc" id="L991">			bonusSkillRankChangeFacet.reset(id);</span>
		}

<span class="fc" id="L994">		dirtyFlag = dirtyState;</span>
<span class="fc" id="L995">	}</span>

	/**
	 * Gets whether the character has been changed since last saved.
	 *
	 * @return true if dirty
	 */
	public boolean isDirty()
	{
<span class="nc" id="L1004">		return dirtyFlag;</span>
	}

	/**
	 * Returns the serial for the instance - every time something changes the
	 * serial is incremented. Use to detect change in PlayerCharacter.
	 *
	 * @return serial
	 */
	public int getSerial()
	{
<span class="nc" id="L1015">		return serial;</span>
	}

	/**
	 * Get the list of equipment sets.
	 *
	 * @return List
	 */
	private Collection&lt;EquipSet&gt; getEquipSet()
	{
<span class="nc" id="L1025">		return equipSetFacet.getSet(id);</span>
	}

	/**
	 * Get the equipment set indexed by path.
	 *
	 * @param path the &quot;path&quot; of the equipSet to return
	 * @return EquipSet
	 */
	public EquipSet getEquipSetByIdPath(final String path)
	{
<span class="nc" id="L1036">		return equipSetFacet.getEquipSetByIdPath(id, path);</span>
	}

	/**
	 * Get the current equipment set number.
	 *
	 * @return equipSet number
	 */
	public int getEquipSetNumber()
	{
<span class="nc" id="L1046">		return currentEquipSetNumber;</span>
	}

	/**
	 * Get equipment set.
	 *
	 * @return equipment set
	 */
	private Set&lt;Equipment&gt; getEquipmentSet()
	{
<span class="nc" id="L1056">		return equipmentFacet.getSet(id);</span>
	}

	/**
	 * Get the character's &quot;equipped&quot; equipment.
	 * @return a set of the &quot;equipped&quot; equipment
	 */
	public Set&lt;Equipment&gt; getEquippedEquipmentSet()
	{
<span class="nc" id="L1065">		return equippedFacet.getSet(id);</span>
	}

	/**
	 * Retrieves a list of the character's equipment in output order. This is in
	 * ascending order of the equipment's outputIndex field. If multiple items
	 * of equipment have the same outputIndex they will be ordered by name. Note
	 * hidden items (outputIndex = -1) are not included in this list.
	 *
	 * @return An ArrayList of the equipment objects in output order.
	 */
	public List&lt;Equipment&gt; getEquipmentListInOutputOrder()
	{
<span class="nc" id="L1078">		return sortEquipmentList(getEquipmentSet(), Constants.MERGE_ALL);</span>
	}

	/**
	 * Retrieves a list of the character's equipment in output order. This is in
	 * ascending order of the equipment's outputIndex field. If multiple items
	 * of equipment have the same outputIndex they will be ordered by name. Note
	 * hidden items (outputIndex = -1) are not included in this list.
	 *
	 * Deals with merge as well.  See the Constants package for acceptable values
	 * of merge .
	 *
	 * @param merge controls how much merging is done.
	 *
	 * @return An ArrayList of the equipment objects in output order.
	 */
	public List&lt;Equipment&gt; getEquipmentListInOutputOrder(final int merge)
	{
<span class="nc" id="L1096">		return sortEquipmentList(getEquipmentSet(), merge);</span>
	}

	/**
	 * Get the master list of equipment.
	 *
	 * @return equipment master list
	 */
	public List&lt;Equipment&gt; getEquipmentMasterList()
	{
<span class="nc" id="L1106">		Set&lt;Equipment&gt; set = userEquipmentFacet.getSet(id);</span>
<span class="nc" id="L1107">		final List&lt;Equipment&gt; aList = new ArrayList&lt;&gt;(set);</span>
<span class="nc" id="L1108">		aList.addAll(autoListEquipmentFacet.getSet(id));</span>
<span class="nc" id="L1109">		aList.addAll(autoEquipFacet.getAutoEquipment(id));</span>
<span class="nc" id="L1110">		return aList;</span>
	}

	/**
	 * Search for a piece of equipment in the specified list by name.
	 *
	 * TODO - This does not belong in PlayerCharacter. Move to Equipment if
	 * needed.
	 *
	 * TODO - This probably won't work with i18n. Should always search by key.
	 *
	 * @param aString
	 *            The name of the equipment.
	 * @param aList
	 *            The Collection of equipment to search in.
	 *
	 * @return The &lt;tt&gt;Equipment&lt;/tt&gt; object or &lt;tt&gt;null&lt;/tt&gt;
	 */
	private static Equipment getEquipmentNamed(final String aString, final Collection&lt;Equipment&gt; aList)
	{

<span class="nc" id="L1131">		return aList.stream()</span>
<span class="nc" id="L1132">		            .filter(eq -&gt; aString.equalsIgnoreCase(eq.getName()))</span>
<span class="nc" id="L1133">		            .findFirst()</span>
<span class="nc" id="L1134">		            .orElse(null);</span>
	}

	/**
	 * Search among the PCs equipment for a named piece of equipment.
	 * @param name The name of the piece of equipment.
	 * @return null or the equipment named.
	 */
	public Equipment getEquipmentNamed(final String name)
	{
<span class="nc" id="L1144">		return getEquipmentNamed(name, getEquipmentMasterList());</span>
	}

	/**
	 * Set the characters eye colour.
	 *
	 * @param aString
	 *            the colour of their eyes
	 */
	public void setEyeColor(final String aString)
	{
<span class="nc" id="L1155">		setStringFor(PCStringKey.EYECOLOR, aString);</span>
<span class="nc" id="L1156">	}</span>

	/**
	 * Get a number that represents the number of feats added to this character
	 * by BONUS statements.
	 *
	 * @return the number of feats added by bonus statements
	 */
	private double getBonusFeatPool()
	{
<span class="nc" id="L1166">		String aString = Globals.getBonusFeatString();</span>

<span class="nc" id="L1168">		final StringTokenizer aTok = new StringTokenizer(aString, Constants.PIPE, false);</span>
<span class="nc" id="L1169">		final int startLevel = Integer.parseInt(aTok.nextToken());</span>
<span class="nc" id="L1170">		final int rangeLevel = Integer.parseInt(aTok.nextToken());</span>

<span class="nc" id="L1172">		double pool = getTotalBonusTo(&quot;FEAT&quot;, &quot;POOL&quot;);</span>
<span class="nc" id="L1173">		double pcpool = getTotalBonusTo(&quot;FEAT&quot;, &quot;PCPOOL&quot;);</span>
<span class="nc" id="L1174">		double mpool = getTotalBonusTo(&quot;FEAT&quot;, &quot;MONSTERPOOL&quot;);</span>
<span class="nc" id="L1175">		double bonus = getTotalBonusTo(&quot;ABILITYPOOL&quot;, &quot;FEAT&quot;);</span>
<span class="nc" id="L1176">		double classLvlBonus = getNumFeatsFromLevels();</span>

<span class="nc bnc" id="L1178" title="All 2 branches missed.">		if (Logging.isDebugMode())</span>
		{
<span class="nc" id="L1180">			Logging.debugPrint(&quot;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1181">			Logging.debugPrint(&quot;==============&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1182">			Logging.debugPrint(&quot;level &quot; + this.totalNonMonsterLevels()); //$NON-NLS-1$</span>

<span class="nc" id="L1184">			Logging.debugPrint(&quot;POOL:   &quot; + pool); //$NON-NLS-1$</span>
<span class="nc" id="L1185">			Logging.debugPrint(&quot;PCPOOL: &quot; + pcpool); //$NON-NLS-1$</span>
<span class="nc" id="L1186">			Logging.debugPrint(&quot;MPOOL:  &quot; + mpool); //$NON-NLS-1$</span>
<span class="nc" id="L1187">			Logging.debugPrint(&quot;APOOL:  &quot; + bonus); //$NON-NLS-1$</span>
<span class="nc" id="L1188">			Logging.debugPrint(&quot;LVLBONUS:  &quot; + classLvlBonus); //$NON-NLS-1$</span>
		}

<span class="nc bnc" id="L1191" title="All 2 branches missed.">		double startAdjust = rangeLevel == 0 ? 0 : startLevel / rangeLevel;</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">		double nonMonsterAdjustment = this.totalNonMonsterLevels() &gt;= startLevel ? 1.0d + pcpool - startAdjust : pcpool;</span>

<span class="nc" id="L1195">		pool += CoreUtility.epsilonFloor(nonMonsterAdjustment);</span>
<span class="nc" id="L1196">		pool += CoreUtility.epsilonFloor(mpool);</span>
<span class="nc" id="L1197">		pool += CoreUtility.epsilonFloor(bonus);</span>
<span class="nc" id="L1198">		pool += CoreUtility.epsilonFloor(classLvlBonus);</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">		if (Logging.isDebugMode())</span>
		{
<span class="nc" id="L1202">			Logging.debugPrint(&quot;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1203">			Logging.debugPrint(&quot;Total Bonus: &quot; + pool); //$NON-NLS-1$</span>
<span class="nc" id="L1204">			Logging.debugPrint(&quot;==============&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1205">			Logging.debugPrint(&quot;&quot;); //$NON-NLS-1$</span>
		}

<span class="nc" id="L1208">		return pool;</span>
	}

	/**
	 * Calculates the number of feats that should be granted as a result of LEVELPERFEAT
	 * entries in classes that the character has levels in. Stacking rules based on
	 * LEVELTYPE are applied as part of this calculation.
	 *
	 * @return the number of feats granted
	 */
	double getNumFeatsFromLevels()
	{
<span class="nc" id="L1220">		Map&lt;String, Double&gt; featByLevelType = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc" id="L1223">			int lvlPerFeat = pcClass.getSafe(IntegerKey.LEVELS_PER_FEAT);</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">			if (lvlPerFeat != 0)</span>
			{
<span class="nc" id="L1226">				double bonus = (double) getLevel(pcClass) / lvlPerFeat;</span>
<span class="nc" id="L1227">				Double existing = featByLevelType.get(pcClass.get(StringKey.LEVEL_TYPE));</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">				if (existing == null)</span>
				{
<span class="nc" id="L1230">					existing = 0.0d;</span>
				}
<span class="nc" id="L1232">				existing += bonus;</span>
<span class="nc" id="L1233">				featByLevelType.put(pcClass.get(StringKey.LEVEL_TYPE), existing);</span>
			}
<span class="nc" id="L1235">		}</span>

<span class="nc" id="L1237">		double bonus = 0.0d;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">		for (final Map.Entry&lt;String, Double&gt; stringDoubleEntry : featByLevelType.entrySet())</span>
		{
<span class="nc" id="L1240">			Double existing = stringDoubleEntry.getValue();</span>
<span class="nc" id="L1241">			bonus += CoreUtility.epsilonFloor(existing);</span>
<span class="nc" id="L1242">		}</span>
<span class="nc" id="L1243">		return bonus;</span>
	}
	/**
	 * Sets the filename of the character.
	 *
	 * @param newFileName the name of the file this character will be saved in
	 */
	public void setFileName(final String newFileName)
	{
<span class="nc" id="L1252">		setStringFor(PCStringKey.FILE_NAME, newFileName);</span>
<span class="nc" id="L1253">	}</span>

	/**
	 * Gets the filename of the character.
	 *
	 * @return file name of character
	 */
	public String getFileName()
	{
<span class="nc" id="L1262">		return getSafeStringFor(PCStringKey.FILE_NAME);</span>
	}

	/**
	 * Returns the followers associated with this character.
	 *
	 * @return A &lt;tt&gt;Set&lt;/tt&gt; of &lt;tt&gt;Follower&lt;/tt&gt; objects.
	 */
	public Collection&lt;Follower&gt; getFollowerList()
	{
<span class="nc" id="L1272">		return followerFacet.getSet(id);</span>
	}

	/**
	 * Sets the character's gender.
	 *
	 * &lt;p&gt;
	 * The gender will only be changed if the character does not have a template
	 * that locks the character's gender.
	 *
	 * @param g
	 *            A gender to try and set.
	 */
	public void setGender(final Gender g)
	{
<span class="nc bnc" id="L1287" title="All 2 branches missed.">		if (genderFacet.getGender(id) != g)</span>
		{
<span class="nc" id="L1289">			genderFacet.set(id, g);</span>
<span class="nc" id="L1290">			setDirty(true);</span>
		}
<span class="nc" id="L1292">	}</span>

	/**
	 * Marks the character as being in the process of being loaded.
	 *
	 * &lt;p&gt;
	 * This information is used to prevent the system from trying to calculate
	 * values on partial information or values that should be set from the saved
	 * character.
	 *
	 * &lt;p&gt;
	 * TODO - This is pretty dangerous.
	 *
	 * @param newIsImporting
	 *            &lt;tt&gt;true&lt;/tt&gt; to mark the character as being imported.
	 */
	public void setImporting(final boolean newIsImporting)
	{
<span class="nc" id="L1310">		this.importing = newIsImporting;</span>
<span class="nc" id="L1311">	}</span>

	/**
	 * Gets the character's list of languages.
	 *
	 * @return An unmodifiable language set.
	 */
	public Set&lt;Language&gt; getLanguageSet()
	{
<span class="nc" id="L1320">		return languageFacet.getSet(id);</span>
	}

	/**
	 * This method returns the effective level of this character for purposes of
	 * applying companion mods to a companion of the specified type.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;: This whole structure is kind of messed up since nothing
	 * enforces that a companion mod of a given type always looks at the same
	 * variable (either Class or Variable).  Note it seems that this used to
	 * be driven off types but now it's driven from a list of companion mods
	 * but the java doc has not been updated.
	 *
	 * @param compList
	 *            A list of companionMods to get level for
	 * @return The effective level for this companion type
	 */
	public int getEffectiveCompanionLevel(final CompanionList compList)
	{
<span class="nc bnc" id="L1339" title="All 2 branches missed.">		for (CompanionMod cMod : Globals.getContext().getReferenceContext().getManufacturerId(compList).getAllObjects())</span>
		{
<span class="nc" id="L1341">			Map&lt;String, Integer&gt; varmap = cMod.getMapFor(MapKey.APPLIED_VARIABLE);</span>

<span class="nc bnc" id="L1343" title="All 2 branches missed.">			for (final String varName : varmap.keySet())</span>
			{
<span class="nc" id="L1345">				final int lvl = this.getVariableValue(varName, Constants.EMPTY_STRING).intValue();</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">				if (lvl &gt; 0)</span>
				{
<span class="nc" id="L1348">					return lvl;</span>
				}
<span class="nc" id="L1350">			}</span>

<span class="nc" id="L1352">			Map&lt;CDOMSingleRef&lt;? extends PCClass&gt;, Integer&gt; ac = cMod.getMapFor(MapKey.APPLIED_CLASS);</span>

<span class="nc bnc" id="L1354" title="All 2 branches missed.">			for (Map.Entry&lt;CDOMSingleRef&lt;? extends PCClass&gt;, Integer&gt; me : ac.entrySet())</span>
			{
<span class="nc" id="L1356">				PCClass pcclass = me.getKey().get();</span>
<span class="nc" id="L1357">				String key = pcclass.getKeyName();</span>
<span class="nc" id="L1358">				int lvl = getLevel(getClassKeyed(key));</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">				if (lvl &gt; 0)</span>
				{
<span class="nc" id="L1361">					return lvl;</span>
				}
<span class="nc" id="L1363">			}</span>
<span class="nc" id="L1364">		}</span>
<span class="nc" id="L1365">		return 0;</span>
	}

	/**
	 * Set the master for this object also set the level dependent stats based
	 * on the masters level and info contained in the companionModList Array
	 * such as HitDie, SR, BONUS, SA, etc.
	 *
	 * @param aM
	 *            The master to be set.
	 */
	public void setMaster(final Follower aM)
	{
<span class="nc" id="L1378">		masterFacet.set(id, aM);</span>

<span class="nc" id="L1380">		final PlayerCharacter mPC = getMasterPC();</span>

<span class="nc bnc" id="L1382" title="All 2 branches missed.">		if (mPC == null)</span>
		{
<span class="nc" id="L1384">			return;</span>
		}

		// make sure masters Name and fileName are correct
<span class="nc bnc" id="L1388" title="All 2 branches missed.">		if (!aM.getFileName().equals(mPC.getFileName()))</span>
		{
<span class="nc" id="L1390">			aM.setFileName(mPC.getFileName());</span>
<span class="nc" id="L1391">			setDirty(true);</span>
		}

<span class="nc bnc" id="L1394" title="All 2 branches missed.">		if (!aM.getName().equals(mPC.getName()))</span>
		{
<span class="nc" id="L1396">			aM.setName(mPC.getName());</span>
<span class="nc" id="L1397">			setDirty(true);</span>
		}

		// Get total wizard + sorcerer levels as they stack like a mother
<span class="nc" id="L1401">		int mTotalLevel = 0;</span>
<span class="nc" id="L1402">		int addHD = 0;</span>

<span class="nc bnc" id="L1404" title="All 2 branches missed.">		for (PCClass mClass : mPC.getClassSet())</span>
		{
<span class="nc" id="L1406">			boolean found = false;</span>

<span class="nc bnc" id="L1408" title="All 2 branches missed.">			for (CompanionMod cMod : Globals.getContext().getReferenceContext().getManufacturerId(aM.getType())</span>
<span class="nc" id="L1409">				.getAllObjects())</span>
			{
<span class="nc bnc" id="L1411" title="All 4 branches missed.">				if ((cMod.getLevelApplied(mClass) &gt; 0) &amp;&amp; !found)</span>
				{
<span class="nc" id="L1413">					mTotalLevel += getLevel(mClass);</span>
<span class="nc" id="L1414">					found = true;</span>
				}
<span class="nc" id="L1416">			}</span>
<span class="nc" id="L1417">		}</span>

<span class="nc" id="L1419">		List&lt;CompanionMod&gt; newCompanionMods = new ArrayList&lt;&gt;();</span>

		// Clear the companionModList so we can add everything to it
<span class="nc" id="L1422">		Collection&lt;CompanionMod&gt; oldCompanionMods = companionModFacet.removeAll(id);</span>

<span class="nc bnc" id="L1424" title="All 2 branches missed.">		for (CompanionMod cMod : Globals.getContext().getReferenceContext().getManufacturerId(aM.getType())</span>
<span class="nc" id="L1425">			.getAllObjects())</span>
		{
			// Check all the masters classes
<span class="nc bnc" id="L1428" title="All 2 branches missed.">			for (PCClass mClass : mPC.getClassSet())</span>
			{
<span class="nc" id="L1430">				final int mLev = mPC.getLevel(mClass) + aM.getAdjustment();</span>
<span class="nc" id="L1431">				final int compLev = cMod.getLevelApplied(mClass);</span>

<span class="nc bnc" id="L1433" title="All 2 branches missed.">				if (compLev &lt; 0)</span>
				{
<span class="nc" id="L1435">					continue;</span>
				}

				// This CompanionMod must be for this Class
				// and for the correct level or lower
<span class="nc bnc" id="L1440" title="All 4 branches missed.">				if ((compLev &lt;= mLev) || (compLev &lt;= mTotalLevel))</span>
				{
<span class="nc bnc" id="L1442" title="All 2 branches missed.">					if (cMod.qualifies(this, cMod))</span>
					{
<span class="nc bnc" id="L1444" title="All 2 branches missed.">						if (!oldCompanionMods.contains(cMod))</span>
						{
<span class="nc" id="L1446">							newCompanionMods.add(cMod);</span>
						}
<span class="nc" id="L1448">						companionModFacet.add(id, cMod);</span>
<span class="nc" id="L1449">						addHD += cMod.getSafe(IntegerKey.HIT_DIE);</span>
					}
				}
<span class="nc" id="L1452">			}</span>
<span class="nc" id="L1453">			Map&lt;String, Integer&gt; varmap = cMod.getMapFor(MapKey.APPLIED_VARIABLE);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">			for (String varName : varmap.keySet())</span>
			{
<span class="nc" id="L1456">				final int mLev = mPC.getVariableValue(varName, Constants.EMPTY_STRING).intValue() + aM.getAdjustment();</span>

<span class="nc bnc" id="L1458" title="All 2 branches missed.">				if (mLev &gt;= cMod.getVariableApplied(varName))</span>
				{
<span class="nc bnc" id="L1460" title="All 2 branches missed.">					if (cMod.qualifies(this, cMod))</span>
					{
<span class="nc bnc" id="L1462" title="All 2 branches missed.">						if (!oldCompanionMods.contains(cMod))</span>
						{
<span class="nc" id="L1464">							newCompanionMods.add(cMod);</span>
						}
<span class="nc" id="L1466">						companionModFacet.add(id, cMod);</span>
<span class="nc" id="L1467">						addHD += cMod.getSafe(IntegerKey.HIT_DIE);</span>
					}
				}
<span class="nc" id="L1470">			}</span>
<span class="nc" id="L1471">		}</span>

		// Add additional HD if required
<span class="nc" id="L1474">		LevelCommandFactory lcf = getRace().get(ObjectKey.MONSTER_CLASS);</span>

<span class="nc" id="L1476">		final int usedHD = aM.getUsedHD();</span>
<span class="nc" id="L1477">		addHD -= usedHD;</span>

		// if ((newClass != null) &amp;&amp; (addHD != 0))
<span class="nc bnc" id="L1480" title="All 4 branches missed.">		if ((lcf != null) &amp;&amp; (addHD != 0))</span>
		{
			// set the new HD (but only do it once!)
<span class="nc" id="L1483">			incrementClassLevel(addHD, lcf.getPCClass(), true);</span>
<span class="nc" id="L1484">			aM.setUsedHD(addHD + usedHD);</span>
<span class="nc" id="L1485">			setDirty(true);</span>
		}

		// If it's a familiar, we need to change it's Skills
<span class="nc bnc" id="L1489" title="All 2 branches missed.">		if (masterFacet.getUseMasterSkill(id))</span>
		{
<span class="nc" id="L1491">			final Collection&lt;Skill&gt; mList = mPC.getSkillSet();</span>
<span class="nc" id="L1492">			final List&lt;Skill&gt; sKeyList = new ArrayList&lt;&gt;();</span>

			// now we have to merge the two lists together and
			// take the higher rank of each skill for the Familiar
<span class="nc bnc" id="L1496" title="All 2 branches missed.">			for (Skill fSkill : getSkillSet())</span>
			{
<span class="nc bnc" id="L1498" title="All 2 branches missed.">				for (Skill mSkill : mList)</span>
				{
					// first check to see if familiar
					// already has ranks in the skill
<span class="nc bnc" id="L1502" title="All 2 branches missed.">					if (mSkill.equals(fSkill))</span>
					{
						// need higher rank of the two
<span class="nc" id="L1505">						Float totalMasterRank = SkillRankControl.getTotalRank(mPC, mSkill);</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">						if (totalMasterRank.intValue() &gt; this.getRank(fSkill).intValue())</span>
						{
							// first zero current
<span class="nc bnc" id="L1509" title="All 2 branches missed.">							SkillRankControl.setZeroRanks(lcf == null ? null : lcf.getPCClass(), this, fSkill);</span>
							// We don't pass in a class here so that the real
							// skills can be distinguished from the ones from
							// the master.
<span class="nc" id="L1513">							SkillRankControl.modRanks(totalMasterRank.doubleValue(), null, true, this, fSkill);</span>
						}
					}

					// build a list of all skills a master
					// Possesses, but the familiar does not
<span class="nc bnc" id="L1519" title="All 4 branches missed.">					if (!hasSkill(mSkill) &amp;&amp; !sKeyList.contains(mSkill))</span>
					{
<span class="nc" id="L1521">						sKeyList.add(mSkill);</span>
					}
<span class="nc" id="L1523">				}</span>
<span class="nc" id="L1524">			}</span>

			// now add all the skills only the master has
<span class="nc bnc" id="L1527" title="All 2 branches missed.">			for (Skill newSkill : sKeyList)</span>
			{
				// familiar doesn't have skill,
				// but master does, so add it
<span class="nc" id="L1531">				final double sr = SkillRankControl.getTotalRank(mPC, newSkill).doubleValue();</span>

				// We don't pass in a class here so that the real skills can be
				// distinguished from the ones form the master.
<span class="nc" id="L1535">				SkillRankControl.modRanks(sr, null, true, this, newSkill);</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">				if (ChooseActivation.hasNewChooseToken(newSkill))</span>
				{
					//TODO a bit reckless :P
<span class="nc" id="L1540">					ChooseInformation&lt;Language&gt; chooseInfo =</span>
<span class="nc" id="L1541">							(ChooseInformation&lt;Language&gt;) newSkill.get(ObjectKey.CHOOSE_INFO);</span>
<span class="nc" id="L1542">					List&lt;? extends Language&gt; selected = chooseInfo.getChoiceActor().getCurrentlySelected(newSkill, mPC);</span>

<span class="nc" id="L1544">					ChoiceManagerList&lt;Language&gt; controller =</span>
<span class="nc" id="L1545">							ChooserUtilities.getConfiguredController(newSkill, this, null, new ArrayList&lt;&gt;());</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">					for (Language lang : selected)</span>
					{
<span class="nc bnc" id="L1548" title="All 2 branches missed.">						if (!controller.conditionallyApply(this, lang))</span>
						{
<span class="nc" id="L1550">							Logging.errorPrint(&quot;Failed to add master's language &quot; + lang + &quot; to companion.&quot;);</span>
						}
<span class="nc" id="L1552">					}</span>

				}

<span class="nc" id="L1556">			}</span>
		}

<span class="nc" id="L1559">		oldCompanionMods.removeAll(companionModFacet.getSet(id));</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">		for (CompanionMod cMod : oldCompanionMods)</span>
		{
<span class="nc" id="L1562">			CDOMObjectUtilities.removeAdds(cMod, this);</span>
<span class="nc" id="L1563">			CDOMObjectUtilities.restoreRemovals(cMod, this);</span>
<span class="nc" id="L1564">		}</span>

<span class="nc bnc" id="L1566" title="All 2 branches missed.">		for (CompanionMod cMod : newCompanionMods)</span>
		{
<span class="nc" id="L1568">			CDOMObjectUtilities.addAdds(cMod, this);</span>
<span class="nc" id="L1569">			CDOMObjectUtilities.checkRemovals(cMod, this);</span>

<span class="nc bnc" id="L1571" title="All 2 branches missed.">			for (CDOMReference&lt;PCTemplate&gt; ref : cMod.getSafeListFor(ListKey.TEMPLATE))</span>
			{
<span class="nc bnc" id="L1573" title="All 2 branches missed.">				for (PCTemplate pct : ref.getContainedObjects())</span>
				{
<span class="nc" id="L1575">					addTemplate(pct);</span>
<span class="nc" id="L1576">				}</span>
<span class="nc" id="L1577">			}</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">			for (CDOMReference&lt;PCTemplate&gt; ref : cMod.getSafeListFor(ListKey.REMOVE_TEMPLATES))</span>
			{
<span class="nc bnc" id="L1580" title="All 2 branches missed.">				for (PCTemplate pct : ref.getContainedObjects())</span>
				{
<span class="nc" id="L1582">					removeTemplate(pct);</span>
<span class="nc" id="L1583">				}</span>
<span class="nc" id="L1584">			}</span>

<span class="nc bnc" id="L1586" title="All 2 branches missed.">			for (TransitionChoice&lt;Kit&gt; kit : cMod.getSafeListFor(ListKey.KIT_CHOICE))</span>
			{
<span class="nc" id="L1588">				kit.act(kit.driveChoice(this), cMod, this);</span>
<span class="nc" id="L1589">			}</span>
<span class="nc" id="L1590">		}</span>
<span class="nc" id="L1591">		calcActiveBonuses();</span>
<span class="nc" id="L1592">		setDirty(true);</span>
<span class="nc" id="L1593">	}</span>

	/**
	 * Returns the maximum number of followers this character can have from
	 * the given companion list. This method does not adjust for any followers
	 * already selected by the character.
	 *
	 * @param cList
	 *            A list of potential follower races
	 * @return The max number of followers -1 for any number
	 */
	public int getMaxFollowers(CompanionList cList)
	{
<span class="nc" id="L1606">		int ret = followerLimitFacet.getMaxFollowers(id, cList);</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">		return (ret == -1) ? getOldFollowerLimit(cList) : ret;</span>
	}

	private int getOldFollowerLimit(CompanionList cList)
	{
		// Old way of handling this
		// If the character qualifies for any companion mod of this type
		// they can take unlimited number of them.
<span class="nc bnc" id="L1615" title="All 2 branches missed.">		for (CompanionMod cMod : Globals.getContext().getReferenceContext().getManufacturerId(cList).getAllObjects())</span>
		{
<span class="nc" id="L1617">			Map&lt;String, Integer&gt; varmap = cMod.getMapFor(MapKey.APPLIED_VARIABLE);</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">			for (String varName : varmap.keySet())</span>
			{
<span class="nc bnc" id="L1620" title="All 2 branches missed.">				if (this.getVariableValue(varName, Constants.EMPTY_STRING).intValue() &gt; 0)</span>
				{
<span class="nc" id="L1622">					return -1;</span>
				}
<span class="nc" id="L1624">			}</span>
<span class="nc" id="L1625">			Map&lt;CDOMSingleRef&lt;? extends PCClass&gt;, Integer&gt; ac = cMod.getMapFor(MapKey.APPLIED_CLASS);</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">			for (Map.Entry&lt;CDOMSingleRef&lt;? extends PCClass&gt;, Integer&gt; me : ac.entrySet())</span>
			{
<span class="nc" id="L1628">				PCClass pcclass = me.getKey().get();</span>
<span class="nc" id="L1629">				String key = pcclass.getKeyName();</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">				for (PCClass pcClass : getClassSet())</span>
				{
<span class="nc bnc" id="L1632" title="All 2 branches missed.">					if (pcClass.getKeyName().equals(key))</span>
					{
<span class="nc" id="L1634">						return me.getValue();</span>
					}
<span class="nc" id="L1636">				}</span>
<span class="nc" id="L1637">			}</span>
<span class="nc" id="L1638">		}</span>

<span class="nc" id="L1640">		return 0;</span>
	}

	/**
	 * Get the PlayerCharacter that is the &quot;master&quot; for this object.
	 *
	 * @return master PC
	 */
	public PlayerCharacter getMasterPC()
	{
<span class="nc" id="L1650">		Follower followerMaster = masterFacet.get(id);</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">		if (followerMaster == null)</span>
		{
<span class="nc" id="L1653">			return null;</span>
		}

<span class="nc bnc" id="L1656" title="All 2 branches missed.">		for (PlayerCharacter nPC : Globals.getPCList())</span>
		{
<span class="nc bnc" id="L1658" title="All 2 branches missed.">			if (followerMaster.getFileName().equals(nPC.getFileName()))</span>
			{
<span class="nc" id="L1660">				return nPC;</span>
			}
<span class="nc" id="L1662">		}</span>

		// could not find a filename match, let's try the Name
<span class="nc bnc" id="L1665" title="All 2 branches missed.">		for (PlayerCharacter nPC : Globals.getPCList())</span>
		{
<span class="nc bnc" id="L1667" title="All 2 branches missed.">			if (followerMaster.getName().equals(nPC.getName()))</span>
			{
<span class="nc" id="L1669">				return nPC;</span>
			}
<span class="nc" id="L1671">		}</span>

		// no Name and no FileName match, so must not be loaded
<span class="nc" id="L1674">		return null;</span>
	}

	/**
	 * Sets the character's name.
	 *
	 * @param aString
	 *            A name to set.
	 */
	public final void setName(final String aString)
	{
<span class="fc" id="L1685">		setStringFor(PCStringKey.NAME, aString);</span>
<span class="fc" id="L1686">	}</span>

	/**
	 * Gets the character's name.
	 *
	 * @return The name
	 */
	public String getName()
	{
<span class="nc" id="L1695">		return getSafeStringFor(PCStringKey.NAME);</span>
	}

	/**
	 * Takes all the Temporary Bonuses and Merges them into just the unique
	 * named bonuses.
	 *
	 * @return List of Strings
	 */
	public List&lt;String&gt; getNamedTempBonusList()
	{
<span class="nc" id="L1706">		return bonusManager.getNamedTempBonusList();</span>
	}

	/**
	 * Takes all the Temporary Bonuses and Merges them into just the unique
	 * named bonuses.
	 *
	 * @return    List of Strings
	 */
	public List&lt;String&gt; getNamedTempBonusDescList()
	{
<span class="nc" id="L1717">		return bonusManager.getNamedTempBonusDescList();</span>
	}

	/**
	 * Set the value of the feat pool.
	 * @param pool value to set the feat pool to
	 */
	public void setPoolAmount(final int pool)
	{
<span class="nc" id="L1726">		poolAmount = pool;</span>
<span class="nc" id="L1727">	}</span>

	/**
	 * Get the value of the feat pool.
	 * @return the feat pool amount
	 */
	public int getPoolAmount()
	{
<span class="nc" id="L1735">		return poolAmount;</span>
	}

	/**
	 * Selector Sets the path to the portrait of the character.
	 *
	 * @param newPortraitPath
	 *            the path to the portrait file
	 */
	public void setPortraitPath(final String newPortraitPath)
	{
<span class="nc" id="L1746">		setStringFor(PCStringKey.PORTRAIT_PATH, newPortraitPath);</span>
<span class="nc" id="L1747">	}</span>

	/**
	 * Set a new outline for the portrait thumbnail.
	 * @param rect The thumbnail outline.
	 */
	public void setPortraitThumbnailRect(Rectangle rect)
	{
<span class="nc" id="L1755">		portraitThumbnailRectFacet.set(id, (Rectangle) rect.clone());</span>
<span class="nc" id="L1756">	}</span>

	/**
	 * Get the character's race.
	 *
	 * @return the character's race
	 */
	public Race getRace()
	{
<span class="fc" id="L1765">		return raceFacet.get(id);</span>
	}

	/**
	 * Set the character's region.
	 *
	 * @param r the character's region
	 */
	public void setRegion(Region r)
	{
<span class="nc" id="L1775">		regionFacet.setRegion(id, r);</span>
<span class="nc" id="L1776">	}</span>

	/**
	 * Set the location of the HTML sheet for this character.
	 *
	 * @param aString the location of the HTML sheet
	 */
	public void setSelectedCharacterHTMLOutputSheet(final String aString)
	{
<span class="nc" id="L1785">		outputSheetHTML = aString;</span>
<span class="nc" id="L1786">	}</span>

	/**
	 * Get the Location of HTML Output Sheet to be used for this character.
	 *
	 * @return HTML output sheet
	 */
	public String getSelectedCharacterHTMLOutputSheet()
	{
<span class="nc" id="L1795">		return outputSheetHTML;</span>
	}

	/**
	 * Set the location of the PDF Output Sheet for this character.
	 *
	 * @param aString the location of the PDF Output Sheet
	 */
	public void setSelectedCharacterPDFOutputSheet(final String aString)
	{
<span class="nc" id="L1805">		outputSheetPDF = aString;</span>
<span class="nc" id="L1806">	}</span>

	/**
	 * Get the location of the PDF Output Sheet to be used for this character.
	 *
	 * @return pdf output sheet
	 */
	public String getSelectedCharacterPDFOutputSheet()
	{
<span class="nc" id="L1815">		return outputSheetPDF;</span>
	}

	/**
	 * Get list of shield proficiencies.
	 *
	 * @return shield prof list
	 */
	public Collection&lt;ProfProvider&lt;ShieldProf&gt;&gt; getShieldProfList()
	{
<span class="nc" id="L1825">		return shieldProfFacet.getQualifiedSet(id);</span>
	}

	/**
	 * Get skill list.
	 *
	 * @return list of skills
	 */
	public Collection&lt;Skill&gt; getSkillSet()
	{
<span class="nc" id="L1835">		return skillFacet.getSet(id);</span>
	}

	/**
	 * Get skill points.
	 *
	 * @return skill points
	 */
	public int getSkillPoints()
	{
<span class="nc" id="L1845">		int returnValue = 0;</span>

		// First compute gained points, and then remove the already spent ones.
		// We can't use Remaining points because the level may be removed, and
		// then we have
		// to display this as -x on the &quot;Total Skill Points&quot; field
<span class="nc bnc" id="L1851" title="All 2 branches missed.">		for (PCLevelInfo li : getLevelInfo())</span>
		{
<span class="nc" id="L1853">			returnValue += li.getSkillPointsGained(this);</span>
<span class="nc" id="L1854">		}</span>

<span class="nc bnc" id="L1856" title="All 2 branches missed.">		for (Skill aSkill : getSkillSet())</span>
		{
<span class="nc bnc" id="L1858" title="All 2 branches missed.">			for (PCClass pcc : getSkillRankClasses(aSkill))</span>
			{
<span class="nc bnc" id="L1860" title="All 2 branches missed.">				if (pcc != null)</span>
				{
<span class="nc" id="L1862">					Double curRank = getSkillRankForClass(aSkill, pcc);</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">					if (curRank == null)</span>
					{
<span class="nc" id="L1865">						Logging.errorPrint(&quot;Got null on ranks for &quot; + aSkill + &quot; in class &quot; + pcc);</span>
<span class="nc" id="L1866">						curRank = 0.0d;</span>
					}
					// Only add the cost for skills associated with a class.
					// Skill ranks from feats etc are free.
<span class="nc" id="L1870">					final int cost = getSkillCostForClass(aSkill, pcc).getCost();</span>
<span class="nc" id="L1871">					returnValue -= (int) (cost * curRank);</span>
				}
<span class="nc" id="L1873">			}</span>
<span class="nc" id="L1874">		}</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">		if (Globals.getGameModeHasPointPool())</span>
		{
<span class="nc" id="L1877">			returnValue += (int) getRemainingFeatPoints(false); // DO NOT CALL</span>
			// getFeats() here! It
			// will set up a
			// recursive loop and
			// result in a stack
			// overflow!
		}
<span class="nc" id="L1884">		return returnValue;</span>
	}

	/**
	 * Get list of special abilities.
	 *
	 * @return List of special abilities
	 */
	public List&lt;SpecialAbility&gt; getSpecialAbilityList()
	{
		// aList will contain a list of SpecialAbility objects
<span class="nc" id="L1895">		List&lt;SpecialAbility&gt; aList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1896">		aList.addAll(userSpecialAbilityFacet.getAllResolved(id, SA_PROC));</span>
<span class="nc" id="L1897">		aList.addAll(specialAbilityFacet.getAllResolved(id, SA_PROC));</span>

<span class="nc" id="L1899">		Collections.sort(aList);</span>

<span class="nc" id="L1901">		return aList;</span>
	}

	/**
	 * Get list of special abilities as Strings.
	 *
	 * @return List of special abilities as Strings
	 */
	private List&lt;String&gt; getSpecialAbilityListStrings()
	{
<span class="nc" id="L1911">		List&lt;String&gt; bList = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1913">		bList.addAll(userSpecialAbilityFacet.getAllResolved(id, SA_TO_STRING_PROC));</span>
<span class="nc" id="L1914">		bList.addAll(specialAbilityFacet.getAllResolved(id, SA_TO_STRING_PROC));</span>

<span class="nc" id="L1916">		Collections.sort(bList);</span>

<span class="nc" id="L1918">		return bList;</span>
	}

	/**
	 * same as getSpecialAbilityList except if you have the same ability
	 * twice, it only lists it once with (2) at the end.
	 *
	 * @return List
	 */
	public ArrayList&lt;String&gt; getSpecialAbilityTimesList()
	{
<span class="nc" id="L1929">		final List&lt;String&gt; abilityList = getSpecialAbilityListStrings();</span>
<span class="nc" id="L1930">		final List&lt;String&gt; sortList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1931">		final int[] numTimes = new int[abilityList.size()];</span>

<span class="nc bnc" id="L1933" title="All 2 branches missed.">		for (int i = 0; i &lt; abilityList.size(); i++)</span>
		{
<span class="nc" id="L1935">			final String ability = abilityList.get(i);</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">			if (sortList.contains(ability))</span>
			{
<span class="nc bnc" id="L1938" title="All 2 branches missed.">				for (int j = 0; j &lt; sortList.size(); j++)</span>
				{
<span class="nc" id="L1940">					final String testAbility = sortList.get(j);</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">					if (testAbility.equals(ability))</span>
					{
<span class="nc" id="L1943">						numTimes[j]++;</span>
					}
				}
			}
			else
			{
<span class="nc" id="L1949">				sortList.add(ability);</span>
<span class="nc" id="L1950">				numTimes[i] = 1;</span>
			}
		}

<span class="nc" id="L1954">		final ArrayList&lt;String&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">		for (int i = 0; i &lt; sortList.size(); i++)</span>
		{
<span class="nc" id="L1957">			String ability = sortList.get(i);</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">			if (numTimes[i] &gt; 1)</span>
			{
<span class="nc" id="L1960">				ability = ability + &quot; (&quot; + numTimes[i] + ')';</span>
			}
<span class="nc" id="L1962">			retList.add(ability);</span>
		}

<span class="nc" id="L1965">		return retList;</span>
	}

	/**
	 * Set the name of the spellbook to auto add new known spells to.
	 *
	 * @param aString
	 *            The new spellbook name.
	 */
	public void setSpellBookNameToAutoAddKnown(final String aString)
	{
<span class="nc" id="L1976">		setStringFor(PCStringKey.SPELLBOOK_AUTO_ADD_KNOWN, aString);</span>
<span class="nc" id="L1977">	}</span>

	/**
	 * Get the name of the spellbook to auto add new known spells to.
	 *
	 * @return spellbook name
	 */
	public String getSpellBookNameToAutoAddKnown()
	{
<span class="nc" id="L1986">		return getSafeStringFor(PCStringKey.SPELLBOOK_AUTO_ADD_KNOWN);</span>
	}

	/**
	 * Retrieve a spell book object given the name of the spell book.
	 *
	 * @param name
	 *            The name of the spell book to be retrieved.
	 * @return The spellbook (or null if not present).
	 */
	public SpellBook getSpellBookByName(final String name)
	{
<span class="nc" id="L1998">		return spellBookFacet.getBookNamed(id, name);</span>
	}

	/**
	 * Get spell books.
	 *
	 * @return spellBooks
	 */
	private List&lt;String&gt; getSpellBookNames()
	{
<span class="nc" id="L2008">		return new ArrayList&lt;&gt;(spellBookFacet.getBookNames(id));</span>
	}

	/**
	 * Get spell class given an index.
	 *
	 * @param ix the index
	 * @return spell class
	 */
	public PObject getSpellClassAtIndex(final int ix)
	{
<span class="nc" id="L2019">		final List&lt;? extends PObject&gt; aList = getSpellClassList();</span>

<span class="nc bnc" id="L2021" title="All 4 branches missed.">		if ((ix &gt;= 0) &amp;&amp; (ix &lt; aList.size()))</span>
		{
<span class="nc" id="L2023">			return aList.get(ix);</span>
		}

<span class="nc" id="L2026">		return null;</span>
	}

	/**
	 * Get spell level temp.
	 *
	 * @return temp spell level
	 */
	public int getSpellLevelTemp()
	{
<span class="nc" id="L2036">		return spellLevelTemp;</span>
	}

	/**
	 * Temp Bonus list.
	 *
	 * @return List
	 */
	public Map&lt;BonusObj, BonusManager.TempBonusInfo&gt; getTempBonusMap()
	{
<span class="nc" id="L2046">		return bonusManager.getTempBonusMap();</span>
	}

	/**
	 * Get temp bonus filters.
	 *
	 * @return temp bonus filters
	 */
	public Set&lt;String&gt; getTempBonusFilters()
	{
<span class="nc" id="L2056">		return bonusManager.getTempBonusFilters();</span>
	}

	/**
	 * Add the temp bonus to the filter, thus removing its effects from the character.
	 *
	 * @param aBonusStr the temporary bonus to add.
	 */
	public void setTempBonusFilter(final String aBonusStr)
	{
<span class="nc" id="L2066">		bonusManager.addTempBonusFilter(aBonusStr);</span>
<span class="nc" id="L2067">		calcActiveBonuses();</span>
<span class="nc" id="L2068">	}</span>

	/**
	 * Remove the temp bonus from the filter, thus restoring its effects to the character.
	 *
	 * @param aBonusStr the temporary bonus to remove.
	 */
	public void unsetTempBonusFilter(final String aBonusStr)
	{
<span class="nc" id="L2077">		bonusManager.removeTempBonusFilter(aBonusStr);</span>
<span class="nc" id="L2078">		calcActiveBonuses();</span>
<span class="nc" id="L2079">	}</span>

	/**
	 * Get a set of the templates applies to this pc.
	 * @return the set of Templates.
	 */
	public Collection&lt;PCTemplate&gt; getTemplateSet()
	{
<span class="nc" id="L2087">		return templateFacet.getSet(id);</span>
	}

	/**
	 * Evaluates the variable string passed in and returns its value.
	 *
	 * This should probably be refactored to return a String instead.
	 *
	 * @param variableString the variable to evaluate
	 * @param isMax if multiple values are stored, whether to return the largest value
	 * found or the first.
	 * @return the value of the variable.
	 */
	public Float getVariable(final String variableString, final boolean isMax)
	{
<span class="nc" id="L2102">		double value = 0.0;</span>
<span class="nc" id="L2103">		boolean found = false;</span>

<span class="nc bnc" id="L2105" title="All 2 branches missed.">		if (lastVariable != null)</span>
		{
<span class="nc bnc" id="L2107" title="All 2 branches missed.">			if (lastVariable.equals(variableString))</span>
			{
<span class="nc bnc" id="L2109" title="All 2 branches missed.">				if (Logging.isDebugMode())</span>
				{
<span class="nc" id="L2111">					final String sb = &quot;This is a deliberate warning message, not an error - &quot;</span>
						+ &quot;Avoiding infinite loop in getVariable: repeated lookup &quot; + &quot;of \&quot;&quot; + lastVariable + &quot;\&quot; at &quot;
						+ value;
<span class="nc" id="L2114">					Logging.debugPrint(sb);</span>
				}
<span class="nc" id="L2116">				lastVariable = null;</span>
<span class="nc" id="L2117">				return (float) value;</span>
			}
		}

		try
		{
<span class="nc" id="L2123">			VariableKey vk = VariableKey.valueOf(variableString);</span>
<span class="nc" id="L2124">			Double val = variableFacet.getVariableValue(id, vk, isMax);</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">			if (val != null)</span>
			{
<span class="nc" id="L2127">				value = val;</span>
<span class="nc" id="L2128">				found = true;</span>
			}
		}
<span class="nc" id="L2131">		catch (IllegalArgumentException e)</span>
		{
			//This variable is not in the data - must be builtin?
<span class="nc" id="L2134">		}</span>

<span class="nc" id="L2136">		boolean includeBonus = true;</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">		if (!found)</span>
		{
<span class="nc" id="L2139">			lastVariable = variableString;</span>
<span class="nc" id="L2140">			value = getVariableValue(variableString, Constants.EMPTY_STRING);</span>
<span class="nc" id="L2141">			includeBonus = false;</span>
<span class="nc" id="L2142">			lastVariable = null;</span>
		}

<span class="nc bnc" id="L2145" title="All 2 branches missed.">		if (includeBonus)</span>
		{
<span class="nc" id="L2147">			value += getTotalBonusTo(&quot;VAR&quot;, variableString);</span>
		}

<span class="nc" id="L2150">		return (float) value;</span>
	}

	public void setPointBuyPoints(final int argPointBuyPoints)
	{
<span class="nc" id="L2155">		pointBuyPoints = argPointBuyPoints;</span>
<span class="nc" id="L2156">	}</span>

	public int getPointBuyPoints()
	{
<span class="nc" id="L2160">		return pointBuyPoints;</span>
	}

	/**
	 * Sets the total Experience Points for the Player Character to the given value.
	 *
	 * Note this sets earned Experience Points as a side effect (calculated based on the
	 * level-adjusted Experience Points the Player Character may have). If the given xp
	 * value is less than the level-adjusted Experience Points possessed by the Player
	 * Character, then an error will be logged, and the earned Experience Points will be
	 * set to 0.
	 *
	 * @param xp
	 *            The total Experience Points for the Player Character
	 */
	public void setXP(int xp)
	{
		// Remove the effect of LEVELADJ when storing our
		// internal notion of experience
<span class="nc" id="L2179">		int realXP = xp - getLAXP();</span>

<span class="nc bnc" id="L2181" title="All 2 branches missed.">		if (realXP &lt; 0)</span>
		{
<span class="nc" id="L2183">			Logging.errorPrint(&quot;ERROR: too little experience: &quot; + realXP);</span>
<span class="nc" id="L2184">			realXP = 0;</span>
		}

<span class="nc bnc" id="L2187" title="All 2 branches missed.">		if (xpFacet.set(id, realXP))</span>
		{
<span class="nc" id="L2189">			setDirty(true);</span>
		}
<span class="nc" id="L2191">	}</span>

	/**
	 * Return the total Experience Points for the Player Character.
	 *
	 * @return The total Experience Points for the Player Character
	 */
	public int getXP()
	{
		// Add the effect of LEVELADJ when showing our external notion of XP.
<span class="nc" id="L2201">		Integer earnedXP = xpFacet.get(id);</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">		return ((earnedXP == null) ? 0 : earnedXP) + getLAXP();</span>
	}

	/**
	 * Returns the level-adjusted Experience Points for the Player Character.
	 *
	 * @return The level-adjusted Experience Points for the Player Character
	 */
	private int getLAXP()
	{
		/*
		 * Why +1? Adjustments are deltas, not absolute levels, so are not
		 * subject to the &quot;back off one&quot; element of the algorithm in
		 * minXPForLevel. This still means that levelAdjustment of 0 gives you 0
		 * XP, but we need LA of 1 to give us 1,000 XP.
		 */
<span class="nc" id="L2218">		return levelTableFacet.minXPForLevel(levelFacet.getLevelAdjustment(id) + 1, id);</span>
	}

	public final void setXPTable(final String xpTableName)
	{
<span class="pc bpc" id="L2223" title="1 of 2 branches missed.">		if (xpTableFacet.set(id, SettingsHandler.getGameAsProperty().get().getLevelInfo(xpTableName)))</span>
		{
<span class="nc" id="L2225">			setDirty(true);</span>
		}
<span class="fc" id="L2227">	}</span>

	public LevelInfo getXPTableLevelInfo(int level)
	{
<span class="nc" id="L2231">		return xpTableFacet.getLevelInfo(id, level);</span>
	}

	public final void setPreviewSheet(final String previewSheet)
	{
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">		if (previewSheetFacet.set(id, previewSheet))</span>
		{
<span class="fc" id="L2238">			setDirty(true);</span>
		}
<span class="fc" id="L2240">	}</span>

	public void addEquipSet(final EquipSet set)
	{
<span class="nc" id="L2244">		equipSetFacet.add(id, set);</span>
		//setDirty(true);
<span class="nc" id="L2246">	}</span>

	/**
	 * Add an item of equipment to the character.
	 *
	 * @param eq
	 *            The equipment to be added.
	 */
	public void addEquipment(final Equipment eq)
	{
<span class="nc" id="L2256">		equipmentFacet.add(id, eq, this);</span>
<span class="nc" id="L2257">		userEquipmentFacet.add(id, eq, this);</span>
		//setDirty(true);
<span class="nc" id="L2259">	}</span>

	/**
	 * Cache the output index of an automatic equipment item.
	 * @param item The equipment item.
	 */
	public void cacheOutputIndex(Equipment item)
	{
<span class="nc bnc" id="L2267" title="All 2 branches missed.">		if (item.isAutomatic())</span>
		{
<span class="nc bnc" id="L2269" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L2271">				Logging.debugPrint(&quot;Caching &quot; + item.getKeyName() + &quot; - &quot; + item.getOutputIndex() + &quot; item&quot;);</span>
			}
<span class="nc" id="L2273">			autoEquipOutputOrderCache.put(item.getKeyName(), item.getOutputIndex());</span>
		}
<span class="nc" id="L2275">	}</span>

	/**
	 * Update the number of a particular equipment item the character possesses.
	 * Mostly concerned with ensuring that the spellbook objects remain in sync
	 * with the number of equipment spellbooks.
	 *
	 * @param eq
	 *            The Equipment being updated.
	 * @param oldQty
	 *            The original number of items.
	 * @param newQty
	 *            The new number of items.
	 */
	public void updateEquipmentQty(final Equipment eq, double oldQty, double newQty)
	{
<span class="nc bnc" id="L2291" title="All 2 branches missed.">		if (eq.isType(Constants.TYPE_SPELLBOOK))</span>
		{
<span class="nc" id="L2293">			String baseBookname = eq.getName();</span>
<span class="nc" id="L2294">			String bookName = eq.getName();</span>
<span class="nc" id="L2295">			int old = (int) oldQty;</span>
<span class="nc" id="L2296">			int newQ = (int) newQty;</span>

			// Add any new items
<span class="nc bnc" id="L2299" title="All 2 branches missed.">			for (int i = old; i &lt; newQ; i++)</span>
			{
<span class="nc bnc" id="L2301" title="All 2 branches missed.">				if (i &gt; 0)</span>
				{
<span class="nc" id="L2303">					bookName = baseBookname + &quot; #&quot; + (i + 1);</span>
				}
<span class="nc" id="L2305">				SpellBook book = spellBookFacet.getBookNamed(id, bookName);</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">				if (book == null)</span>
				{
<span class="nc" id="L2308">					book = new SpellBook(bookName, SpellBook.TYPE_SPELL_BOOK);</span>
				}
<span class="nc" id="L2310">				book.setEquip(eq);</span>
<span class="nc" id="L2311">				addSpellBook(book);</span>
			}

			// Remove any old items
<span class="nc bnc" id="L2315" title="All 2 branches missed.">			for (int i = old; i &gt; newQ; i--)</span>
			{
<span class="nc bnc" id="L2317" title="All 2 branches missed.">				if (i &gt; 0)</span>
				{
<span class="nc" id="L2319">					bookName = baseBookname + &quot; #&quot; + i;</span>
				}
<span class="nc" id="L2321">				delSpellBook(bookName);</span>
			}
		}
<span class="nc" id="L2324">		setDirty(true);</span>
<span class="nc" id="L2325">	}</span>

	public void addFollower(final Follower aFollower)
	{
<span class="nc bnc" id="L2329" title="All 2 branches missed.">		if (followerFacet.add(id, aFollower))</span>
		{
<span class="nc" id="L2331">			setDirty(true);</span>
		}
<span class="nc" id="L2333">	}</span>

	private void addLocalEquipment(final Equipment eq)
	{
<span class="nc" id="L2337">		equipmentFacet.add(id, eq, this);</span>
<span class="nc" id="L2338">	}</span>

	public void addNotesItem(final NoteItem item)
	{
<span class="nc bnc" id="L2342" title="All 2 branches missed.">		if (noteItemFacet.add(id, item))</span>
		{
<span class="nc" id="L2344">			setDirty(true);</span>
		}
<span class="nc" id="L2346">	}</span>

	/**
	 * Adds a &quot;temporary&quot; bonus.
	 *
	 * @param aBonus The bonus object to add.
	 * @param source The source of the temporary bonus
	 * @param target The object getting the bonus (typically the PC, can also be equipment).
	 * @return The bonus info representing the added instance of the bonus.
	 */
	public TempBonusInfo addTempBonus(final BonusObj aBonus, Object source, Object target)
	{
<span class="nc" id="L2358">		TempBonusInfo tempBonusInfo = bonusManager.addTempBonus(aBonus, source, target);</span>
<span class="nc" id="L2359">		setDirty(true);</span>
<span class="nc" id="L2360">		return tempBonusInfo;</span>
	}

	/**
	 * Add a piece of equipment to the temporary bonus list.
	 * @param aEq The piece of equipment to add.
	 */
	public void addTempBonusItemList(final Equipment aEq)
	{
<span class="nc" id="L2369">		tempBonusItemList.add(aEq);</span>
<span class="nc" id="L2370">		setDirty(true);</span>
<span class="nc" id="L2371">	}</span>

	/**
	 * Compute the total bonus from a List of BonusObjs.
	 *
	 * @param aList The list of objects
	 * @param source The source of the bonus objects.
	 * @return The aggregate bonus
	 */
	public double calcBonusFromList(final List&lt;BonusObj&gt; aList, CDOMObject source)
	{
<span class="nc" id="L2382">		double iBonus = 0;</span>

<span class="nc bnc" id="L2384" title="All 2 branches missed.">		for (BonusObj bonus : aList)</span>
		{
<span class="nc" id="L2386">			iBonus += bonus.resolve(this, source.getQualifiedKey()).doubleValue();</span>
<span class="nc" id="L2387">		}</span>

<span class="nc" id="L2389">		return iBonus;</span>
	}

	/**
	 * Checks that the parameter passed in is in the list of objects for which this PC qualifies.
	 * @param obj the object to test for qualification.
	 * @return true if the PC is qualified to have this object.
	 */
	public boolean checkQualifyList(CDOMObject obj)
	{
<span class="nc" id="L2399">		return qualifyFacet.grantsQualify(id, obj);</span>
	}

	/**
	 * Check whether this PC has this WeaponProf.
	 * @param wp The WeaponProf to check.
	 * @return True if the PC has the WeaponProf
	 */
	public boolean hasWeaponProf(final WeaponProf wp)
	{
<span class="nc" id="L2409">		return weaponProfFacet.containsProf(id, wp);</span>
	}

	/**
	 * Remove an EqSet from the PC's Equipped Equipment.
	 * @param eSet - The EquipSet to remove.
	 * @return true if the object was removed.
	 */
	public boolean delEquipSet(final EquipSet eSet)
	{
<span class="nc" id="L2419">		boolean found = equipSetFacet.delEquipSet(id, eSet);</span>
<span class="nc" id="L2420">		setDirty(true);</span>
<span class="nc" id="L2421">		return found;</span>
	}

	/**
	 * Remove a Follower from this PC.
	 * @param aFollower The follower to remove.
	 */
	public void delFollower(final Follower aFollower)
	{
<span class="nc" id="L2430">		followerFacet.remove(id, aFollower);</span>
<span class="nc" id="L2431">		setDirty(true);</span>
<span class="nc" id="L2432">	}</span>

	/**
	 * Check whether the PC has this variable.
	 * @param variableString The variable to check for.
	 * @return True if the PC has the variable.
	 */
	public boolean hasVariable(final String variableString)
	{
		try
		{
<span class="nc" id="L2443">			return variableFacet.contains(id, VariableKey.valueOf(variableString));</span>
		}
<span class="nc" id="L2445">		catch (IllegalArgumentException e)</span>
		{
			//Built in variable
<span class="nc" id="L2448">			return false;</span>
		}
	}

	/**
	 *
	 * @param eq
	 */
	public void removeEquipment(final Equipment eq)
	{
<span class="nc bnc" id="L2458" title="All 2 branches missed.">		if (eq.isType(Constants.TYPE_SPELLBOOK))</span>
		{
<span class="nc" id="L2460">			delSpellBook(eq.getName());</span>
		}

<span class="nc" id="L2463">		equipmentFacet.remove(id, eq, this);</span>
<span class="nc" id="L2464">		userEquipmentFacet.remove(id, eq, this);</span>
<span class="nc" id="L2465">		setDirty(true);</span>
<span class="nc" id="L2466">	}</span>

	/**
	 *
	 * @param eq
	 */
	private void removeLocalEquipment(final Equipment eq)
	{
<span class="nc" id="L2474">		equipmentFacet.remove(id, eq, this);</span>
<span class="nc" id="L2475">		setDirty(true);</span>
<span class="nc" id="L2476">	}</span>

	/**
	 * @param allowDebt the allowDebt to set
	 */
	public void setAllowDebt(boolean allowDebt)
	{
<span class="nc" id="L2483">		allowDebtFacet.set(id, allowDebt);</span>
<span class="nc" id="L2484">	}</span>

	public String getAttackString(AttackType at)
	{
<span class="nc" id="L2488">		return getAttackString(at, 0);</span>
	}

	public String getAttackString(AttackType at, final int bonus)
	{
<span class="nc" id="L2493">		return getAttackString(at, bonus, 0);</span>
	}

	/**
	 * Calculates and returns an attack string for one of Melee, Ranged or
	 * Unarmed damage. This will be returned in attack string format i.e.
	 * +11/+6/+1. The attack string returned by this function normally only
	 * includes the attacks generated by the characters Base Attack Bonus. There
	 * are two bonuses to TOHIT that may be applied to the attack string
	 * returned by this function. The first bonus increases only the size of the
	 * attacks generated. The second increases both the size and number of
	 * attacks
	 *
	 * @param at
	 *            The type of attack. Takes an AttackType (an enumeration)
	 *
	 * @param TOHITBonus
	 *            A bonus that will be added to the TOHIT numbers. This bonus
	 *            affects only the numbers produced, not the number of attacks
	 *
	 * @param BABBonus
	 *            This bonus will be added to BAB before the number of attacks
	 *            has been determined.
	 * @return The attack string for this character
	 */

	public String getAttackString(AttackType at, final int TOHITBonus, int BABBonus)
	{
<span class="nc" id="L2521">		final String cacheLookup = &quot;AttackString:&quot; + at.getIdentifier() + ',' + TOHITBonus + ',' + BABBonus;</span>
<span class="nc" id="L2522">		final String cached = variableProcessor.getCachedString(cacheLookup);</span>

<span class="nc bnc" id="L2524" title="All 2 branches missed.">		if (cached != null)</span>
		{
<span class="nc" id="L2526">			return cached;</span>
		}

		// index: 0 = melee; 1 = ranged; 2 = unarmed
		// now we see if this PC is a Familiar
		// Initialise to some large negative number
<span class="nc" id="L2532">		int masterBAB = -9999;</span>
<span class="nc" id="L2533">		int masterTotal = -9999;</span>
<span class="nc" id="L2534">		final PlayerCharacter nPC = getMasterPC();</span>

<span class="nc bnc" id="L2536" title="All 4 branches missed.">		if ((nPC != null) &amp;&amp; (!masterFacet.getCopyMasterBAB(id).isEmpty()))</span>
		{
<span class="nc" id="L2538">			masterBAB = nPC.baseAttackBonus();</span>

<span class="nc" id="L2540">			final String copyMasterBAB = replaceMasterString(masterFacet.getCopyMasterBAB(id), masterBAB);</span>
<span class="nc" id="L2541">			masterBAB = getVariableValue(copyMasterBAB, Constants.EMPTY_STRING).intValue();</span>
<span class="nc" id="L2542">			masterTotal = masterBAB + TOHITBonus;</span>
		}

<span class="nc" id="L2545">		final int BAB = baseAttackBonus();</span>

<span class="nc" id="L2547">		int attackCycle = 1;</span>
<span class="nc" id="L2548">		int workingBAB = BAB + TOHITBonus;</span>
<span class="nc" id="L2549">		int subTotal = BAB;</span>
<span class="nc" id="L2550">		int raceBAB = 0;</span>

<span class="nc" id="L2552">		final List&lt;Integer&gt; ab = new ArrayList&lt;&gt;(10);</span>
<span class="nc" id="L2553">		final StringBuilder attackString = new StringBuilder(30);</span>

		// Assume a max of 10 attack cycles
<span class="nc bnc" id="L2556" title="All 2 branches missed.">		for (int total = 0; total &lt; 10; ++total)</span>
		{
<span class="nc" id="L2558">			ab.add(0);</span>
		}

		// Some classes (like the Monk or Ranged Sniper) use
		// a different attack cycle than the standard classes
		// So compute the base attack for this type (BAB, RAB, UAB)
<span class="nc bnc" id="L2564" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
			// Get the attack bonus
<span class="nc" id="L2567">			final int b = pcClass.baseAttackBonus(this);</span>

			// Get the attack cycle
<span class="nc" id="L2570">			final int c = pcClass.attackCycle(at);</span>

			// add to all other classes
<span class="nc bnc" id="L2573" title="All 2 branches missed.">			if (c &lt; ab.size())</span>
			{
<span class="nc" id="L2575">				final int d = ab.get(c) + b;</span>

				// set new value for iteration
<span class="nc" id="L2578">				ab.set(c, d);</span>
			}

<span class="nc bnc" id="L2581" title="All 2 branches missed.">			if (c != 3)</span>
			{
<span class="nc" id="L2583">				raceBAB += b;</span>
			}
<span class="nc" id="L2585">		}</span>

		// Iterate through all the possible attack cycle values
		// and find the one with the highest attack value
<span class="nc bnc" id="L2589" title="All 2 branches missed.">		for (int i = 2; i &lt; 10; ++i)</span>
		{
<span class="nc" id="L2591">			final int newAttack = ab.get(i);</span>
<span class="nc" id="L2592">			final int oldAttack = ab.get(attackCycle);</span>

<span class="nc bnc" id="L2594" title="All 2 branches missed.">			if ((newAttack / i) &gt; (oldAttack / attackCycle))</span>
			{
<span class="nc" id="L2596">				attackCycle = i;</span>
			}
		}
		// total Number of Attacks for this PC
<span class="nc" id="L2600">		int attackTotal = ab.get(attackCycle);</span>

		// Default cut-off before multiple attacks (e.g. 5)
<span class="nc" id="L2603">		final int defaultAttackCycle = SettingsHandler.getGameAsProperty().get().getBabAttCyc();</span>

<span class="nc bnc" id="L2605" title="All 2 branches missed.">		if (attackTotal == 0)</span>
		{
<span class="nc" id="L2607">			attackCycle = defaultAttackCycle;</span>
		}

		// FAMILIAR: check to see if the masters BAB is better
<span class="nc" id="L2611">		workingBAB = Math.max(workingBAB, masterTotal);</span>
<span class="nc" id="L2612">		subTotal = Math.max(subTotal, masterBAB);</span>
<span class="nc" id="L2613">		raceBAB = Math.max(raceBAB, masterBAB);</span>

<span class="nc bnc" id="L2615" title="All 2 branches missed.">		if (attackCycle != defaultAttackCycle)</span>
		{
<span class="nc bnc" id="L2617" title="All 2 branches missed.">			if ((attackTotal / attackCycle) &lt; (subTotal / defaultAttackCycle))</span>
			{
<span class="nc" id="L2619">				attackCycle = defaultAttackCycle;</span>
<span class="nc" id="L2620">				attackTotal = subTotal;</span>
			}
			else
			{
<span class="nc" id="L2624">				workingBAB -= raceBAB;</span>
<span class="nc" id="L2625">				subTotal -= raceBAB;</span>
			}
		}

<span class="nc" id="L2629">		int maxAttacks = SettingsHandler.getGameAsProperty().get().getBabMaxAtt();</span>
<span class="nc" id="L2630">		final int minMultiBab = SettingsHandler.getGameAsProperty().get().getBabMinVal();</span>

		// If there is a bonus to BAB, it needs to be added to ALL of
		// the variables used to determine the number of attacks
<span class="nc" id="L2634">		attackTotal += BABBonus;</span>
<span class="nc" id="L2635">		workingBAB += BABBonus;</span>
<span class="nc" id="L2636">		subTotal += BABBonus;</span>

		do
		{
<span class="nc bnc" id="L2640" title="All 2 branches missed.">			if (attackString.length() &gt; 0)</span>
			{
<span class="nc" id="L2642">				attackString.append('/');</span>
			}

<span class="nc" id="L2645">			attackString.append(Delta.toString(workingBAB));</span>
<span class="nc" id="L2646">			workingBAB -= attackCycle;</span>
<span class="nc" id="L2647">			attackTotal -= attackCycle;</span>
<span class="nc" id="L2648">			subTotal -= attackCycle;</span>
<span class="nc" id="L2649">			maxAttacks--;</span>
		}
<span class="nc bnc" id="L2651" title="All 6 branches missed.">		while (((attackTotal &gt;= minMultiBab) || (subTotal &gt;= minMultiBab)) &amp;&amp; (maxAttacks &gt; 0));</span>

<span class="nc" id="L2653">		variableProcessor.addCachedString(cacheLookup, attackString.toString());</span>
<span class="nc" id="L2654">		return attackString.toString();</span>
	}

	/**
	 * @return the autoResize
	 */
	public boolean isAutoResize()
	{
<span class="nc" id="L2662">		return autoResize;</span>
	}

	/**
	 * @param autoResize the autoResize to set
	 */
	public void setAutoResize(boolean autoResize)
	{
<span class="nc" id="L2670">		this.autoResize = autoResize;</span>
<span class="nc" id="L2671">	}</span>

	/**
	 * whether we should add auto known spells at level up
	 *
	 * @param aBool
	 */
	public void setAutoSpells(final boolean aBool)
	{
<span class="nc bnc" id="L2680" title="All 2 branches missed.">		if (autoKnownSpells != aBool)</span>
		{
<span class="nc" id="L2682">			autoKnownSpells = aBool;</span>
<span class="nc" id="L2683">			setDirty(true);</span>
		}
<span class="nc" id="L2685">	}</span>

	public boolean getAutoSpells()
	{
<span class="nc" id="L2689">		return autoKnownSpells;</span>
	}

	/**
	 * @param ignoreCost the ignoreCost to set
	 */
	public void setIgnoreCost(boolean ignoreCost)
	{
<span class="nc" id="L2697">		ignoreCostFacet.set(id, ignoreCost);</span>
<span class="nc" id="L2698">	}</span>

	/**
	 * Determine whether higher level known spell slots can be used for lower
	 * level spells, or if known spells are restricted to their own level only.
	 *
	 * @return Returns the useHigherKnownSlots.
	 */
	public boolean getUseHigherKnownSlots()
	{
<span class="nc" id="L2708">		return useHigherKnownSlots;</span>
	}

	/**
	 * Set whether higher level known spell slots can be used for lower level
	 * spells, or if known spells are restricted to their own level only.
	 *
	 * @param useHigher
	 *            Can higher level known spell slots be used?
	 */
	public void setUseHigherKnownSlots(boolean useHigher)
	{
<span class="nc" id="L2720">		this.useHigherKnownSlots = useHigher;</span>
<span class="nc" id="L2721">	}</span>

	/**
	 * Determine whether higher level prepared spell slots can be used for lower
	 * level spells, or if prepared spells are restricted to their own level
	 * only.
	 *
	 * @return Returns the useHigherPreppedSlots.
	 */
	public boolean getUseHigherPreppedSlots()
	{
<span class="nc" id="L2732">		return useHigherPreppedSlots;</span>
	}

	/**
	 * Set whether higher level prepared spell slots can be used for lower level
	 * spells, or if prepared spells are restricted to their own level only.
	 *
	 * @param useHigher
	 *            Can higher level prepared spell slots be used?
	 */
	public void setUseHigherPreppedSlots(boolean useHigher)
	{
<span class="nc" id="L2744">		this.useHigherPreppedSlots = useHigher;</span>
<span class="nc" id="L2745">	}</span>

	/**
	 * Returns the &amp;quot;Base&amp;quot; check value for the check at the index
	 * specified.
	 *
	 * @param check
	 *            The index of the check to get
	 *
	 * @return The base check value.
	 */
	public int getBaseCheck(final PCCheck check)
	{
<span class="nc" id="L2758">		String checkVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.BASESAVE);</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">		if (checkVar != null)</span>
		{
<span class="nc" id="L2761">			return ((Number) this.getLocal(check, checkVar)).intValue();</span>
		}

<span class="nc" id="L2764">		final String cacheLookup = &quot;getBaseCheck:&quot; + check.getKeyName(); //$NON-NLS-1$</span>

<span class="nc" id="L2766">		Float total = variableProcessor.getCachedVariable(cacheLookup);</span>

<span class="nc bnc" id="L2768" title="All 2 branches missed.">		if (total != null)</span>
		{
<span class="nc" id="L2770">			return total.intValue();</span>
		}

<span class="nc" id="L2773">		double bonus = 0;</span>

<span class="nc" id="L2775">		final String checkName = check.getKeyName();</span>

		//Apply non-magical bonuses
<span class="nc" id="L2778">		bonus += getTotalBonusTo(&quot;SAVE&quot;, &quot;BASE.&quot; + checkName);</span>

		//
		// now we see if this PC is a Familiar/Mount
<span class="nc" id="L2782">		final PlayerCharacter nPC = getMasterPC();</span>
<span class="nc bnc" id="L2783" title="All 4 branches missed.">		if ((nPC != null) &amp;&amp; (!masterFacet.getCopyMasterCheck(id).isEmpty()))</span>
		{
<span class="nc" id="L2785">			int masterBonus = nPC.getBaseCheck(check);</span>

<span class="nc" id="L2787">			final String copyMasterCheck = replaceMasterString(masterFacet.getCopyMasterCheck(id), masterBonus);</span>
<span class="nc" id="L2788">			masterBonus = getVariableValue(copyMasterCheck, Constants.EMPTY_STRING).intValue();</span>

			// use masters save if better
<span class="nc" id="L2791">			bonus = Math.max(bonus, masterBonus);</span>
		}

<span class="nc" id="L2794">		variableProcessor.addCachedVariable(cacheLookup, (float) bonus);</span>
<span class="nc" id="L2795">		return (int) bonus;</span>
	}

	/**
	 * Returns the total check value for the check specified for the character.
	 *
	 * &lt;p&gt;
	 * This total includes all check bonuses the character has.
	 *
	 * @param check
	 *            The check to get.
	 *
	 * @return A check value.
	 */
	public int getTotalCheck(PCCheck check)
	{
<span class="nc" id="L2811">		String checkVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.TOTALSAVE);</span>
<span class="nc bnc" id="L2812" title="All 2 branches missed.">		if (checkVar != null)</span>
		{
<span class="nc" id="L2814">			return ((Number) this.getLocal(check, checkVar)).intValue();</span>
		}
<span class="nc" id="L2816">		return getBaseCheck(check) + (int) getTotalBonusTo(&quot;SAVE&quot;, check.getKeyName());</span>
	}

	/**
	 * return bonus total for a specific bonusType e.g:
	 * getBonusDueToType(&quot;COMBAT&quot;,&quot;AC&quot;,&quot;Armor&quot;) to get armor bonuses
	 *
	 * @param mainType
	 * @param subType
	 * @param bonusType
	 * @return bonus due to type
	 */
	public double getBonusDueToType(final String mainType, final String subType, final String bonusType)
	{
<span class="nc" id="L2830">		return bonusManager.getBonusDueToType(mainType, subType, bonusType);</span>
	}

	/**
	 * Retrieves an unsorted list of the character's equipment matching the
	 * supplied type and status criteria.
	 *
	 * @param typeName
	 *            The type of equipment to be selected
	 * @param status
	 *            The required status: 1 (equipped) 2 (not equipped) 3 (don't
	 *            care)
	 * @return An ArrayList of the matching equipment objects.
	 */
	public List&lt;Equipment&gt; getEquipmentOfType(final String typeName, final int status)
	{
<span class="nc" id="L2846">		return getEquipmentOfType(typeName, Constants.EMPTY_STRING, status);</span>
	}

	/**
	 * Retrieves an unsorted list of the character's equipment matching the
	 * supplied type, sub type and status criteria.
	 *
	 * @param typeName
	 *            The type of equipment to be selected
	 * @param subtypeName
	 *            The subtype of equipment to be selected (empty string for no
	 *            subtype)
	 * @param status
	 *            The required status: 1 (equipped) 2 (not equipped) 3 (don't
	 *            care)
	 * @return An ArrayList of the matching equipment objects.
	 */
	public List&lt;Equipment&gt; getEquipmentOfType(final String typeName, final String subtypeName, final int status)
	{
<span class="nc" id="L2865">		final List&lt;Equipment&gt; aArrayList = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L2867" title="All 2 branches missed.">		for (Equipment eq : getEquipmentSet())</span>
		{
<span class="nc bnc" id="L2869" title="All 4 branches missed.">			final boolean subTypeOk = Constants.EMPTY_STRING.equals(subtypeName) || eq.typeStringContains(subtypeName);</span>

<span class="nc bnc" id="L2871" title="All 4 branches missed.">			final boolean statusOk =</span>
<span class="nc bnc" id="L2872" title="All 6 branches missed.">					status == 3 || (status == 2 &amp;&amp; !eq.isEquipped()) || (status == 1 &amp;&amp; eq.isEquipped());</span>

<span class="nc bnc" id="L2874" title="All 6 branches missed.">			if (eq.typeStringContains(typeName) &amp;&amp; subTypeOk &amp;&amp; statusOk)</span>
			{
<span class="nc" id="L2876">				aArrayList.add(eq);</span>
			}
<span class="nc" id="L2878">		}</span>

<span class="nc" id="L2880">		return aArrayList;</span>
	}

	/**
	 * Retrieves a list, sorted in output order, of the character's equipment
	 * matching the supplied type and status criteria. This list is in ascending
	 * order of the equipment's outputIndex field. If multiple items of
	 * equipment have the same outputIndex they will be ordered by name. Note
	 * hidden items (outputIndex = -1) are not included in this list.
	 *
	 * @param typeName
	 *            The type of equipment to be selected
	 * @param status
	 *            The required status: 1 (equipped) 2 (not equipped) 3 (don't
	 *            care)
	 * @return An ArrayList of the matching equipment objects in output order.
	 */
	public List&lt;Equipment&gt; getEquipmentOfTypeInOutputOrder(final String typeName, final int status)
	{
<span class="nc" id="L2899">		return sortEquipmentList(getEquipmentOfType(typeName, status), Constants.MERGE_ALL);</span>
	}

	/**
	 * @param typeName
	 *            The type of equipment to be selected
	 * @param status
	 *            The required status
	 * @param merge
	 *            What type of merge for like equipment
	 * @return An ArrayList of equipment objects
	 */
	public List&lt;Equipment&gt; getEquipmentOfTypeInOutputOrder(final String typeName, final int status, final int merge)
	{
<span class="nc" id="L2913">		return sortEquipmentList(getEquipmentOfType(typeName, status), merge);</span>
	}

	/**
	 * @param typeName
	 *            The type of equipment to be selected
	 * @param subtypeName
	 *            The subtype of equipment to be selected
	 * @param status
	 *            The required status
	 * @param merge
	 *            What sort of merging should occur
	 * @return An ArrayList of equipment objects
	 */
	public List&lt;Equipment&gt; getEquipmentOfTypeInOutputOrder(final String typeName, final String subtypeName,
		final int status, final int merge)
	{
<span class="nc" id="L2930">		return sortEquipmentList(getEquipmentOfType(typeName, subtypeName, status), merge);</span>
	}

	/**
	 * Retrieve the expanded list of weapons Expanded weapons include: double
	 * weapons and melee+ranged weapons Output order is assumed Merge of like
	 * equipment depends on the passed in int
	 *
	 * @param merge The type of merge to perform
	 *
	 * @return the sorted list of weapons.
	 */
	public List&lt;Equipment&gt; getExpandedWeapons(final int merge)
	{
<span class="nc" id="L2944">		final List&lt;Equipment&gt; weapList = sortEquipmentList(getEquipmentOfType(&quot;Weapon&quot;, 3), merge);</span>

		//
		// If any weapon is both Melee and Ranged, then make 2 weapons
		// for list, one Melee only, the other Ranged and Thrown.
		// For double weapons, if wielded in two hands show attacks
		// for both heads, head 1 and head 2 else
		// if wielded in 1 hand, just show damage by head
		//
<span class="nc bnc" id="L2953" title="All 2 branches missed.">		for (int idx = 0; idx &lt; weapList.size(); ++idx)</span>
		{
<span class="nc" id="L2955">			final Equipment equip = weapList.get(idx);</span>

<span class="nc bnc" id="L2957" title="All 4 branches missed.">			if (equip.isDouble() &amp;&amp; (equip.getLocation() == EquipmentLocation.EQUIPPED_TWO_HANDS))</span>
			{
<span class="nc" id="L2959">				Equipment eqm = equip.clone();</span>
<span class="nc" id="L2960">				eqm.removeType(Type.DOUBLE);</span>
<span class="nc" id="L2961">				eqm.addType(Type.HEAD1);</span>

				// Add &quot;Head 1 only&quot; to the name of the weapon
<span class="nc" id="L2964">				eqm.setWholeItemName(eqm.getName());</span>
<span class="nc" id="L2965">				eqm.setName(EquipmentUtilities.appendToName(eqm.getName(), &quot;Head 1 only&quot;));</span>

<span class="nc bnc" id="L2967" title="All 2 branches missed.">				if (!eqm.getOutputName().contains(&quot;Head 1 only&quot;))</span>
				{
<span class="nc" id="L2969">					eqm.put(StringKey.OUTPUT_NAME, EquipmentUtilities.appendToName(eqm.getOutputName(), &quot;Head 1 only&quot;));</span>
				}

<span class="nc" id="L2972">				setProf(equip, eqm);</span>
<span class="nc" id="L2973">				weapList.add(idx + 1, eqm);</span>

<span class="nc" id="L2975">				eqm = equip.clone();</span>

<span class="nc" id="L2977">				final String altType = eqm.getType(false);</span>
<span class="nc bnc" id="L2978" title="All 2 branches missed.">				if (!altType.isEmpty())</span>
				{
<span class="nc" id="L2980">					eqm.removeListFor(ListKey.TYPE);</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">					for (String s : altType.split(&quot;\\.&quot;))</span>
					{
<span class="nc" id="L2983">						eqm.addType(Type.getConstant(s));</span>
					}
				}

<span class="nc" id="L2987">				eqm.removeType(Type.DOUBLE);</span>
<span class="nc" id="L2988">				eqm.addType(Type.HEAD2);</span>
<span class="nc" id="L2989">				EquipmentHead head = eqm.getEquipmentHead(1);</span>
<span class="nc" id="L2990">				String altDamage = eqm.getAltDamage(this);</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">				if (!altDamage.isEmpty())</span>
				{
<span class="nc" id="L2993">					head.put(StringKey.DAMAGE, altDamage);</span>
				}
<span class="nc" id="L2995">				head.put(IntegerKey.CRIT_MULT, eqm.getAltCritMultiplier());</span>
<span class="nc" id="L2996">				head.put(IntegerKey.CRIT_RANGE, eqm.getRawCritRange(false));</span>
<span class="nc" id="L2997">				head.removeListFor(ListKey.EQMOD);</span>
<span class="nc" id="L2998">				head.addAllToListFor(ListKey.EQMOD, eqm.getEqModifierList(false));</span>

				// Add &quot;Head 2 only&quot; to the name of the weapon
<span class="nc" id="L3001">				eqm.setWholeItemName(eqm.getName());</span>
<span class="nc" id="L3002">				eqm.setName(EquipmentUtilities.appendToName(eqm.getName(), &quot;Head 2 only&quot;));</span>

<span class="nc bnc" id="L3004" title="All 2 branches missed.">				if (!eqm.getOutputName().contains(&quot;Head 2 only&quot;))</span>
				{
<span class="nc" id="L3006">					eqm.put(StringKey.OUTPUT_NAME, EquipmentUtilities.appendToName(eqm.getOutputName(), &quot;Head 2 only&quot;));</span>
				}

<span class="nc" id="L3009">				setProf(equip, eqm);</span>
<span class="nc" id="L3010">				weapList.add(idx + 2, eqm);</span>
<span class="nc" id="L3011">			}</span>

			//
			// Leave else here, as otherwise will show attacks
			// for both heads for thrown double weapons when
			// it should only show one
			//
<span class="nc bnc" id="L3018" title="All 4 branches missed.">			else if (equip.isMelee() &amp;&amp; equip.isRanged())</span>
			{
				//
				// Strip off the Ranged portion, set range to 0
				//
<span class="nc" id="L3023">				Equipment eqm = equip.clone();</span>
<span class="nc" id="L3024">				eqm.addType(Type.BOTH);</span>
<span class="nc" id="L3025">				eqm.removeType(Type.RANGED);</span>
<span class="nc" id="L3026">				eqm.removeType(Type.THROWN);</span>
<span class="nc" id="L3027">				eqm.put(IntegerKey.RANGE, 0);</span>
<span class="nc" id="L3028">				setProf(equip, eqm);</span>
<span class="nc" id="L3029">				weapList.set(idx, eqm);</span>

<span class="nc" id="L3031">				boolean replacedPrimary = primaryWeaponFacet.replace(id, equip, eqm);</span>
<span class="nc" id="L3032">				boolean replacedSecondary = secondaryWeaponFacet.replace(id, equip, eqm);</span>

				//
				// Add thrown portion, strip Melee
				//
<span class="nc" id="L3037">				Equipment eqr = equip.clone();</span>
<span class="nc" id="L3038">				eqr.addType(Type.RANGED);</span>
<span class="nc" id="L3039">				eqr.addType(Type.THROWN);</span>
<span class="nc" id="L3040">				eqr.addType(Type.BOTH);</span>
<span class="nc" id="L3041">				eqr.removeType(Type.MELEE);</span>

				// Add &quot;Thrown&quot; to the name of the weapon
<span class="nc" id="L3044">				eqr.setName(EquipmentUtilities.appendToName(eqr.getName(), &quot;Thrown&quot;));</span>

<span class="nc bnc" id="L3046" title="All 2 branches missed.">				if (!eqr.getOutputName().contains(&quot;Thrown&quot;))</span>
				{
<span class="nc" id="L3048">					eqr.put(StringKey.OUTPUT_NAME, EquipmentUtilities.appendToName(eqr.getOutputName(), &quot;Thrown&quot;));</span>
				}

<span class="nc" id="L3051">				setProf(equip, eqr);</span>
<span class="nc" id="L3052">				weapList.add(++idx, eqr);</span>

<span class="nc bnc" id="L3054" title="All 2 branches missed.">				if (replacedPrimary)</span>
				{
<span class="nc" id="L3056">					primaryWeaponFacet.addAfter(id, eqm, eqr);</span>
				}
<span class="nc bnc" id="L3058" title="All 2 branches missed.">				else if (replacedSecondary)</span>
				{
<span class="nc" id="L3060">					secondaryWeaponFacet.addAfter(id, eqm, eqr);</span>
				}
			}
		}

<span class="nc" id="L3065">		return weapList;</span>
	}

	/**
	 * Calculates total bonus from Feats
	 *
	 * @param aType
	 * @param aName
	 * @return feat bonus to
	 */
	public double getFeatBonusTo(String aType, String aName)
	{
<span class="nc" id="L3077">		final Map&lt;String, Ability&gt; aHashMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L3079" title="All 2 branches missed.">		for (Ability aFeat : getAbilityList(AbilityCategory.FEAT, Nature.NORMAL))</span>
		{
<span class="nc bnc" id="L3081" title="All 2 branches missed.">			if (aFeat != null)</span>
			{
<span class="nc" id="L3083">				aHashMap.put(aFeat.getKeyName(), aFeat);</span>
			}
<span class="nc" id="L3085">		}</span>

<span class="nc" id="L3087">		addUniqueAbilitiesToMap(aHashMap, getAbilityList(AbilityCategory.FEAT, Nature.VIRTUAL));</span>
<span class="nc" id="L3088">		addUniqueAbilitiesToMap(aHashMap, getAbilityList(AbilityCategory.FEAT, Nature.AUTOMATIC));</span>
<span class="nc" id="L3089">		List&lt;Ability&gt; aggregateFeatList = new ArrayList&lt;&gt;(aHashMap.values());</span>
<span class="nc" id="L3090">		return getPObjectWithCostBonusTo(aggregateFeatList, aType.toUpperCase(), aName.toUpperCase());</span>
	}

	public Ability getMatchingAbility(Category&lt;Ability&gt; abilityCategory, Ability ability, Nature nature)
	{
<span class="nc" id="L3095">		Collection&lt;CNAbility&gt; cnas = grantedAbilityFacet.getPoolAbilities(id, abilityCategory, nature);</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">		for (CNAbility cna : cnas)</span>
		{
<span class="nc bnc" id="L3098" title="All 2 branches missed.">			if (cna.getAbilityKey().equals(ability.getKeyName()))</span>
			{
<span class="nc" id="L3100">				return cna.getAbility();</span>
			}
<span class="nc" id="L3102">		}</span>
<span class="nc" id="L3103">		return null;</span>
	}

	public void setHasMadeKitSelectionForAgeSet(final int index, final boolean arg)
	{
<span class="nc bnc" id="L3108" title="All 4 branches missed.">		if ((index &gt;= 0) &amp;&amp; (index &lt; 10))</span>
		{
<span class="nc" id="L3110">			ageSetKitSelections[index] = arg;</span>
		}
<span class="nc" id="L3112">		setDirty(true);</span>
<span class="nc" id="L3113">	}</span>

	public Collection&lt;Kit&gt; getKitInfo()
	{
<span class="nc" id="L3117">		return kitFacet.getSet(id);</span>
	}

	public final Collection&lt;PCLevelInfo&gt; getLevelInfo()
	{
<span class="nc" id="L3122">		return levelInfoFacet.getSet(id);</span>
	}

	public Collection&lt;PCLevelInfo&gt; clearLevelInfo()
	{
<span class="nc" id="L3127">		return levelInfoFacet.removeAll(id);</span>
	}

	public PCLevelInfo getLevelInfo(int index)
	{
<span class="nc" id="L3132">		return levelInfoFacet.get(id, index);</span>
	}

	public String getLevelInfoClassKeyName(final int idx)
	{
<span class="nc bnc" id="L3137" title="All 4 branches missed.">		if ((idx &gt;= 0) &amp;&amp; (idx &lt; getLevelInfoSize()))</span>
		{
<span class="nc" id="L3139">			return levelInfoFacet.get(id, idx).getClassKeyName();</span>
		}

<span class="nc" id="L3142">		return Constants.EMPTY_STRING;</span>
	}

	public PCLevelInfo getLevelInfoFor(final String classKey, int level)
	{
<span class="nc bnc" id="L3147" title="All 2 branches missed.">		for (PCLevelInfo pcl : getLevelInfo())</span>
		{
<span class="nc bnc" id="L3149" title="All 2 branches missed.">			if (pcl.getClassKeyName().equals(classKey))</span>
			{
<span class="nc" id="L3151">				level--;</span>
			}

<span class="nc bnc" id="L3154" title="All 2 branches missed.">			if (level &lt;= 0)</span>
			{
<span class="nc" id="L3156">				return pcl;</span>
			}
<span class="nc" id="L3158">		}</span>

<span class="nc" id="L3160">		return null;</span>
	}

	public int getLevelInfoSize()
	{
<span class="nc" id="L3165">		return levelInfoFacet.getCount(id);</span>
	}

	/**
	 * whether we should load companions on master load
	 *
	 * @param aBool
	 */
	public void setLoadCompanion(final boolean aBool)
	{
<span class="nc bnc" id="L3175" title="All 2 branches missed.">		if (autoLoadCompanion != aBool)</span>
		{
<span class="nc" id="L3177">			autoLoadCompanion = aBool;</span>
<span class="nc" id="L3178">			setDirty(true);</span>
		}
<span class="nc" id="L3180">	}</span>

	public boolean getLoadCompanion()
	{
<span class="nc" id="L3184">		return autoLoadCompanion;</span>
	}

	/**
	 * @return the number of Character Domains possible
	 */
	public int getMaxCharacterDomains()
	{
<span class="nc" id="L3192">		return (int) getTotalBonusTo(&quot;DOMAIN&quot;, &quot;NUMBER&quot;);</span>
	}

	/**
	 * @param source
	 * @param aPC
	 * @return the number of Character Domains possible and check the level of
	 *         the source class if the result is 0.
	 */
	public int getMaxCharacterDomains(final PCClass source, final PlayerCharacter aPC)
	{
<span class="nc" id="L3203">		int i = getMaxCharacterDomains();</span>
<span class="nc bnc" id="L3204" title="All 4 branches missed.">		if (i == 0 &amp;&amp; !hasDefaultDomainSource())</span>
		{
<span class="nc" id="L3206">			i = (int) source.getBonusTo(&quot;DOMAIN&quot;, &quot;NUMBER&quot;, getLevel(source), aPC);</span>
		}
<span class="nc" id="L3208">		return i;</span>
	}

	/**
	 * Calculate the maximum number of ranks the character is allowed to have in
	 * the specified skill.
	 *
	 * @param aSkill
	 *            The skill being checked.
	 * @param aClass
	 *            The name of the current class in which points are being spent -
	 *            only used to check cross-class skill cost.
	 * @return max rank
	 */
	public Float getMaxRank(Skill aSkill, final PCClass aClass)
	{
<span class="nc" id="L3224">		int levelForSkillPurposes = getTotalLevels();</span>
		final BigDecimal maxRanks;

<span class="nc bnc" id="L3227" title="All 2 branches missed.">		if (aSkill == null)</span>
		{
<span class="nc" id="L3229">			return 0.0f;</span>
		}
<span class="nc bnc" id="L3231" title="All 2 branches missed.">		if (aSkill.getSafe(ObjectKey.EXCLUSIVE))</span>
		{
			// Exclusive skills only count levels in classes which give access
			// to the skill
<span class="nc" id="L3235">			levelForSkillPurposes = 0;</span>

<span class="nc bnc" id="L3237" title="All 2 branches missed.">			for (PCClass bClass : getClassSet())</span>
			{
<span class="nc bnc" id="L3239" title="All 2 branches missed.">				if (this.isClassSkill(bClass, aSkill))</span>
				{
<span class="nc" id="L3241">					levelForSkillPurposes += getLevel(bClass);</span>
				}
<span class="nc" id="L3243">			}</span>

<span class="nc bnc" id="L3245" title="All 2 branches missed.">			if (levelForSkillPurposes == 0)</span>
			{
				// No classes qualify for this exclusive skill, so treat it as a
				// cross-class skill
				// This does not seem right to me! JD
<span class="nc" id="L3250">				levelForSkillPurposes = (getTotalLevels());</span>

<span class="nc" id="L3252">				maxRanks = SkillUtilities.maxCrossClassSkillForLevel(levelForSkillPurposes, this);</span>
			}
			else
			{
<span class="nc" id="L3256">				maxRanks = SkillUtilities.maxClassSkillForLevel(levelForSkillPurposes, this);</span>
			}
		}
<span class="nc bnc" id="L3259" title="All 4 branches missed.">		else if (!this.isClassSkill(aSkill) &amp;&amp; (this.getSkillCostForClass(aSkill, aClass) == SkillCost.CLASS))</span>
		{
			// Cross class skill - but as cost is 1 only return a whole number
<span class="nc" id="L3262">			maxRanks =</span>
					new BigDecimal(
<span class="nc" id="L3264">						SkillUtilities.maxCrossClassSkillForLevel(</span>
<span class="nc" id="L3265">							levelForSkillPurposes, this).intValue()); // This was (int) (i/2.0) previously</span>
		}
<span class="nc bnc" id="L3267" title="All 2 branches missed.">		else if (!this.isClassSkill(aSkill))</span>
		{
			// Cross class skill
<span class="nc" id="L3270">			maxRanks = SkillUtilities.maxCrossClassSkillForLevel(levelForSkillPurposes, this);</span>
		}
		else
		{
			// Class skill
<span class="nc" id="L3275">			maxRanks = SkillUtilities.maxClassSkillForLevel(levelForSkillPurposes, this);</span>
		}
<span class="nc" id="L3277">		return maxRanks.floatValue();</span>
	}

	/**
	 * Checks if the stat is a non ability.
	 *
	 * @return true, if is non ability
	 */
	public boolean isNonAbility(PCStat stat)
	{
<span class="nc" id="L3287">		return nonAbilityFacet.isNonAbility(id, stat);</span>
	}

	public int getOffHandLightBonus()
	{
<span class="nc" id="L3292">		return getVariableValue(&quot;OFFHANDLIGHTBONUS&quot;, Constants.EMPTY_STRING).intValue();</span>
	}

	public boolean isProficientWith(final Equipment eq)
	{
<span class="nc bnc" id="L3297" title="All 2 branches missed.">		if (eq.isShield())</span>
		{
<span class="nc" id="L3299">			return shieldProfFacet.isProficientWithShield(id, eq);</span>
		}
<span class="nc bnc" id="L3301" title="All 2 branches missed.">		else if (eq.isArmor())</span>
		{
<span class="nc" id="L3303">			return armorProfFacet.isProficientWithArmor(id, eq);</span>
		}
<span class="nc bnc" id="L3305" title="All 2 branches missed.">		else if (eq.isWeapon())</span>
		{
<span class="nc" id="L3307">			return weaponProfFacet.isProficientWithWeapon(id, eq);</span>
		}

<span class="nc" id="L3310">		return false;</span>
	}

	/**
	 * Changes the race of the character. First it removes the current Race,
	 * then add the new Race.
	 *
	 * @param newRace
	 */
	public final boolean setRace(final Race newRace)
	{
		boolean success;
<span class="pc bpc" id="L3322" title="1 of 2 branches missed.">		if (newRace == null)</span>
		{
<span class="nc" id="L3324">			success = raceInputFacet.set(id, RaceUtilities.getUnselectedRace());</span>
		}
		else
		{
<span class="fc" id="L3328">			success = raceInputFacet.set(id, newRace);</span>
		}

<span class="pc bpc" id="L3331" title="1 of 2 branches missed.">		if (success)</span>
		{
<span class="fc" id="L3333">			calcActiveBonuses();</span>
		}
<span class="fc" id="L3335">		return success;</span>
	}

	/**
	 * return bonus from a Race
	 *
	 * @param aType
	 * @param aName
	 * @return race bonus to
	 */
	public double getRaceBonusTo(String aType, String aName)
	{
<span class="nc bnc" id="L3347" title="All 2 branches missed.">		if (getRace() == null)</span>
		{
<span class="nc" id="L3349">			return 0;</span>
		}

<span class="nc" id="L3352">		final List&lt;BonusObj&gt; tempList =</span>
<span class="nc" id="L3353">				BonusUtilities.getBonusFromList(getRace().getBonusList(this), aType.toUpperCase(), aName.toUpperCase());</span>

<span class="nc" id="L3355">		return calcBonusFromList(tempList, getRace());</span>
	}

	public int getSR()
	{
<span class="nc" id="L3360">		return calcSR(true);</span>
	}

	/**
	 * Calculates total bonus from Size adjustments
	 *
	 * @param aType
	 * @param aName
	 * @return size adjustment bonus to
	 */
	public double getSizeAdjustmentBonusTo(String aType, String aName)
	{
<span class="nc" id="L3372">		return getBonusDueToType(aType.toUpperCase(), aName.toUpperCase(), &quot;SIZE&quot;);</span>
	}

	/**
	 * Set the skill display filter
	 *
	 * @param filter
	 *            The new filter
	 */
	public void setSkillFilter(final SkillFilter filter)
	{
<span class="nc bnc" id="L3383" title="All 2 branches missed.">		if (skillFilterFacet.set(id, filter))</span>
		{
<span class="nc" id="L3385">			setDirty(true);</span>
		}
<span class="nc" id="L3387">	}</span>

	/**
	 * @return The selected skill display filter.
	 */
	public SkillFilter getSkillFilter()
	{
<span class="nc" id="L3394">		SkillFilter filter = skillFilterFacet.get(id);</span>
<span class="nc bnc" id="L3395" title="All 2 branches missed.">		if (filter == null)</span>
		{
<span class="nc" id="L3397">			filter = SkillFilter.getByValue(PCGenSettings.OPTIONS_CONTEXT.initInt(PCGenSettings.OPTION_SKILL_FILTER,</span>
<span class="nc" id="L3398">				SkillFilter.Usable.getValue()));</span>
<span class="nc bnc" id="L3399" title="All 2 branches missed.">			if (filter == SkillFilter.SkillsTab)</span>
			{
<span class="nc" id="L3401">				filter = SkillFilter.Usable;</span>
			}
<span class="nc" id="L3403">			setSkillFilter(filter);</span>
		}
<span class="nc" id="L3405">		return filter;</span>
	}

	/**
	 * Set the order in which skills should be sorted for output.
	 *
	 * @param i
	 *            The new output order
	 */
	public void setSkillsOutputOrder(final SkillsOutputOrder i)
	{
<span class="nc bnc" id="L3416" title="All 2 branches missed.">		if (skillsOutputOrder != i)</span>
		{
<span class="nc" id="L3418">			skillsOutputOrder = i;</span>
<span class="nc" id="L3419">			setDirty(true);</span>
		}
<span class="nc" id="L3421">	}</span>

	/**
	 * @return The selected Output Order for skills.
	 */
	public SkillsOutputOrder getSkillsOutputOrder()
	{
<span class="nc" id="L3428">		return skillsOutputOrder;</span>
	}

	/**
	 * Method will go through the list of classes that the player character has
	 * and see if they are a spell caster and of the desired caster level.
	 *
	 * @param minLevel
	 * @return boolean
	 */
	public boolean isSpellCaster(final int minLevel)
	{
<span class="nc bnc" id="L3440" title="All 2 branches missed.">		return isSpellCaster(minLevel, false) &gt; 0;</span>
	}

	/**
	 * Method will go through the list of classes that the player character has
	 * and see if they are a spell caster and of the total of all of their
	 * spellcasting levels is at least the desired caster level.
	 *
	 * @param minLevel
	 *            The desired caster level
	 * @param sumOfLevels
	 *            True if all of the character caster levels should be added
	 *            together before the comparison.
	 * @return boolean
	 */
	public int isSpellCaster(final int minLevel, final boolean sumOfLevels)
	{
<span class="nc" id="L3457">		return isSpellCaster(null, minLevel, sumOfLevels);</span>
	}

	/**
	 * Method will go through the list of classes that the player character has
	 * and see if they are a spell caster of the desired type and of the desired
	 * caster level.
	 *
	 * @param spellType
	 *            The type of spellcaster (i.e. &quot;Arcane&quot; or &quot;Divine&quot;)
	 * @param minLevel
	 *            The desired caster level
	 * @param sumLevels
	 *            True if all of the character caster levels should be added
	 *            together before the comparison.
	 * @return boolean
	 */
	public int isSpellCaster(final String spellType, final int minLevel, final boolean sumLevels)
	{
<span class="nc" id="L3476">		int classTotal = 0;</span>
<span class="nc" id="L3477">		int runningTotal = 0;</span>

<span class="nc bnc" id="L3479" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc bnc" id="L3481" title="All 4 branches missed.">			if (spellType == null || spellType.equalsIgnoreCase(pcClass.getSpellType()))</span>
			{
<span class="nc" id="L3483">				int classLevels = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, pcClass.getKeyName());</span>
<span class="nc bnc" id="L3484" title="All 4 branches missed.">				if ((classLevels == 0) &amp;&amp; (canCastSpellTypeLevel(pcClass.getSpellType(), 0)</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">					|| canCastSpellTypeLevel(pcClass.getSpellType(), 1)))</span>
				{
					// missing CASTERLEVEL hack
<span class="nc" id="L3488">					classLevels = getLevel(pcClass);</span>
				}
<span class="nc" id="L3490">				classLevels += (int) getTotalBonusTo(&quot;PCLEVEL&quot;, pcClass.getKeyName());</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">				if (sumLevels)</span>
				{
<span class="nc" id="L3493">					runningTotal += classLevels;</span>
				}
				else
				{
<span class="nc bnc" id="L3497" title="All 2 branches missed.">					if (classLevels &gt;= minLevel)</span>
					{
<span class="nc" id="L3499">						classTotal++;</span>
					}
				}
			}
<span class="nc" id="L3503">		}</span>

<span class="nc bnc" id="L3505" title="All 2 branches missed.">		if (sumLevels)</span>
		{
<span class="nc bnc" id="L3507" title="All 2 branches missed.">			return runningTotal &gt;= minLevel ? 1 : 0;</span>
		}
<span class="nc" id="L3509">		return classTotal;</span>
	}

	public void getSpellList()
	{
		// all non-spellcaster spells are added to race
		// so return if it's null
<span class="nc" id="L3516">		Race race = getRace();</span>
<span class="nc bnc" id="L3517" title="All 2 branches missed.">		if (race == null)</span>
		{
<span class="nc" id="L3519">			return;</span>
		}

<span class="nc" id="L3522">		activeSpellsFacet.process(id);</span>
<span class="nc" id="L3523">		setDirty(true);</span>
<span class="nc" id="L3524">	}</span>

	/**
	 * Parses a spells range (short, medium or long) into an Integer based on
	 * the spell and spell casters level
	 *
	 * @param aSpell
	 *            The spell being output.
	 * @param si
	 *            The info about conditions applied to the spell
	 * @return spell range
	 */
	public String getSpellRange(final CharacterSpell aSpell, final SpellInfo si)
	{
<span class="nc" id="L3538">		String aRange = aSpell.getSpell().getListAsString(ListKey.RANGE);</span>
<span class="nc" id="L3539">		String aSpellClass = aSpell.getVariableSource(this);</span>
		int rangeInFeet;
<span class="nc" id="L3541">		String aString = SettingsHandler.getGameAsProperty().get().getSpellRangeFormula(aRange.toUpperCase());</span>

<span class="nc bnc" id="L3543" title="All 4 branches missed.">		if (aRange.equalsIgnoreCase(&quot;CLOSE&quot;) &amp;&amp; (aString == null))</span>
		{
<span class="nc" id="L3545">			aString = &quot;((CASTERLEVEL/2).TRUNC*5)+25&quot;; //$NON-NLS-1$</span>
		}
<span class="nc bnc" id="L3547" title="All 4 branches missed.">		else if (aRange.equalsIgnoreCase(&quot;MEDIUM&quot;) &amp;&amp; (aString == null))</span>
		{
<span class="nc" id="L3549">			aString = &quot;(CASTERLEVEL*10)+100&quot;; //$NON-NLS-1$</span>
		}
<span class="nc bnc" id="L3551" title="All 4 branches missed.">		else if (aRange.equalsIgnoreCase(&quot;LONG&quot;) &amp;&amp; (aString == null))</span>
		{
<span class="nc" id="L3553">			aString = &quot;(CASTERLEVEL*40)+400&quot;; //$NON-NLS-1$</span>
		}

<span class="nc bnc" id="L3556" title="All 2 branches missed.">		if (aString != null)</span>
		{
<span class="nc" id="L3558">			List&lt;Ability&gt; metaFeats = null;</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">			if (si != null)</span>
			{
<span class="nc" id="L3561">				metaFeats = si.getFeatList();</span>
			}
<span class="nc" id="L3563">			rangeInFeet = getVariableValue(aSpell, aString, aSpellClass).intValue();</span>
<span class="nc bnc" id="L3564" title="All 4 branches missed.">			if ((metaFeats != null) &amp;&amp; !metaFeats.isEmpty())</span>
			{
<span class="nc bnc" id="L3566" title="All 2 branches missed.">				for (Ability feat : metaFeats)</span>
				{
<span class="nc" id="L3568">					rangeInFeet += (int) BonusCalc.charBonusTo(feat, &quot;SPELL&quot;, &quot;RANGE&quot;, this);</span>

<span class="nc" id="L3570">					final int iMult = (int) BonusCalc.charBonusTo(feat, &quot;SPELL&quot;, &quot;RANGEMULT&quot;, this);</span>

<span class="nc bnc" id="L3572" title="All 2 branches missed.">					if (iMult &gt; 0)</span>
					{
<span class="nc" id="L3574">						rangeInFeet *= iMult;</span>
					}
<span class="nc" id="L3576">				}</span>
			}

<span class="nc" id="L3579">			aRange += (&quot; (&quot; + Globals.getGameModeUnitSet().displayDistanceInUnitSet(rangeInFeet)</span>
<span class="nc" id="L3580">				+ Globals.getGameModeUnitSet().getDistanceUnit() + ')');</span>
<span class="nc" id="L3581">		}</span>
		else
		{
<span class="nc" id="L3584">			aRange = parseSpellString(aSpell, aRange);</span>
		}

<span class="nc" id="L3587">		return aRange;</span>
	}

	/**
	 * Computes the Caster Level for a Class
	 *
	 * @param aClass
	 * @return caster level for class
	 */
	public int getCasterLevelForClass(final PCClass aClass)
	{
<span class="nc" id="L3598">		final Spell sp = new Spell();</span>
<span class="nc" id="L3599">		final CharacterSpell cs = new CharacterSpell(aClass, sp);</span>
<span class="nc" id="L3600">		final String aSpellClass = &quot;CLASS:&quot; + aClass.getKeyName();</span>
<span class="nc" id="L3601">		return getVariableValue(cs, &quot;CASTERLEVEL&quot;, aSpellClass).intValue();</span>
	}

	/**
	 * Computes the Caster Level for a Class
	 *
	 * @param aSpell
	 * @return caster level for spell
	 */
	public int getCasterLevelForSpell(final CharacterSpell aSpell)
	{
<span class="nc" id="L3612">		return getVariableValue(aSpell, &quot;CASTERLEVEL&quot;, aSpell.getVariableSource(this)).intValue();</span>
	}

	/**
	 * Calculates total bonus from all stats
	 *
	 * @param aType
	 * @param aName
	 * @return stat bonus to
	 */
	private double getStatBonusTo(String aType, String aName)
	{
<span class="nc" id="L3624">		return statBonusFacet.getStatBonusTo(id, aType, aName);</span>
	}

	/**
	 * Parses through all templates to calculate total bonus
	 *
	 * @param aType
	 * @param aName
	 * @return template bonus to
	 */
	public double getTemplateBonusTo(String aType, String aName)
	{
<span class="nc" id="L3636">		return getPObjectWithCostBonusTo(templateFacet.getSet(id), aType.toUpperCase(), aName.toUpperCase());</span>
	}

	/**
	 * Get the total bonus from Stats, Size, Age, Alignment, Classes,
	 * companions, Equipment, Feats, Templates, Domains, Races, etc This value
	 * is taken from an already populated HashMap for speed
	 *
	 * @param bonusType
	 *            Type of bonus (&quot;COMBAT&quot; or &quot;SKILL&quot;)
	 * @param bonusName
	 *            Name of bonus (&quot;AC&quot; or &quot;Hide&quot;);
	 * @return total bonus to
	 */
	public double getTotalBonusTo(final String bonusType, final String bonusName)
	{
<span class="fc" id="L3652">		return bonusManager.getTotalBonusTo(bonusType, bonusName);</span>
	}

	public int getTotalLevels()
	{
<span class="nc" id="L3657">		return levelFacet.getTotalLevels(id);</span>
	}

	/**
	 * Get the value of the desired stat at the point just before the character
	 * was raised to the next level.
	 *
	 * @param stat
	 *            The Stat to check.
	 * @param level
	 *            The level we want to see the stat at.
	 * @param includePost
	 *            Should stat mods that occurred after levelling be included?
	 * @return The stat as it was at the level
	 */
	public int getTotalStatAtLevel(final PCStat stat, final int level, final boolean includePost)
	{
<span class="nc" id="L3674">		int curStat = this.getTotalStatFor(stat);</span>
<span class="nc bnc" id="L3675" title="All 2 branches missed.">		for (int idx = getLevelInfoSize() - 1; idx &gt;= level; --idx)</span>
		{
<span class="nc" id="L3677">			final int statLvlAdjust = levelInfoFacet.get(id, idx).getTotalStatMod(stat, true);</span>
<span class="nc" id="L3678">			curStat -= statLvlAdjust;</span>
		}
		// If the user doesn't want POST changes, we remove any made in the
		// target level only
<span class="nc bnc" id="L3682" title="All 4 branches missed.">		if (!includePost &amp;&amp; level &gt; 0)</span>
		{
<span class="nc" id="L3684">			int statLvlAdjust = levelInfoFacet.get(id, level - 1).getTotalStatMod(stat, true);</span>
<span class="nc" id="L3685">			statLvlAdjust -= levelInfoFacet.get(id, level - 1).getTotalStatMod(stat, false);</span>
<span class="nc" id="L3686">			curStat -= statLvlAdjust;</span>

		}

<span class="nc" id="L3690">		return curStat;</span>
	}

	/**
	 * whether we should use/save Temporary bonuses
	 *
	 * @param aBool
	 */
	public void setUseTempMods(final boolean aBool)
	{
<span class="nc" id="L3700">		useTempMods = aBool;</span>
		// commented out setDirty because this causes a re-load of all tabs
		// every time any tab is viewed! merton_monk
		// setDirty(true);
<span class="nc" id="L3704">	}</span>

	public boolean getUseTempMods()
	{
<span class="fc" id="L3708">		return useTempMods;</span>
	}

	/**
	 * Evaluates a variable for this character e.g:
	 * getVariableValue(&quot;3+CHA&quot;,&quot;CLASS:Cleric&quot;) for Turn Undead
	 *
	 * @param aString
	 *            The variable to be evaluated
	 * @param src
	 *            The source within which the variable is evaluated
	 * @return The value of the variable
	 */
	public Float getVariableValue(final String aString, final String src)
	{
<span class="nc" id="L3723">		return getVariableValue(null, aString, src);</span>
	}

	@Override
	public Float getVariableValue(final String varName, final String src, final PlayerCharacter aPC)
	{
<span class="nc" id="L3729">		return getVariableValue(null, varName, src);</span>
	}

	/**
	 * Evaluates a variable for this character e.g:
	 * getVariableValue(&quot;3+CHA&quot;,&quot;CLASS:Cleric&quot;) for Turn Undead
	 *
	 * @param aSpell
	 *            This is specifically to compute bonuses to CASTERLEVEL for a
	 *            specific spell.
	 * @param aString
	 *            The variable to be evaluated
	 * @param src
	 *            The source within which the variable is evaluated
	 * @return The value of the variable
	 */
	private Float getVariableValue(final CharacterSpell aSpell, String aString, String src)
	{
<span class="nc" id="L3747">		return variableProcessor.getVariableValue(aSpell, aString, src, spellLevelTemp);</span>
	}

	/**
	 * @return VariableProcessor
	 */
	public VariableProcessor getVariableProcessor()
	{
<span class="nc" id="L3755">		return variableProcessor;</span>
	}

	public int getTotalCasterLevelWithSpellBonus(CharacterSpell acs, final Spell aSpell, final String spellType,
		final String classOrRace, final int casterLev)
	{
<span class="nc bnc" id="L3761" title="All 4 branches missed.">		if (aSpell != null &amp;&amp; acs.getFixedCasterLevel() != null)</span>
		{
<span class="nc" id="L3763">			return getVariableValue(acs.getFixedCasterLevel(), Constants.EMPTY_STRING).intValue();</span>
		}

		int tBonus;
<span class="nc" id="L3767">		boolean replaceCasterLevel = false;</span>

		String tType;
		String tStr;
		// final List&lt;TypedBonus&gt; bonuses = new ArrayList&lt;TypedBonus&gt;();
<span class="nc" id="L3772">		final List&lt;CasterLevelSpellBonus&gt; bonuses = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3774" title="All 2 branches missed.">		if (classOrRace != null)</span>
		{
			// bonuses.addAll(getBonusesTo(&quot;CASTERLEVEL&quot;, classOrRace));
<span class="nc" id="L3777">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, classOrRace);</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3780">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, classOrRace);</span>
<span class="nc" id="L3781">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}

			// Support both types of syntax for CLASS:
			// BONUS:CASTERLEVEL|Sorcerer|1 and
			// BONUS:CASTERLEVEL|CLASS.Sorcerer|1
<span class="nc bnc" id="L3787" title="All 2 branches missed.">			if (!classOrRace.startsWith(&quot;RACE.&quot;))</span>
			{
<span class="nc" id="L3789">				tStr = &quot;CLASS.&quot; + classOrRace;</span>
				// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3791">				tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3792" title="All 2 branches missed.">				if (tBonus &gt; 0)</span>
				{
<span class="nc" id="L3794">					tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3795">					bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
				}
			}
		}

<span class="nc bnc" id="L3800" title="All 2 branches missed.">		if (aSpell == null)</span>
		{
<span class="nc" id="L3802">			return tallyCasterlevelBonuses(casterLev, false, bonuses);</span>
		}

<span class="nc bnc" id="L3805" title="All 2 branches missed.">		if (!spellType.equals(Constants.NONE))</span>
		{
<span class="nc" id="L3807">			tStr = &quot;TYPE.&quot; + spellType;</span>
			// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3809">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3810" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3812">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3813">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3815">			tStr += &quot;.RESET&quot;;</span>
			// final List&lt;TypedBonus&gt; reset = getBonusesTo(&quot;CASTERLEVEL&quot;, tStr);
			// if ( reset.size() &gt; 0 )
			// {
			// bonuses.addAll(reset);
			// replaceCasterLevel = true;
			// }
<span class="nc" id="L3822">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3823" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3825">				replaceCasterLevel = true;</span>
<span class="nc" id="L3826">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3827">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
		}

<span class="nc" id="L3831">		tStr = &quot;SPELL.&quot; + aSpell.getKeyName();</span>
		// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3833">		tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3834" title="All 2 branches missed.">		if (tBonus &gt; 0)</span>
		{
<span class="nc" id="L3836">			tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3837">			bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
		}
<span class="nc" id="L3839">		tStr += &quot;.RESET&quot;;</span>
		// final List&lt;TypedBonus&gt; reset = getBonusesTo(&quot;CASTERLEVEL&quot;, tStr);
		// if ( reset.size() &gt; 0 )
		// {
		// bonuses.addAll(reset);
		// replaceCasterLevel = true;
		// }
<span class="nc" id="L3846">		tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3847" title="All 2 branches missed.">		if (tBonus &gt; 0)</span>
		{
<span class="nc" id="L3849">			replaceCasterLevel = true;</span>
<span class="nc" id="L3850">			tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3851">			bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
		}

		/*
		 * This wraps in TreeSet because it looks to me like this is ordered
		 * (given .RESET)
		 */
<span class="nc bnc" id="L3858" title="All 2 branches missed.">		for (SpellSchool school : new TreeSet&lt;&gt;(aSpell.getSafeListFor(ListKey.SPELL_SCHOOL)))</span>
		{
<span class="nc" id="L3860">			tStr = &quot;SCHOOL.&quot; + school;</span>
			// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3862">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3863" title="All 2 branches missed.">			if (tBonus != 0) // Allow negative bonus to casterlevel</span>
			{
<span class="nc" id="L3865">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3866">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3868">			tStr += &quot;.RESET&quot;;</span>
			// final List&lt;TypedBonus&gt; reset1 = getBonusesTo(&quot;CASTERLEVEL&quot;,
			// tStr);
			// if ( reset.size() &gt; 0 )
			// {
			// bonuses.addAll(reset1);
			// replaceCasterLevel = true;
			// }
<span class="nc" id="L3876">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3877" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3879">				replaceCasterLevel = true;</span>
<span class="nc" id="L3880">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3881">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3883">		}</span>

<span class="nc bnc" id="L3885" title="All 2 branches missed.">		for (String subschool : new TreeSet&lt;&gt;(aSpell.getSafeListFor(ListKey.SPELL_SUBSCHOOL)))</span>
		{
<span class="nc" id="L3887">			tStr = &quot;SUBSCHOOL.&quot; + subschool;</span>
			// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3889">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3890" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3892">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3893">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3895">			tStr += &quot;.RESET&quot;;</span>
			// final List&lt;TypedBonus&gt; reset1 = getBonusesTo(&quot;CASTERLEVEL&quot;,
			// tStr);
			// if ( reset.size() &gt; 0 )
			// {
			// bonuses.addAll(reset1);
			// replaceCasterLevel = true;
			// }
<span class="nc" id="L3903">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3904" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3906">				replaceCasterLevel = true;</span>
<span class="nc" id="L3907">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3908">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3910">		}</span>

		//Not wrapped because it wasn't in 5.14
<span class="nc bnc" id="L3913" title="All 2 branches missed.">		for (String desc : aSpell.getSafeListFor(ListKey.SPELL_DESCRIPTOR))</span>
		{
<span class="nc" id="L3915">			tStr = &quot;DESCRIPTOR.&quot; + desc;</span>
			// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3917">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3918" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3920">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3921">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3923">			tStr += &quot;.RESET&quot;;</span>
			// final List&lt;TypedBonus&gt; reset1 = getBonusesTo(&quot;CASTERLEVEL&quot;,
			// tStr);
			// if ( reset.size() &gt; 0 )
			// {
			// bonuses.addAll(reset1);
			// replaceCasterLevel = true;
			// }
<span class="nc" id="L3931">			tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3932" title="All 2 branches missed.">			if (tBonus &gt; 0)</span>
			{
<span class="nc" id="L3934">				replaceCasterLevel = true;</span>
<span class="nc" id="L3935">				tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3936">				bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
			}
<span class="nc" id="L3938">		}</span>

<span class="nc" id="L3940">		final HashMapToList&lt;CDOMList&lt;Spell&gt;, Integer&gt; domainMap = getSpellLevelInfo(aSpell);</span>
<span class="nc bnc" id="L3941" title="All 2 branches missed.">		if (domainMap != null)</span>
		{
<span class="nc bnc" id="L3943" title="All 2 branches missed.">			for (CDOMList&lt;Spell&gt; spellList : domainMap.getKeySet())</span>
			{
<span class="nc bnc" id="L3945" title="All 2 branches missed.">				if (spellList instanceof DomainSpellList)</span>
				{
<span class="nc" id="L3947">					tStr = &quot;DOMAIN.&quot; + spellList.getKeyName();</span>
					// bonuses.addAll( getBonusesTo(&quot;CASTERLEVEL&quot;, tStr) );
<span class="nc" id="L3949">					tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3950" title="All 2 branches missed.">					if (tBonus &gt; 0)</span>
					{
<span class="nc" id="L3952">						tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3953">						bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
					}
<span class="nc" id="L3955">					tStr += &quot;.RESET&quot;;</span>
					// final List&lt;TypedBonus&gt; reset1 =
					// getBonusesTo(&quot;CASTERLEVEL&quot;, tStr);
					// if ( reset.size() &gt; 0 )
					// {
					// bonuses.addAll(reset1);
					// replaceCasterLevel = true;
					// }
<span class="nc" id="L3963">					tBonus = (int) getTotalBonusTo(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc bnc" id="L3964" title="All 2 branches missed.">					if (tBonus &gt; 0)</span>
					{
<span class="nc" id="L3966">						replaceCasterLevel = true;</span>
<span class="nc" id="L3967">						tType = getSpellBonusType(&quot;CASTERLEVEL&quot;, tStr);</span>
<span class="nc" id="L3968">						bonuses.add(new CasterLevelSpellBonus(tBonus, tType));</span>
					}
				}
<span class="nc" id="L3971">			}</span>
		}

<span class="nc" id="L3974">		return (tallyCasterlevelBonuses(casterLev, replaceCasterLevel, bonuses));</span>
	}

	private static int tallyCasterlevelBonuses(final int casterLev, boolean replaceCasterLevel,
		final List&lt;CasterLevelSpellBonus&gt; bonuses)
	{
		// now go through all bonuses, checking types to see what should add
		// together
<span class="nc bnc" id="L3982" title="All 2 branches missed.">		for (int z = 0; z &lt; bonuses.size() - 1; z++)</span>
		{
<span class="nc" id="L3984">			final CasterLevelSpellBonus zBonus = bonuses.get(z);</span>

<span class="nc" id="L3986">			String zType = zBonus.getType();</span>
<span class="nc bnc" id="L3987" title="All 4 branches missed.">			if ((zBonus.getBonus() == 0) || zType.isEmpty())</span>
			{
<span class="nc" id="L3989">				continue;</span>
			}

<span class="nc" id="L3992">			boolean zReplace = false;</span>
<span class="nc" id="L3993">			boolean zStack = false;</span>
<span class="nc bnc" id="L3994" title="All 2 branches missed.">			if (zType.endsWith(&quot;.REPLACE&quot;))</span>
			{
<span class="nc" id="L3996">				zType = zType.substring(0, zType.length() - 8);</span>
<span class="nc" id="L3997">				zReplace = true;</span>
			}
			else
			{
<span class="nc bnc" id="L4001" title="All 2 branches missed.">				if (zType.endsWith(&quot;.STACK&quot;))</span>
				{
<span class="nc" id="L4003">					zType = zType.substring(0, zType.length() - 6);</span>
<span class="nc" id="L4004">					zStack = true;</span>
				}
			}

<span class="nc bnc" id="L4008" title="All 2 branches missed.">			for (int k = z + 1; k &lt; bonuses.size(); k++)</span>
			{
<span class="nc" id="L4010">				final CasterLevelSpellBonus kBonus = bonuses.get(k);</span>

<span class="nc" id="L4012">				String kType = kBonus.getType();</span>
<span class="nc bnc" id="L4013" title="All 4 branches missed.">				if ((kBonus.getBonus() == 0) || kType.isEmpty())</span>
				{
<span class="nc" id="L4015">					continue;</span>
				}

<span class="nc" id="L4018">				boolean kReplace = false;</span>
<span class="nc" id="L4019">				boolean kStack = false;</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">				if (kType.endsWith(&quot;.REPLACE&quot;))</span>
				{
<span class="nc" id="L4022">					kType = kType.substring(0, kType.length() - 8);</span>
<span class="nc" id="L4023">					kReplace = true;</span>
				}
				else
				{
<span class="nc bnc" id="L4027" title="All 2 branches missed.">					if (kType.endsWith(&quot;.STACK&quot;))</span>
					{
<span class="nc" id="L4029">						kType = kType.substring(0, kType.length() - 6);</span>
<span class="nc" id="L4030">						kStack = true;</span>
					}
				}

<span class="nc bnc" id="L4034" title="All 2 branches missed.">				if (!zType.equals(kType))</span>
				{
<span class="nc" id="L4036">					continue;</span>
				}

				// if both end in &quot;.REPLACE&quot;, add together and save for later
				// comparison
<span class="nc bnc" id="L4041" title="All 4 branches missed.">				if (zReplace &amp;&amp; kReplace)</span>
				{
<span class="nc" id="L4043">					kBonus.setBonus(zBonus.getBonus() + kBonus.getBonus());</span>
<span class="nc" id="L4044">					zBonus.setBonus(0);</span>
<span class="nc" id="L4045">					continue;</span>
				}

				// if either ends in &quot;.STACK&quot;, then they will add
<span class="nc bnc" id="L4049" title="All 4 branches missed.">				if (zStack || kStack)</span>
				{
<span class="nc" id="L4051">					continue;</span>
				}

				// otherwise, only keep max
<span class="nc bnc" id="L4055" title="All 2 branches missed.">				if (zBonus.getBonus() &gt; kBonus.getBonus())</span>
				{
<span class="nc" id="L4057">					kBonus.setBonus(0);</span>
				}
				else
				{
<span class="nc" id="L4061">					zBonus.setBonus(0);</span>
				}
			}
		}

<span class="nc" id="L4066">		int result = 0;</span>
<span class="nc bnc" id="L4067" title="All 2 branches missed.">		if (!replaceCasterLevel)</span>
		{
<span class="nc" id="L4069">			result += casterLev;</span>
		}

		// result += TypedBonus.totalBonuses(bonuses);
		// Now go through bonuses and add it up
<span class="nc bnc" id="L4074" title="All 2 branches missed.">		for (CasterLevelSpellBonus resultBonus : bonuses)</span>
		{
<span class="nc" id="L4076">			result += resultBonus.getBonus();</span>
<span class="nc" id="L4077">		}</span>

<span class="nc bnc" id="L4079" title="All 2 branches missed.">		if (result &lt;= 0)</span>
		{
<span class="nc" id="L4081">			result = 1; // Casterlevel must be at least 1</span>
		}
<span class="nc" id="L4083">		return result;</span>
	}

	private String getSpellBonusType(final String bonusType, final String bonusName)
	{
<span class="nc" id="L4088">		return bonusManager.getSpellBonusType(bonusType, bonusName);</span>
	}

	/**
	 * returns all equipment (from the equipmentList) of type aString
	 *
	 * @param aList
	 * @param aType
	 * @return List
	 */
	public List&lt;Equipment&gt; addEqType(final List&lt;Equipment&gt; aList, final String aType)
	{
<span class="nc bnc" id="L4100" title="All 2 branches missed.">		for (Equipment eq : getEquipmentSet())</span>
		{
<span class="nc bnc" id="L4102" title="All 6 branches missed.">			if (eq.typeStringContains(aType) || aType.equalsIgnoreCase(&quot;CONTAINED&quot;) &amp;&amp; (eq.getParent() != null))</span>
			{
<span class="nc" id="L4104">				aList.add(eq);</span>
			}
<span class="nc" id="L4106">		}</span>

<span class="nc" id="L4108">		return aList;</span>
	}

	/**
	 * Adds a &lt;tt&gt;Kit&lt;/tt&gt; to the applied list of kits for the character.
	 *
	 * @param aKit
	 *            The &lt;tt&gt;Kit&lt;/tt&gt; to add.
	 */
	public void addKit(final Kit aKit)
	{
<span class="nc" id="L4119">		kitFacet.add(id, aKit);</span>
<span class="nc" id="L4120">		setDirty(true);</span>
<span class="nc" id="L4121">	}</span>

	/**
	 * @param acs
	 *            is the CharacterSpell object containing the spell which is to
	 *            be modified
	 * @param aFeatList
	 *            is the list of feats to be added to the SpellInfo object
	 * @param classKey
	 *            is the name of the class whose list of character spells will
	 *            be modified
	 * @param bookName
	 *            is the name of the book for the SpellInfo object
	 * @param spellLevel
	 *            is the original (unadjusted) level of the spell not including
	 *            feat adjustments
	 * @param adjSpellLevel
	 *            is the adjustedLevel (including feat adjustments) of this
	 *            spell, it may be higher if the user chooses a higher level.
	 *
	 * @return an empty string on successful completion, otherwise the return
	 *         value indicates the reason the add function failed.
	 */
	public String addSpell(CharacterSpell acs, final List&lt;Ability&gt; aFeatList, final String classKey,
		final String bookName, final int adjSpellLevel, final int spellLevel)
	{
<span class="nc bnc" id="L4147" title="All 2 branches missed.">		if (acs == null)</span>
		{
<span class="nc" id="L4149">			return &quot;Invalid parameter to add spell&quot;;</span>
		}

<span class="nc" id="L4152">		PCClass aClass = null;</span>
<span class="nc" id="L4153">		final Spell aSpell = acs.getSpell();</span>

<span class="nc bnc" id="L4155" title="All 4 branches missed.">		if ((bookName == null) || (bookName.isEmpty()))</span>
		{
<span class="nc" id="L4157">			return &quot;Invalid spell list/book name.&quot;;</span>
		}

<span class="nc bnc" id="L4160" title="All 2 branches missed.">		if (!hasSpellBook(bookName))</span>
		{
<span class="nc" id="L4162">			return &quot;Could not find spell list/book &quot; + bookName;</span>
		}

<span class="nc bnc" id="L4165" title="All 2 branches missed.">		if (classKey != null)</span>
		{
<span class="nc" id="L4167">			aClass = getClassKeyed(classKey);</span>

<span class="nc bnc" id="L4169" title="All 4 branches missed.">			if ((aClass == null) &amp;&amp; (classKey.lastIndexOf('(') &gt;= 0))</span>
			{
<span class="nc" id="L4171">				aClass = getClassKeyed(classKey.substring(0, classKey.lastIndexOf('(')).trim());</span>
			}
		}

		// If this is a spellbook, the class doesn't have to be one the PC has
		// already.
<span class="nc" id="L4177">		SpellBook spellBook = getSpellBookByName(bookName);</span>
<span class="nc bnc" id="L4178" title="All 4 branches missed.">		if (aClass == null &amp;&amp; spellBook.getType() == SpellBook.TYPE_SPELL_BOOK)</span>
		{
<span class="nc" id="L4180">			aClass = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class,</span>
				classKey);
<span class="nc bnc" id="L4182" title="All 4 branches missed.">			if ((aClass == null) &amp;&amp; (classKey.lastIndexOf('(') &gt;= 0))</span>
			{
<span class="nc" id="L4184">				aClass = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class,</span>
<span class="nc" id="L4185">					classKey.substring(0, classKey.lastIndexOf('(')).trim());</span>
			}
		}

<span class="nc bnc" id="L4189" title="All 2 branches missed.">		if (aClass == null)</span>
		{
<span class="nc" id="L4191">			return &quot;No class keyed &quot; + classKey;</span>
		}

<span class="nc bnc" id="L4194" title="All 4 branches missed.">		if (!aClass.getSafe(ObjectKey.MEMORIZE_SPELLS) &amp;&amp; !bookName.equals(Globals.getDefaultSpellBook()))</span>
		{
<span class="nc" id="L4196">			return aClass.getDisplayName() + &quot; can only add to &quot; + Globals.getDefaultSpellBook();</span>
		}

		// Divine spellcasters get no bonus spells at level 0
		// TODO: allow classes to define how many bonus spells they get each
		// level!
		// int numSpellsFromSpecialty = aClass.getNumSpellsFromSpecialty();
		// if (spellLevel == 0 &amp;&amp;
		// &quot;Divine&quot;.equalsIgnoreCase(aClass.getSpellType()))
		// {
		// numSpellsFromSpecialty = 0;
		// }
		// all the exists checks are done.

		// don't allow adding spells which are not qualified for.
<span class="nc bnc" id="L4211" title="All 2 branches missed.">		if (!aSpell.qualifies(this, aSpell))</span>
		{
<span class="nc" id="L4213">			return &quot;You do not qualify for &quot; + acs.getSpell().getDisplayName() + '.';</span>
		}

		// don't allow adding spells which are prohibited to known
		// or prepared lists
		// But if a spell is both prohibited and in a speciality
		// which can be the case for some spells, then allow it.
<span class="nc bnc" id="L4220" title="All 4 branches missed.">		if (spellBook.getType() != SpellBook.TYPE_SPELL_BOOK &amp;&amp; !acs.isSpecialtySpell(this)</span>
<span class="nc bnc" id="L4221" title="All 2 branches missed.">			&amp;&amp; SpellCountCalc.isProhibited(aSpell, aClass, this))</span>
		{
<span class="nc" id="L4223">			return acs.getSpell().getDisplayName() + &quot; is prohibited.&quot;;</span>
		}

		// Now let's see if they should be able to add this spell
		// first check for known/cast/threshold
<span class="nc" id="L4228">		final int known = this.getSpellSupport(aClass).getKnownForLevel(spellLevel, this);</span>
<span class="nc" id="L4229">		int specialKnown = 0;</span>
<span class="nc" id="L4230">		final int cast = this.getSpellSupport(aClass).getCastForLevel(adjSpellLevel, bookName, true, true, this);</span>
<span class="nc" id="L4231">		SpellCountCalc.memorizedSpellForLevelBook(this, aClass, adjSpellLevel, bookName);</span>

<span class="nc" id="L4233">		final boolean isDefault = bookName.equals(Globals.getDefaultSpellBook());</span>

<span class="nc bnc" id="L4235" title="All 2 branches missed.">		if (isDefault)</span>
		{
<span class="nc" id="L4237">			specialKnown = this.getSpellSupport(aClass).getSpecialtyKnownForLevel(spellLevel, this);</span>
		}

<span class="nc" id="L4240">		int numPages = 0;</span>

		// known is the maximum spells that can be known this level
		// listNum is the current spells already memorized this level
		// cast is the number of spells that can be cast at this level
		// Modified this to use new availableSpells() method so you can &quot;blow&quot;
		// higher-level slots on
		// lower-level spells
		// in re BUG [569517]
		// sk4p 13 Dec 2002
<span class="nc bnc" id="L4250" title="All 2 branches missed.">		if (spellBook.getType() == SpellBook.TYPE_SPELL_BOOK)</span>
		{
			// If this is a spellbook rather than known spells
			// or prepared spells, then let them add spells up to
			// the page limit of the book.
			// Explicitly should *not* set the dirty flag to true.
<span class="nc" id="L4256">			spellLevelTemp = spellLevel;</span>
			/*
					 * TODO Need to understand more about this context of formula
					 * resolution (in context of a spell??) in order to understand how
					 * to put this method into the Formula interface
					 */
<span class="nc" id="L4262">			numPages = getVariableValue(acs, spellBook.getPageFormula().toString(), &quot;&quot;).intValue();</span>
			// Check number of pages remaining in the book
<span class="nc bnc" id="L4264" title="All 2 branches missed.">			if (numPages + spellBook.getNumPagesUsed() &gt; spellBook.getNumPages())</span>
			{
<span class="nc" id="L4266">				return &quot;There are not enough pages left to add this spell to the spell book.&quot;;</span>
			}
<span class="nc" id="L4268">			spellBook.setNumPagesUsed(numPages + spellBook.getNumPagesUsed());</span>
<span class="nc" id="L4269">			spellBook.setNumSpells(spellBook.getNumSpells() + 1);</span>
		}
<span class="nc bnc" id="L4271" title="All 2 branches missed.">		else if (!aClass.getSafe(ObjectKey.MEMORIZE_SPELLS)</span>
<span class="nc bnc" id="L4272" title="All 2 branches missed.">			&amp;&amp; !availableSpells(adjSpellLevel, aClass, bookName, true, acs.isSpecialtySpell(this)))</span>
		{
			String ret;
			int maxAllowed;
			// If this were a specialty spell, would there be room?
<span class="nc bnc" id="L4277" title="All 4 branches missed.">			if (!acs.isSpecialtySpell(this) &amp;&amp; availableSpells(adjSpellLevel, aClass, bookName, true, true))</span>
			{
<span class="nc" id="L4279">				ret = &quot;Your remaining slot(s) must be filled with your speciality.&quot;;</span>
<span class="nc" id="L4280">				maxAllowed = known;</span>
			}
			else
			{
<span class="nc" id="L4284">				ret = &quot;You can only learn &quot; + (known + specialKnown) + &quot; spells for level &quot; + adjSpellLevel</span>
					+ &quot; \nand there are no higher-level slots available.&quot;;
<span class="nc" id="L4286">				maxAllowed = known + specialKnown;</span>
			}
<span class="nc" id="L4288">			int memTot = SpellCountCalc.memorizedSpellForLevelBook(this, aClass, adjSpellLevel, bookName);</span>
<span class="nc" id="L4289">			int spellDifference = maxAllowed - memTot;</span>
<span class="nc bnc" id="L4290" title="All 2 branches missed.">			if (spellDifference &gt; 0)</span>
			{
<span class="nc" id="L4292">				ret += &quot;\n&quot; + spellDifference + &quot; spells from lower levels are using slots for this level.&quot;;</span>
			}
<span class="nc" id="L4294">			return ret;</span>
		}
<span class="nc bnc" id="L4296" title="All 4 branches missed.">		else if (aClass.getSafe(ObjectKey.MEMORIZE_SPELLS) &amp;&amp; !isDefault</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">			&amp;&amp; !availableSpells(adjSpellLevel, aClass, bookName, false, acs.isSpecialtySpell(this)))</span>
		{
			String ret;
			int maxAllowed;
<span class="nc bnc" id="L4301" title="All 4 branches missed.">			if (!acs.isSpecialtySpell(this) &amp;&amp; availableSpells(adjSpellLevel, aClass, bookName, false, true))</span>
			{
<span class="nc" id="L4303">				ret = &quot;Your remaining slot(s) must be filled with your speciality or domain.&quot;;</span>
<span class="nc" id="L4304">				maxAllowed = this.getSpellSupport(aClass).getCastForLevel(adjSpellLevel, bookName, false, true, this);</span>
			}
<span class="nc bnc" id="L4306" title="All 4 branches missed.">			else if (acs.isSpecialtySpell(this) &amp;&amp; availableSpells(adjSpellLevel, aClass, bookName, false, false))</span>
			{
<span class="nc" id="L4308">				ret = &quot;Your remaining slot(s) must be filled with spells not from your speciality or domain.&quot;;</span>
<span class="nc" id="L4309">				maxAllowed = this.getSpellSupport(aClass).getCastForLevel(adjSpellLevel, bookName, false, true, this);</span>
			}
			else
			{
<span class="nc" id="L4313">				ret = &quot;You can only prepare &quot; + cast + &quot; spells for level &quot; + adjSpellLevel</span>
					+ &quot; \nand there are no higher-level slots available.&quot;;
<span class="nc" id="L4315">				maxAllowed = cast;</span>
<span class="nc" id="L4316">				int memTot = SpellCountCalc.memorizedSpellForLevelBook(this, aClass, adjSpellLevel, bookName);</span>
<span class="nc" id="L4317">				int spellDifference = maxAllowed - memTot;</span>
<span class="nc bnc" id="L4318" title="All 2 branches missed.">				if (spellDifference &gt; 0)</span>
				{
<span class="nc" id="L4320">					ret += &quot;\n&quot; + spellDifference + &quot; spells from lower levels are using slots for this level.&quot;;</span>
				}
			}
<span class="nc" id="L4323">			return ret;</span>
		}

		// determine if this spell already exists
		// for this character in this book at this level
<span class="nc" id="L4328">		SpellInfo si = null;</span>
<span class="nc" id="L4329">		final List&lt;CharacterSpell&gt; acsList = getCharacterSpells(aClass, acs.getSpell(), bookName, adjSpellLevel);</span>
<span class="nc bnc" id="L4330" title="All 2 branches missed.">		if (!acsList.isEmpty())</span>
		{
<span class="nc bnc" id="L4332" title="All 2 branches missed.">			for (int x = acsList.size() - 1; x &gt;= 0; x--)</span>
			{
<span class="nc" id="L4334">				final CharacterSpell c = acsList.get(x);</span>
<span class="nc bnc" id="L4335" title="All 2 branches missed.">				if (!c.equals(acs))</span>
				{
<span class="nc" id="L4337">					acsList.remove(x);</span>
				}
			}
		}
<span class="nc" id="L4341">		final boolean isEmpty = acsList.isEmpty();</span>
<span class="nc bnc" id="L4342" title="All 2 branches missed.">		if (!isEmpty)</span>
		{
			// I am not sure why this code is set up like this but it is
			// bogus. I am trying to break as little as possible so if
			// I have one matching spell I will use it otherwise I will
			// use the passed in spell.
<span class="nc bnc" id="L4348" title="All 2 branches missed.">			if (acsList.size() == 1)</span>
			{
<span class="nc" id="L4350">				final CharacterSpell tcs = acsList.get(0);</span>
<span class="nc" id="L4351">				si = tcs.getSpellInfoFor(bookName, adjSpellLevel, aFeatList);</span>
<span class="nc" id="L4352">			}</span>
			else
			{
<span class="nc" id="L4355">				si = acs.getSpellInfoFor(bookName, adjSpellLevel, aFeatList);</span>
			}
		}

<span class="nc bnc" id="L4359" title="All 2 branches missed.">		if (si != null)</span>
		{
			// okay, we already known this spell, so if they are
			// trying to add it to the default spellBook, barf
			// otherwise increment the number of times memorized
<span class="nc bnc" id="L4364" title="All 2 branches missed.">			if (isDefault)</span>
			{
<span class="nc" id="L4366">				return &quot;The Known Spells spellbook contains all spells of this level that you know. &quot;</span>
						+ &quot;You cannot place spells in multiple times.&quot;;
			}
<span class="nc" id="L4369">			si.setTimes(si.getTimes() + 1);</span>
		}
		else
		{
<span class="nc bnc" id="L4373" title="All 4 branches missed.">			if (isEmpty &amp;&amp; !containsCharacterSpell(aClass, acs))</span>
			{
<span class="nc" id="L4375">				addCharacterSpell(aClass, acs);</span>
			}
<span class="nc bnc" id="L4377" title="All 2 branches missed.">			else if (isEmpty)</span>
			{
				// Make sure that we are working on the same spell object, not just the same spell
<span class="nc bnc" id="L4380" title="All 2 branches missed.">				for (CharacterSpell characterSpell : getCharacterSpells(aClass))</span>
				{
<span class="nc bnc" id="L4382" title="All 2 branches missed.">					if (characterSpell.equals(acs))</span>
					{
<span class="nc" id="L4384">						acs = characterSpell;</span>
					}
<span class="nc" id="L4386">				}</span>
			}
<span class="nc" id="L4388">			si = acs.addInfo(spellLevel, adjSpellLevel, 1, bookName, aFeatList);</span>
		}
		// Set number of pages on the spell
<span class="nc" id="L4391">		si.setNumPages(si.getNumPages() + numPages);</span>
<span class="nc" id="L4392">		setDirty(true);</span>
<span class="nc" id="L4393">		return &quot;&quot;;</span>
	}

	/**
	 * return value indicates if book was actually added or not
	 *
	 * @param aName
	 * @return TRUE or FALSE
	 */
	public boolean addSpellBook(final String aName)
	{
<span class="nc bnc" id="L4404" title="All 6 branches missed.">		if (aName != null &amp;&amp; (!aName.isEmpty()) &amp;&amp; !spellBookFacet.containsBookNamed(id, aName))</span>
		{
<span class="nc" id="L4406">			return addSpellBook(new SpellBook(aName, SpellBook.TYPE_PREPARED_LIST));</span>
		}
<span class="nc" id="L4408">		return false;</span>
	}

	public final boolean addSpellBook(final SpellBook book)
	{
<span class="pc bpc" id="L4413" title="1 of 2 branches missed.">		if (!spellBookFacet.containsBookNamed(id, book.getName()))</span>
		{
<span class="fc" id="L4415">			spellBookFacet.add(id, book);</span>
			//setDirty(true);
<span class="fc" id="L4417">			return true;</span>
		}
<span class="nc" id="L4419">		return false;</span>
	}

	public boolean addTemplate(final PCTemplate inTemplate)
	{
<span class="pc bpc" id="L4424" title="1 of 2 branches missed.">		if (inTemplate == null)</span>
		{
<span class="nc" id="L4426">			return false;</span>
		}

		// Don't allow multiple copies of template.
<span class="pc bpc" id="L4430" title="1 of 2 branches missed.">		if (hasTemplate(inTemplate))</span>
		{
<span class="nc" id="L4432">			return false;</span>
		}

<span class="fc" id="L4435">		int lockMonsterSkillPoints = 0; // this is what this value was before</span>
		// adding this template
<span class="pc bpc" id="L4437" title="1 of 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc bnc" id="L4439" title="All 2 branches missed.">			if (pcClass.isMonster())</span>
			{
<span class="nc" id="L4441">				lockMonsterSkillPoints = (int) getTotalBonusTo(&quot;MONSKILLPTS&quot;, &quot;LOCKNUMBER&quot;);</span>
<span class="nc" id="L4442">				break;</span>
			}
<span class="nc" id="L4444">		}</span>

<span class="fc" id="L4446">		boolean added = templateInputFacet.add(id, inTemplate);</span>

<span class="pc bpc" id="L4448" title="1 of 2 branches missed.">		if (!added)</span>
		{
<span class="nc" id="L4450">			return false;</span>
		}

<span class="fc" id="L4453">		this.setDirty(true);</span>

<span class="fc" id="L4455">		calcActiveBonuses();</span>
		// adding this template
<span class="fc" id="L4457">		boolean first = true;</span>
<span class="pc bpc" id="L4458" title="1 of 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc bnc" id="L4460" title="All 2 branches missed.">			if (pcClass.isMonster())</span>
			{
<span class="nc" id="L4462">				int postLockMonsterSkillPoints =</span>
<span class="nc" id="L4463">						(int) getTotalBonusTo(&quot;MONSKILLPTS&quot;, &quot;LOCKNUMBER&quot;); // this is what this value was before</span>

<span class="nc bnc" id="L4465" title="All 4 branches missed.">				if (postLockMonsterSkillPoints != lockMonsterSkillPoints &amp;&amp; postLockMonsterSkillPoints &gt; 0)</span>
				{
<span class="nc bnc" id="L4467" title="All 2 branches missed.">					for (PCLevelInfo pi : getLevelInfo())</span>
					{
<span class="nc" id="L4469">						final int newSkillPointsGained = recalcSkillPointMod(pcClass, pi.getClassLevel());</span>
<span class="nc bnc" id="L4470" title="All 2 branches missed.">						if (pi.getClassKeyName().equals(pcClass.getKeyName()))</span>
						{
<span class="nc" id="L4472">							final int formerGained = pi.getSkillPointsGained(this);</span>
<span class="nc" id="L4473">							pi.setSkillPointsGained(this, newSkillPointsGained);</span>
<span class="nc" id="L4474">							pi.setSkillPointsRemaining(</span>
<span class="nc" id="L4475">								pi.getSkillPointsRemaining() + newSkillPointsGained - formerGained);</span>
<span class="nc" id="L4476">							setSkillPool(pcClass, pcClass.getSkillPool(this) + newSkillPointsGained - formerGained);</span>
						}
<span class="nc" id="L4478">					}</span>
				}
			}
			//
			// Recalculate HPs in case HD have changed.
			//
<span class="nc bnc" id="L4484" title="All 2 branches missed.">			if (!importing)</span>
			{
<span class="nc" id="L4486">				Processor&lt;HitDie&gt; dieLock = inTemplate.get(ObjectKey.HITDIE);</span>
<span class="nc bnc" id="L4487" title="All 2 branches missed.">				if (dieLock != null)</span>
				{
<span class="nc bnc" id="L4489" title="All 2 branches missed.">					for (int level = 1; level &lt;= getLevel(pcClass); level++)</span>
					{
<span class="nc" id="L4491">						HitDie baseHD = pcClass.getSafe(ObjectKey.LEVEL_HITDIE);</span>
<span class="nc bnc" id="L4492" title="All 2 branches missed.">						if (!baseHD.equals(getLevelHitDie(pcClass, level)))</span>
						{
							// If the HD has changed from base reroll
<span class="nc" id="L4495">							rollHP(pcClass, level, first);</span>
						}
					}
				}
			}
<span class="nc" id="L4500">			first = false;</span>
<span class="nc" id="L4501">		}</span>

<span class="fc" id="L4503">		setDirty(true);</span>
<span class="fc" id="L4504">		return true;</span>
	}

	/**
	 * recalculate all the move rates and modifiers
	 */
	public void adjustMoveRates()
	{
<span class="nc" id="L4512">		moveResultFacet.reset(id);</span>
		//setDirty(true);
<span class="nc" id="L4514">	}</span>

	public List&lt;Spell&gt; aggregateSpellList(final String school, final String subschool, final String descriptor,
		final int minLevel, final int maxLevel)
	{
<span class="nc" id="L4519">		final List&lt;Spell&gt; retList = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L4521" title="All 2 branches missed.">		for (PObject pObj : getSpellClassList())</span>
		{
<span class="nc bnc" id="L4523" title="All 2 branches missed.">			for (int a = minLevel; a &lt;= maxLevel; a++)</span>
			{
<span class="nc bnc" id="L4525" title="All 2 branches missed.">				for (CharacterSpell cs : getCharacterSpells(pObj, a))</span>
				{
<span class="nc" id="L4527">					final Spell aSpell = cs.getSpell();</span>
<span class="nc" id="L4528">					SpellSchool ss = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4529">						.silentlyGetConstructedCDOMObject(SpellSchool.class, school);</span>

<span class="nc bnc" id="L4531" title="All 6 branches missed.">					if ((school.isEmpty()) || (ss != null) &amp;&amp; aSpell.containsInList(ListKey.SPELL_SCHOOL, ss)</span>
<span class="nc bnc" id="L4532" title="All 4 branches missed.">						|| (subschool.isEmpty()) || aSpell.containsInList(ListKey.SPELL_SUBSCHOOL, subschool)</span>
<span class="nc bnc" id="L4533" title="All 4 branches missed.">						|| (descriptor.isEmpty()) || aSpell.containsInList(ListKey.SPELL_DESCRIPTOR, descriptor))</span>
					{
<span class="nc" id="L4535">						retList.add(aSpell);</span>
					}
<span class="nc" id="L4537">				}</span>
			}
<span class="nc" id="L4539">		}</span>

<span class="nc" id="L4541">		return retList;</span>
	}

	/**
	 * @return Total base attack bonus as an int
	 */
	public int baseAttackBonus()
	{
		// check for cached version
<span class="nc" id="L4550">		final String cacheLookup = &quot;BaseAttackBonus&quot;;</span>
<span class="nc" id="L4551">		Float total = variableProcessor.getCachedVariable(cacheLookup);</span>
<span class="nc bnc" id="L4552" title="All 2 branches missed.">		if (total != null)</span>
		{
<span class="nc" id="L4554">			return total.intValue();</span>
		}

		// get Master's BAB
<span class="nc" id="L4558">		final PlayerCharacter nPC = getMasterPC();</span>

<span class="nc bnc" id="L4560" title="All 4 branches missed.">		if ((nPC != null) &amp;&amp; (!masterFacet.getCopyMasterBAB(id).isEmpty()))</span>
		{
<span class="nc" id="L4562">			int masterBAB = nPC.baseAttackBonus();</span>
<span class="nc" id="L4563">			final String copyMasterBAB = replaceMasterString(masterFacet.getCopyMasterBAB(id), masterBAB);</span>
<span class="nc" id="L4564">			masterBAB = getVariableValue(copyMasterBAB, &quot;&quot;).intValue();</span>

<span class="nc" id="L4566">			variableProcessor.addCachedVariable(cacheLookup, (float) masterBAB);</span>
<span class="nc" id="L4567">			return masterBAB;</span>
		}
<span class="nc" id="L4569">		int bab = (int) getTotalBonusTo(&quot;COMBAT&quot;, &quot;BASEAB&quot;);</span>
<span class="nc" id="L4570">		variableProcessor.addCachedVariable(cacheLookup, (float) bab);</span>
<span class="nc" id="L4571">		return bab;</span>
	}

	/**
	 * Creates the activeBonusList which is used to calculate all the bonuses to
	 * a PC
	 */
	public void calcActiveBonuses()
	{
<span class="pc bpc" id="L4580" title="1 of 4 branches missed.">		if (importing || (getRace() == null))</span>
		{
<span class="fc" id="L4582">			return;</span>
		}

		// Keep rebuilding the active bonus map until the
		// contents do not change. This is to cope with the
		// situation where we have a variable A that has a prereq
		// that depends on variable B that will not be the correct
		// value until after the map has been completely created.

<span class="fc" id="L4591">		int count = 0;</span>
		do
		{
<span class="pc bpc" id="L4594" title="1 of 2 branches missed.">			if (count &gt;= 29)</span>
			{
<span class="nc" id="L4596">				Logging.errorPrint(&quot;Active bonus loop exceeded reasonable limit of &quot; + count + '.');</span>
<span class="nc" id="L4597">				bonusManager.logChangeFromCheckpoint();</span>
<span class="nc bnc" id="L4598" title="All 2 branches missed.">				if (count &gt; 31)</span>
				{
<span class="nc" id="L4600">					break;</span>
				}
			}
<span class="fc" id="L4603">			bonusManager.checkpointBonusMap();</span>
<span class="fc" id="L4604">			setDirty(true);</span>
<span class="fc" id="L4605">			count++;</span>
<span class="fc" id="L4606">			calcActiveBonusLoop();</span>
<span class="pc bpc" id="L4607" title="1 of 2 branches missed.">			if (Globals.checkRule(RuleConstants.RETROSKILL))</span>
			{
<span class="nc" id="L4609">				checkSkillModChange();</span>
			}
		}
<span class="pc bpc" id="L4612" title="1 of 2 branches missed.">		while (!bonusManager.compareToCheckpoint());</span>
		// If the newly calculated bonus map is different to the old one
		// loop again until they are the same.
<span class="pc bpc" id="L4615" title="1 of 2 branches missed.">		if (Logging.isDebugMode())</span>
		{
<span class="nc" id="L4617">			Logging.log(Logging.DEBUG, &quot;Ran &quot; + count + &quot; loops to calc bonuses&quot;);</span>
		}
<span class="fc" id="L4619">	}</span>

	/*
	 * These are designed to catch a re-entrant bonus loop, which can occur
	 * when a BONUS contains a level limited item in a Formula, such as BAB
	 */
<span class="pc" id="L4625">	private int cablInt = 1;</span>
<span class="pc" id="L4626">	private int lastCablInt = 0;</span>

	private void calcActiveBonusLoop()
	{
<span class="pc bpc" id="L4630" title="1 of 2 branches missed.">		if (cablInt == lastCablInt)</span>
		{
<span class="nc" id="L4632">			return;</span>
		}
<span class="fc" id="L4634">		lastCablInt = cablInt;</span>
<span class="fc" id="L4635">		bonusManager.setActiveBonusList();</span>
		// buildBonusMap(bonuses);
<span class="fc" id="L4637">		bonusManager.buildActiveBonusMap();</span>
<span class="fc" id="L4638">		cablInt++;</span>
<span class="fc" id="L4639">		bonusChangeFacet.reset(id);</span>
<span class="fc" id="L4640">	}</span>

	public int calcSR(final boolean includeEquipment)
	{
<span class="nc" id="L4644">		int SR = srFacet.getSR(id);</span>

<span class="nc bnc" id="L4646" title="All 2 branches missed.">		if (includeEquipment)</span>
		{
<span class="nc bnc" id="L4648" title="All 2 branches missed.">			for (Equipment eq : getEquippedEquipmentSet())</span>
			{
<span class="nc" id="L4650">				SR = Math.max(SR,</span>
<span class="nc" id="L4651">					eq.getSafe(ObjectKey.SR).getReduction().resolve(this, eq.getQualifiedKey()).intValue());</span>

<span class="nc bnc" id="L4653" title="All 2 branches missed.">				for (EquipmentModifier eqMod : eq.getEqModifierList(true))</span>
				{
<span class="nc" id="L4655">					SR = Math.max(SR, eqMod.getSR(eq, this));</span>
<span class="nc" id="L4656">				}</span>

<span class="nc bnc" id="L4658" title="All 2 branches missed.">				for (EquipmentModifier eqMod : eq.getEqModifierList(false))</span>
				{
<span class="nc" id="L4660">					SR = Math.max(SR, eqMod.getSR(eq, this));</span>
<span class="nc" id="L4661">				}</span>
<span class="nc" id="L4662">			}</span>
		}

<span class="nc" id="L4665">		SR += (int) getTotalBonusTo(&quot;MISC&quot;, &quot;SR&quot;);</span>
		// SR += (int) getBonusValue(&quot;MISC&quot;, &quot;SR&quot;);

		//
		// This would make more sense to just not add in the first place...
		//
<span class="nc bnc" id="L4671" title="All 2 branches missed.">		if (!includeEquipment)</span>
		{
<span class="nc" id="L4673">			SR -= (int) getEquipmentBonusTo(&quot;MISC&quot;, &quot;SR&quot;);</span>
		}

<span class="nc" id="L4676">		return SR;</span>
	}

	/**
	 * Method will go through the list of classes that the PC has and see if
	 * they can cast spells of desired type at desired &lt;b&gt;spell level&lt;/b&gt;.
	 *
	 * @param spellType
	 *            Spell type to check for
	 * @param spellLevel
	 *            Desired spell level
	 * @return boolean &lt;p&gt; author David Wilson
	 *         &lt;eldiosyeldiablo@users.sourceforge.net&gt;
	 */
	private boolean canCastSpellTypeLevel(final String spellType, final int spellLevel)
	{
<span class="nc bnc" id="L4692" title="All 2 branches missed.">		for (PCClass aClass : getClassSet())</span>
		{
<span class="nc" id="L4694">			FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;SpellType&quot;);</span>
<span class="nc" id="L4695">			String classSpellType = aClass.getResolved(fk);</span>
<span class="nc bnc" id="L4696" title="All 2 branches missed.">			if (classSpellType != null</span>
<span class="nc bnc" id="L4697" title="All 4 branches missed.">				&amp;&amp; (&quot;Any&quot;.equalsIgnoreCase(spellType) || classSpellType.equalsIgnoreCase(spellType)))</span>
			{
				// Get the number of known spells for the level
<span class="nc" id="L4700">				int knownForLevel = this.getSpellSupport(aClass).getKnownForLevel(spellLevel, this);</span>
<span class="nc" id="L4701">				knownForLevel += this.getSpellSupport(aClass).getSpecialtyKnownForLevel(spellLevel, this);</span>
<span class="nc bnc" id="L4702" title="All 2 branches missed.">				if (knownForLevel &gt;= 1)</span>
				{
<span class="nc" id="L4704">					return true;</span>
				}

				// See if the character can cast
				// at the required spell level
<span class="nc bnc" id="L4709" title="All 2 branches missed.">				if (this.getSpellSupport(aClass).getCastForLevel(spellLevel, this) &gt;= 1)</span>
				{
<span class="nc" id="L4711">					return true;</span>
				}

				// If they don't memorise spells and don't have
				// a CastList then they use something funky
				// like Power Points (psionic)
<span class="nc bnc" id="L4717" title="All 4 branches missed.">				if (!aClass.getSafe(ObjectKey.MEMORIZE_SPELLS) &amp;&amp; !this.getSpellSupport(aClass).hasKnownList()</span>
<span class="nc bnc" id="L4718" title="All 2 branches missed.">					&amp;&amp; this.getSpellSupport(aClass).canCastSpells(this))</span>
				{
<span class="nc" id="L4720">					return true;</span>
				}
			}
<span class="nc" id="L4723">		}</span>

<span class="nc" id="L4725">		return false;</span>
	}

	/**
	 * Method will go through the list of classes that the PC has and see if
	 * they can cast spells of desired type at desired &lt;b&gt;spell level&lt;/b&gt;.
	 *
	 * @param spellType
	 *            Spell type to check for
	 * @param spellLevel
	 *            Desired spell level
	 * @return The number of spells castable
	 **/
	public int countSpellCastTypeLevel(final String spellType, final int spellLevel)
	{
<span class="nc" id="L4740">		int known = 0;</span>
<span class="nc" id="L4741">		int cast = 0;</span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">		for (PCClass aClass : getClassSet())</span>
		{
<span class="nc" id="L4744">			FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;SpellType&quot;);</span>
<span class="nc" id="L4745">			String classSpellType = aClass.getResolved(fk);</span>
<span class="nc bnc" id="L4746" title="All 2 branches missed.">			if (classSpellType != null</span>
<span class="nc bnc" id="L4747" title="All 4 branches missed.">				&amp;&amp; (&quot;Any&quot;.equalsIgnoreCase(spellType) || classSpellType.equalsIgnoreCase(spellType)))</span>
			{
<span class="nc" id="L4749">				int numCastLevel = this.getSpellSupport(aClass).getCastForLevel(spellLevel, this);</span>

				// Get the number of known spells for the level
<span class="nc" id="L4752">				known += this.getSpellSupport(aClass).getKnownForLevel(spellLevel, this);</span>
<span class="nc bnc" id="L4753" title="All 2 branches missed.">				if (numCastLevel &gt; 0)</span>
				{
<span class="nc" id="L4755">					known += this.getSpellSupport(aClass).getSpecialtyKnownForLevel(spellLevel, this);</span>
				}

				// See if the character can cast
				// at the required spell level
<span class="nc" id="L4760">				cast += numCastLevel;</span>

				// If they don't memorise spells and don't have
				// a CastList then they use something funky
				// like Power Points (psionic)
<span class="nc bnc" id="L4765" title="All 4 branches missed.">				if (!aClass.getSafe(ObjectKey.MEMORIZE_SPELLS) &amp;&amp; !this.getSpellSupport(aClass).hasKnownList()</span>
<span class="nc bnc" id="L4766" title="All 2 branches missed.">					&amp;&amp; this.getSpellSupport(aClass).canCastSpells(this))</span>
				{
<span class="nc" id="L4768">					return Integer.MAX_VALUE;</span>
				}
			}
<span class="nc" id="L4771">		}</span>

<span class="nc bnc" id="L4773" title="All 2 branches missed.">		return known == 0 ? cast : known;</span>
	}

	/**
	 * Check whether a deity can be selected by this character
	 *
	 * @return {@code true} means the deity can be a selected by a
	 *         character with the given properties; {@code false} means
	 *         the character cannot.
	 */
	public boolean canSelectDeity(final Deity aDeity)
	{
<span class="nc" id="L4785">		return legalDeityFacet.allows(id, aDeity);</span>
	}

	/**
	 * Return value indicates whether or not a spell was deleted.
	 *
	 * @param si
	 * @param aClass
	 * @param bookName
	 * @return String
	 */
	public String delSpell(SpellInfo si, final PCClass aClass, final String bookName)
	{
<span class="nc bnc" id="L4798" title="All 4 branches missed.">		if ((bookName == null) || (bookName.isEmpty()))</span>
		{
<span class="nc" id="L4800">			return &quot;Invalid spell book name.&quot;;</span>
		}

<span class="nc bnc" id="L4803" title="All 2 branches missed.">		if (aClass == null)</span>
		{
<span class="nc" id="L4805">			return &quot;Error: Class is null&quot;;</span>
		}

<span class="nc" id="L4808">		final CharacterSpell acs = si.getOwner();</span>

<span class="nc" id="L4810">		final boolean isDefault = bookName.equals(Globals.getDefaultSpellBook());</span>

		// yes, you can remove spells from the default spellbook,
		// but they will just get added back in when the character
		// is re-loaded. But, allow them to do it anyway, just in case
		// there is some weird spell that keeps getting loaded by
		// accident (or is saved in the .pcg file)
<span class="nc bnc" id="L4817" title="All 2 branches missed.">		if (isDefault</span>
<span class="nc bnc" id="L4818" title="All 2 branches missed.">			&amp;&amp; this.getSpellSupport(aClass).isAutoKnownSpell(acs.getSpell(), si.getActualLevel(), false, this))</span>
		{
<span class="nc" id="L4820">			Logging.errorPrint(</span>
<span class="nc" id="L4821">				&quot;Notice: removing &quot; + acs.getSpell().getDisplayName() + &quot; even though it is an auto known spell&quot;);</span>
		}

<span class="nc" id="L4824">		SpellBook spellBook = getSpellBookByName(bookName);</span>
<span class="nc bnc" id="L4825" title="All 2 branches missed.">		if (spellBook.getType() == SpellBook.TYPE_SPELL_BOOK)</span>
		{
<span class="nc" id="L4827">			int pagesPerSpell = si.getNumPages() / si.getTimes();</span>
<span class="nc" id="L4828">			spellBook.setNumPagesUsed(spellBook.getNumPagesUsed() - pagesPerSpell);</span>
<span class="nc" id="L4829">			spellBook.setNumSpells(spellBook.getNumSpells() - 1);</span>
<span class="nc" id="L4830">			si.setNumPages(si.getNumPages() - pagesPerSpell);</span>
		}
<span class="nc" id="L4832">		si.setTimes(si.getTimes() - 1);</span>

<span class="nc bnc" id="L4834" title="All 2 branches missed.">		if (si.getTimes() &lt;= 0)</span>
		{
<span class="nc" id="L4836">			acs.removeSpellInfo(si);</span>
		}

		// Remove the spell form the character's class instance if it
		// is no longer present in any book
<span class="nc bnc" id="L4841" title="All 2 branches missed.">		if (acs.getInfoList().isEmpty())</span>
		{
<span class="nc" id="L4843">			removeCharacterSpell(aClass, acs);</span>
		}

<span class="nc" id="L4846">		return &quot;&quot;;</span>
	}

	/**
	 * Calculate different kinds of bonuses to saves. possible tokens are
	 * &lt;ul&gt;
	 * &lt;li&gt;save&lt;/li&gt;
	 * &lt;li&gt;save.TOTAL&lt;/li&gt;
	 * &lt;li&gt;save.BASE&lt;/li&gt;
	 * &lt;li&gt;save.MISC&lt;/li&gt;
	 * &lt;li&gt;save.list&lt;/li&gt;
	 * &lt;li&gt;save.TOTAL.list&lt;/li&gt;
	 * &lt;li&gt;save.BASE.list&lt;/li&gt;
	 * &lt;li&gt;save.MISC.list&lt;/li&gt;
	 * &lt;/ul&gt;
	 * where&lt;br&gt;
	 * save := &quot;CHECK1&quot;|&quot;CHECK2&quot;|&quot;CHECK3&quot;&lt;br&gt;
	 * list := ((include|exclude)del)*(include|exclude)&lt;br&gt;
	 * include := &quot;FEATS&quot;|&quot;MAGIC&quot;|&quot;RACE&quot;&lt;br&gt;
	 * exclude := &quot;NOFEATS&quot;|&quot;NOMAGIC&quot;|&quot;NORACE&quot;|&quot;NOSTAT&quot; &lt;br&gt;
	 * del := &quot;.&quot; &lt;br&gt;
	 * given as regular expression. &lt;p&gt; &quot;include&quot;-s will add the appropriate
	 * modifier &quot;exclude&quot;-s will subtract the appropriate modifier &lt;p&gt; (This
	 * means &lt;tt&gt;save.MAGIC.NOMAGIC&lt;/tt&gt; equals 0, whereas
	 * &lt;tt&gt;save.RACE.RACE&lt;/tt&gt; equals 2 times the racial bonus) &lt;p&gt; If you
	 * use unrecognised terminals, their value will amount to 0 This means
	 * &lt;tt&gt;save.BLABLA&lt;/tt&gt; equals 0 whereas &lt;tt&gt;save.MAGIC.BLABLA&lt;/tt&gt;
	 * equals &lt;tt&gt;save.MAGIC&lt;/tt&gt; &lt;p&gt; &lt;br&gt;
	 * author: Thomas Behr 09-03-02
	 *
	 * @param check
	 * @param tokenString
	 *            tokenString to parse
	 * @return the calculated save bonus
	 */
	public int calculateSaveBonus(final PCCheck check, final String tokenString)
	{
<span class="nc bnc" id="L4883" title="All 2 branches missed.">		if (check == null)</span>
		{
<span class="nc" id="L4885">			return 0;</span>
		}
<span class="nc" id="L4887">		final StringTokenizer aTok = new StringTokenizer(tokenString, &quot;.&quot;);</span>
<span class="nc" id="L4888">		final String[] tokens = new String[aTok.countTokens()];</span>
<span class="nc" id="L4889">		int save = 0;</span>
<span class="nc" id="L4890">		String saveType = check.toString();</span>

<span class="nc bnc" id="L4892" title="All 2 branches missed.">		for (int i = 0; aTok.hasMoreTokens(); ++i)</span>
		{
<span class="nc" id="L4894">			tokens[i] = aTok.nextToken();</span>

<span class="nc bnc" id="L4896" title="All 2 branches missed.">			if (&quot;TOTAL&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4898">				save += getTotalCheck(check);</span>
			}
<span class="nc bnc" id="L4900" title="All 2 branches missed.">			else if (&quot;BASE&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4902">				save += getBaseCheck(check);</span>
			}
<span class="nc bnc" id="L4904" title="All 2 branches missed.">			else if (&quot;MISC&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4906">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.MISCSAVE);</span>
<span class="nc bnc" id="L4907" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4909">					save += (int) getTotalBonusTo(&quot;SAVE&quot;, saveType);</span>
				}
				else
				{
<span class="nc" id="L4913">					save += ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L4917" title="All 2 branches missed.">			if (&quot;EPIC&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4919">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.EPICSAVE);</span>
<span class="nc bnc" id="L4920" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4922">					save += (int) getBonusDueToType(&quot;SAVE&quot;, saveType, &quot;EPIC&quot;);</span>
				}
				else
				{
<span class="nc" id="L4926">					save += ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L4930" title="All 2 branches missed.">			if (&quot;MAGIC&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4932">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.MAGICSAVE);</span>
<span class="nc bnc" id="L4933" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4935">					save += (int) getEquipmentBonusTo(&quot;SAVE&quot;, saveType);</span>
				}
				else
				{
<span class="nc" id="L4939">					save += ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L4943" title="All 2 branches missed.">			if (&quot;RACE&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4945">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.RACESAVE);</span>
<span class="nc bnc" id="L4946" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4948">					save += calculateSaveBonusRace(check);</span>
				}
				else
				{
<span class="nc" id="L4952">					save += ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L4956" title="All 2 branches missed.">			if (&quot;FEATS&quot;.equals(tokens[i]))</span>
			{
<span class="nc bnc" id="L4958" title="All 2 branches missed.">				if (ControlUtilities.hasControlToken(Globals.getContext(), CControl.BASESAVE))</span>
				{
<span class="nc" id="L4960">					Logging.errorPrint(</span>
						&quot;FEATS is not a supported SAVE modification &quot; + &quot;when BASESAVE Code Control is used&quot;);
				}
				else
				{
<span class="nc" id="L4965">					save += (int) getFeatBonusTo(&quot;SAVE&quot;, saveType);</span>
				}
			}

<span class="nc bnc" id="L4969" title="All 2 branches missed.">			if (&quot;STATMOD&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4971">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.STATMODSAVE);</span>
<span class="nc bnc" id="L4972" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4974">					save += (int) checkBonusFacet.getCheckBonusTo(id, &quot;SAVE&quot;, saveType);</span>
				}
				else
				{
<span class="nc" id="L4978">					save += ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

			/*
			 * exclude stuff
			 */
<span class="nc bnc" id="L4985" title="All 2 branches missed.">			if (&quot;NOEPIC&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L4987">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.EPICSAVE);</span>
<span class="nc bnc" id="L4988" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L4990">					save -= (int) getBonusDueToType(&quot;SAVE&quot;, saveType, &quot;EPIC&quot;);</span>
				}
				else
				{
<span class="nc" id="L4994">					save -= ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L4998" title="All 2 branches missed.">			if (&quot;NOMAGIC&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L5000">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.MAGICSAVE);</span>
<span class="nc bnc" id="L5001" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L5003">					save -= (int) getEquipmentBonusTo(&quot;SAVE&quot;, saveType);</span>
				}
				else
				{
<span class="nc" id="L5007">					save -= ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L5011" title="All 2 branches missed.">			if (&quot;NORACE&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L5013">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.RACESAVE);</span>
<span class="nc bnc" id="L5014" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L5016">					save -= calculateSaveBonusRace(check);</span>
				}
				else
				{
<span class="nc" id="L5020">					save -= ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}

<span class="nc bnc" id="L5024" title="All 2 branches missed.">			if (&quot;NOFEATS&quot;.equals(tokens[i]))</span>
			{
<span class="nc bnc" id="L5026" title="All 2 branches missed.">				if (ControlUtilities.hasControlToken(Globals.getContext(), CControl.BASESAVE))</span>
				{
<span class="nc" id="L5028">					Logging.errorPrint(</span>
						&quot;NOFEATS is not a supported SAVE modification &quot; + &quot;when BASESAVE Code Control is used&quot;);
				}
				else
				{
<span class="nc" id="L5033">					save -= (int) getFeatBonusTo(&quot;SAVE&quot;, saveType);</span>
				}
			}

<span class="nc bnc" id="L5037" title="All 4 branches missed.">			if (&quot;NOSTAT&quot;.equals(tokens[i]) || &quot;NOSTATMOD&quot;.equals(tokens[i]))</span>
			{
<span class="nc" id="L5039">				String saveVar = ControlUtilities.getControlToken(Globals.getContext(), CControl.STATMODSAVE);</span>
<span class="nc bnc" id="L5040" title="All 2 branches missed.">				if (saveVar == null)</span>
				{
<span class="nc" id="L5042">					save -= (int) checkBonusFacet.getCheckBonusTo(id, &quot;SAVE&quot;, saveType);</span>
				}
				else
				{
<span class="nc" id="L5046">					save -= ((Number) getLocal(check, saveVar)).intValue();</span>
				}
			}
		}

<span class="nc" id="L5051">		return save;</span>
	}

	/**
	 * return value indicates whether or not a book was actually removed
	 *
	 * @param aName
	 * @return true or false
	 */
	public boolean delSpellBook(final String aName)
	{
<span class="nc bnc" id="L5062" title="All 4 branches missed.">		if ((!aName.isEmpty()) &amp;&amp; !aName.equals(Globals.getDefaultSpellBook())</span>
<span class="nc bnc" id="L5063" title="All 2 branches missed.">			&amp;&amp; spellBookFacet.containsBookNamed(id, aName))</span>
		{
<span class="nc" id="L5065">			processSpellBookRemoval(aName);</span>
<span class="nc" id="L5066">			return true;</span>
		}

<span class="nc" id="L5069">		return false;</span>
	}

	private void processSpellBookRemoval(String aName)
	{
<span class="nc" id="L5074">		spellBookFacet.removeBookNamed(id, aName);</span>
<span class="nc" id="L5075">		setDirty(true);</span>

<span class="nc bnc" id="L5077" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc bnc" id="L5079" title="All 2 branches missed.">			for (CharacterSpell cs : getCharacterSpells(pcClass, aName))</span>
			{
<span class="nc" id="L5081">				cs.removeSpellInfo(cs.getSpellInfoFor(aName, -1));</span>
<span class="nc" id="L5082">			}</span>
<span class="nc" id="L5083">		}</span>
<span class="nc" id="L5084">	}</span>

	private void determinePrimaryOffWeapon()
	{
<span class="nc" id="L5088">		primaryWeaponFacet.removeAll(id);</span>
<span class="nc" id="L5089">		secondaryWeaponFacet.removeAll(id);</span>

<span class="nc bnc" id="L5091" title="All 2 branches missed.">		if (!hasEquipment())</span>
		{
<span class="nc" id="L5093">			return;</span>
		}

<span class="nc" id="L5096">		final List&lt;Equipment&gt; unequippedPrimary = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L5097">		final List&lt;Equipment&gt; unequippedSecondary = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L5099" title="All 2 branches missed.">		for (Equipment eq : getEquipmentSet())</span>
		{
<span class="nc bnc" id="L5101" title="All 4 branches missed.">			if (!eq.isWeapon() || (eq.getSlots(this) &lt; 1))</span>
			{
<span class="nc" id="L5103">				continue;</span>
			}

<span class="nc" id="L5106">			final boolean isEquipped = eq.isEquipped();</span>

<span class="nc bnc" id="L5108" title="All 2 branches missed.">			if ((eq.getLocation() == EquipmentLocation.EQUIPPED_PRIMARY)</span>
<span class="nc bnc" id="L5109" title="All 4 branches missed.">				|| ((eq.getLocation() == EquipmentLocation.EQUIPPED_BOTH) &amp;&amp; primaryWeaponFacet.isEmpty(id))</span>
<span class="nc bnc" id="L5110" title="All 2 branches missed.">				|| (eq.getLocation() == EquipmentLocation.EQUIPPED_TWO_HANDS))</span>
			{
<span class="nc bnc" id="L5112" title="All 2 branches missed.">				if (isEquipped)</span>
				{
<span class="nc" id="L5114">					primaryWeaponFacet.add(id, eq);</span>
				}
				else
				{
<span class="nc" id="L5118">					unequippedPrimary.add(eq);</span>
				}
			}
<span class="nc bnc" id="L5121" title="All 4 branches missed.">			else if ((eq.getLocation() == EquipmentLocation.EQUIPPED_BOTH) &amp;&amp; !primaryWeaponFacet.isEmpty(id))</span>
			{
<span class="nc bnc" id="L5123" title="All 2 branches missed.">				if (isEquipped)</span>
				{
<span class="nc" id="L5125">					secondaryWeaponFacet.add(id, eq);</span>
				}
				else
				{
<span class="nc" id="L5129">					unequippedSecondary.add(eq);</span>
				}
			}

<span class="nc bnc" id="L5133" title="All 2 branches missed.">			if (eq.getLocation() == EquipmentLocation.EQUIPPED_SECONDARY)</span>
			{
<span class="nc bnc" id="L5135" title="All 2 branches missed.">				if (isEquipped)</span>
				{
<span class="nc" id="L5137">					secondaryWeaponFacet.add(id, eq);</span>
				}
				else
				{
<span class="nc" id="L5141">					unequippedSecondary.add(eq);</span>
				}
			}

<span class="nc bnc" id="L5145" title="All 2 branches missed.">			if (eq.getLocation() == EquipmentLocation.EQUIPPED_TWO_HANDS)</span>
			{
<span class="nc bnc" id="L5147" title="All 2 branches missed.">				for (int y = 0; y &lt; (eq.getNumberEquipped() - 1); ++y)</span>
				{
<span class="nc bnc" id="L5149" title="All 2 branches missed.">					if (isEquipped)</span>
					{
<span class="nc" id="L5151">						secondaryWeaponFacet.add(id, eq);</span>
					}
					else
					{
<span class="nc" id="L5155">						unequippedSecondary.add(eq);</span>
					}
				}
			}
<span class="nc" id="L5159">		}</span>

<span class="nc bnc" id="L5161" title="All 2 branches missed.">		if (Globals.checkRule(RuleConstants.EQUIPATTACK))</span>
		{
<span class="nc bnc" id="L5163" title="All 2 branches missed.">			if (!unequippedPrimary.isEmpty())</span>
			{
<span class="nc" id="L5165">				primaryWeaponFacet.addAll(id, unequippedPrimary);</span>
			}

<span class="nc bnc" id="L5168" title="All 2 branches missed.">			if (!unequippedSecondary.isEmpty())</span>
			{
<span class="nc" id="L5170">				secondaryWeaponFacet.addAll(id, unequippedSecondary);</span>
			}
		}
<span class="nc" id="L5173">	}</span>

	public boolean hasMadeKitSelectionForAgeSet(final int index)
	{
<span class="nc bnc" id="L5177" title="All 6 branches missed.">		return ((index &gt;= 0) &amp;&amp; (index &lt; 10) &amp;&amp; ageSetKitSelections[index]);</span>
	}

	public boolean hasSpecialAbility(final String abilityKey)
	{
<span class="nc bnc" id="L5182" title="All 2 branches missed.">		for (SpecialAbility sa : getSpecialAbilityList())</span>
		{
<span class="nc bnc" id="L5184" title="All 2 branches missed.">			if (sa.getKeyName().equalsIgnoreCase(abilityKey))</span>
			{
<span class="nc" id="L5186">				return true;</span>
			}
<span class="nc" id="L5188">		}</span>

<span class="nc" id="L5190">		return false;</span>
	}

	public int hitPoints()
	{
<span class="nc" id="L5195">		int total = 0;</span>

<span class="nc" id="L5197">		double iConMod = getStatBonusTo(&quot;HP&quot;, &quot;BONUS&quot;);</span>

<span class="nc bnc" id="L5199" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc" id="L5201">			total += getClassHitPoints(pcClass, (int) iConMod);</span>
<span class="nc" id="L5202">		}</span>

<span class="nc" id="L5204">		total += (int) getTotalBonusTo(&quot;HP&quot;, &quot;CURRENTMAX&quot;);</span>

		//
		// now we see if this PC is a Familiar
<span class="nc" id="L5208">		final PlayerCharacter nPC = getMasterPC();</span>

<span class="nc bnc" id="L5210" title="All 2 branches missed.">		if (nPC == null)</span>
		{
<span class="nc" id="L5212">			return total;</span>
		}

<span class="nc bnc" id="L5215" title="All 2 branches missed.">		if (masterFacet.getCopyMasterHP(id).isEmpty())</span>
		{
<span class="nc" id="L5217">			return total;</span>
		}
		//
		// In order for the BONUS's to work, the PC we want
		// to get the hit points for must be the &quot;current&quot; one.
		//
<span class="nc" id="L5223">		int masterHP = nPC.hitPoints();</span>

<span class="nc" id="L5225">		final String copyMasterHP = replaceMasterString(masterFacet.getCopyMasterHP(id), masterHP);</span>
<span class="nc" id="L5226">		masterHP = getVariableValue(copyMasterHP, &quot;&quot;).intValue();</span>

<span class="nc" id="L5228">		return masterHP;</span>
	}

	private int getClassHitPoints(PCClass pcClass, int iConMod)
	{
<span class="nc" id="L5233">		int total = 0;</span>

<span class="nc bnc" id="L5235" title="All 2 branches missed.">		for (int i = 0; i &lt;= getLevel(pcClass); ++i)</span>
		{
<span class="nc" id="L5237">			PCClassLevel pcl = getActiveClassLevel(pcClass, i);</span>
<span class="nc" id="L5238">			Integer hp = getHP(pcl);</span>
<span class="nc bnc" id="L5239" title="All 4 branches missed.">			if (hp != null &amp;&amp; hp &gt; 0)</span>
			{
<span class="nc" id="L5241">				int iHp = hp + iConMod;</span>

<span class="nc bnc" id="L5243" title="All 2 branches missed.">				if (iHp &lt; 1)</span>
				{
<span class="nc" id="L5245">					iHp = 1;</span>
				}

<span class="nc" id="L5248">				total += iHp;</span>
			}
		}

<span class="nc" id="L5252">		return total;</span>
	}

	/**
	 * Change the number of levels a character has in a particular class. Note:
	 * It is assumed that this method is not used as part of loading a
	 * previously saved character. there is no way to bypass the prerequisites
	 * with this method, also this method does not print warning messages see:
	 * incrementClassLevel(int, PCClass, boolean, boolean);
	 *
	 * @param mod
	 *            the number of levels to add/remove
	 * @param aClass
	 *            the class to adjust
	 */
	public void incrementClassLevel(final int mod, final PCClass aClass)
	{
<span class="nc" id="L5269">		incrementClassLevel(mod, aClass, false);</span>
<span class="nc" id="L5270">		setDirty(true);</span>
<span class="nc" id="L5271">	}</span>

	/**
	 * Calculates the number of languages that the character is qualified
	 * for.
	 *
	 * @return The number of languages allowed
	 */
	public int getBonusLanguageCount()
	{
<span class="nc" id="L5281">		int i = Math.max(0, (int) getStatBonusTo(&quot;LANG&quot;, &quot;BONUS&quot;));</span>
<span class="nc bnc" id="L5282" title="All 2 branches missed.">		if (getRace() != null)</span>
		{
<span class="nc" id="L5284">			i = (int) (i + getTotalBonusTo(&quot;LANGUAGES&quot;, &quot;NUMBER&quot;));</span>
		}
<span class="nc" id="L5286">		return i;</span>
	}

	/**
	 * Lists all the tokens that match prefix with associated values
	 *
	 * @param bonusType
	 * @param bonusName
	 * @return String TODO - Not sure what this is trying to do.
	 */
	public String listBonusesFor(String bonusType, String bonusName)
	{
<span class="nc" id="L5298">		return bonusManager.listBonusesFor(bonusType, bonusName);</span>
	}

	public void makeIntoExClass(final PCClass fromClass)
	{
<span class="nc" id="L5303">		CDOMSingleRef&lt;PCClass&gt; exc = fromClass.get(ObjectKey.EX_CLASS);</span>

		try
		{
<span class="nc" id="L5307">			PCClass cl = exc.get();</span>
<span class="nc" id="L5308">			PCClass toClass = getClassKeyed(cl.getKeyName());</span>

			boolean bClassNew;
			int toLevel;
<span class="nc bnc" id="L5312" title="All 2 branches missed.">			if (toClass == null)</span>
			{
<span class="nc" id="L5314">				toClass = cl.clone(); //Still required :(</span>
<span class="nc" id="L5315">				bClassNew = true;</span>
<span class="nc" id="L5316">				toLevel = 0;</span>
			}
			else
			{
<span class="nc" id="L5320">				bClassNew = false;</span>
<span class="nc" id="L5321">				toLevel = getLevel(toClass);</span>
			}

			//Capture necessary information
<span class="nc" id="L5325">			final int fromLevel = getLevel(fromClass);</span>
<span class="nc" id="L5326">			Integer[] hpArray = new Integer[fromLevel];</span>
<span class="nc bnc" id="L5327" title="All 2 branches missed.">			for (int i = 0; i &lt; fromLevel; i++)</span>
			{
<span class="nc" id="L5329">				PCClassLevel frompcl = getActiveClassLevel(fromClass, i);</span>
<span class="nc" id="L5330">				Integer hp = getHP(frompcl);</span>
<span class="nc bnc" id="L5331" title="All 2 branches missed.">				if (hp == null)</span>
				{
<span class="nc" id="L5333">					System.err.println(&quot;Did not find HP for &quot; + fromClass + ' ' + (i + 1) + ' ' + frompcl);</span>
				}
<span class="nc" id="L5335">				hpArray[i] = hp;</span>
			}

<span class="nc bnc" id="L5338" title="All 2 branches missed.">			for (int i = 0; i &lt; fromLevel; i++)</span>
			{
<span class="nc" id="L5340">				fromClass.doMinusLevelMods(this, fromLevel - i);</span>
			}
<span class="nc" id="L5342">			fromClass.setLevel(0, this);</span>

			//Do the class swap
<span class="nc bnc" id="L5345" title="All 2 branches missed.">			if (bClassNew)</span>
			{
<span class="nc" id="L5347">				classFacet.replaceClass(id, fromClass, toClass);</span>
			}
			else
			{
<span class="nc" id="L5351">				classFacet.removeClass(id, fromClass);</span>
			}
<span class="nc" id="L5353">			toClass.setLevel(toLevel + fromLevel, this);</span>

			//Restore capture info to new class
<span class="nc bnc" id="L5356" title="All 2 branches missed.">			for (int i = 0; i &lt; fromLevel; i++)</span>
			{
<span class="nc" id="L5358">				PCClassLevel topcl = getActiveClassLevel(toClass, i);</span>
<span class="nc" id="L5359">				setHP(topcl, hpArray[i]);</span>
			}

			//
			// change all the levelling info to the ex-class as well
			//
<span class="nc bnc" id="L5365" title="All 2 branches missed.">			for (int idx = getLevelInfoSize() - 1; idx &gt;= 0; --idx)</span>
			{
<span class="nc" id="L5367">				final PCLevelInfo li = levelInfoFacet.get(id, idx);</span>

<span class="nc bnc" id="L5369" title="All 2 branches missed.">				if (li.getClassKeyName().equals(fromClass.getKeyName()))</span>
				{
<span class="nc" id="L5371">					li.setClassKeyName(toClass.getKeyName());</span>
				}
			}

			//
			// Find all skills associated with old class and link them to new
			// class
			//
<span class="nc bnc" id="L5379" title="All 2 branches missed.">			for (Skill skill : getSkillSet())</span>
			{
<span class="nc" id="L5381">				SkillRankControl.replaceClassRank(this, skill, fromClass, cl);</span>
<span class="nc" id="L5382">			}</span>

<span class="nc" id="L5384">			setSkillPool(toClass, fromClass.getSkillPool(this));</span>
		}
<span class="nc" id="L5386">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L5388">			ShowMessageDelegate.showMessageDialog(nfe.getMessage(), Constants.APPLICATION_NAME,</span>
				MessageType.INFORMATION);
<span class="nc" id="L5390">		}</span>
<span class="nc" id="L5391">	}</span>

	public int minXPForECL()
	{
<span class="nc" id="L5395">		return levelTableFacet.minXPForLevel(levelFacet.getECL(id), id);</span>
	}

	public int minXPForNextECL()
	{
<span class="nc" id="L5400">		return levelTableFacet.minXPForLevel(levelFacet.getECL(id) + 1, id);</span>
	}

	/**
	 * Figure out if Load should affect AC and Skills, if so, set the load
	 * appropriately, otherwise set a light load to eliminate the effects of
	 * heavier loads
	 *
	 * @return a loadType appropriate for this Pc
	 */
	private Load getHouseRuledLoadType()
	{
<span class="nc bnc" id="L5412" title="All 2 branches missed.">		if (Globals.checkRule(RuleConstants.SYS_LDPACSK))</span>
		{
<span class="nc" id="L5414">			return getLoadType();</span>
		}
<span class="nc" id="L5416">		return Load.LIGHT;</span>
	}

	/**
	 * Calculate the AC bonus from equipped items. Extracted from
	 * modToFromEquipment.
	 *
	 * @return PC's AC bonus from equipment
	 */
	public int modToACFromEquipment()
	{
<span class="nc" id="L5427">		int bonus = 0;</span>
<span class="nc bnc" id="L5428" title="All 2 branches missed.">		for (Equipment eq : getEquippedEquipmentSet())</span>
		{
<span class="nc" id="L5430">			bonus += eq.getACMod(this);</span>
<span class="nc" id="L5431">		}</span>
<span class="nc" id="L5432">		return bonus;</span>
	}

	/**
	 * Calculate the ACCHECK bonus from equipped items. Extracted from
	 * modToFromEquipment.
	 *
	 * TODO Penalty for load could/should be GameMode specific?
	 *
	 * @return PC's ACCHECK bonus from equipment
	 * @deprecated due to PCACCHECK code control
	 */
	@Deprecated
	public int processOldAcCheck()
	{
<span class="nc" id="L5447">		Load load = getHouseRuledLoadType();</span>
<span class="nc" id="L5448">		int bonus = 0;</span>

<span class="nc bnc" id="L5450" title="All 4 branches missed.">		int penaltyForLoad = (load == Load.MEDIUM) ? -3 : (load == Load.HEAVY) ? -6 : 0;</span>

<span class="nc" id="L5452">		final IdentityList&lt;Equipment&gt; vEqList = new IdentityList&lt;&gt;(tempBonusItemList);</span>

<span class="nc bnc" id="L5454" title="All 2 branches missed.">		for (Equipment eq : getEquippedEquipmentSet())</span>
		{
			// Do not count virtual items created by temporary bonuses
<span class="nc bnc" id="L5457" title="All 2 branches missed.">			if (!vEqList.contains(eq))</span>
			{
<span class="nc" id="L5459">				bonus += EqToken.getAcCheckTokenInt(this, eq);</span>
			}
<span class="nc" id="L5461">		}</span>

<span class="nc" id="L5463">		bonus = Math.min(bonus, penaltyForLoad);</span>

<span class="nc" id="L5465">		bonus += (int) getTotalBonusTo(&quot;MISC&quot;, &quot;ACCHECK&quot;);</span>
<span class="nc" id="L5466">		return bonus;</span>
	}

	/**
	 * Calculate the MAXDEX bonus taking account of equipped items. Extracted
	 * from modToFromEquipment.
	 *
	 * @return MAXDEX bonus
	 * @deprecated due to PCMAXDEX code control
	 */
	@Deprecated
	public int processOldMaxDex()
	{
<span class="nc" id="L5479">		final int statBonus = (int) getStatBonusTo(&quot;MISC&quot;, &quot;MAXDEX&quot;);</span>
<span class="nc" id="L5480">		final Load load = getHouseRuledLoadType();</span>
<span class="nc bnc" id="L5481" title="All 6 branches missed.">		int bonus = (load == Load.MEDIUM) ? 2 : (load == Load.HEAVY) ? 1 : (load == Load.OVERLOAD) ? 0 : statBonus;</span>

		// If this is still true after all the equipment has been
		// examined, then we should use the Maximum - Maximum Dex modifier.
<span class="nc bnc" id="L5485" title="All 2 branches missed.">		boolean useMax = (load == Load.LIGHT);</span>

<span class="nc bnc" id="L5487" title="All 2 branches missed.">		for (Equipment eq : getEquippedEquipmentSet())</span>
		{
<span class="nc" id="L5489">			final int potentialMax = EqToken.getMaxDexTokenInt(this, eq);</span>
<span class="nc bnc" id="L5490" title="All 2 branches missed.">			if (potentialMax != Constants.MAX_MAXDEX)</span>
			{
<span class="nc bnc" id="L5492" title="All 4 branches missed.">				if (useMax || bonus &gt; potentialMax)</span>
				{
<span class="nc" id="L5494">					bonus = potentialMax;</span>
				}
<span class="nc" id="L5496">				useMax = false;</span>
			}
<span class="nc" id="L5498">		}</span>

<span class="nc bnc" id="L5500" title="All 2 branches missed.">		if (useMax)</span>
		{
<span class="nc" id="L5502">			bonus = Constants.MAX_MAXDEX;</span>
		}

<span class="nc" id="L5505">		bonus += ((int) getTotalBonusTo(&quot;MISC&quot;, &quot;MAXDEX&quot;) - statBonus);</span>

<span class="nc bnc" id="L5507" title="All 2 branches missed.">		if (bonus &lt; 0)</span>
		{
<span class="nc" id="L5509">			bonus = 0;</span>
		}
<span class="nc bnc" id="L5511" title="All 2 branches missed.">		else if (bonus &gt; Constants.MAX_MAXDEX)</span>
		{
<span class="nc" id="L5513">			bonus = Constants.MAX_MAXDEX;</span>
		}
<span class="nc" id="L5515">		return bonus;</span>
	}

	/**
	 * Takes a String and a Class name and computes spell based variable such as
	 * Class level.
	 *
	 * @param aSpell The spell object
	 * @param aString the variable to evaluate
	 * @return String
	 */
	public String parseSpellString(final CharacterSpell aSpell, String aString)
	{
<span class="nc" id="L5528">		String aSpellClass = aSpell.getVariableSource(this);</span>

<span class="nc bnc" id="L5530" title="All 2 branches missed.">		if (aSpellClass.isEmpty())</span>
		{
<span class="nc" id="L5532">			return aString;</span>
		}

		// Only want to replace items between ()'s
<span class="nc bnc" id="L5536" title="All 2 branches missed.">		while (aString.lastIndexOf('(') &gt;= 0)</span>
		{
<span class="nc" id="L5538">			boolean found = false;</span>

<span class="nc" id="L5540">			final int start = aString.indexOf('(');</span>
<span class="nc" id="L5541">			int end = 0;</span>
<span class="nc" id="L5542">			int level = 0;</span>

<span class="nc bnc" id="L5544" title="All 2 branches missed.">			for (int i = start; i &lt; aString.length(); i++)</span>
			{
<span class="nc bnc" id="L5546" title="All 2 branches missed.">				if (aString.charAt(i) == '(')</span>
				{
<span class="nc" id="L5548">					level++;</span>
				}
<span class="nc bnc" id="L5550" title="All 2 branches missed.">				else if (aString.charAt(i) == ')')</span>
				{
<span class="nc" id="L5552">					level--;</span>
<span class="nc bnc" id="L5553" title="All 2 branches missed.">					if (level == 0)</span>
					{
<span class="nc" id="L5555">						end = i;</span>
<span class="nc" id="L5556">						break;</span>
					}
				}
			}

			/*
			 * int x = CoreUtility.innerMostStringStart(aString); int y =
			 * CoreUtility.innerMostStringEnd(aString); // bounds checking if
			 * ((start &gt; end) || (start &gt;= aString.length())) { break; } if
			 * ((end &lt;= 0) || (end &gt;= aString.length())) { break; }
			 */
<span class="nc" id="L5567">			final String inCalc = aString.substring(start + 1, end);</span>

<span class="nc" id="L5569">			String replacement = &quot;0&quot;;</span>

<span class="nc" id="L5571">			final Float fVal = getVariableValue(aSpell, inCalc, aSpellClass);</span>
<span class="nc bnc" id="L5572" title="All 4 branches missed.">			if (!CoreUtility.doublesEqual(fVal, 0.0f) || (inCalc.contains(&quot;MIN&quot;))</span>
<span class="nc bnc" id="L5573" title="All 4 branches missed.">				|| (inCalc.contains(&quot;MAX&quot;)) || inCalc.toUpperCase().contains(&quot;MIN(&quot;)</span>
<span class="nc bnc" id="L5574" title="All 2 branches missed.">				|| inCalc.toUpperCase().contains(&quot;MAX(&quot;))</span>
			{
<span class="nc" id="L5576">				found = true;</span>
<span class="nc" id="L5577">				replacement = String.valueOf(fVal.intValue());</span>
			}

<span class="nc bnc" id="L5580" title="All 2 branches missed.">			if (found)</span>
			{
<span class="nc" id="L5582">				aString = aString.substring(0, start) + replacement + aString.substring(end + 1);</span>
			}
			else
			{
<span class="nc" id="L5586">				aString = aString.substring(0, start) + '[' + inCalc + ']' + aString.substring(end + 1);</span>
			}
<span class="nc" id="L5588">		}</span>

<span class="nc" id="L5590">		return aString;</span>
	}

	/**
	 * Removes a &quot;temporary&quot; bonus
	 *
	 * @param aBonus
	 */
	public void removeTempBonus(final BonusObj aBonus)
	{
<span class="nc" id="L5600">		bonusManager.removeTempBonus(aBonus);</span>
<span class="nc" id="L5601">		setDirty(true);</span>
<span class="nc" id="L5602">	}</span>

	public void removeTempBonusItemList(final Equipment aEq)
	{
<span class="nc" id="L5606">		tempBonusItemList.remove(aEq);</span>
<span class="nc" id="L5607">		setDirty(true);</span>
<span class="nc" id="L5608">	}</span>

	public void removeTemplate(final PCTemplate inTmpl)
	{
<span class="fc" id="L5612">		templateInputFacet.remove(id, inTmpl);</span>
<span class="fc" id="L5613">		setDirty(true);</span>
<span class="fc" id="L5614">	}</span>

	private static String replaceMasterString(String aString, final int aNum)
	{
		while (true)
		{
<span class="nc" id="L5620">			final int x = aString.indexOf(&quot;MASTER&quot;);</span>

<span class="nc bnc" id="L5622" title="All 2 branches missed.">			if (x == -1)</span>
			{
<span class="nc" id="L5624">				break;</span>
			}

<span class="nc" id="L5627">			final String leftString = aString.substring(0, x);</span>
<span class="nc" id="L5628">			final String rightString = aString.substring(x + 6);</span>
<span class="nc" id="L5629">			aString = leftString + Integer.toString(aNum) + rightString;</span>
<span class="nc" id="L5630">		}</span>

<span class="nc" id="L5632">		return aString;</span>
	}

	public PCLevelInfo addLevelInfo(final String classKeyName)
	{
<span class="nc" id="L5637">		final PCLevelInfo li = new PCLevelInfo(classKeyName);</span>
<span class="nc" id="L5638">		addLevelInfo(li);</span>
<span class="nc" id="L5639">		return li;</span>
	}

	public void addLevelInfo(final PCLevelInfo pli)
	{
<span class="nc" id="L5644">		levelInfoFacet.add(id, pli);</span>
<span class="nc" id="L5645">	}</span>

	public void saveStatIncrease(final PCStat stat, final int mod, final boolean isPreMod)
	{
<span class="nc" id="L5649">		final int idx = getLevelInfoSize() - 1;</span>

<span class="nc bnc" id="L5651" title="All 2 branches missed.">		if (idx &gt;= 0)</span>
		{
<span class="nc" id="L5653">			levelInfoFacet.get(id, idx).addModifiedStat(stat, mod, isPreMod);</span>
		}

<span class="nc" id="L5656">		setDirty(true);</span>
<span class="nc" id="L5657">	}</span>

	public int getStatIncrease(final PCStat stat, final boolean includePost)
	{
<span class="nc" id="L5661">		final int idx = getLevelInfoSize() - 1;</span>

<span class="nc bnc" id="L5663" title="All 2 branches missed.">		if (idx &gt;= 0)</span>
		{
<span class="nc" id="L5665">			return levelInfoFacet.get(id, idx).getTotalStatMod(stat, includePost);</span>
		}
<span class="nc" id="L5667">		return 0;</span>
	}

	public int sizeInt()
	{
<span class="nc" id="L5672">		return getSizeAdjustment().get(IntegerKey.SIZEORDER);</span>
	}

	private int totalHitDice()
	{
<span class="nc" id="L5677">		return levelFacet.getMonsterLevelCount(id);</span>
	}

	public int totalNonMonsterLevels()
	{
<span class="nc" id="L5682">		return levelFacet.getNonMonsterLevelCount(id);</span>
	}

	public BigDecimal totalValue()
	{
<span class="nc" id="L5687">		BigDecimal totalValue = BigDecimal.ZERO;</span>

<span class="nc bnc" id="L5689" title="All 2 branches missed.">		for (Equipment eq : getEquipmentMasterList())</span>
		{
<span class="nc" id="L5691">			totalValue = totalValue.add(eq.getCost(this).multiply(BigDecimal.valueOf(eq.qty())));</span>
<span class="nc" id="L5692">		}</span>

<span class="nc" id="L5694">		return totalValue;</span>
	}

	/**
	 * @return true if character is currently being read from file.
	 */
	public boolean isImporting()
	{
<span class="fc" id="L5702">		return importing;</span>
	}

	public void giveClassesAway(final PCClass toClass, final PCClass fromClass, int iCount)
	{
<span class="nc bnc" id="L5707" title="All 4 branches missed.">		if ((toClass == null) || (fromClass == null))</span>
		{
<span class="nc" id="L5709">			return;</span>
		}

		// Will take destination class over maximum?
<span class="nc bnc" id="L5713" title="All 4 branches missed.">		if (toClass.hasMaxLevel() &amp;&amp; (getLevel(toClass) + iCount) &gt; toClass.getSafe(IntegerKey.LEVEL_LIMIT))</span>
		{
<span class="nc" id="L5715">			iCount = toClass.getSafe(IntegerKey.LEVEL_LIMIT) - getLevel(toClass);</span>
		}

		// Enough levels to move?
<span class="nc bnc" id="L5719" title="All 4 branches missed.">		if ((getLevel(fromClass) &lt;= iCount) || (iCount &lt; 1))</span>
		{
<span class="nc" id="L5721">			return;</span>
		}

<span class="nc" id="L5724">		final int fromLevel = getLevel(fromClass);</span>
<span class="nc" id="L5725">		final int iFromLevel = fromLevel - iCount;</span>
<span class="nc" id="L5726">		final int toLevel = getLevel(toClass);</span>

		//Capture necessary information
<span class="nc" id="L5729">		Integer[] hpArray = new Integer[iCount + toLevel];</span>
<span class="nc bnc" id="L5730" title="All 2 branches missed.">		for (int i = 0; i &lt; iCount; i++)</span>
		{
<span class="nc" id="L5732">			PCClassLevel frompcl = getActiveClassLevel(fromClass, i + iFromLevel);</span>
<span class="nc" id="L5733">			hpArray[i] = getHP(frompcl);</span>
		}
<span class="nc bnc" id="L5735" title="All 2 branches missed.">		for (int i = 0; i &lt; toLevel; i++)</span>
		{
<span class="nc" id="L5737">			PCClassLevel topcl = getActiveClassLevel(toClass, i);</span>
<span class="nc" id="L5738">			hpArray[i + iCount] = getHP(topcl);</span>
		}

<span class="nc bnc" id="L5741" title="All 2 branches missed.">		for (int i = 0; i &lt; iCount; i++)</span>
		{
<span class="nc" id="L5743">			fromClass.doMinusLevelMods(this, fromLevel - i);</span>
		}

		//Do the class level swap
<span class="nc" id="L5747">		fromClass.setLevel(iFromLevel, this);</span>
<span class="nc" id="L5748">		toClass.setLevel(toLevel + iCount, this);</span>

		//Restore capture info to new class
<span class="nc bnc" id="L5751" title="All 2 branches missed.">		for (int i = 0; i &lt; iCount + toLevel; i++)</span>
		{
<span class="nc" id="L5753">			PCClassLevel topcl = getActiveClassLevel(toClass, i);</span>
<span class="nc" id="L5754">			setHP(topcl, hpArray[i]);</span>
		}

		// first, change the toClass current PCLevelInfo level
<span class="nc bnc" id="L5758" title="All 2 branches missed.">		for (PCLevelInfo pcl : getLevelInfo())</span>
		{
<span class="nc bnc" id="L5760" title="All 2 branches missed.">			if (pcl.getClassKeyName().equals(toClass.getKeyName()))</span>
			{
<span class="nc" id="L5762">				final int iTo = (pcl.getClassLevel() + getLevel(toClass)) - toLevel;</span>
<span class="nc" id="L5763">				pcl.setClassLevel(iTo);</span>
			}
<span class="nc" id="L5765">		}</span>

		// change old class PCLevelInfo to the new class
<span class="nc bnc" id="L5768" title="All 2 branches missed.">		for (PCLevelInfo pcl : getLevelInfo())</span>
		{
<span class="nc bnc" id="L5770" title="All 4 branches missed.">			if (pcl.getClassKeyName().equals(fromClass.getKeyName()) &amp;&amp; (pcl.getClassLevel() &gt; iFromLevel))</span>
			{
<span class="nc" id="L5772">				final int iFrom = pcl.getClassLevel() - iFromLevel;</span>
<span class="nc" id="L5773">				pcl.setClassKeyName(toClass.getKeyName());</span>
<span class="nc" id="L5774">				pcl.setClassLevel(iFrom);</span>
			}
<span class="nc" id="L5776">		}</span>

		/*
		 * // get skills associated with old class and link to new class for
		 * (Iterator e = getSkillList().iterator(); e.hasNext();) { Skill aSkill =
		 * (Skill) e.next(); aSkill.replaceClassRank(fromClass.getName(),
		 * toClass.getName()); } toClass.setSkillPool(fromClass.getSkillPool());
		 */
<span class="nc" id="L5784">	}</span>

	public void addAddLanguage(final Language aLang, CDOMObject source)
	{
<span class="nc" id="L5788">		addLangFacet.add(id, aLang, source);</span>
<span class="nc" id="L5789">		setDirty(true);</span>
<span class="nc" id="L5790">	}</span>

	public void removeAddLanguage(final Language aLang, CDOMObject source)
	{
<span class="nc" id="L5794">		addLangFacet.remove(id, aLang, source);</span>
<span class="nc" id="L5795">		setDirty(true);</span>
<span class="nc" id="L5796">	}</span>

	public void addAutoLanguage(Language l, Object obj)
	{
<span class="fc" id="L5800">		autoLangListFacet.add(id, l, obj);</span>
<span class="fc" id="L5801">	}</span>

	public void removeAutoLanguage(Language l, Object obj)
	{
<span class="fc" id="L5805">		autoLangListFacet.remove(id, l, obj);</span>
<span class="fc" id="L5806">	}</span>

	/**
	 * Scan through the list of domains the character has to ensure that they
	 * are all still valid. Any invalid domains will be removed from the
	 * character.
	 */
	public void validateCharacterDomains()
	{
		//Clone to avoid Concurrent Mod Exception, CODE-153
<span class="nc bnc" id="L5816" title="All 2 branches missed.">		for (Domain d : new ArrayList&lt;&gt;(getDomainSet()))</span>
		{
<span class="nc bnc" id="L5818" title="All 2 branches missed.">			if (!isDomainValid(d, this.getDomainSource(d)))</span>
			{
<span class="nc" id="L5820">				removeDomain(d);</span>
			}
<span class="nc" id="L5822">		}</span>
<span class="nc" id="L5823">	}</span>

	private boolean isDomainValid(Domain domain, ClassSource cs)
	{
<span class="nc bnc" id="L5827" title="All 2 branches missed.">		if (domain == null)</span>
		{
<span class="nc" id="L5829">			return false;</span>
		}
<span class="nc" id="L5831">		final PCClass aClass = getClassKeyed(cs.getPcclass().getKeyName());</span>
<span class="nc bnc" id="L5832" title="All 4 branches missed.">		return ((aClass != null) &amp;&amp; (getLevel(aClass) &gt;= cs.getLevel()));</span>
	}

	/**
	 * Active BonusObjs
	 *
	 * @return List
	 */
	public Collection&lt;BonusObj&gt; getActiveBonusList()
	{
<span class="nc" id="L5842">		return bonusManager.getActiveBonusList();</span>
	}

	/**
	 * Parses through all Equipment items and calculates total Bonus
	 *
	 * @param aType
	 * @param aName
	 * @return equipment bonus to
	 */
	private double getEquipmentBonusTo(String aType, String aName)
	{
<span class="nc" id="L5854">		double bonus = 0;</span>

<span class="nc bnc" id="L5856" title="All 2 branches missed.">		if (!hasEquipment())</span>
		{
<span class="nc" id="L5858">			return bonus;</span>
		}

<span class="nc" id="L5861">		aType = aType.toUpperCase();</span>
<span class="nc" id="L5862">		aName = aName.toUpperCase();</span>

<span class="nc bnc" id="L5864" title="All 2 branches missed.">		for (Equipment eq : getEquippedEquipmentSet())</span>
		{
<span class="nc" id="L5866">			final List&lt;BonusObj&gt; tempList = eq.getBonusListOfType(this, aType, aName, true);</span>

<span class="nc bnc" id="L5868" title="All 4 branches missed.">			if (eq.isWeapon() &amp;&amp; eq.isDouble())</span>
			{
<span class="nc" id="L5870">				tempList.addAll(eq.getBonusListOfType(this, aType, aName, false));</span>
			}

<span class="nc" id="L5873">			bonus += calcBonusFromList(tempList, eq);</span>
<span class="nc" id="L5874">		}</span>

<span class="nc" id="L5876">		return bonus;</span>
	}

	/*
	 * Return Number of attacks per round based on Base Attack Bonus
	 */

	public int getNumAttacks()
	{
<span class="nc" id="L5885">		return Math.min(Math.max((int) Math.ceil((double) baseAttackBonus() / 5), 1), 4);</span>
	}

	/**
	 * Returns a bonus.
	 *
	 * @param aList
	 * @param aType
	 * @param aName
	 * @return double
	 */
	private double getPObjectWithCostBonusTo(final Collection&lt;? extends CDOMObject&gt; aList, final String aType,
		final String aName)
	{
<span class="nc" id="L5899">		double iBonus = 0;</span>

<span class="nc bnc" id="L5901" title="All 2 branches missed.">		if (aList.isEmpty())</span>
		{
<span class="nc" id="L5903">			return iBonus;</span>
		}

<span class="nc bnc" id="L5906" title="All 2 branches missed.">		for (CDOMObject anObj : aList)</span>
		{
<span class="nc" id="L5908">			final List&lt;BonusObj&gt; tempList = BonusUtilities.getBonusFromList(anObj.getBonusList(this), aType, aName);</span>
<span class="nc" id="L5909">			iBonus += calcBonusWithCostFromList(tempList);</span>
<span class="nc" id="L5910">		}</span>

<span class="nc" id="L5912">		return iBonus;</span>
	}

	/**
	 * Get the class level as a String
	 *
	 * @param aClassKey
	 * @param doReplace
	 * @return class level as String
	 */
	public String getClassLevelString(String aClassKey, final boolean doReplace)
	{
<span class="nc" id="L5924">		int lvl = 0;</span>
<span class="nc" id="L5925">		int idx = aClassKey.indexOf(&quot;;BEFORELEVEL=&quot;);</span>

<span class="nc bnc" id="L5927" title="All 2 branches missed.">		if (idx &lt; 0)</span>
		{
<span class="nc" id="L5929">			idx = aClassKey.indexOf(&quot;;BEFORELEVEL.&quot;);</span>
		}

<span class="nc bnc" id="L5932" title="All 2 branches missed.">		if (idx &gt; 0)</span>
		{
<span class="nc" id="L5934">			lvl = Integer.parseInt(aClassKey.substring(idx + 13));</span>
<span class="nc" id="L5935">			aClassKey = aClassKey.substring(0, idx);</span>
		}

<span class="nc bnc" id="L5938" title="All 2 branches missed.">		if (doReplace)</span>
		{
<span class="nc" id="L5940">			aClassKey = aClassKey.replace('{', '(').replace('}', ')');</span>
		}

<span class="nc bnc" id="L5943" title="All 4 branches missed.">		if (aClassKey.startsWith(&quot;TYPE=&quot;) || aClassKey.startsWith(&quot;TYPE.&quot;))</span>
		{
<span class="nc" id="L5945">			int totalLevels = 0;</span>
<span class="nc" id="L5946">			String[] classTypes = aClassKey.substring(5).split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L5947" title="All 2 branches missed.">			CLASSFOR: for (PCClass cl : getClassSet())</span>
			{
<span class="nc bnc" id="L5949" title="All 2 branches missed.">				for (String type : classTypes)</span>
				{
<span class="nc bnc" id="L5951" title="All 2 branches missed.">					if (!cl.isType(type))</span>
					{
<span class="nc" id="L5953">						continue CLASSFOR;</span>
					}
<span class="nc bnc" id="L5955" title="All 2 branches missed.">					if (lvl &gt; 0)</span>
					{
<span class="nc" id="L5957">						totalLevels += getLevelBefore(cl.getKeyName(), lvl);</span>
					}

<span class="nc" id="L5960">					totalLevels += getLevel(cl);</span>
				}
<span class="nc" id="L5962">			}</span>
<span class="nc" id="L5963">			return Integer.toString(totalLevels);</span>
		}
		else
		{
<span class="nc" id="L5967">			final PCClass aClass = getClassKeyed(aClassKey);</span>

<span class="nc bnc" id="L5969" title="All 2 branches missed.">			if (aClass != null)</span>
			{
<span class="nc bnc" id="L5971" title="All 2 branches missed.">				if (lvl &gt; 0)</span>
				{
<span class="nc" id="L5973">					return Integer.toString(getLevelBefore(aClass.getKeyName(), lvl));</span>
				}

<span class="nc" id="L5976">				return Integer.toString(getLevel(aClass));</span>
			}

<span class="nc" id="L5979">			return &quot;0&quot;;</span>
		}
	}

	public int getLevelBefore(final String classKey, final int charLevel)
	{
<span class="nc" id="L5985">		int lvl = 0;</span>

<span class="nc bnc" id="L5987" title="All 2 branches missed.">		for (int idx = 0; idx &lt; charLevel; ++idx)</span>
		{
<span class="nc" id="L5989">			String thisClassKey = getLevelInfoClassKeyName(idx);</span>

<span class="nc bnc" id="L5991" title="All 2 branches missed.">			if (thisClassKey.isEmpty())</span>
			{
<span class="nc" id="L5993">				break;</span>
			}

<span class="nc bnc" id="L5996" title="All 2 branches missed.">			if (thisClassKey.equals(classKey))</span>
			{
<span class="nc" id="L5998">				++lvl;</span>
			}
		}

<span class="nc" id="L6002">		return lvl;</span>
	}

	public List&lt;? extends CDOMObject&gt; getCDOMObjectList()
	{
<span class="fc" id="L6007">		List&lt;CDOMObject&gt; list = new ArrayList&lt;&gt;(expandedCampaignFacet.getSet(id));</span>

		// Loaded campaigns

		// Alignment

<span class="pc bpc" id="L6013" title="1 of 2 branches missed.">		if (isFeatureEnabled(CControl.ALIGNMENTFEATURE))</span>
		{
<span class="nc" id="L6015">			PCAlignment align = AlignmentCompat.getCurrentAlignment(id);</span>
<span class="nc bnc" id="L6016" title="All 2 branches missed.">			if (align != null)</span>
			{
<span class="nc" id="L6018">				list.add(align);</span>
			}
		}

		// BioSet
<span class="fc" id="L6023">		list.add(bioSetFacet.get(id));</span>

<span class="fc" id="L6025">		list.addAll(checkFacet.getSet(id));</span>

		// Class
<span class="fc" id="L6028">		list.addAll(classFacet.getSet(id));</span>

		// CompanionMod
<span class="fc" id="L6031">		list.addAll(companionModFacet.getSet(id));</span>

		// Deity
<span class="pc bpc" id="L6034" title="1 of 2 branches missed.">		if (isFeatureEnabled(CControl.DOMAINFEATURE))</span>
		{
<span class="fc" id="L6036">			list.add((Deity) ChannelUtilities.readControlledChannel(getCharID(),</span>
				CControl.DEITYINPUT));
		}

		// Domain
<span class="fc" id="L6041">		list.addAll(domainFacet.getSet(id));</span>

		// Equipment
<span class="pc bpc" id="L6044" title="1 of 2 branches missed.">		for (Equipment eq : activeEquipmentFacet.getSet(id))</span>
		{
<span class="nc" id="L6046">			list.add(eq);</span>

<span class="nc" id="L6048">			list.addAll(eq.getEqModifierList(true));</span>

<span class="nc" id="L6050">			list.addAll(eq.getEqModifierList(false));</span>
<span class="nc" id="L6051">		}</span>

		// Feats and abilities (virtual feats, auto feats)
<span class="fc bfc" id="L6054" title="All 2 branches covered.">		for (AbilityCategory cat : SettingsHandler.getGameAsProperty().get().getAllAbilityCategories())</span>
		{
<span class="fc" id="L6056">			list.addAll(getAggregateAbilityListNoDuplicates(cat));</span>
<span class="fc" id="L6057">		}</span>

		// Race
<span class="fc" id="L6060">		Race race = raceFacet.get(id);</span>
<span class="pc bpc" id="L6061" title="1 of 2 branches missed.">		if (race != null)</span>
		{
<span class="fc" id="L6063">			list.add(race);</span>
		}

		// SizeAdjustment
<span class="fc" id="L6067">		SizeAdjustment sa = getSizeAdjustment();</span>
<span class="pc bpc" id="L6068" title="1 of 2 branches missed.">		if (sa != null)</span>
		{
<span class="fc" id="L6070">			list.add(sa);</span>
		}

		// Skill
<span class="fc" id="L6074">		list.addAll(skillFacet.getSet(id));</span>

		// Stat (PCStat)
<span class="fc" id="L6077">		list.addAll(statFacet.getSet(id));</span>

		// Template (PCTemplate)
<span class="fc" id="L6080">		list.addAll(templateFacet.getSet(id));</span>

<span class="pc bpc" id="L6082" title="1 of 2 branches missed.">		for (PCClass cl : getClassSet())</span>
		{
<span class="nc bnc" id="L6084" title="All 2 branches missed.">			for (int i = 1; i &lt;= getLevel(cl); i++)</span>
			{
<span class="nc" id="L6086">				PCClassLevel classLevel = getActiveClassLevel(cl, i);</span>
<span class="nc" id="L6087">				list.add(classLevel);</span>
			}
<span class="nc" id="L6089">		}</span>
<span class="fc" id="L6090">		return list;</span>
	}

	/**
	 * availableSpells sk4p 13 Dec 2002
	 *
	 * For learning or preparing a spell: Are there slots available at this
	 * level or higher Fixes BUG [569517]
	 *
	 * @param level
	 *            the level being checked for availability
	 * @param aClass
	 *            the class under consideration
	 * @param bookName
	 *            the name of the spellbook
	 * @param knownLearned
	 *            &quot;true&quot; if this is learning a spell, &quot;false&quot; if prepping
	 * @param isSpecialtySpell
	 *            &quot;true&quot; if this is a speciality for the given class
	 * @return true or false, a new spell can be added
	 */
	public boolean availableSpells(final int level, final PCClass aClass, final String bookName,
		final boolean knownLearned, final boolean isSpecialtySpell)
	{
<span class="nc" id="L6114">		boolean available = false;</span>
<span class="nc" id="L6115">		FactKey&lt;String&gt; fk = FactKey.valueOf(&quot;SpellType&quot;);</span>
<span class="nc" id="L6116">		String spelltype = aClass.getResolved(fk);</span>
<span class="nc" id="L6117">		final boolean isDivine = (&quot;Divine&quot;.equalsIgnoreCase(spelltype));</span>
<span class="nc bnc" id="L6118" title="All 2 branches missed.">		final boolean canUseHigher = knownLearned ? useHigherKnownSlots : useHigherPreppedSlots;</span>
		int knownTot;
		int knownNon;
		int knownSpec;
		int memTot;
		int memNon;
		int memSpec;

		// int excTot
		int excNon;

		// int excTot
		int excSpec;
<span class="nc" id="L6131">		int lowExcSpec = 0;</span>
<span class="nc" id="L6132">		int lowExcNon = 0;</span>
<span class="nc" id="L6133">		int goodExcSpec = 0;</span>
<span class="nc" id="L6134">		int goodExcNon = 0;</span>

<span class="nc bnc" id="L6136" title="All 2 branches missed.">		for (int i = 0; i &lt; level; ++i)</span>
		{
			// Get the number of castable slots
<span class="nc bnc" id="L6139" title="All 2 branches missed.">			if (knownLearned)</span>
			{
<span class="nc" id="L6141">				knownNon = this.getSpellSupport(aClass).getKnownForLevel(i, this);</span>
<span class="nc" id="L6142">				knownSpec = this.getSpellSupport(aClass).getSpecialtyKnownForLevel(i, this);</span>
			}
			else
			{
				// Get the number of castable slots
<span class="nc" id="L6147">				knownTot = this.getSpellSupport(aClass).getCastForLevel(i, bookName, true, true, this);</span>
<span class="nc" id="L6148">				knownNon = this.getSpellSupport(aClass).getCastForLevel(i, bookName, false, true, this);</span>
<span class="nc" id="L6149">				knownSpec = knownTot - knownNon;</span>
			}

			// Now get the number of spells memorised, total and specialities
<span class="nc" id="L6153">			memTot = SpellCountCalc.memorizedSpellForLevelBook(this, aClass, i, bookName);</span>
<span class="nc" id="L6154">			memSpec = SpellCountCalc.memorizedSpecialtiesForLevelBook(i, bookName, this, aClass);</span>
<span class="nc" id="L6155">			memNon = memTot - memSpec;</span>

			// Excess castings
<span class="nc" id="L6158">			excSpec = knownSpec - memSpec;</span>
<span class="nc" id="L6159">			excNon = knownNon - memNon;</span>

			// Now we spend these slots making up any deficits in lower levels
			//
<span class="nc bnc" id="L6163" title="All 4 branches missed.">			while ((excNon &gt; 0) &amp;&amp; (lowExcNon &lt; 0))</span>
			{
<span class="nc" id="L6165">				--excNon;</span>
<span class="nc" id="L6166">				++lowExcNon;</span>
			}

<span class="nc bnc" id="L6169" title="All 4 branches missed.">			while ((excSpec &gt; 0) &amp;&amp; (lowExcSpec &lt; 0))</span>
			{
<span class="nc" id="L6171">				--excSpec;</span>
<span class="nc" id="L6172">				++lowExcSpec;</span>
			}

<span class="nc bnc" id="L6175" title="All 4 branches missed.">			if (!isDivine || knownLearned)</span>
			{
				// If I'm not divine, I can use non-specialty slots of this
				// level
				// to take up the slack of my excess speciality spells from
				// lower levels.
<span class="nc bnc" id="L6181" title="All 4 branches missed.">				while ((excNon &gt; 0) &amp;&amp; (lowExcSpec &lt; 0))</span>
				{
<span class="nc" id="L6183">					--excNon;</span>
<span class="nc" id="L6184">					++lowExcSpec;</span>
				}

				// And I can use non-specialty slots of this level to take
				// up the slack of my excess speciality spells of this level.
				//
<span class="nc bnc" id="L6190" title="All 4 branches missed.">				while ((excNon &gt; 0) &amp;&amp; (excSpec &lt; 0))</span>
				{
<span class="nc" id="L6192">					--excNon;</span>
<span class="nc" id="L6193">					++excSpec;</span>
				}
			}

			// Now, if there are slots left over, I don't add them to the
			// running totals.
			// Spell slots of this level won't help me at the next level.
			// Deficits, however, will have to be made up at the next level.
			//
<span class="nc bnc" id="L6202" title="All 2 branches missed.">			if (excSpec &lt; 0)</span>
			{
<span class="nc" id="L6204">				lowExcSpec += excSpec;</span>
			}

<span class="nc bnc" id="L6207" title="All 2 branches missed.">			if (excNon &lt; 0)</span>
			{
<span class="nc" id="L6209">				lowExcNon += excNon;</span>
			}
		}

<span class="nc bnc" id="L6213" title="All 2 branches missed.">		for (int i = level; i &lt;= Constants.MAX_SPELL_LEVEL; ++i)</span>
		{
<span class="nc bnc" id="L6215" title="All 2 branches missed.">			if (knownLearned)</span>
			{
<span class="nc" id="L6217">				knownNon = this.getSpellSupport(aClass).getKnownForLevel(i, this);</span>
<span class="nc" id="L6218">				knownSpec = this.getSpellSupport(aClass).getSpecialtyKnownForLevel(i, this);</span>
			}
			else
			{
				// Get the number of castable slots
<span class="nc" id="L6223">				knownTot = this.getSpellSupport(aClass).getCastForLevel(i, bookName, true, true, this);</span>
<span class="nc" id="L6224">				knownNon = this.getSpellSupport(aClass).getCastForLevel(i, bookName, false, true, this);</span>
<span class="nc" id="L6225">				knownSpec = knownTot - knownNon;</span>
			}

			// At the level currently being looped through, if the number of
			// casts
			// is zero, that means we have reached a level beyond which no
			// higher-level
			// casts are possible. Therefore, it's time to break.
			// Likewise if we aren't allowed to use higher level slots, no sense
			// in
			// going higher than the spell's level.
			//
<span class="nc bnc" id="L6237" title="All 4 branches missed.">			if (!canUseHigher &amp;&amp; i &gt; level)</span>
			{
<span class="nc" id="L6239">				break;</span>
			}

			// Now get the number of spells memorised, total and specialities
<span class="nc" id="L6243">			memTot = SpellCountCalc.memorizedSpellForLevelBook(this, aClass, i, bookName);</span>
<span class="nc" id="L6244">			memSpec = SpellCountCalc.memorizedSpecialtiesForLevelBook(i, bookName, this, aClass);</span>
<span class="nc" id="L6245">			memNon = memTot - memSpec;</span>

			// Excess castings
<span class="nc" id="L6248">			excSpec = knownSpec - memSpec;</span>
<span class="nc" id="L6249">			excNon = knownNon - memNon;</span>

			// Now we spend these slots making up any deficits in lower levels
			//
<span class="nc bnc" id="L6253" title="All 4 branches missed.">			while ((excNon &gt; 0) &amp;&amp; (lowExcNon &lt; 0))</span>
			{
<span class="nc" id="L6255">				--excNon;</span>
<span class="nc" id="L6256">				++lowExcNon;</span>
			}

<span class="nc bnc" id="L6259" title="All 4 branches missed.">			while ((excNon &gt; 0) &amp;&amp; (goodExcNon &lt; 0))</span>
			{
<span class="nc" id="L6261">				--excNon;</span>
<span class="nc" id="L6262">				++goodExcNon;</span>
			}

<span class="nc bnc" id="L6265" title="All 4 branches missed.">			while ((excSpec &gt; 0) &amp;&amp; (lowExcSpec &lt; 0))</span>
			{
<span class="nc" id="L6267">				--excSpec;</span>
<span class="nc" id="L6268">				++lowExcSpec;</span>
			}

<span class="nc bnc" id="L6271" title="All 4 branches missed.">			while ((excSpec &gt; 0) &amp;&amp; (goodExcSpec &lt; 0))</span>
			{
<span class="nc" id="L6273">				--excSpec;</span>
<span class="nc" id="L6274">				++goodExcSpec;</span>
			}

<span class="nc bnc" id="L6277" title="All 2 branches missed.">			if (!isDivine)</span>
			{
				// If I'm not divine, I can use non-specialty slots of this
				// level
				// to take up the slack of my excess speciality spells from
				// lower levels.
<span class="nc bnc" id="L6283" title="All 4 branches missed.">				while ((excNon &gt; 0) &amp;&amp; (lowExcSpec &lt; 0))</span>
				{
<span class="nc" id="L6285">					--excNon;</span>
<span class="nc" id="L6286">					++lowExcSpec;</span>
				}

				// And also for levels sufficiently high for the spell that got
				// me
				// into this mess, but of lower level than the level currently
				// being calculated.
<span class="nc bnc" id="L6293" title="All 4 branches missed.">				while ((excNon &gt; 0) &amp;&amp; (goodExcSpec &lt; 0))</span>
				{
<span class="nc" id="L6295">					--excNon;</span>
<span class="nc" id="L6296">					++goodExcSpec;</span>
				}

				// And finally use non-specialty slots of this level to take
				// up the slack of excess speciality spells of this level.
				//
<span class="nc bnc" id="L6302" title="All 4 branches missed.">				while ((excNon &gt; 0) &amp;&amp; (excSpec &lt; 0))</span>
				{
<span class="nc" id="L6304">					--excNon;</span>
<span class="nc" id="L6305">					++excSpec;</span>
				}
			}

			// Right now, if there are slots left over at this level,
			// it means that there are slots left to add the spell that started
			// all of this.
<span class="nc bnc" id="L6312" title="All 6 branches missed.">			if (!isSpecialtySpell &amp;&amp; (excNon &gt; 0) &amp;&amp; (excNon + excSpec &gt; 0))</span>
			{
<span class="nc" id="L6314">				available = true;</span>
			}

			// Account for specialty spells using up non specialty slots
<span class="nc bnc" id="L6318" title="All 2 branches missed.">			if (isDivine)</span>
			{
<span class="nc bnc" id="L6320" title="All 4 branches missed.">				if (isSpecialtySpell &amp;&amp; (excSpec &gt; 0))</span>
				{
<span class="nc" id="L6322">					available = true;</span>
				}
			}
<span class="nc bnc" id="L6325" title="All 4 branches missed.">			else if (isSpecialtySpell &amp;&amp; (excNon + excSpec &gt; 0))</span>
			{
<span class="nc" id="L6327">				available = true;</span>
			}

			// If we found a slot, we need look no further.
<span class="nc bnc" id="L6331" title="All 2 branches missed.">			if (available)</span>
			{
<span class="nc" id="L6333">				break;</span>
			}

			// Now, if there are slots left over, I don't add them to the
			// running totals.
			// Spell slots of this level won't help me at the next level.
			// Deficits, however, will have to be made up at the next level.
			//
<span class="nc bnc" id="L6341" title="All 2 branches missed.">			if (excSpec &lt; 0)</span>
			{
<span class="nc" id="L6343">				goodExcSpec += excSpec;</span>
			}

<span class="nc bnc" id="L6346" title="All 2 branches missed.">			if (excNon &lt; 0)</span>
			{
<span class="nc" id="L6348">				goodExcNon += excNon;</span>
			}
		}

<span class="nc" id="L6352">		return available;</span>
	}

	/**
	 * Compute total bonus from a List of BonusObjs Use cost of bonus to adjust
	 * total bonus up or down This method takes a list of bonus objects.
	 *
	 * For each object in the list, it gets the creating object and queries it
	 * for its &quot;COST&quot;. It then multiplies the value of the bonus by this cost
	 * and adds it to the cumulative total so far. If subSearch is true, the
	 * choices made in the object that the bonus originated in are searched, the
	 * effective bonus is multiplied by the number of times this bonus appears
	 * in the list.
	 *
	 * Note: This COST seems to be used for several different things in the code
	 * base, in feats for instance, it is used to modify the feat pool by
	 * amounts other than 1 when selecting a given feat. Here it is used as a
	 * multiplier to say how effective a given bonus is i.e. a bonus with a COST
	 * of 0.5 counts for half its normal value. The COST is limited to a max of
	 * 1, so it can only make bonuses less effective.
	 *
	 * @param aList
	 *            a list of bonus objects
	 * @return the calculated cumulative bonus
	 */
	private double calcBonusWithCostFromList(final List&lt;BonusObj&gt; aList)
	{
<span class="nc" id="L6379">		return bonusManager.calcBonusesWithCost(aList);</span>
	}

	/**
	 * calculate the total racial modifier to save: racial bonuses like the
	 * standard halfling's +1 on all saves template bonuses like the Lightfoot
	 * halfling's +1 on all saves racial base modifiers for certain monsters
	 *
	 * @param check
	 * @return int
	 */
	private int calculateSaveBonusRace(PCCheck check)
	{
<span class="nc" id="L6392">		final String sString = check.toString();</span>
<span class="nc" id="L6393">		Race race = getRace();</span>
<span class="nc" id="L6394">		int save = (int) BonusCalc.charBonusTo(race, &quot;SAVE&quot;, &quot;BASE.&quot; + sString, this);</span>
<span class="nc" id="L6395">		save += (int) BonusCalc.charBonusTo(race, &quot;SAVE&quot;, sString, this);</span>

<span class="nc" id="L6397">		return save;</span>
	}

	/**
	 * Counts the number of spells inside a spellbook Yes, divine casters can
	 * have a &quot;spellbook&quot;
	 *
	 * @param aString
	 * @return spells in a book
	 */
	public int countSpellsInBook(final String aString)
	{
<span class="nc" id="L6409">		final StringTokenizer aTok = new StringTokenizer(aString, &quot;.&quot;);</span>
<span class="nc" id="L6410">		final int classNum = Integer.parseInt(aTok.nextToken());</span>
<span class="nc" id="L6411">		final int sbookNum = Integer.parseInt(aTok.nextToken());</span>
		final int levelNum;

<span class="nc bnc" id="L6414" title="All 2 branches missed.">		if (sbookNum &gt;= getSpellBookCount())</span>
		{
<span class="nc" id="L6416">			return 0;</span>
		}

<span class="nc bnc" id="L6419" title="All 2 branches missed.">		if (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L6421">			levelNum = Integer.parseInt(aTok.nextToken());</span>
		}
		else
		{
<span class="nc" id="L6425">			levelNum = -1;</span>
		}

<span class="nc" id="L6428">		String bookName = Globals.getDefaultSpellBook();</span>

<span class="nc bnc" id="L6430" title="All 2 branches missed.">		if (sbookNum &gt; 0)</span>
		{
<span class="nc" id="L6432">			bookName = getSpellBookNames().get(sbookNum);</span>
		}

<span class="nc" id="L6435">		final PObject aObject = getSpellClassAtIndex(classNum);</span>

<span class="nc bnc" id="L6437" title="All 2 branches missed.">		if (aObject != null)</span>
		{
<span class="nc" id="L6439">			final List&lt;CharacterSpell&gt; aList = getCharacterSpells(aObject, null, bookName, levelNum);</span>
<span class="nc" id="L6440">			return aList.size();</span>
		}

<span class="nc" id="L6443">		return 0;</span>
	}

	public SizeAdjustment getSizeAdjustment()
	{
<span class="fc" id="L6448">		String sizeControl = getControl(CControl.PCSIZE);</span>
<span class="pc bpc" id="L6449" title="1 of 2 branches missed.">		if (sizeControl != null)</span>
		{
<span class="nc" id="L6451">			return (SizeAdjustment) getGlobal(sizeControl);</span>
		}
		else
		{
<span class="fc" id="L6455">			return sizeFacet.get(id);</span>
		}
	}

	public int getSpellClassCount()
	{
<span class="nc" id="L6461">		return getSpellClassList().size();</span>
	}

	/**
	 * Get the spell class list
	 *
	 * @return List
	 */
	public List&lt;? extends PObject&gt; getSpellClassList()
	{
<span class="nc" id="L6471">		final List&lt;PObject&gt; aList = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L6473">		Race race = getRace();</span>
<span class="nc bnc" id="L6474" title="All 2 branches missed.">		if (!getCharacterSpells(race).isEmpty())</span>
		{
<span class="nc" id="L6476">			aList.add(race);</span>
		}

<span class="nc bnc" id="L6479" title="All 2 branches missed.">		for (PCClass pcClass : getClassSet())</span>
		{
<span class="nc bnc" id="L6481" title="All 2 branches missed.">			if (pcClass.get(FactKey.valueOf(&quot;SpellType&quot;)) != null)</span>
			{
<span class="nc" id="L6483">				aList.add(pcClass);</span>
			}
<span class="nc" id="L6485">		}</span>

<span class="nc" id="L6487">		return aList;</span>
	}

	public boolean includeSkill(final Skill skill, final SkillFilter filter)
	{
<span class="nc bnc" id="L6492" title="All 6 branches missed.">		if (skill.getSafe(ObjectKey.EXCLUSIVE) &amp;&amp; !this.isClassSkill(skill) &amp;&amp; !this.isCrossClassSkill(skill))</span>
		{
<span class="nc" id="L6494">			return false;</span>
		}

<span class="nc bnc" id="L6497" title="All 4 branches missed.">		return switch (filter)</span>
				{
<span class="nc bnc" id="L6499" title="All 2 branches missed.">					case Ranks -&gt; (SkillRankControl.getTotalRank(this, skill) &gt; 0);</span>
<span class="nc" id="L6500">					case NonDefault -&gt; (</span>
<span class="nc bnc" id="L6501" title="All 2 branches missed.">							SkillRankControl.getTotalRank(this, skill) &gt; 0</span>
<span class="nc" id="L6502">									|| SkillModifier.modifier(skill, this) != SkillModifier.getStatMod(skill, this)</span>
<span class="nc bnc" id="L6503" title="All 2 branches missed.">									+ getSizeAdjustmentBonusTo(&quot;SKILL&quot;, skill.getKeyName()));</span>
<span class="nc bnc" id="L6504" title="All 2 branches missed.">					case Usable -&gt; qualifySkill(skill) &amp;&amp; (</span>
<span class="nc bnc" id="L6505" title="All 2 branches missed.">							SkillRankControl.getTotalRank(this, skill) &gt; 0</span>
<span class="nc bnc" id="L6506" title="All 2 branches missed.">									|| skill.getSafe(ObjectKey.USE_UNTRAINED));</span>
<span class="nc" id="L6507">					default -&gt; qualifySkill(skill);</span>
				};
	}

	private boolean qualifySkill(final Skill skill)
	{
<span class="nc" id="L6513">		return skill.qualifies(this, skill);</span>
	}

	/**
	 * Change the number of levels a character has in a particular class. Note:
	 * It is assumed that this method is not used as part of loading a
	 * previously saved character. there is no way to bypass the prerequisites
	 * with this method, see: incrementClassLevel(int, PCClass, boolean,
	 * boolean);
	 *
	 *
	 * @param numberOfLevels
	 *            number of levels to add
	 * @param globalClass
	 *            the class to add the levels to
	 * @param bSilent
	 *            whether or not to display warning messages
	 */
	public void incrementClassLevel(final int numberOfLevels, final PCClass globalClass, final boolean bSilent)
	{
<span class="nc" id="L6533">		incrementClassLevel(numberOfLevels, globalClass, bSilent, false);</span>
<span class="nc" id="L6534">	}</span>

	/**
	 * Change the number of levels a character has in a particular class. Note:
	 * It is assumed that this method is not used as part of loading a
	 * previously saved character.
	 *
	 * @param numberOfLevels
	 *            The number of levels to add or remove. If a positive number is
	 *            passed in then that many levels will be added. If the number
	 *            of levels passed in is negative then that many levels will be
	 *            removed from the specified class.
	 * @param globalClass
	 *            The global class from the data store. The class as stored in
	 *            the character will be compared to this one using the
	 *            getClassNamed() method
	 * @param bSilent
	 *            If true do not display any warning messages about adding or
	 *            removing too many levels
	 * @param bypassPrereqs
	 *            Whether we should bypass the checks as to whether or not the
	 *            PC qualifies to take this class. If true, the checks will be
	 *            bypassed
	 */
	public void incrementClassLevel(final int numberOfLevels, final PCClass globalClass, final boolean bSilent,
		final boolean bypassPrereqs)
	{
		// If not importing, load the spell list
<span class="nc bnc" id="L6562" title="All 2 branches missed.">		if (!importing)</span>
		{
<span class="nc" id="L6564">			getSpellList();</span>
		}

		// Make sure the character qualifies for the class if adding it
<span class="nc bnc" id="L6568" title="All 2 branches missed.">		if (numberOfLevels &gt; 0)</span>
		{
<span class="nc bnc" id="L6570" title="All 4 branches missed.">			if (!bypassPrereqs &amp;&amp; !globalClass.qualifies(this, globalClass))</span>
			{
<span class="nc" id="L6572">				return;</span>
			}

<span class="nc" id="L6575">			Race race = getRace();</span>
<span class="nc bnc" id="L6576" title="All 6 branches missed.">			if (globalClass.isMonster() &amp;&amp; !SettingsHandler.isIgnoreMonsterHDCap() &amp;&amp; !race.isAdvancementUnlimited()</span>
<span class="nc bnc" id="L6577" title="All 4 branches missed.">				&amp;&amp; ((totalHitDice() + numberOfLevels) &gt; race.maxHitDiceAdvancement()) &amp;&amp; !bSilent)</span>
			{
<span class="nc" id="L6579">				ShowMessageDelegate.showMessageDialog(</span>
<span class="nc" id="L6580">					&quot;Cannot increase Monster Hit Dice for this character beyond &quot; + race.maxHitDiceAdvancement()</span>
<span class="nc" id="L6581">						+ &quot;. This character's current number of Monster Hit Dice is &quot; + totalHitDice(),</span>
					Constants.APPLICATION_NAME, MessageType.INFORMATION);

<span class="nc" id="L6584">				return;</span>
			}
		}

		// Check if the character already has the class.
<span class="nc" id="L6589">		PCClass pcClassClone = getClassKeyed(globalClass.getKeyName());</span>

		// If the character did not already have the class...
<span class="nc bnc" id="L6592" title="All 2 branches missed.">		if (pcClassClone == null)</span>
		{
			// add the class even if setting to level 0
<span class="nc bnc" id="L6595" title="All 2 branches missed.">			if (numberOfLevels &gt;= 0)</span>
			{
				// Get a clone of the class so we don't modify the globals!
<span class="nc" id="L6598">				pcClassClone = globalClass.clone(); //Still required :(</span>

				// Make sure the clone was successful
<span class="nc bnc" id="L6601" title="All 2 branches missed.">				if (pcClassClone == null)</span>
				{
<span class="nc" id="L6603">					Logging.errorPrint(&quot;PlayerCharacter::incrementClassLevel =&gt; &quot; + &quot;Clone of class &quot;</span>
<span class="nc" id="L6604">						+ globalClass.getKeyName() + &quot; failed!&quot;);</span>

<span class="nc" id="L6606">					return;</span>
				}

				// If not importing, add extra feats
<span class="nc bnc" id="L6610" title="All 4 branches missed.">				if (!importing &amp;&amp; classFacet.isEmpty(id))</span>
				{
<span class="nc" id="L6612">					adjustAbilities(AbilityCategory.FEAT, new BigDecimal(pcClassClone.getSafe(IntegerKey.START_FEATS)));</span>
				}

				// Add the class to the character classes as level 0
<span class="nc" id="L6616">				classFacet.addClass(id, pcClassClone);</span>
			}
			else
			{
				// mod is &lt; 0 and character does not have class. Return.
<span class="nc" id="L6621">				return;</span>
			}
		}

		// Add or remove levels as needed
<span class="nc bnc" id="L6626" title="All 2 branches missed.">		if (numberOfLevels &gt; 0)</span>
		{
<span class="nc bnc" id="L6628" title="All 2 branches missed.">			for (int i = 0; i &lt; numberOfLevels; ++i)</span>
			{
<span class="nc" id="L6630">				addLevelInfo(pcClassClone.getKeyName());</span>

				// if we fail to add the level, remove and return
<span class="nc bnc" id="L6633" title="All 2 branches missed.">				if (!pcClassClone.addLevel(false, bSilent, this, bypassPrereqs))</span>
				{
<span class="nc" id="L6635">					removeLevelInfo(pcClassClone.getKeyName());</span>
<span class="nc" id="L6636">					return;</span>
				}
			}
		}
<span class="nc bnc" id="L6640" title="All 2 branches missed.">		else if (numberOfLevels &lt; 0)</span>
		{
<span class="nc bnc" id="L6642" title="All 2 branches missed.">			for (int i = 0; i &lt; -numberOfLevels; ++i)</span>
			{
<span class="nc" id="L6644">				int currentLevel = getLevel(pcClassClone);</span>
<span class="nc" id="L6645">				pcClassClone.subLevel(this);</span>
<span class="nc" id="L6646">				PCLevelInfo removedLI = removeLevelInfo(pcClassClone.getKeyName());</span>
<span class="nc" id="L6647">				int pointsToRemove = removedLI.getSkillPointsGained(this) - removedLI.getSkillPointsRemaining();</span>
<span class="nc" id="L6648">				SkillRankControl.removeSkillsForTopLevel(this, pcClassClone, currentLevel, pointsToRemove);</span>
			}
		}

<span class="nc" id="L6652">		calcActiveBonuses();</span>
<span class="nc" id="L6653">	}</span>

	/**
	 * Remove from the character the PCLevelInfo representing the highest level
	 * of the supplied class.
	 *
	 * @param classKeyName The keyname of the class to have a level removed.
	 * @return The level removed, or null if none was found
	 */
	private PCLevelInfo removeLevelInfo(final String classKeyName)
	{
<span class="nc bnc" id="L6664" title="All 2 branches missed.">		for (int idx = getLevelInfoSize() - 1; idx &gt;= 0; --idx)</span>
		{
<span class="nc" id="L6666">			final PCLevelInfo li = levelInfoFacet.get(id, idx);</span>

<span class="nc bnc" id="L6668" title="All 2 branches missed.">			if (li.getClassKeyName().equals(classKeyName))</span>
			{
<span class="nc" id="L6670">				levelInfoFacet.remove(id, li);</span>
<span class="nc" id="L6671">				setDirty(true);</span>

<span class="nc" id="L6673">				return li;</span>
			}
		}

<span class="nc" id="L6677">		return null;</span>
	}

	/**
	 * {@code rollStats} roll Globals.s_ATTRIBLONG.length random stats
	 * Method: 1: 4d6 Drop Lowest 2: 3d6 3: 5d6 Drop 2 Lowest 4: 4d6 reroll 1's
	 * drop lowest 5: 4d6 reroll 1's and 2's drop lowest 6: 3d6 +5 7: 5d6 Drop
	 * lowest and middle as per FREQ #458917
	 *
	 * @param method
	 *            the method to be used for rolling.
	 */
	public final void rollStats(final int method)
	{
<span class="fc" id="L6691">		int aMethod = method;</span>
<span class="pc bpc" id="L6692" title="1 of 2 branches missed.">		if (SettingsHandler.getGameAsProperty().get().isPurchaseStatMode())</span>
		{
<span class="nc" id="L6694">			aMethod = Constants.CHARACTER_STAT_METHOD_PURCHASE;</span>
		}
<span class="fc" id="L6696">		rollStats(aMethod, statFacet.getSet(id), SettingsHandler.getGameAsProperty().get().getCurrentRollingMethod(), false);</span>
<span class="fc" id="L6697">	}</span>

	public void rollStats(final int method, final Collection&lt;PCStat&gt; aStatList, final RollMethod rollMethod,
		boolean aSortedFlag)
	{
<span class="fc" id="L6702">		int[] rolls = new int[aStatList.size()];</span>

<span class="fc bfc" id="L6704" title="All 2 branches covered.">		for (int i = 0; i &lt; rolls.length; i++)</span>
		{
<span class="pc bpc" id="L6706" title="3 of 4 branches missed.">			switch (method)</span>
			{
<span class="nc" id="L6708">				case Constants.CHARACTER_STAT_METHOD_PURCHASE -&gt; rolls[i] =</span>
<span class="nc" id="L6709">						SettingsHandler.getGameAsProperty().get().getPurchaseModeBaseStatScore(this);</span>
<span class="nc" id="L6710">				case Constants.CHARACTER_STAT_METHOD_ALL_THE_SAME -&gt; rolls[i] =</span>
<span class="nc" id="L6711">						SettingsHandler.getGameAsProperty().get().getAllStatsValue();</span>
				case Constants.CHARACTER_STAT_METHOD_ROLLED -&gt; {
<span class="nc" id="L6713">					final String diceExpression = rollMethod.getMethodRoll();</span>
<span class="nc" id="L6714">					rolls[i] = RollingMethods.roll(diceExpression);</span>
<span class="nc" id="L6715">				}</span>
<span class="fc" id="L6716">				default -&gt; rolls[i] = 0;</span>
			}
		}
<span class="pc bpc" id="L6719" title="1 of 2 branches missed.">		if (aSortedFlag)</span>
		{
<span class="nc" id="L6721">			Arrays.sort(rolls);</span>
		}

<span class="fc" id="L6724">		int i = rolls.length - 1;</span>
<span class="fc bfc" id="L6725" title="All 2 branches covered.">		for (PCStat currentStat : aStatList)</span>
		{
<span class="fc" id="L6727">			setStat(currentStat, 0);</span>

<span class="pc bpc" id="L6729" title="1 of 2 branches missed.">			if (!currentStat.getSafe(ObjectKey.ROLLED))</span>
			{
<span class="nc" id="L6731">				continue;</span>
			}

<span class="fc" id="L6734">			int roll = rolls[i--] + getStat(currentStat);</span>

<span class="pc bpc" id="L6736" title="1 of 2 branches missed.">			if (roll &lt; currentStat.getSafe(IntegerKey.MIN_VALUE))</span>
			{
<span class="nc" id="L6738">				roll = currentStat.getSafe(IntegerKey.MIN_VALUE);</span>
			}

<span class="pc bpc" id="L6741" title="1 of 2 branches missed.">			if (roll &gt; currentStat.getSafe(IntegerKey.MAX_VALUE))</span>
			{
<span class="nc" id="L6743">				roll = currentStat.getSafe(IntegerKey.MAX_VALUE);</span>
			}

<span class="fc" id="L6746">			setStat(currentStat, roll);</span>
<span class="fc" id="L6747">		}</span>

<span class="pc bpc" id="L6749" title="1 of 2 branches missed.">		if (method != Constants.CHARACTER_STAT_METHOD_PURCHASE)</span>
		{
<span class="fc" id="L6751">			poolAmount = 0;</span>
<span class="fc" id="L6752">			this.costPool = 0;</span>
		}
<span class="pc bpc" id="L6754" title="1 of 2 branches missed.">		if (method != Constants.CHARACTER_STAT_METHOD_PURCHASE)</span>
		{
<span class="fc" id="L6756">			poolAmount = 0;</span>
		}
<span class="fc" id="L6758">	}</span>

	/**
	 * Sorts the provided list of equipment in output order. This is in
	 * ascending order of the equipment's outputIndex field. If multiple items
	 * of equipment have the same outputIndex they will be ordered by name. Note
	 * hidden items (outputIndex = -1) are not included in list.
	 *
	 * @param unsortedEquip
	 *            An ArrayList of the equipment to be sorted.
	 * @param merge
	 *            How to merge.
	 * @return An ArrayList of the equipment objects in output order.
	 */
	private static List&lt;Equipment&gt; sortEquipmentList(final Collection&lt;Equipment&gt; unsortedEquip, final int merge)
	{
<span class="nc bnc" id="L6774" title="All 2 branches missed.">		if (unsortedEquip.isEmpty())</span>
		{
			// Create a real list so it can be added to later on
<span class="nc" id="L6777">			return new ArrayList&lt;&gt;();</span>
		}

		// Merge list for duplicates
		// The sorting is done during the Merge
<span class="nc" id="L6782">		final List&lt;Equipment&gt; sortedList = CoreUtility.mergeEquipmentList(unsortedEquip, merge);</span>

		// Remove the hidden items from the list
<span class="nc bnc" id="L6785" title="All 2 branches missed.">		sortedList.removeIf(item -&gt; item.getOutputIndex() == -1);</span>

<span class="nc" id="L6787">		return sortedList;</span>
	}

	/**
	 * Prepares this PC object for output by ensuring that all its
	 * info is up to date.
	 */
	public void preparePCForOutput()
	{
		// Get the EquipSet used for output and calculations
		// possibly include equipment from temporary bonuses
<span class="nc" id="L6798">		setCalcEquipmentList(useTempMods);</span>

		// Make sure spell lists are setup
<span class="nc" id="L6801">		getSpellList();</span>

		// Calculate any active bonuses
<span class="nc" id="L6804">		calcActiveBonuses();</span>

		//Sort Skills
<span class="nc" id="L6807">		SkillDisplay.resortSelected(this, skillsOutputOrder);</span>

		// Determine which hands weapons are currently being wielded in
<span class="nc" id="L6810">		determinePrimaryOffWeapon();</span>

		// Recalculate the movement rates
<span class="nc" id="L6813">		adjustMoveRates();</span>

		// Calculate any active bonuses
<span class="nc" id="L6816">		calcActiveBonuses();</span>
<span class="nc" id="L6817">	}</span>

	private static final class CasterLevelSpellBonus
	{
		private int bonus;
		private final String type;

		/**
		 * Constructor
		 *
		 * @param b
		 * @param t
		 */
		private CasterLevelSpellBonus(final int b, final String t)
<span class="nc" id="L6831">		{</span>
<span class="nc" id="L6832">			bonus = b;</span>
<span class="nc" id="L6833">			type = t;</span>
<span class="nc" id="L6834">		}</span>

		/**
		 * Get bonus
		 *
		 * @return bonus
		 */
		public int getBonus()
		{
<span class="nc" id="L6843">			return bonus;</span>
		}

		/**
		 * Get type
		 *
		 * @return type
		 */
		public String getType()
		{
<span class="nc" id="L6853">			return type;</span>
		}

		/**
		 * Set bonus
		 *
		 * @param newBonus
		 */
		public void setBonus(final int newBonus)
		{
<span class="nc" id="L6863">			bonus = newBonus;</span>
<span class="nc" id="L6864">		}</span>

		@Override
		public String toString()
		{
<span class="nc" id="L6869">			return (&quot;bonus: &quot; + bonus + &quot;    type: &quot; + type);</span>
		}

	}

	/**
	 * @param info
	 * @return character level
	 */
	public int getCharacterLevel(final PCLevelInfo info)
	{
<span class="nc" id="L6880">		int i = 1;</span>
<span class="nc bnc" id="L6881" title="All 2 branches missed.">		for (PCLevelInfo element : getLevelInfo())</span>
		{
<span class="nc bnc" id="L6883" title="All 2 branches missed.">			if (info == element)</span>
			{
<span class="nc" id="L6885">				return i;</span>
			}
<span class="nc" id="L6887">			i++;</span>
<span class="nc" id="L6888">		}</span>
<span class="nc" id="L6889">		return -1;</span>
	}

	/**
	 * Return a list of bonus languages which the character may select from.
	 * This function is not efficient, but is sufficient for it's current use of
	 * only being called when the user requests the bonus language selection
	 * list. Note: A check will be made for the ALL language and it will be
	 * replaced with the current list of languages in globals. These should be
	 * further restricted by the prerequisites of the languages to ensure that
	 * 'secret' languages are not offered.
	 *
	 * @return List of bonus languages for the character.
	 */
	public Set&lt;Language&gt; getLanguageBonusSelectionList()
	{
<span class="nc" id="L6905">		return startingLangFacet.getSet(id);</span>
	}

	/**
	 * Retrieve the value of the stat excluding either temporary bonuses,
	 * equipment bonuses or both. This method ensure stacking rules are applied
	 * to all included bonuses. If not excluding either, it is quicker to use
	 * getTotalBonusTo.
	 *
	 * @param stat
	 *            The stat to calculate the bonus for.
	 * @param useTemp
	 *            Should temp bonuses be included?
	 * @param useEquip
	 *            Should equipment bonuses be included?
	 * @return The bonus to the stat.
	 */
	public int getPartialStatFor(PCStat stat, boolean useTemp, boolean useEquip)
	{
<span class="nc" id="L6924">		int partialStatBonus = bonusManager.getPartialStatBonusFor(stat, useTemp, useEquip);</span>
<span class="nc" id="L6925">		return statCalcFacet.getPartialStatFor(id, stat, partialStatBonus);</span>
	}

	/**
	 * Retrieve the stat as it was at a particular level excluding either
	 * temporary bonuses, equipment bonuses or both. This method ensures
	 * stacking rules are applied to all included bonuses. If not excluding
	 * either, it is quicker to use getTotalStatAtLevel.
	 *
	 * @param stat
	 *            The stat to calculate the value of.
	 * @param level
	 *            The level we want to see the stat at.
	 * @param usePost
	 *            Should stat mods that occurred after levelling be included?
	 * @param useTemp
	 *            Should temp bonuses be included?
	 * @param useEquip
	 *            Should equipment bonuses be included?
	 * @return The stat as it was at the level
	 */
	public int getPartialStatAtLevel(PCStat stat, int level, boolean usePost, boolean useTemp, boolean useEquip)
	{
<span class="nc" id="L6948">		int curStat = StatAnalysis.getPartialStatFor(this, stat, useTemp, useEquip);</span>
<span class="nc bnc" id="L6949" title="All 2 branches missed.">		for (int idx = getLevelInfoSize() - 1; idx &gt;= level; --idx)</span>
		{
<span class="nc" id="L6951">			final int statLvlAdjust = levelInfoFacet.get(id, idx).getTotalStatMod(stat, usePost);</span>
<span class="nc" id="L6952">			curStat -= statLvlAdjust;</span>
		}

<span class="nc" id="L6955">		return curStat;</span>
	}

	/**
	 * Returns a deep copy of the PlayerCharacter. Note: This method does a
	 * shallow copy of many lists in here that seem to point to &quot;system&quot;
	 * objects. These copies should be validated before using this method.
	 *
	 * @return a new deep copy of the {@code PlayerCharacter}
	 */
	@Override
	public PlayerCharacter clone()
	{
		PlayerCharacter aClone;

		// calling super.clone won't work because it will not create
		// new data instances for all the final variables and I won't
		// be able to reset them. Need to call new PlayerCharacter()
		// aClone = (PlayerCharacter)super.clone();
<span class="nc" id="L6974">		aClone = new PlayerCharacter(this);</span>
		try
		{
<span class="nc" id="L6977">			aClone.assocSupt = assocSupt.clone();</span>
		}
<span class="nc" id="L6979">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L6981">			Logging.errorPrint(&quot;PlayerCharacter.clone failed&quot;, e);</span>
<span class="nc" id="L6982">		}</span>
<span class="nc" id="L6983">		Collection&lt;AbstractStorageFacet&gt; beans = SpringHelper.getStorageBeans();</span>
<span class="nc bnc" id="L6984" title="All 2 branches missed.">		for (AbstractStorageFacet bean : beans)</span>
		{
<span class="nc" id="L6986">			bean.copyContents(id, aClone.id);</span>
<span class="nc" id="L6987">		}</span>
<span class="nc" id="L6988">		SolverManager sm = solverManagerFacet.get(id);</span>
<span class="nc bnc" id="L6989" title="All 2 branches missed.">		if (sm != null)</span>
		{
<span class="nc" id="L6991">			SolverManager replacement = sm.createReplacement(variableStoreFacet.get(aClone.id));</span>
<span class="nc" id="L6992">			solverManagerFacet.set(aClone.id, replacement);</span>
		}
<span class="nc" id="L6994">		aClone.bonusManager = bonusManager.buildDeepClone(aClone);</span>

<span class="nc bnc" id="L6996" title="All 2 branches missed.">		for (PCClass cloneClass : aClone.classFacet.getSet(aClone.id))</span>
		{
<span class="nc" id="L6998">			cloneClass.addFeatPoolBonus(aClone);</span>
<span class="nc" id="L6999">		}</span>
<span class="nc" id="L7000">		Follower followerMaster = masterFacet.get(id);</span>
<span class="nc bnc" id="L7001" title="All 2 branches missed.">		if (followerMaster != null)</span>
		{
<span class="nc" id="L7003">			aClone.masterFacet.set(id, followerMaster.clone());</span>
		}
		else
		{
<span class="nc" id="L7007">			aClone.masterFacet.remove(id);</span>
		}
<span class="nc" id="L7009">		aClone.equipSetFacet.removeAll(aClone.id);</span>
<span class="nc bnc" id="L7010" title="All 2 branches missed.">		for (EquipSet eqSet : equipSetFacet.getSet(id))</span>
		{
<span class="nc" id="L7012">			aClone.addEquipSet(eqSet.clone());</span>
<span class="nc" id="L7013">		}</span>
<span class="nc" id="L7014">		List&lt;Equipment&gt; equipmentMasterList = aClone.getEquipmentMasterList();</span>
<span class="nc" id="L7015">		aClone.userEquipmentFacet.removeAll(aClone.id);</span>
<span class="nc" id="L7016">		aClone.equipmentFacet.removeAll(aClone.id);</span>
<span class="nc" id="L7017">		aClone.equippedFacet.removeAll(aClone.id);</span>
<span class="nc" id="L7018">		FacetLibrary.getFacet(SourcedEquipmentFacet.class).removeAll(aClone.id);</span>
<span class="nc bnc" id="L7019" title="All 2 branches missed.">		for (Equipment equip : equipmentMasterList)</span>
		{
<span class="nc" id="L7021">			aClone.addEquipment(equip.clone());</span>
<span class="nc" id="L7022">		}</span>

<span class="nc" id="L7024">		aClone.levelInfoFacet.removeAll(aClone.id);</span>
<span class="nc bnc" id="L7025" title="All 2 branches missed.">		for (PCLevelInfo info : getLevelInfo())</span>
		{
<span class="nc" id="L7027">			PCLevelInfo newLvlInfo = info.clone();</span>
<span class="nc" id="L7028">			aClone.levelInfoFacet.add(aClone.id, newLvlInfo);</span>
<span class="nc" id="L7029">		}</span>
<span class="nc" id="L7030">		aClone.spellBookFacet.removeAll(aClone.id);</span>
<span class="nc bnc" id="L7031" title="All 2 branches missed.">		for (String book : spellBookFacet.getBookNames(id))</span>
		{
<span class="nc" id="L7033">			aClone.addSpellBook(spellBookFacet.getBookNamed(id, book).clone());</span>
<span class="nc" id="L7034">		}</span>
<span class="nc" id="L7035">		aClone.calcEquipSetId = calcEquipSetId;</span>
<span class="nc" id="L7036">		aClone.tempBonusItemList.addAll(tempBonusItemList);</span>
<span class="nc" id="L7037">		aClone.autoKnownSpells = autoKnownSpells;</span>
<span class="nc" id="L7038">		aClone.autoLoadCompanion = autoLoadCompanion;</span>
<span class="nc" id="L7039">		aClone.outputSheetHTML = outputSheetHTML;</span>
<span class="nc" id="L7040">		aClone.outputSheetPDF = outputSheetPDF;</span>
<span class="nc" id="L7041">		aClone.defaultDomainSource = defaultDomainSource;</span>

<span class="nc" id="L7043">		aClone.ageSetKitSelections =</span>
<span class="nc" id="L7044">				Arrays.copyOf(ageSetKitSelections, ageSetKitSelections.length);</span>

		// Not sure what this is for
<span class="nc" id="L7047">		aClone.importing = false;</span>
<span class="nc" id="L7048">		aClone.useTempMods = useTempMods;</span>
<span class="nc" id="L7049">		aClone.costPool = costPool;</span>
<span class="nc" id="L7050">		aClone.currentEquipSetNumber = currentEquipSetNumber;</span>
<span class="nc" id="L7051">		aClone.poolAmount = poolAmount;</span>

		// order in which the skills will be output.
<span class="nc" id="L7054">		aClone.skillsOutputOrder = skillsOutputOrder;</span>
<span class="nc" id="L7055">		aClone.spellLevelTemp = spellLevelTemp;</span>
<span class="nc" id="L7056">		aClone.pointBuyPoints = pointBuyPoints;</span>

<span class="nc" id="L7058">		aClone.adjustMoveRates();</span>
		//This mod set is necessary to trigger certain calculations to ensure correct output
		//modSkillPointsBuffer = Integer.MIN_VALUE;
<span class="nc" id="L7061">		aClone.calcActiveBonuses();</span>
		//Just to be safe
<span class="nc" id="L7063">		aClone.equippedFacet.reset(aClone.id);</span>

<span class="nc" id="L7065">		aClone.serial = serial;</span>

<span class="nc" id="L7067">		return aClone;</span>
	}

	/**
	 * Set the string for the characteristic
	 *
	 * @param key
	 * @param s
	 */
	public void setStringFor(PCStringKey key, String s)
	{
<span class="pc bpc" id="L7078" title="1 of 2 branches missed.">		assert (key != null);</span>
<span class="fc" id="L7079">		String currValue = factFacet.get(id, key);</span>
<span class="pc bpc" id="L7080" title="1 of 2 branches missed.">		if (PlayerCharacter.shouldDirtyForChange(s, currValue))</span>
		{
<span class="fc" id="L7082">			factFacet.set(id, key, s);</span>
<span class="fc" id="L7083">			setDirty(true);</span>
		}
<span class="fc" id="L7085">	}</span>

	private static boolean shouldDirtyForChange(final String s, final String currValue)
	{
<span class="pc bpc" id="L7089" title="6 of 8 branches missed.">		return (currValue == null &amp;&amp; s != null) || (currValue != null &amp;&amp; !currValue.equals(s));</span>
	}

	private Float getEquippedQty(EquipSet eSet, Equipment eqI)
	{
<span class="nc" id="L7094">		return equipSetFacet.getEquippedQuantity(id, eSet, eqI);</span>
	}

	/**
	 * If an item can only go in one location, return the name of that location
	 * to add to an EquipSet
	 *
	 * @param eqI
	 * @return single location
	 */
	private String getSingleLocation(Equipment eqI)
	{
		// Handle natural weapons
<span class="nc" id="L7107">		String loc = getNaturalWeaponLocation(eqI);</span>
<span class="nc bnc" id="L7108" title="All 2 branches missed.">		if (loc != null)</span>
		{
<span class="nc" id="L7110">			return loc;</span>
		}

		// Always force weapons to go through the chooser dialog
		// unless they are also armor (ie: with Armor Spikes)
<span class="nc bnc" id="L7115" title="All 4 branches missed.">		if ((eqI.isWeapon()) &amp;&amp; !(eqI.isArmor()))</span>
		{
<span class="nc" id="L7117">			return Constants.EMPTY_STRING;</span>
		}

<span class="nc" id="L7120">		List&lt;EquipSlot&gt; eqSlotList = SystemCollections.getUnmodifiableEquipSlotList();</span>

<span class="nc bnc" id="L7122" title="All 2 branches missed.">		if (eqSlotList.isEmpty())</span>
		{
<span class="nc" id="L7124">			return Constants.EMPTY_STRING;</span>
		}

<span class="nc bnc" id="L7127" title="All 2 branches missed.">		for (EquipSlot es : eqSlotList)</span>
		{
			// see if this EquipSlot can contain this item TYPE
<span class="nc bnc" id="L7130" title="All 2 branches missed.">			if (es.canContainType(eqI.getType()))</span>
			{
<span class="nc" id="L7132">				return es.getSlotName();</span>
			}
<span class="nc" id="L7134">		}</span>

<span class="nc" id="L7136">		return Constants.EMPTY_STRING;</span>
	}

	/**
	 * Identify the equipping location for a natural weapon.
	 * @param eqI The natural weapon
	 * @return The location name, or null if not a natural weapon.
	 */
	public String getNaturalWeaponLocation(Equipment eqI)
	{
<span class="nc bnc" id="L7146" title="All 2 branches missed.">		if (eqI.isNatural())</span>
		{
<span class="nc bnc" id="L7148" title="All 2 branches missed.">			if (eqI.getSlots(this) == 0)</span>
			{
<span class="nc bnc" id="L7150" title="All 2 branches missed.">				if (eqI.isPrimaryNaturalWeapon())</span>
				{
<span class="nc" id="L7152">					return Constants.EQUIP_LOCATION_NATURAL_PRIMARY;</span>
				}
<span class="nc" id="L7154">				return Constants.EQUIP_LOCATION_NATURAL_SECONDARY;</span>
			}
		}
<span class="nc" id="L7157">		return null;</span>
	}

	/**
	 * returns true if you can put Equipment into a location in EquipSet
	 *
	 * @param eSet
	 * @param locName
	 * @param eqI
	 * @param eqTarget
	 * @return true if equipment can be added
	 */
	private boolean canEquipItem(EquipSet eSet, String locName, Equipment eqI, Equipment eqTarget)
	{
<span class="nc" id="L7171">		final String idPath = eSet.getIdPath();</span>
		// If target is a container, allow it
<span class="nc bnc" id="L7173" title="All 4 branches missed.">		if ((eqTarget != null) &amp;&amp; eqTarget.isContainer())</span>
		{
<span class="nc" id="L7175">			return true; // TODO - Should make sure eqI can be contained by eqTarget</span>
		}

		// If Carried/Equipped/Not Carried slot
		// allow as many as they would like
<span class="nc bnc" id="L7180" title="All 2 branches missed.">		if (locName.startsWith(Constants.EQUIP_LOCATION_CARRIED)</span>
<span class="nc bnc" id="L7181" title="All 2 branches missed.">			|| locName.startsWith(Constants.EQUIP_LOCATION_EQUIPPED)</span>
<span class="nc bnc" id="L7182" title="All 2 branches missed.">			|| locName.startsWith(Constants.EQUIP_LOCATION_NOTCARRIED))</span>
		{
<span class="nc" id="L7184">			return true;</span>
		}

		// allow as many unarmed items as you'd like
<span class="nc bnc" id="L7188" title="All 2 branches missed.">		if (eqI.isUnarmed())</span>
		{
<span class="nc" id="L7190">			return true;</span>
		}

		// allow many Secondary Natural weapons
<span class="nc bnc" id="L7194" title="All 2 branches missed.">		if (locName.equals(Constants.EQUIP_LOCATION_NATURAL_SECONDARY))</span>
		{
<span class="nc" id="L7196">			return true;</span>
		}

		// Don't allow weapons that are too large for PC
<span class="nc bnc" id="L7200" title="All 6 branches missed.">		if (eqI.isWeapon() &amp;&amp; eqI.isWeaponOutsizedForPC(this) &amp;&amp; !eqI.isNatural())</span>
		{
<span class="nc" id="L7202">			return false;</span>
		}

		// make a HashMap to keep track of the number of each
		// item that is already equipped to a slot
<span class="nc" id="L7207">		Map&lt;String, String&gt; slotMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L7209" title="All 2 branches missed.">		for (EquipSet es : getEquipSet())</span>
		{
<span class="nc" id="L7211">			String esID = es.getParentIdPath() + Constants.EQUIP_SET_PATH_SEPARATOR;</span>
<span class="nc" id="L7212">			String abID = idPath + Constants.EQUIP_SET_PATH_SEPARATOR;</span>
<span class="nc bnc" id="L7213" title="All 2 branches missed.">			if (!esID.startsWith(abID))</span>
			{
<span class="nc" id="L7215">				continue;</span>
			}

			// check to see if we already have
			// an item in that particular location
<span class="nc bnc" id="L7220" title="All 2 branches missed.">			if (es.getName().equals(locName))</span>
			{
<span class="nc" id="L7222">				final Equipment eItem = es.getItem();</span>
<span class="nc" id="L7223">				final String nString = slotMap.get(locName);</span>
<span class="nc" id="L7224">				int existNum = 0;</span>
<span class="nc bnc" id="L7225" title="All 2 branches missed.">				if (nString != null)</span>
				{
<span class="nc" id="L7227">					existNum = Integer.parseInt(nString);</span>
				}
<span class="nc bnc" id="L7229" title="All 2 branches missed.">				if (eItem != null)</span>
				{
<span class="nc" id="L7231">					existNum += eItem.getSlots(this);</span>
				}
<span class="nc" id="L7233">				slotMap.put(locName, String.valueOf(existNum));</span>
			}
<span class="nc" id="L7235">		}</span>
<span class="nc bnc" id="L7236" title="All 2 branches missed.">		for (EquipSet es : getEquipSet())</span>
		{
<span class="nc" id="L7238">			String esID = es.getParentIdPath() + Constants.EQUIP_SET_PATH_SEPARATOR;</span>
<span class="nc" id="L7239">			String abID = idPath + Constants.EQUIP_SET_PATH_SEPARATOR;</span>

<span class="nc bnc" id="L7241" title="All 2 branches missed.">			if (!esID.startsWith(abID))</span>
			{
<span class="nc" id="L7243">				continue;</span>
			}

			// if it's a weapon we have to do some
			// checks for hands already in use
<span class="nc bnc" id="L7248" title="All 4 branches missed.">			if (eqI.isWeapon() &amp;&amp; !eqI.isNatural())</span>
			{
				// weapons can never occupy the same slot
<span class="nc bnc" id="L7251" title="All 2 branches missed.">				if (es.getName().equals(locName))</span>
				{
<span class="nc" id="L7253">					return false;</span>
				}

				// if Double Weapon or Both Hands, then no
				// other weapon slots can be occupied
<span class="nc bnc" id="L7258" title="All 4 branches missed.">				if ((locName.equals(Constants.EQUIP_LOCATION_BOTH) || locName.equals(Constants.EQUIP_LOCATION_DOUBLE))</span>
<span class="nc bnc" id="L7259" title="All 2 branches missed.">					&amp;&amp; (es.getName().equals(Constants.EQUIP_LOCATION_PRIMARY)</span>
<span class="nc bnc" id="L7260" title="All 2 branches missed.">						|| es.getName().equals(Constants.EQUIP_LOCATION_SECONDARY)</span>
<span class="nc bnc" id="L7261" title="All 2 branches missed.">						|| es.getName().equals(Constants.EQUIP_LOCATION_BOTH)</span>
<span class="nc bnc" id="L7262" title="All 2 branches missed.">						|| es.getName().equals(Constants.EQUIP_LOCATION_DOUBLE)))</span>
				{
<span class="nc" id="L7264">					return false;</span>
				}

				// inverse of above case
<span class="nc bnc" id="L7268" title="All 2 branches missed.">				if ((locName.equals(Constants.EQUIP_LOCATION_PRIMARY)</span>
<span class="nc bnc" id="L7269" title="All 2 branches missed.">					|| locName.equals(Constants.EQUIP_LOCATION_SECONDARY))</span>
<span class="nc bnc" id="L7270" title="All 2 branches missed.">					&amp;&amp; (es.getName().equals(Constants.EQUIP_LOCATION_BOTH)</span>
<span class="nc bnc" id="L7271" title="All 2 branches missed.">						|| es.getName().equals(Constants.EQUIP_LOCATION_DOUBLE)))</span>
				{
<span class="nc" id="L7273">					return false;</span>
				}
			}

			// If we already have an item in that location
			// check to see how many are allowed in that slot
<span class="nc bnc" id="L7279" title="All 2 branches missed.">			if (es.getName().equals(locName))</span>
			{
<span class="nc" id="L7281">				final String nString = slotMap.get(locName);</span>
<span class="nc" id="L7282">				int existNum = 0;</span>

<span class="nc bnc" id="L7284" title="All 2 branches missed.">				if (nString != null)</span>
				{
<span class="nc" id="L7286">					existNum = Integer.parseInt(nString);</span>
				}

<span class="nc" id="L7289">				existNum += eqI.getSlots(this);</span>

<span class="nc" id="L7291">				EquipSlot eSlot = Globals.getEquipSlotByName(locName);</span>

<span class="nc bnc" id="L7293" title="All 2 branches missed.">				if (eSlot == null)</span>
				{
<span class="nc" id="L7295">					return true;</span>
				}

<span class="nc bnc" id="L7298" title="All 2 branches missed.">				for (String slotType : eSlot.getContainType())</span>
				{
<span class="nc bnc" id="L7300" title="All 2 branches missed.">					if (eqI.isType(slotType))</span>
					{
						// if the item takes more slots, return false
<span class="nc bnc" id="L7303" title="All 2 branches missed.">						if (existNum &gt; (eSlot.getSlotCount() + (int) getTotalBonusTo(&quot;SLOTS&quot;, slotType)))</span>
						{
<span class="nc" id="L7305">							return false;</span>
						}
					}
<span class="nc" id="L7308">				}</span>

<span class="nc" id="L7310">				return true;</span>
			}
<span class="nc" id="L7312">		}</span>

<span class="nc" id="L7314">		return true;</span>
	}

	/**
	 * Checks to see if Equipment exists in selected EquipSet and if so, then
	 * return the EquipSet containing eqI
	 *
	 * @param eSet
	 * @param eqI
	 * @return EquipSet
	 */
	public EquipSet getEquipSetForItem(EquipSet eSet, Equipment eqI)
	{
<span class="nc" id="L7327">		final String rPath = eSet.getIdPath();</span>

<span class="nc bnc" id="L7329" title="All 2 branches missed.">		for (EquipSet es : getEquipSet())</span>
		{
<span class="nc" id="L7331">			String esIdPath = es.getIdPath() + Constants.EQUIP_SET_PATH_SEPARATOR;</span>
<span class="nc" id="L7332">			String rIdPath = rPath + Constants.EQUIP_SET_PATH_SEPARATOR;</span>

<span class="nc bnc" id="L7334" title="All 2 branches missed.">			if (!esIdPath.startsWith(rIdPath))</span>
			{
<span class="nc" id="L7336">				continue;</span>
			}

<span class="nc bnc" id="L7339" title="All 2 branches missed.">			if (eqI.getName().equals(es.getValue()))</span>
			{
<span class="nc" id="L7341">				return es;</span>
			}
<span class="nc" id="L7343">		}</span>

<span class="nc" id="L7345">		return null;</span>
	}

	/**
	 * returns a new id_Path with the last id one higher than the current highest
	 * child of the supplied EquipSet.
	 *
	 * @param eSet The equipset which would be the parent of a new node.
	 * @return new id path
	 */
	private String getNewIdPath(EquipSet eSet)
	{
<span class="nc" id="L7357">		String pid = Constants.EQUIP_SET_ROOT_ID;</span>

<span class="nc bnc" id="L7359" title="All 2 branches missed.">		if (eSet != null)</span>
		{
<span class="nc" id="L7361">			pid = eSet.getIdPath();</span>
		}

<span class="nc" id="L7364">		int newID = getNewChildId(pid);</span>

<span class="nc" id="L7366">		return pid + Constants.EQUIP_SET_PATH_SEPARATOR + newID;</span>
	}

	/**
	 * Identify a new id (only the final number in the path) for a child
	 * equipment set. The id is guarantyeed to be unique and have no siblings
	 * with higher ids.
	 *
	 * @param pid The parent path.
	 * @return New id for a child node
	 */
	public int getNewChildId(String pid)
	{
<span class="nc" id="L7379">		int newID = 0;</span>
<span class="nc bnc" id="L7380" title="All 2 branches missed.">		for (EquipSet es : getEquipSet())</span>
		{
<span class="nc bnc" id="L7382" title="All 4 branches missed.">			if (es.getParentIdPath().equals(pid) &amp;&amp; (es.getId() &gt; newID))</span>
			{
<span class="nc" id="L7384">				newID = es.getId();</span>
			}
<span class="nc" id="L7386">		}</span>

<span class="nc" id="L7388">		++newID;</span>
<span class="nc" id="L7389">		return newID;</span>
	}

	public EquipSet addEquipToTarget(final EquipSet eSet, final Equipment eqTarget, String locName, final Equipment eqI,
		Float newQty)
	{
<span class="nc" id="L7395">		float tempQty = 1.0f;</span>
<span class="nc bnc" id="L7396" title="All 2 branches missed.">		if (newQty != null)</span>
		{
<span class="nc" id="L7398">			tempQty = newQty;</span>
		}
		else
		{
<span class="nc" id="L7402">			newQty = tempQty;</span>
		}
<span class="nc" id="L7404">		boolean addAll = false;</span>
<span class="nc" id="L7405">		boolean mergeItem = false;</span>

<span class="nc" id="L7407">		Equipment masterEq = getEquipmentNamed(eqI.getName());</span>
<span class="nc bnc" id="L7408" title="All 2 branches missed.">		if (masterEq == null)</span>
		{
<span class="nc" id="L7410">			return null;</span>
		}
<span class="nc" id="L7412">		float diffQty = masterEq.getQty() - getEquippedQty(eSet, eqI);</span>

		// if newQty is less than zero, we want to
		// add all of this item to the EquipSet
		// or all remaining items that havn't already
		// been added to the EquipSet
<span class="nc bnc" id="L7418" title="All 2 branches missed.">		if (newQty &lt; 0.0f)</span>
		{
<span class="nc" id="L7420">			tempQty = diffQty;</span>
<span class="nc" id="L7421">			newQty = tempQty + getEquippedQty(eSet, eqI);</span>
<span class="nc" id="L7422">			addAll = true;</span>
		}

		// Check to make sure this EquipSet does not exceed
		// the PC's equipmentList number for this item
<span class="nc bnc" id="L7427" title="All 2 branches missed.">		if (tempQty &gt; diffQty)</span>
		{
<span class="nc" id="L7429">			return null;</span>
		}

		// check to see if the target item is a container
<span class="nc bnc" id="L7433" title="All 4 branches missed.">		if ((eqTarget != null) &amp;&amp; eqTarget.isContainer())</span>
		{
			// set these to newQty just for testing
<span class="nc" id="L7436">			eqI.setQty(newQty);</span>
<span class="nc" id="L7437">			eqI.setNumberCarried(newQty);</span>

			// Make sure the container accepts items
			// of this type and is not full
<span class="nc bnc" id="L7441" title="All 2 branches missed.">			if (eqTarget.canContain(this, eqI) == 1)</span>
			{
<span class="nc" id="L7443">				locName = eqTarget.getName();</span>
<span class="nc" id="L7444">				addAll = true;</span>
<span class="nc" id="L7445">				mergeItem = true;</span>
			}
			else
			{
<span class="nc" id="L7449">				return null;</span>
			}
		}

		// If locName is empty equip this item to its default location.
		// If there is more than one option return with an error.
<span class="nc bnc" id="L7455" title="All 4 branches missed.">		if (locName == null || locName.isEmpty())</span>
		{
<span class="nc" id="L7457">			locName = getSingleLocation(eqI);</span>

<span class="nc bnc" id="L7459" title="All 2 branches missed.">			if (locName.isEmpty())</span>
			{
<span class="nc" id="L7461">				return null;</span>
			}
		}
		// If it is to go into equipped, check for a specific slot it should be in.
<span class="nc bnc" id="L7465" title="All 2 branches missed.">		else if (locName.equalsIgnoreCase(&quot;Equipped&quot;))</span>
		{
<span class="nc" id="L7467">			String singleLoc = getSingleLocation(eqI);</span>
<span class="nc bnc" id="L7468" title="All 2 branches missed.">			if (!singleLoc.isEmpty())</span>
			{
<span class="nc" id="L7470">				locName = singleLoc;</span>
			}
		}

		// make sure we can add item to that slot in this EquipSet
<span class="nc bnc" id="L7475" title="All 2 branches missed.">		if (!canEquipItem(eSet, locName, eqI, eqTarget))</span>
		{
<span class="nc" id="L7477">			return null;</span>
		}

<span class="nc bnc" id="L7480" title="All 2 branches missed.">		if (eqI.isContainer())</span>
		{
			// don't merge containers
<span class="nc" id="L7483">			mergeItem = false;</span>
		}

<span class="nc" id="L7486">		EquipSet existingSet = getEquipSetForItem(eSet, eqI);</span>

<span class="nc bnc" id="L7488" title="All 6 branches missed.">		if (addAll &amp;&amp; mergeItem &amp;&amp; (existingSet != null))</span>
		{
<span class="nc" id="L7490">			newQty = tempQty + getEquippedQty(eSet, eqI);</span>
<span class="nc" id="L7491">			existingSet.setQty(newQty);</span>
<span class="nc" id="L7492">			eqI.setQty(newQty);</span>
<span class="nc" id="L7493">			eqI.setNumberCarried(newQty);</span>
<span class="nc" id="L7494">			setDirty(true);</span>

<span class="nc bnc" id="L7496" title="All 2 branches missed.">			if (eqTarget.isContainer())</span>
			{
<span class="nc" id="L7498">				eqTarget.updateContainerContentsString(this);</span>
			}

<span class="nc" id="L7501">			return existingSet;</span>
		}
<span class="nc bnc" id="L7503" title="All 4 branches missed.">		if ((eqTarget != null) &amp;&amp; eqTarget.isContainer())</span>
		{
<span class="nc" id="L7505">			eqTarget.insertChild(this, eqI);</span>
<span class="nc" id="L7506">			eqI.setParent(eqTarget);</span>
		}

		// construct the new IdPath
		// new id is one larger than any
		// other id at this path level
<span class="nc" id="L7512">		String id = getNewIdPath(eSet);</span>

		// now create a new EquipSet to add
		// this Equipment item to
<span class="nc" id="L7516">		EquipSet newSet = new EquipSet(id, locName, eqI.getName(), eqI);</span>

		// set the Quantity of equipment
<span class="nc" id="L7519">		eqI.setQty(newQty);</span>
<span class="nc" id="L7520">		newSet.setQty(newQty);</span>

<span class="nc" id="L7522">		addEquipSet(newSet);</span>
<span class="nc" id="L7523">		setDirty(true);</span>

<span class="nc" id="L7525">		return newSet;</span>
	}

	/**
	 * Move the equipset to a new unique path under its existing parent.
	 * @param es The equipment set item to be moved.
	 */
	public void moveEquipSetToNewPath(EquipSet es)
	{
<span class="nc" id="L7534">		String parentPath = es.getParentIdPath();</span>
<span class="nc" id="L7535">		EquipSet parent = getEquipSetByIdPath(parentPath);</span>
<span class="nc" id="L7536">		String newPath = getNewIdPath(parent);</span>
<span class="nc" id="L7537">		es.setIdPath(newPath);</span>
<span class="nc" id="L7538">	}</span>

	/**
	 * Gets a 'safe' String representation
	 *
	 * @param key
	 * @return a 'safe' String
	 */
	public String getSafeStringFor(PCStringKey key)
	{
<span class="nc" id="L7548">		String s = factFacet.get(id, key);</span>
<span class="nc bnc" id="L7549" title="All 2 branches missed.">		if (s == null)</span>
		{
<span class="nc" id="L7551">			s = Constants.EMPTY_STRING;</span>
		}
<span class="nc" id="L7553">		return s;</span>
	}

	/**
	 * Sets if ADD: level abilities should be processed when incrementing a
	 * level.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;: This is kind of a hack used by the Kit code to allow a kit
	 * to specify what the level abilities are.
	 *
	 * @param yesNo
	 *            Yes if level increases should process ADD: level abilities.
	 */
	public void setDoLevelAbilities(boolean yesNo)
	{
<span class="nc" id="L7569">		processLevelAbilities = yesNo;</span>
<span class="nc" id="L7570">	}</span>

	/**
	 * Returns if level increases will process ADD: level abilities.
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if ADD: level abilities will be processed.
	 */
	public boolean doLevelAbilities()
	{
<span class="nc" id="L7579">		return processLevelAbilities;</span>
	}

	/*
	 * For debugging purposes Dumps contents of spell books to System.err
	 *
	 * static public void dumpSpells(final PlayerCharacter pc) { final List
	 * bookList = pc.getSpellBooks(); for(int bookIdx = 0; bookIdx &lt;
	 * bookList.size(); ++bookIdx) { final String bookName = (String)
	 * pc.getSpellBooks().get(bookIdx);
	 *
	 * System.err.println(&quot;==========&quot;); System.err.println(&quot;Book:&quot; + bookName);
	 * final List casterList = pc.getSpellClassList(); for(int casterIdx = 0;
	 * casterIdx &lt; casterList.size(); ++casterIdx) { final PObject aCaster =
	 * (PObject) casterList.get(casterIdx); final List spellList =
	 * aCaster.getCharacterSpellList(); if (spellList == null) { continue; }
	 * System.err.println(&quot;Class/Race:&quot; + aCaster.getName());
	 *
	 * for (Iterator i = spellList.iterator(); i.hasNext();) { final
	 * CharacterSpell cs = (CharacterSpell) i.next();
	 *
	 * for (Iterator csi = cs.getInfoListIterator(); csi.hasNext();) { final
	 * SpellInfo sInfo = (SpellInfo) csi.next(); if
	 * (bookName.equals(sInfo.getBook())) {
	 * System.err.println(cs.getSpell().getOutputName() + sInfo.toString() + &quot;
	 * level:&quot; + Integer.toString(sInfo.getActualLevel())); } } } } } }
	 */

	// --------------------------------------------------
	// Feat/Ability stuff
	// --------------------------------------------------

	public void adjustAbilities(final Category&lt;Ability&gt; aCategory, final BigDecimal arg)
	{
<span class="nc bnc" id="L7613" title="All 2 branches missed.">		if (arg.compareTo(BigDecimal.ZERO) == 0)</span>
		{
<span class="nc" id="L7615">			return;</span>
		}
<span class="nc bnc" id="L7617" title="All 2 branches missed.">		if (theUserPoolBonuses == null)</span>
		{
<span class="nc" id="L7619">			theUserPoolBonuses = new HashMap&lt;&gt;();</span>
		}
<span class="nc" id="L7621">		BigDecimal userMods = theUserPoolBonuses.get(aCategory);</span>
<span class="nc bnc" id="L7622" title="All 2 branches missed.">		if (userMods != null)</span>
		{
<span class="nc" id="L7624">			userMods = userMods.add(arg);</span>
		}
		else
		{
<span class="nc" id="L7628">			userMods = arg;</span>
		}
<span class="nc" id="L7630">		theUserPoolBonuses.put(aCategory, userMods);</span>
<span class="nc" id="L7631">		setDirty(true);</span>
<span class="nc" id="L7632">	}</span>

	public final void setUserPoolBonus(final AbilityCategory aCategory, final BigDecimal anAmount)
	{
<span class="pc bpc" id="L7636" title="1 of 2 branches missed.">		if (theUserPoolBonuses == null)</span>
		{
<span class="fc" id="L7638">			theUserPoolBonuses = new HashMap&lt;&gt;();</span>
		}
<span class="fc" id="L7640">		theUserPoolBonuses.put(aCategory, anAmount);</span>
<span class="fc" id="L7641">	}</span>

	public double getUserPoolBonus(final AbilityCategory aCategory)
	{
<span class="nc" id="L7645">		BigDecimal userBonus = null;</span>
<span class="nc bnc" id="L7646" title="All 2 branches missed.">		if (theUserPoolBonuses != null)</span>
		{
<span class="nc" id="L7648">			userBonus = theUserPoolBonuses.get(aCategory);</span>
		}
<span class="nc bnc" id="L7650" title="All 2 branches missed.">		if (userBonus == null)</span>
		{
<span class="nc" id="L7652">			return 0.0d;</span>
		}
<span class="nc" id="L7654">		return userBonus.doubleValue();</span>
	}

	public BigDecimal getTotalAbilityPool(final AbilityCategory aCategory)
	{
<span class="nc" id="L7659">		Number basePool = getBasePool(aCategory);</span>
		double bonus;
<span class="nc bnc" id="L7661" title="All 2 branches missed.">		if (AbilityCategory.FEAT.equals(aCategory))</span>
		{
<span class="nc" id="L7663">			bonus = getBonusFeatPool();</span>
		}
		else
		{
<span class="nc" id="L7667">			bonus = getTotalBonusTo(&quot;ABILITYPOOL&quot;, aCategory.getKeyName());</span>
		}
		// double bonus = getBonusValue(&quot;ABILITYPOOL&quot;, aCategory.getKeyName());
<span class="nc bnc" id="L7670" title="All 2 branches missed.">		if (!aCategory.allowFractionalPool())</span>
		{
<span class="nc" id="L7672">			bonus = Math.floor(bonus);</span>
		}
		// User bonuses already handle the fractional pool flag.
<span class="nc" id="L7675">		final double userBonus = getUserPoolBonus(aCategory);</span>
<span class="nc" id="L7676">		return BigDecimal.valueOf(basePool.floatValue() + bonus + userBonus);</span>
	}

	private Number getBasePool(final AbilityCategory aCategory)
	{
<span class="nc" id="L7681">		Number basePool = aCategory.getPoolFormula().resolve(this, getClass().toString());</span>

<span class="nc bnc" id="L7683" title="All 2 branches missed.">		if (!aCategory.allowFractionalPool())</span>
		{
<span class="nc" id="L7685">			basePool = (float) basePool.intValue();</span>
		}
<span class="nc" id="L7687">		return basePool;</span>
	}

	/**
	 * Get the remaining Feat Points (or Skill Points if the GameMode uses a Point Pool).
	 *
	 * @return Number of remaining Feat Points
	 */
	public double getRemainingFeatPoolPoints()
	{
<span class="nc bnc" id="L7697" title="All 2 branches missed.">		if (Globals.getGameModeHasPointPool())</span>
		{
<span class="nc" id="L7699">			return getSkillPoints();</span>
		}
<span class="nc" id="L7701">		return getRemainingFeatPoints(true);</span>
	}

	public BigDecimal getAvailableAbilityPool(final AbilityCategory aCategory)
	{
<span class="nc" id="L7706">		return getTotalAbilityPool(aCategory).subtract(getAbilityPoolSpent(aCategory));</span>
	}

	/**
	 * Get the number of remaining feat points.
	 *
	 * @param bIncludeBonus - Flag whether to include any bonus feat points
	 * @return number of remaining feat points
	 */
	public double getRemainingFeatPoints(final boolean bIncludeBonus)
	{
<span class="nc bnc" id="L7717" title="All 2 branches missed.">		if (bIncludeBonus)</span>
		{
<span class="nc" id="L7719">			return getAvailableAbilityPool(AbilityCategory.FEAT).doubleValue();</span>
		}
<span class="nc" id="L7721">		return getUserPoolBonus(AbilityCategory.FEAT);</span>
	}

	private BigDecimal getAbilityPoolSpent(final AbilityCategory aCategory)
	{
<span class="nc" id="L7726">		double spent = 0.0d;</span>

<span class="nc" id="L7728">		Collection&lt;CNAbility&gt; abilities = getPoolAbilities(aCategory, Nature.NORMAL);</span>
<span class="nc bnc" id="L7729" title="All 2 branches missed.">		if (abilities != null)</span>
		{
<span class="nc bnc" id="L7731" title="All 2 branches missed.">			for (final CNAbility cna : abilities)</span>
			{
<span class="nc" id="L7733">				Ability ability = cna.getAbility();</span>
<span class="nc" id="L7734">				final int subfeatCount = getSelectCorrectedAssociationCount(cna);</span>
<span class="nc" id="L7735">				double cost = ability.getSafe(ObjectKey.SELECTION_COST).doubleValue();</span>
<span class="nc bnc" id="L7736" title="All 2 branches missed.">				if (ChooseActivation.hasNewChooseToken(ability))</span>
				{
<span class="nc" id="L7738">					spent += Math.ceil(subfeatCount * cost);</span>
				}
				else
				{
<span class="nc" id="L7742">					int select = ability.getSafe(FormulaKey.SELECT).resolve(this, &quot;&quot;).intValue();</span>
<span class="nc" id="L7743">					double relativeCost = cost / select;</span>
<span class="nc bnc" id="L7744" title="All 2 branches missed.">					if (aCategory.allowFractionalPool())</span>
					{
<span class="nc" id="L7746">						spent += relativeCost;</span>
					}
					else
					{
<span class="nc" id="L7750">						spent += (int) Math.ceil(relativeCost);</span>
					}
				}
<span class="nc" id="L7753">			}</span>
		}
<span class="nc bnc" id="L7755" title="All 2 branches missed.">		if (!aCategory.allowFractionalPool())</span>
		{
<span class="nc" id="L7757">			return BigDecimal.valueOf((int) Math.ceil(spent));</span>
		}
<span class="nc" id="L7759">		return BigDecimal.valueOf(spent);</span>
	}

	public Ability getAbilityKeyed(AbilityCategory aCategory, String aKey)
	{
<span class="nc bnc" id="L7764" title="All 2 branches missed.">		for (Ability ability : getAbilityList(aCategory, Nature.NORMAL))</span>
		{
<span class="nc bnc" id="L7766" title="All 2 branches missed.">			if (ability.getKeyName().equals(aKey))</span>
			{
<span class="nc" id="L7768">				return ability;</span>
			}
<span class="nc" id="L7770">		}</span>
<span class="nc bnc" id="L7771" title="All 2 branches missed.">		for (Ability ability : getAbilityList(aCategory, Nature.VIRTUAL))</span>
		{
<span class="nc bnc" id="L7773" title="All 2 branches missed.">			if (ability.getKeyName().equals(aKey))</span>
			{
<span class="nc" id="L7775">				return ability;</span>
			}
<span class="nc" id="L7777">		}</span>
<span class="nc bnc" id="L7778" title="All 2 branches missed.">		for (Ability ability : getAbilityList(aCategory, Nature.AUTOMATIC))</span>
		{
<span class="nc bnc" id="L7780" title="All 2 branches missed.">			if (ability.getKeyName().equals(aKey))</span>
			{
<span class="nc" id="L7782">				return ability;</span>
			}
<span class="nc" id="L7784">		}</span>
<span class="nc" id="L7785">		return null;</span>
	}

	public boolean hasAbilityKeyed(final Category&lt;Ability&gt; cat, final String aKey)
	{
<span class="nc" id="L7790">		return grantedAbilityFacet.hasAbilityKeyed(id, cat, aKey);</span>
	}

	/**
	 * Retrieve a list of all abilities held by the character in the specified
	 * category. &lt;br&gt;
	 * NB: Abilities are only returned in the category they are taken
	 * in, so if parent category is supplied only those taken directly in the
	 * parent category will be returned. e.g. If asking for feats, Power Attack
	 * taken as a fighter feat will not be returned. You would need to query
	 * fighter feats to get that. &lt;br&gt;
	 * NB: Duplicate abilities will not be returned by this method. The order
	 * of priority is normal, virtual then automatic.
	 *
	 * @param aCategory The ability category to be queried.
	 * @return The list of abilities of the category regardless of nature.
	 */
	public List&lt;Ability&gt; getAggregateAbilityListNoDuplicates(final AbilityCategory aCategory)
	{
<span class="fc" id="L7809">		final Map&lt;String, Ability&gt; aHashMap = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L7811" title="1 of 2 branches missed.">		for (Ability aFeat : getAbilityList(aCategory, Nature.NORMAL))</span>
		{
<span class="nc bnc" id="L7813" title="All 2 branches missed.">			if (aFeat != null)</span>
			{
<span class="nc" id="L7815">				aHashMap.put(aFeat.getKeyName(), aFeat);</span>
			}
<span class="nc" id="L7817">		}</span>

<span class="fc" id="L7819">		addUniqueAbilitiesToMap(aHashMap, getAbilityList(aCategory, Nature.VIRTUAL));</span>
<span class="fc" id="L7820">		addUniqueAbilitiesToMap(aHashMap, getAbilityList(aCategory, Nature.AUTOMATIC));</span>

<span class="fc" id="L7822">		return new ArrayList&lt;&gt;(aHashMap.values());</span>
	}

	/**
	 * @param aHashMap
	 * @param abilityList TODO
	 */
	private static void addUniqueAbilitiesToMap(final Map&lt;String, Ability&gt; aHashMap, Collection&lt;Ability&gt; abilityList)
	{
<span class="pc bpc" id="L7831" title="1 of 2 branches missed.">		for (Ability vFeat : abilityList)</span>
		{
<span class="nc bnc" id="L7833" title="All 2 branches missed.">			if (!aHashMap.containsKey(vFeat.getKeyName()))</span>
			{
<span class="nc" id="L7835">				aHashMap.put(vFeat.getKeyName(), vFeat);</span>
			}
<span class="nc" id="L7837">		}</span>
<span class="fc" id="L7838">	}</span>

	private void processAbilityListsOnAdd(CDOMObject cdo, CDOMReference&lt;? extends CDOMList&lt;?&gt;&gt; ref)
	{
<span class="nc bnc" id="L7842" title="All 2 branches missed.">		for (CDOMList&lt;?&gt; list : ref.getContainedObjects())</span>
		{
<span class="nc bnc" id="L7844" title="All 2 branches missed.">			if (list instanceof AbilityList)</span>
			{
<span class="nc" id="L7846">				processAbilityList(cdo, (CDOMReference) ref);</span>
<span class="nc" id="L7847">				break; // Only do once</span>
			}
<span class="nc" id="L7849">		}</span>
<span class="nc" id="L7850">	}</span>

	private void processAbilityList(CDOMObject cdo, CDOMReference&lt;AbilityList&gt; ref)
	{
<span class="nc" id="L7854">		Collection&lt;CDOMReference&lt;Ability&gt;&gt; mods = cdo.getListMods(ref);</span>
<span class="nc bnc" id="L7855" title="All 2 branches missed.">		for (CDOMReference&lt;Ability&gt; objref : mods)</span>
		{
<span class="nc" id="L7857">			Collection&lt;Ability&gt; objs = null;</span>
			try
			{
<span class="nc" id="L7860">				objs = objref.getContainedObjects();</span>
<span class="nc" id="L7861">			} catch (Exception e)</span>
			{
<span class="nc" id="L7863">				Logging.log(Logging.LST_ERROR, &quot;Missing object referenced in the ability list for '&quot; + cdo</span>
<span class="nc" id="L7864">						+ &quot;' list is &quot; + ref + &quot;. Source &quot; + cdo.getSourceURI());</span>
<span class="nc" id="L7865">				continue;</span>
<span class="nc" id="L7866">			}</span>
<span class="nc" id="L7867">			Collection&lt;AssociatedPrereqObject&gt; assoc = cdo.getListAssociations(ref, objref);</span>
<span class="nc bnc" id="L7868" title="All 2 branches missed.">			for (Ability ab : objs)</span>
			{
<span class="nc bnc" id="L7870" title="All 2 branches missed.">				if (ab == null)</span>
				{
<span class="nc" id="L7872">					Logging.log(Logging.LST_ERROR, &quot;Missing object referenced in the ability list for '&quot; + cdo</span>
<span class="nc" id="L7873">						+ &quot;' list is &quot; + ref + &quot;. Source &quot; + cdo.getSourceURI());</span>
<span class="nc" id="L7874">					continue;</span>
				}
<span class="nc bnc" id="L7876" title="All 2 branches missed.">				for (AssociatedPrereqObject apo : assoc)</span>
				{
<span class="nc" id="L7878">					Nature nature = apo.getAssociation(AssociationKey.NATURE);</span>
<span class="nc" id="L7879">					CDOMSingleRef&lt;AbilityCategory&gt; acRef = apo.getAssociation(AssociationKey.CATEGORY);</span>
<span class="nc" id="L7880">					AbilityCategory cat = acRef.get();</span>
<span class="nc bnc" id="L7881" title="All 2 branches missed.">					if (ab.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
					{
<span class="nc" id="L7883">						List&lt;String&gt; choices = apo.getAssociation(AssociationKey.ASSOC_CHOICES);</span>
<span class="nc bnc" id="L7884" title="All 2 branches missed.">						if (choices == null)</span>
						{
							//CHOOSE:NOCHOICE can be unconditionally applied (must be STACK:YES)
<span class="nc" id="L7887">							CNAbilitySelection cas =</span>
<span class="nc" id="L7888">									new CNAbilitySelection(CNAbilityFactory.getCNAbility(cat, nature, ab), &quot;&quot;);</span>
<span class="nc" id="L7889">							cas.addAllPrerequisites(apo.getPrerequisiteList());</span>
<span class="nc" id="L7890">							applyAbility(cas, cdo);</span>
<span class="nc" id="L7891">						}</span>
						else
						{
<span class="nc bnc" id="L7894" title="All 2 branches missed.">							for (final String choice : choices)</span>
							{
<span class="nc" id="L7896">								CNAbilitySelection cas =</span>
<span class="nc" id="L7897">										new CNAbilitySelection(CNAbilityFactory.getCNAbility(cat, nature, ab), choice);</span>
<span class="nc" id="L7898">								cas.addAllPrerequisites(apo.getPrerequisiteList());</span>
<span class="nc" id="L7899">								applyAbility(cas, cdo);</span>
<span class="nc" id="L7900">							}</span>
						}
<span class="nc" id="L7902">					}</span>
					else
					{
<span class="nc" id="L7905">						CNAbilitySelection cas = new CNAbilitySelection(CNAbilityFactory.getCNAbility(cat, nature, ab));</span>
<span class="nc" id="L7906">						cas.addAllPrerequisites(apo.getPrerequisiteList());</span>
<span class="nc" id="L7907">						applyAbility(cas, cdo);</span>
					}
<span class="nc" id="L7909">				}</span>
<span class="nc" id="L7910">			}</span>
<span class="nc" id="L7911">		}</span>
<span class="nc" id="L7912">		cabFacet.update(id);</span>
<span class="nc" id="L7913">	}</span>

	//WARNING: This is public only for testing, do NOT use without understanding what you are shortcutting!!
	public void applyAbility(CNAbilitySelection cas, Object source)
	{
<span class="pc bpc" id="L7918" title="1 of 2 branches missed.">		if (cas.hasPrerequisites())</span>
		{
<span class="nc" id="L7920">			conditionalFacet.add(id, cas, source);</span>
		}
		else
		{
<span class="fc" id="L7924">			directAbilityFacet.add(id, cas, source);</span>
		}
<span class="fc" id="L7926">	}</span>

	private void addTemplatesIfMissing(Collection&lt;PCTemplate&gt; templateList)
	{
		//		if (!isImporting())
		//		{
<span class="nc bnc" id="L7932" title="All 2 branches missed.">		for (PCTemplate pct : templateList)</span>
		{
<span class="nc" id="L7934">			addTemplate(pct);</span>
<span class="nc" id="L7935">		}</span>
		//		}
<span class="nc" id="L7937">	}</span>

	public boolean hasSpellInSpellbook(Spell spell, String spellbookname)
	{
<span class="nc bnc" id="L7941" title="All 2 branches missed.">		for (CDOMObject po : getCDOMObjectList())</span>
		{
<span class="nc" id="L7943">			List&lt;CharacterSpell&gt; csl = getCharacterSpells(po, spell, spellbookname, -1);</span>
<span class="nc bnc" id="L7944" title="All 2 branches missed.">			if (!csl.isEmpty())</span>
			{
<span class="nc" id="L7946">				return true;</span>
			}
<span class="nc" id="L7948">		}</span>
<span class="nc" id="L7949">		return false;</span>
	}

	public Collection&lt;PCTemplate&gt; getTemplatesAdded(CDOMObject po)
	{
<span class="nc" id="L7954">		return addedTemplateFacet.getFromSource(id, po);</span>
	}

	public void setTemplatesAdded(CDOMObject po, PCTemplate pct)
	{
<span class="nc" id="L7959">		addedTemplateFacet.add(id, pct, po);</span>
<span class="nc" id="L7960">	}</span>

	public boolean isClassSkill(Skill sk)
	{
<span class="nc bnc" id="L7964" title="All 2 branches missed.">		for (PCClass cl : getClassSet())</span>
		{
<span class="nc bnc" id="L7966" title="All 2 branches missed.">			if (isClassSkill(cl, sk))</span>
			{
<span class="nc" id="L7968">				return true;</span>
			}
<span class="nc" id="L7970">		}</span>
<span class="nc" id="L7971">		return false;</span>
	}

	private boolean isCrossClassSkill(Skill sk, PCClass pcc)
	{
<span class="nc" id="L7976">		PCClass cl = getClassKeyed(pcc.getKeyName());</span>
<span class="nc bnc" id="L7977" title="All 2 branches missed.">		if (cl == null)</span>
		{
<span class="nc" id="L7979">			return false;</span>
		}
<span class="nc" id="L7981">		return skillCostFacet.isCrossClassSkill(id, pcc, sk);</span>
	}

	private boolean isCrossClassSkill(Skill sk)
	{
<span class="nc bnc" id="L7986" title="All 2 branches missed.">		for (PCClass cl : getClassSet())</span>
		{
<span class="nc bnc" id="L7988" title="All 2 branches missed.">			if (isCrossClassSkill(sk, cl))</span>
			{
<span class="nc" id="L7990">				return true;</span>
			}
<span class="nc" id="L7992">		}</span>
<span class="nc" id="L7993">		return false;</span>
	}

	public SkillCost getSkillCostForClass(Skill sk, PCClass cl)
	{
		/*
		 * Unfortunately class can be null if skill awarded by a master
		 */
<span class="nc bnc" id="L8001" title="All 2 branches missed.">		if (cl == null)</span>
		{
<span class="nc bnc" id="L8003" title="All 2 branches missed.">			return sk.getSafe(ObjectKey.EXCLUSIVE) ? SkillCost.EXCLUSIVE : SkillCost.CROSS_CLASS;</span>
		}
<span class="nc" id="L8005">		cl = getClassKeyed(cl.getKeyName());</span>
<span class="nc bnc" id="L8006" title="All 2 branches missed.">		if (cl == null)</span>
		{
<span class="nc bnc" id="L8008" title="All 2 branches missed.">			return sk.getSafe(ObjectKey.EXCLUSIVE) ? SkillCost.EXCLUSIVE : SkillCost.CROSS_CLASS;</span>
		}
<span class="nc" id="L8010">		return skillCostFacet.skillCostForPCClass(id, sk, cl);</span>
	}

	public int getSelectCorrectedAssociationCount(ChooseDriver obj)
	{
<span class="nc" id="L8015">		return getDetailedAssociationCount(obj) / obj.getSelectFormula().resolve(this, &quot;&quot;).intValue();</span>
	}

	public List&lt;String&gt; getAssociationList(ChooseDriver obj)
	{
<span class="nc" id="L8020">		ChooseInformation&lt;?&gt; info = obj.getChooseInfo();</span>
<span class="nc bnc" id="L8021" title="All 2 branches missed.">		if (info == null)</span>
		{
<span class="nc" id="L8023">			return Collections.emptyList();</span>
		}
<span class="nc" id="L8025">		return getExpandedAssociations(obj, info);</span>
	}

	/**
	 * Return a list of the choice assications in an export compatible string
	 * format. Note that this is not sufficient for the choice to be
	 * reconstructed, so this format should never be saved, only output.
	 *
	 * @param obj The choice to be output.
	 * @return The list of choices.
	 */
	public List&lt;String&gt; getAssociationExportList(ChooseDriver obj)
	{
<span class="nc" id="L8038">		ChooseInformation&lt;?&gt; info = obj.getChooseInfo();</span>
<span class="nc bnc" id="L8039" title="All 2 branches missed.">		if (info == null)</span>
		{
<span class="nc" id="L8041">			return Collections.emptyList();</span>
		}
<span class="nc" id="L8043">		return getExportAssociations(obj, info);</span>
	}

	public boolean hasAssociations(ChooseDriver obj)
	{
<span class="nc" id="L8048">		ChooseInformation&lt;?&gt; info = obj.getChooseInfo();</span>
<span class="nc bnc" id="L8049" title="All 2 branches missed.">		if (info == null)</span>
		{
<span class="nc" id="L8051">			return false;</span>
		}
<span class="nc" id="L8053">		List&lt;?&gt; selections = info.getChoiceActor().getCurrentlySelected(obj, this);</span>
<span class="nc bnc" id="L8054" title="All 4 branches missed.">		return (selections != null) &amp;&amp; !selections.isEmpty();</span>
	}

	public int getDetailedAssociationCount(ChooseDriver obj)
	{
<span class="nc" id="L8059">		ChooseInformation&lt;?&gt; info = obj.getChooseInfo();</span>
<span class="nc bnc" id="L8060" title="All 2 branches missed.">		if (info == null)</span>
		{
<span class="nc" id="L8062">			return 0;</span>
		}
<span class="nc" id="L8064">		List&lt;?&gt; selections = info.getChoiceActor().getCurrentlySelected(obj, this);</span>
<span class="nc bnc" id="L8065" title="All 4 branches missed.">		if ((selections == null) || selections.isEmpty())</span>
		{
<span class="nc" id="L8067">			return 0;</span>
		}
<span class="nc" id="L8069">		return selections.size();</span>
	}

	private &lt;T&gt; List&lt;String&gt; getExpandedAssociations(ChooseDriver obj, ChooseInformation&lt;T&gt; info)
	{
<span class="nc" id="L8074">		List&lt;? extends T&gt; selections = info.getChoiceActor().getCurrentlySelected(obj, this);</span>
<span class="nc bnc" id="L8075" title="All 4 branches missed.">		if ((selections == null) || selections.isEmpty())</span>
		{
<span class="nc" id="L8077">			return Collections.emptyList();</span>
		}
<span class="nc" id="L8079">		List&lt;String&gt; ret = new ArrayList&lt;&gt;(selections.size());</span>
<span class="nc bnc" id="L8080" title="All 2 branches missed.">		for (T sel : selections)</span>
		{
<span class="nc" id="L8082">			ret.add(info.encodeChoice(sel));</span>
<span class="nc" id="L8083">		}</span>
<span class="nc" id="L8084">		return ret;</span>
	}

	private &lt;T&gt; List&lt;String&gt; getExportAssociations(ChooseDriver obj, ChooseInformation&lt;T&gt; info)
	{
<span class="nc" id="L8089">		List&lt;? extends T&gt; selections = info.getChoiceActor().getCurrentlySelected(obj, this);</span>
<span class="nc bnc" id="L8090" title="All 4 branches missed.">		if ((selections == null) || selections.isEmpty())</span>
		{
<span class="nc" id="L8092">			return Collections.emptyList();</span>
		}
<span class="nc" id="L8094">		List&lt;String&gt; ret = new ArrayList&lt;&gt;(selections.size());</span>
<span class="nc bnc" id="L8095" title="All 2 branches missed.">		for (T sel : selections)</span>
		{
<span class="nc" id="L8097">			ret.add(String.valueOf(sel));</span>
<span class="nc" id="L8098">		}</span>
<span class="nc" id="L8099">		return ret;</span>
	}

	public &lt;T&gt; void addAssoc(Object obj, AssociationListKey&lt;T&gt; ak, T o)
	{
<span class="fc" id="L8104">		assocSupt.addAssoc(obj, ak, o);</span>
<span class="fc" id="L8105">	}</span>

	public int getAssocCount(Object obj, AssociationListKey&lt;?&gt; ak)
	{
<span class="nc" id="L8109">		return assocSupt.getAssocCount(obj, ak);</span>
	}

	public &lt;T&gt; List&lt;T&gt; getAssocList(Object obj, AssociationListKey&lt;T&gt; ak)
	{
<span class="fc" id="L8114">		return assocSupt.getAssocList(obj, ak);</span>
	}

	public &lt;T&gt; List&lt;T&gt; removeAllAssocs(Object obj, AssociationListKey&lt;T&gt; ak)
	{
<span class="nc" id="L8119">		return assocSupt.removeAllAssocs(obj, ak);</span>
	}

	public &lt;T&gt; void removeAssoc(Object obj, AssociationListKey&lt;T&gt; ak, T o)
	{
<span class="nc" id="L8124">		assocSupt.removeAssoc(obj, ak, o);</span>
<span class="nc" id="L8125">	}</span>

	public &lt;T&gt; T getAssoc(Object obj, AssociationKey&lt;T&gt; ak)
	{
<span class="nc" id="L8129">		return assocSupt.getAssoc(obj, ak);</span>
	}

	public boolean hasAssocs(Object obj, AssociationKey&lt;?&gt; ak)
	{
<span class="nc" id="L8134">		return assocSupt.hasAssocs(obj, ak);</span>
	}

	public &lt;T&gt; void removeAssoc(Object obj, AssociationKey&lt;T&gt; ak)
	{
<span class="nc" id="L8139">		assocSupt.removeAssoc(obj, ak);</span>
<span class="nc" id="L8140">	}</span>

	public &lt;T&gt; void setAssoc(Object obj, AssociationKey&lt;T&gt; ak, T o)
	{
<span class="nc" id="L8144">		assocSupt.setAssoc(obj, ak, o);</span>
<span class="nc" id="L8145">	}</span>

	public boolean hasNonStatStat(PCStat stat)
	{
		// Check for a non stat, but only if it hasn't been reset to a stat
<span class="nc bnc" id="L8150" title="All 2 branches missed.">		if (!nonStatToStatFacet.contains(id, stat))</span>
		{
<span class="nc" id="L8152">            return nonStatStatFacet.contains(id, stat);</span>
		}
<span class="nc" id="L8154">		return false;</span>
	}

	public boolean hasUnlockedStat(PCStat stat)
	{
<span class="nc" id="L8159">		return unlockedStatFacet.contains(id, stat);</span>
	}

	public Number getLockedStat(PCStat stat)
	{
<span class="nc" id="L8164">		return statLockFacet.getLockedStat(id, stat);</span>
	}

	public String getDescription(PObject pobj)
	{
<span class="nc" id="L8169">		return getDescription(Collections.singletonList(pobj));</span>
	}

	public String getDescription(List&lt;? extends Object&gt; objList)
	{
<span class="nc bnc" id="L8174" title="All 2 branches missed.">		if (objList.isEmpty())</span>
		{
<span class="nc" id="L8176">			return Constants.EMPTY_STRING;</span>
		}
		PObject cdo;
<span class="nc" id="L8179">		Object b = objList.get(0);</span>
<span class="nc bnc" id="L8180" title="All 2 branches missed.">		if (b instanceof PObject)</span>
		{
<span class="nc" id="L8182">			cdo = (PObject) b;</span>
<span class="nc" id="L8183">			String dString = getInfoToken(&quot;.INFO.DESC&quot;, cdo);</span>
<span class="nc bnc" id="L8184" title="All 2 branches missed.">			if (!dString.equals(&quot;.INFO.DESC&quot;))</span>
<span class="nc" id="L8185">				return dString;</span>
<span class="nc" id="L8186">		}</span>
<span class="nc bnc" id="L8187" title="All 2 branches missed.">		else if (b instanceof CNAbility)</span>
		{
<span class="nc" id="L8189">			cdo = ((CNAbility) b).getAbility();</span>
		}
		else
		{
<span class="nc" id="L8193">			Logging.errorPrint(&quot;Unable to resolve Description with object of type: &quot; + b.getClass().getName());</span>
<span class="nc" id="L8194">			return Constants.EMPTY_STRING;</span>
		}

<span class="nc" id="L8197">		List&lt;Description&gt; theDescriptions = cdo.getListFor(cdo.getDescriptionKey());</span>
<span class="nc bnc" id="L8198" title="All 2 branches missed.">		if (theDescriptions == null)</span>
		{
<span class="nc" id="L8200">			return Constants.EMPTY_STRING;</span>
		}
<span class="nc" id="L8202">		final StringBuilder sb = new StringBuilder(250);</span>
<span class="nc" id="L8203">		boolean needSpace = false;</span>
<span class="nc bnc" id="L8204" title="All 2 branches missed.">		for (final Description desc : theDescriptions)</span>
		{
<span class="nc" id="L8206">			final String str = desc.getDescription(this, objList);</span>
<span class="nc bnc" id="L8207" title="All 2 branches missed.">			if (!str.isEmpty())</span>
			{
<span class="nc bnc" id="L8209" title="All 2 branches missed.">				if (needSpace)</span>
				{
<span class="nc" id="L8211">					sb.append(' ');</span>
				}
<span class="nc" id="L8213">				sb.append(str);</span>
<span class="nc" id="L8214">				needSpace = true;</span>
			}
<span class="nc" id="L8216">		}</span>
<span class="nc" id="L8217">		return sb.toString();</span>
	}

	public String getInfoToken(String token, PObject po) {
		// looking for a token in the form of RACE.INFO.TAG where
		// RACE indicate which token map to check for a INFO label of TAG to return
<span class="nc" id="L8223">		int i = token.indexOf(&quot;.INFO.&quot;);</span>
<span class="nc" id="L8224">		String ts = token;</span>
<span class="nc bnc" id="L8225" title="All 2 branches missed.">		if (i&gt;-1)</span>
<span class="nc" id="L8226">			ts = token.substring(i+6).toUpperCase();</span>
		else
<span class="nc" id="L8228">			return token;</span>
<span class="nc" id="L8229">		Set&lt;MapKey&lt;?, ?&gt;&gt; keys = po.getMapKeys();</span>
<span class="nc bnc" id="L8230" title="All 2 branches missed.">		for (MapKey&lt;?, ?&gt; key : keys) {</span>
<span class="nc" id="L8231">			Map&lt;?, ?&gt; key2 = po.getMapFor(key);</span>
<span class="nc bnc" id="L8232" title="All 2 branches missed.">			for(Object k : key2.keySet()) {</span>
<span class="nc bnc" id="L8233" title="All 2 branches missed.">				if (k.toString().equals(ts)) {</span>
<span class="nc" id="L8234">					MessageFormat m = (MessageFormat) key2.get(k);</span>
<span class="nc" id="L8235">					return m.toPattern();</span>
				}
<span class="nc" id="L8237">			}</span>
<span class="nc" id="L8238">		}</span>
<span class="nc" id="L8239">		return token;</span>
	}


	/**
	 * This method gets the information about the levels at which classes and
	 * domains may cast the spell.
	 *
	 * @param sp The spell to get the info for.
	 *
	 * @return Map containing the class levels and domains that may cast the
	 *         spell
	 */
	public HashMapToList&lt;CDOMList&lt;Spell&gt;, Integer&gt; getSpellLevelInfo(Spell sp)
	{
<span class="nc" id="L8254">		HashMapToList&lt;CDOMList&lt;Spell&gt;, Integer&gt; hml = cache.get(MapKey.SPELL_PC_INFO, sp);</span>
<span class="nc bnc" id="L8255" title="All 2 branches missed.">		if (hml == null)</span>
		{
<span class="nc" id="L8257">			hml = availSpellFacet.getSpellLevelInfo(id, sp);</span>
<span class="nc" id="L8258">			cache.addToMapFor(MapKey.SPELL_PC_INFO, sp, hml);</span>
		}
<span class="nc" id="L8260">		HashMapToList&lt;CDOMList&lt;Spell&gt;, Integer&gt; newhml = new HashMapToList&lt;&gt;();</span>
<span class="nc" id="L8261">		newhml.addAllLists(hml);</span>
<span class="nc" id="L8262">		return newhml;</span>
	}

	/**
	 * Retrieve the character's existing version of this spell, if any.
	 * @param po The source of the spell list for this spell (normally a PCClass)
	 * @param spell The spell to be retrieved
	 * @param owner The source of the spell (either the PCClass or the Domian)
	 * @return The character's existing instance of the spell, or null if none.
	 */
	public CharacterSpell getCharacterSpellForSpell(PObject po, Spell spell, PObject owner)
	{
<span class="nc" id="L8274">		List&lt;CharacterSpell&gt; cspells = new ArrayList&lt;&gt;(getCharacterSpells(po));</span>
		// Add in the spells granted by objects
<span class="nc" id="L8276">		addBonusKnownSpellsToList(po, cspells);</span>

<span class="nc bnc" id="L8278" title="All 2 branches missed.">		for (CharacterSpell cs : cspells)</span>
		{
<span class="nc" id="L8280">			Spell sp = cs.getSpell();</span>
<span class="nc bnc" id="L8281" title="All 4 branches missed.">			if (spell.equals(sp) &amp;&amp; (cs.getOwner().equals(owner)))</span>
			{
<span class="nc" id="L8283">				return cs;</span>
			}
<span class="nc" id="L8285">		}</span>
<span class="nc" id="L8286">		return null;</span>
	}

	/**
	 * Get a list of CharacterSpells from the character spell list.
	 * @param spellSource
	 * @param aSpell
	 * @param book
	 * @param level
	 * @return list of CharacterSpells from the character spell list
	 */
	public final List&lt;CharacterSpell&gt; getCharacterSpells(CDOMObject spellSource, final Spell aSpell, final String book,
		final int level)
	{
<span class="nc" id="L8300">		List&lt;CharacterSpell&gt; csList = new ArrayList&lt;&gt;(getCharacterSpells(spellSource));</span>
		// Add in the spells granted by objects
<span class="nc" id="L8302">		addBonusKnownSpellsToList(spellSource, csList);</span>
<span class="nc" id="L8303">		final List&lt;CharacterSpell&gt; aList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L8304" title="All 2 branches missed.">		if (csList.isEmpty())</span>
		{
<span class="nc" id="L8306">			return aList;</span>
		}

<span class="nc bnc" id="L8309" title="All 2 branches missed.">		for (CharacterSpell cs : csList)</span>
		{
<span class="nc bnc" id="L8311" title="All 4 branches missed.">			if ((aSpell == null) || cs.getSpell().equals(aSpell))</span>
			{
<span class="nc" id="L8313">				final SpellInfo si = cs.getSpellInfoFor(book, level, null);</span>

<span class="nc bnc" id="L8315" title="All 2 branches missed.">				if (si != null)</span>
				{
<span class="nc" id="L8317">					aList.add(cs);</span>
				}
			}
<span class="nc" id="L8320">		}</span>

<span class="nc" id="L8322">		return aList;</span>
	}

	/**
	 * Returns DC for a spell and SpellInfo.
	 * @param sp the spell
	 * @param cs TODO
	 * @param si the spell info
	 * @return DC for a spell and SpellInfo
	 */
	public int getDC(final Spell sp, CharacterSpell cs, final SpellInfo si)
	{
		CDOMObject ow;
		int spellLevel;
<span class="nc" id="L8336">		int metaDC = 0;</span>

<span class="nc" id="L8338">		spellLevel = si.getActualLevel();</span>
<span class="nc" id="L8339">		ow = cs.getOwner();</span>

<span class="nc" id="L8341">		String fixedDC = si.getFixedDC();</span>
		// TODO Temp fix for 1223858, better fix would be to move fixedDC to
		// spellInfo
		/*
		 * TODO Need to evaluate how duplicative this logic is and what is
		 * really necessary
		 */
<span class="nc bnc" id="L8348" title="All 4 branches missed.">		if (fixedDC != null &amp;&amp; &quot;INNATE&quot;.equalsIgnoreCase(si.getBook()))</span>
		{
<span class="nc" id="L8350">			return getVariableValue(fixedDC, &quot;&quot;).intValue();</span>
		}

		// Check for a non class based fixed DC
<span class="nc bnc" id="L8354" title="All 6 branches missed.">		if (fixedDC != null &amp;&amp; ow != null &amp;&amp; !(ow instanceof PCClass))</span>
		{
<span class="nc" id="L8356">			return getVariableValue(fixedDC, &quot;&quot;).intValue();</span>
		}

<span class="nc bnc" id="L8359" title="All 2 branches missed.">		if (si.getFeatList() != null)</span>
		{
<span class="nc bnc" id="L8361" title="All 2 branches missed.">			for (Ability metaFeat : si.getFeatList())</span>
			{
<span class="nc" id="L8363">				spellLevel -= metaFeat.getSafe(IntegerKey.ADD_SPELL_LEVEL);</span>
<span class="nc" id="L8364">				metaDC = (int) (metaDC + BonusCalc.charBonusTo(metaFeat, &quot;DC&quot;, &quot;FEATBONUS&quot;, this));</span>
<span class="nc" id="L8365">			}</span>
		}

<span class="nc" id="L8368">		return getDC(sp, null, spellLevel, metaDC, ow);</span>
	}

	public int getDC(final Spell sp, PCClass aClass, int spellLevel, int metaDC, CDOMObject ow)
	{
<span class="nc" id="L8373">		String bonDomain = &quot;&quot;;</span>
<span class="nc bnc" id="L8374" title="All 2 branches missed.">		if (ow instanceof Domain)</span>
		{
<span class="nc" id="L8376">			bonDomain = &quot;DOMAIN.&quot; + ow.getKeyName();</span>

<span class="nc" id="L8378">			ClassSource source = getDomainSource((Domain) ow);</span>
<span class="nc bnc" id="L8379" title="All 2 branches missed.">			if (source != null)</span>
			{
<span class="nc" id="L8381">				aClass = getClassKeyed(source.getPcclass().getKeyName());</span>
			}
		}

<span class="nc" id="L8385">		boolean useStatFromSpell = false;</span>
<span class="nc" id="L8386">		String bonClass = &quot;&quot;;</span>
<span class="nc" id="L8387">		String spellType = &quot;&quot;;</span>
<span class="nc" id="L8388">		String classKey = &quot;&quot;;</span>

<span class="nc bnc" id="L8390" title="All 4 branches missed.">		if ((aClass != null) || (ow instanceof PCClass))</span>
		{
<span class="nc bnc" id="L8392" title="All 4 branches missed.">			if ((aClass == null) || (ow instanceof PCClass))</span>
			{
<span class="nc" id="L8394">				aClass = (PCClass) ow;</span>
			}

<span class="nc" id="L8397">			bonClass = &quot;CLASS.&quot; + aClass.getKeyName();</span>
<span class="nc" id="L8398">			classKey = &quot;CLASS:&quot; + aClass.getKeyName();</span>
<span class="nc" id="L8399">			spellType = aClass.getSpellType();</span>
<span class="nc" id="L8400">			useStatFromSpell = aClass.getSafe(ObjectKey.USE_SPELL_SPELL_STAT);</span>
		}

<span class="nc bnc" id="L8403" title="All 4 branches missed.">		if (!(ow instanceof PCClass) &amp;&amp; !(ow instanceof Domain))</span>
		{
			// get BASESPELLSTAT from spell itself
<span class="nc" id="L8406">			useStatFromSpell = true;</span>
		}

		// set the spell Level used in aPC.getVariableValue()
		// Explicitly should *not* set the dirty flag to true.
<span class="nc" id="L8411">		spellLevelTemp = spellLevel;</span>

		// must be done after spellLevel is set above
<span class="nc" id="L8414">		int dc = getVariableValue(SettingsHandler.getGameAsProperty().get().getSpellBaseDC(), classKey).intValue() + metaDC;</span>
<span class="nc" id="L8415">		dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;ALLSPELLS&quot;);</span>

<span class="nc bnc" id="L8417" title="All 2 branches missed.">		if (useStatFromSpell)</span>
		{
			// get the BASESPELLSTAT from the spell itself
<span class="nc" id="L8420">			CDOMSingleRef&lt;PCStat&gt; stat = sp.get(ObjectKey.SPELL_STAT);</span>
<span class="nc bnc" id="L8421" title="All 2 branches missed.">			if (stat != null)</span>
			{
<span class="nc" id="L8423">				dc += this.getStatModFor(stat.get());</span>
			}
		}

<span class="nc bnc" id="L8427" title="All 2 branches missed.">		if (!sp.getKeyName().isEmpty())</span>
		{
<span class="nc" id="L8429">			dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;SPELL.&quot; + sp.getKeyName());</span>
		}

		// DOMAIN.name
<span class="nc bnc" id="L8433" title="All 2 branches missed.">		if (!bonDomain.isEmpty())</span>
		{
<span class="nc" id="L8435">			dc += (int) getTotalBonusTo(&quot;DC&quot;, bonDomain);</span>
		}

		// CLASS.name
<span class="nc bnc" id="L8439" title="All 2 branches missed.">		if (!bonClass.isEmpty())</span>
		{
<span class="nc" id="L8441">			dc += (int) getTotalBonusTo(&quot;DC&quot;, bonClass);</span>
		}

<span class="nc" id="L8444">		dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;TYPE.&quot; + spellType);</span>

<span class="nc bnc" id="L8446" title="All 2 branches missed.">		if (spellType.equals(&quot;ALL&quot;))</span>
		{
<span class="nc bnc" id="L8448" title="All 2 branches missed.">			for (Type aType : sp.getTrueTypeList(false))</span>
			{
<span class="nc" id="L8450">				dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;TYPE.&quot; + aType);</span>
<span class="nc" id="L8451">			}</span>
		}

<span class="nc bnc" id="L8454" title="All 2 branches missed.">		for (SpellSchool aType : sp.getSafeListFor(ListKey.SPELL_SCHOOL))</span>
		{
<span class="nc" id="L8456">			dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;SCHOOL.&quot; + aType);</span>
<span class="nc" id="L8457">		}</span>

<span class="nc bnc" id="L8459" title="All 2 branches missed.">		for (String aType : sp.getSafeListFor(ListKey.SPELL_SUBSCHOOL))</span>
		{
<span class="nc" id="L8461">			dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;SUBSCHOOL.&quot; + aType);</span>
<span class="nc" id="L8462">		}</span>

<span class="nc bnc" id="L8464" title="All 2 branches missed.">		for (String aType : sp.getSafeListFor(ListKey.SPELL_DESCRIPTOR))</span>
		{
<span class="nc" id="L8466">			dc += (int) getTotalBonusTo(&quot;DC&quot;, &quot;DESCRIPTOR.&quot; + aType);</span>
<span class="nc" id="L8467">		}</span>

		// Explicitly should *not* set the dirty flag to true.
<span class="nc" id="L8470">		spellLevelTemp = 0;</span>

<span class="nc" id="L8472">		return dc;</span>
	}

	/**
	 * Returns concentration bonus for a spell and SpellInfo.
	 * @param sp the spell
	 * @param cs TODO
	 * @param si the spell info
	 * @return concentration bonus for a spell and SpellInfo
	 */
	public int getConcentration(final Spell sp, CharacterSpell cs, final SpellInfo si)
	{
		CDOMObject ow;
		int spellLevel;
<span class="nc" id="L8486">		int metaConcentration = 0;</span>

<span class="nc" id="L8488">		spellLevel = si.getActualLevel();</span>
<span class="nc" id="L8489">		ow = cs.getOwner();</span>

<span class="nc bnc" id="L8491" title="All 2 branches missed.">		if (si.getFeatList() != null)</span>
		{
<span class="nc bnc" id="L8493" title="All 2 branches missed.">			for (Ability metaFeat : si.getFeatList())</span>
			{
<span class="nc" id="L8495">				spellLevel -= metaFeat.getSafe(IntegerKey.ADD_SPELL_LEVEL);</span>
<span class="nc" id="L8496">				metaConcentration =</span>
<span class="nc" id="L8497">						(int) (metaConcentration + BonusCalc.charBonusTo(metaFeat, &quot;CONCENTRATION&quot;, &quot;FEATBONUS&quot;, this));</span>
<span class="nc" id="L8498">			}</span>
		}

<span class="nc" id="L8501">		return getConcentration(sp, cs, null, spellLevel, metaConcentration, ow);</span>
	}

	public int getConcentration(final Spell sp, final CharacterSpell aSpell, PCClass aClass, int spellLevel,
		int metaConcentration, CDOMObject ow)
	{
<span class="nc" id="L8507">		String bonDomain = &quot;&quot;;</span>
<span class="nc bnc" id="L8508" title="All 2 branches missed.">		if (ow instanceof Domain)</span>
		{
<span class="nc" id="L8510">			bonDomain = &quot;DOMAIN.&quot; + ow.getKeyName();</span>

<span class="nc" id="L8512">			ClassSource source = getDomainSource((Domain) ow);</span>
<span class="nc bnc" id="L8513" title="All 2 branches missed.">			if (source != null)</span>
			{
<span class="nc" id="L8515">				aClass = getClassKeyed(source.getPcclass().getKeyName());</span>
			}
		}

<span class="nc" id="L8519">		boolean useStatFromSpell = false;</span>
<span class="nc" id="L8520">		String bonClass = &quot;&quot;;</span>
<span class="nc" id="L8521">		String spellType = &quot;&quot;;</span>
<span class="nc" id="L8522">		String classKey = &quot;&quot;;</span>

<span class="nc bnc" id="L8524" title="All 4 branches missed.">		if ((aClass != null) || (ow instanceof PCClass))</span>
		{
<span class="nc bnc" id="L8526" title="All 4 branches missed.">			if ((aClass == null) || (ow instanceof PCClass))</span>
			{
<span class="nc" id="L8528">				aClass = (PCClass) ow;</span>
			}

<span class="nc" id="L8531">			bonClass = &quot;CLASS.&quot; + aClass.getKeyName();</span>
<span class="nc" id="L8532">			classKey = &quot;CLASS:&quot; + aClass.getKeyName();</span>
<span class="nc" id="L8533">			spellType = aClass.getSpellType();</span>
<span class="nc" id="L8534">			useStatFromSpell = aClass.getSafe(ObjectKey.USE_SPELL_SPELL_STAT);</span>
		}

<span class="nc bnc" id="L8537" title="All 4 branches missed.">		if (!(ow instanceof PCClass) &amp;&amp; !(ow instanceof Domain))</span>
		{
			// get BASESPELLSTAT from spell itself
<span class="nc" id="L8540">			useStatFromSpell = true;</span>
		}

		// set the spell Level used in aPC.getVariableValue()
		// Explicitly should *not* set the dirty flag to true.
<span class="nc" id="L8545">		spellLevelTemp = spellLevel;</span>

		// must be done after spellLevel is set above
<span class="nc" id="L8548">		int concentration =</span>
<span class="nc" id="L8549">				getVariableValue(aSpell, SettingsHandler.getGameAsProperty().get().getSpellBaseConcentration(), classKey).intValue()</span>
					+ metaConcentration;
<span class="nc" id="L8551">		concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;ALLSPELLS&quot;);</span>

<span class="nc bnc" id="L8553" title="All 2 branches missed.">		if (useStatFromSpell)</span>
		{
			// get the BASESPELLSTAT from the spell itself
<span class="nc" id="L8556">			CDOMSingleRef&lt;PCStat&gt; stat = sp.get(ObjectKey.SPELL_STAT);</span>
<span class="nc bnc" id="L8557" title="All 2 branches missed.">			if (stat != null)</span>
			{
<span class="nc" id="L8559">				concentration += this.getStatModFor(stat.get());</span>
			}
		}

<span class="nc bnc" id="L8563" title="All 2 branches missed.">		if (!sp.getKeyName().isEmpty())</span>
		{
<span class="nc" id="L8565">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;SPELL.&quot; + sp.getKeyName());</span>
		}

		// DOMAIN.name
<span class="nc bnc" id="L8569" title="All 2 branches missed.">		if (!bonDomain.isEmpty())</span>
		{
<span class="nc" id="L8571">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, bonDomain);</span>
		}

		// CLASS.name
<span class="nc bnc" id="L8575" title="All 2 branches missed.">		if (!bonClass.isEmpty())</span>
		{
<span class="nc" id="L8577">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, bonClass);</span>
		}

<span class="nc" id="L8580">		concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;TYPE.&quot; + spellType);</span>

<span class="nc bnc" id="L8582" title="All 2 branches missed.">		if (spellType.equals(&quot;ALL&quot;))</span>
		{
<span class="nc bnc" id="L8584" title="All 2 branches missed.">			for (Type aType : sp.getTrueTypeList(false))</span>
			{
<span class="nc" id="L8586">				concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;TYPE.&quot; + aType);</span>
<span class="nc" id="L8587">			}</span>
		}

<span class="nc bnc" id="L8590" title="All 2 branches missed.">		for (SpellSchool aType : sp.getSafeListFor(ListKey.SPELL_SCHOOL))</span>
		{
<span class="nc" id="L8592">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;SCHOOL.&quot; + aType);</span>
<span class="nc" id="L8593">		}</span>

<span class="nc bnc" id="L8595" title="All 2 branches missed.">		for (String aType : sp.getSafeListFor(ListKey.SPELL_SUBSCHOOL))</span>
		{
<span class="nc" id="L8597">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;SUBSCHOOL.&quot; + aType);</span>
<span class="nc" id="L8598">		}</span>

<span class="nc bnc" id="L8600" title="All 2 branches missed.">		for (String aType : sp.getSafeListFor(ListKey.SPELL_DESCRIPTOR))</span>
		{
<span class="nc" id="L8602">			concentration += (int) getTotalBonusTo(&quot;CONCENTRATION&quot;, &quot;DESCRIPTOR.&quot; + aType);</span>
<span class="nc" id="L8603">		}</span>

		// Explicitly should *not* set the dirty flag to true.
<span class="nc" id="L8606">		spellLevelTemp = 0;</span>

<span class="nc" id="L8608">		return concentration;</span>
	}

	public boolean hasSkill(Skill skill)
	{
<span class="nc" id="L8613">		return skillFacet.contains(id, skill);</span>
	}

	public boolean hasTemplate(PCTemplate template)
	{
<span class="fc" id="L8618">		return templateFacet.contains(id, template);</span>
	}

	public Collection&lt;PCStat&gt; getStatSet()
	{
<span class="nc" id="L8623">		return statFacet.getSet(id);</span>
	}

	public boolean hasDefaultDomainSource()
	{
<span class="nc bnc" id="L8628" title="All 2 branches missed.">		return defaultDomainSource != null;</span>
	}

	public void setDefaultDomainSource(ClassSource cs)
	{
<span class="fc" id="L8633">		defaultDomainSource = cs;</span>
<span class="fc" id="L8634">	}</span>

	public boolean addDomain(Domain domain)
	{
<span class="fc" id="L8638">		return addDomain(domain, defaultDomainSource);</span>
	}

	public boolean addDomain(Domain domain, ClassSource source)
	{
<span class="fc" id="L8643">		boolean added = domainInputFacet.add(id, domain, source);</span>
<span class="pc bpc" id="L8644" title="1 of 2 branches missed.">		if (added)</span>
		{
<span class="fc" id="L8646">			setDirty(true);</span>
		}
<span class="fc" id="L8648">		return added;</span>
	}

	public boolean hasDomain(Domain domain)
	{
<span class="nc" id="L8653">		return domainFacet.contains(id, domain);</span>
	}

	public void removeDomain(Domain domain)
	{
<span class="nc" id="L8658">		domainInputFacet.remove(id, domain);</span>
<span class="nc" id="L8659">		setDirty(true);</span>
<span class="nc" id="L8660">	}</span>

	public boolean hasDomains()
	{
<span class="nc bnc" id="L8664" title="All 2 branches missed.">		return !domainFacet.isEmpty(id);</span>
	}

	public int getDomainCount()
	{
<span class="nc" id="L8669">		return domainFacet.getCount(id);</span>
	}

	public Set&lt;Domain&gt; getDomainSet()
	{
<span class="nc" id="L8674">		return domainFacet.getSet(id);</span>
	}

	public ClassSource getDomainSource(Domain d)
	{
<span class="fc" id="L8679">		return domainFacet.getSource(id, d);</span>
	}

	public Map&lt;String, String&gt; getBonusStrings(String bonusString, String substring)
	{
<span class="nc" id="L8684">		return bonusManager.getBonuses(bonusString, substring);</span>
	}

	public boolean isApplied(BonusObj bonus)
	{
<span class="nc" id="L8689">		return appliedBonusFacet.contains(id, bonus);</span>
	}

	public SpellSupportForPCClass getSpellSupport(PCClass cl)
	{
<span class="nc" id="L8694">		SpellSupportForPCClass ss = spellSupportFacet.get(id, cl);</span>
<span class="nc bnc" id="L8695" title="All 2 branches missed.">		if (ss == null)</span>
		{
<span class="nc" id="L8697">			ss = new SpellSupportForPCClass(cl);</span>
<span class="nc" id="L8698">			spellSupportFacet.set(id, cl, ss);</span>
		}
<span class="nc" id="L8700">		return ss;</span>
	}

	public Map&lt;BonusObj, BonusManager.TempBonusInfo&gt; getTempBonusMap(String sourceStr, String targetStr)
	{
<span class="nc" id="L8705">		return bonusManager.getTempBonusMap(sourceStr, targetStr);</span>
	}

	public String getBonusContext(BonusObj bonus, boolean shortForm)
	{
<span class="nc" id="L8710">		return bonusManager.getBonusContext(bonus, shortForm);</span>
	}

	public List&lt;BonusPair&gt; getStringListFromBonus(BonusObj bonus)
	{
<span class="nc" id="L8715">		return bonusManager.getStringListFromBonus(bonus);</span>
	}

	public void setApplied(BonusObj bonusObj, boolean bool)
	{
<span class="nc bnc" id="L8720" title="All 2 branches missed.">		if (bool)</span>
		{
<span class="nc" id="L8722">			appliedBonusFacet.add(id, bonusObj);</span>
		}
		else
		{
<span class="nc" id="L8726">			appliedBonusFacet.remove(id, bonusObj);</span>
		}
<span class="nc" id="L8728">	}</span>

	public void setSubstitutionLevel(PCClass pcc, PCClassLevel originalClassLevel)
	{
		try
		{
<span class="nc" id="L8734">			PCClassLevel clvl = originalClassLevel.clone();</span>
<span class="nc" id="L8735">			clvl.put(StringKey.QUALIFIED_KEY, pcc.getQualifiedKey());</span>
<span class="nc" id="L8736">			classFacet.setClassLevel(id, pcc, clvl);</span>
		}
<span class="nc" id="L8738">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L8740">			Logging.errorPrint(e.getLocalizedMessage(), e);</span>
<span class="nc" id="L8741">		}</span>
<span class="nc" id="L8742">	}</span>

	public PCClassLevel getActiveClassLevel(PCClass pcc, int lvl)
	{
<span class="nc" id="L8746">		return classFacet.getClassLevel(id, pcc, lvl);</span>
	}

	public boolean hasLanguage(Language lang)
	{
<span class="fc" id="L8751">		return languageFacet.contains(id, lang);</span>
	}

	public boolean hasClass()
	{
<span class="nc bnc" id="L8756" title="All 2 branches missed.">		return !classFacet.isEmpty(id);</span>
	}

	public void removeClass(PCClass pcc)
	{
<span class="nc" id="L8761">		classFacet.removeClass(id, pcc);</span>
<span class="nc" id="L8762">	}</span>

	public void addClass(PCClass pcc)
	{
<span class="nc" id="L8766">		classFacet.addClass(id, pcc);</span>
<span class="nc" id="L8767">	}</span>

	public final int getLevel(PCClass pcc)
	{
<span class="nc" id="L8771">		return classFacet.getLevel(id, pcc);</span>
	}

	/**
	 * set the level to arg without impacting spells, hp, or anything else - use
	 * this with great caution only.
	 */
	public final void setLevelWithoutConsequence(PCClass pcc, final int level)
	{
<span class="nc" id="L8780">		classFacet.setLevel(id, pcc, level);</span>
<span class="nc" id="L8781">		cabFacet.update(id);</span>
<span class="nc" id="L8782">	}</span>

	public boolean hasEquipment()
	{
<span class="nc bnc" id="L8786" title="All 2 branches missed.">		return !equipmentFacet.isEmpty(id);</span>
	}

	private Set&lt;Ability&gt; getAbilityList(Category&lt;Ability&gt; cat, Nature nature)
	{
<span class="fc" id="L8791">		Set&lt;Ability&gt; newSet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L8792">		Collection&lt;CNAbility&gt; cnas = grantedAbilityFacet.getPoolAbilities(id, cat, nature);</span>
<span class="pc bpc" id="L8793" title="1 of 2 branches missed.">		for (CNAbility cna : cnas)</span>
		{
<span class="nc" id="L8795">			newSet.add(cna.getAbility());</span>
<span class="nc" id="L8796">		}</span>
<span class="fc" id="L8797">		return newSet;</span>
	}

	public boolean containsKit(Kit kit)
	{
<span class="nc" id="L8802">		return kitFacet.contains(id, kit);</span>
	}

	/*
	 * Yes, this method really is what it says. The primary reason for this
	 * being in PlayerCharacter is that I don't want to export id at this time
	 * (it's private to avoid changing too much outside of PlayerCharacter at
	 * this time). In the future, the Unit Tests should behave better - but I
	 * think that generally goes along with Equipment
	 * Location/Equipped/NumberEquipped/NumberCarried all being made consistent
	 * (they are highly correlated, but no control is exerted over them by
	 * Equipment to ensure appropriate states are maintained)
	 */
	@TestOnly
	public void doAfavorForAunitTestThatIgnoresEquippingRules()
	{
<span class="nc" id="L8818">		equippedFacet.reset(id);</span>
<span class="nc" id="L8819">	}</span>

	public void processAddition(CDOMObject cdo)
	{
<span class="pc bpc" id="L8823" title="1 of 2 branches missed.">		for (CDOMReference&lt;PCTemplate&gt; tr : cdo.getSafeListFor(ListKey.TEMPLATE))</span>
		{
<span class="nc" id="L8825">			addTemplatesIfMissing(tr.getContainedObjects());</span>
<span class="nc" id="L8826">		}</span>
<span class="pc bpc" id="L8827" title="1 of 2 branches missed.">		for (CDOMReference ref : cdo.getModifiedLists())</span>
		{
<span class="nc" id="L8829">			processAbilityListsOnAdd(cdo, ref);</span>
<span class="nc" id="L8830">		}</span>
<span class="fc" id="L8831">	}</span>

	public void processRemoval(CDOMObject cdo)
	{
<span class="fc" id="L8835">		conditionalFacet.removeAll(id, cdo);</span>
<span class="fc" id="L8836">		directAbilityFacet.removeAll(id, cdo);</span>
		//setDirty(true);
<span class="fc" id="L8838">	}</span>

	public void addWeaponBonus(CDOMObject owner, WeaponProf choice)
	{
<span class="nc" id="L8842">		wpBonusFacet.add(id, choice, owner);</span>
<span class="nc" id="L8843">	}</span>

	public List&lt;? extends WeaponProf&gt; getBonusWeaponProfs(CDOMObject owner)
	{
<span class="nc" id="L8847">		return wpBonusFacet.getSet(id, owner);</span>
	}

	public void removeWeaponBonus(CDOMObject owner, WeaponProf choice)
	{
<span class="nc" id="L8852">		wpBonusFacet.remove(id, choice, owner);</span>
<span class="nc" id="L8853">	}</span>

	public void addFavoredClass(PCClass cls, Object source)
	{
<span class="fc" id="L8857">		favClassFacet.add(id, cls, source);</span>
<span class="fc" id="L8858">	}</span>

	public void removeFavoredClass(PCClass cls, Object source)
	{
<span class="fc" id="L8862">		favClassFacet.remove(id, cls, source);</span>
<span class="fc" id="L8863">	}</span>

	public PCClass getLegacyFavoredClass()
	{
<span class="nc" id="L8867">		List&lt;? extends PCClass&gt; list = favClassFacet.getSet(id, this);</span>
<span class="nc bnc" id="L8868" title="All 2 branches missed.">		if (list.isEmpty())</span>
		{
<span class="nc" id="L8870">			return null;</span>
		}
<span class="nc" id="L8872">		return list.get(0);</span>
	}

	public void addWeaponProf(Object owner, WeaponProf choice)
	{
<span class="fc" id="L8877">		alWeaponProfFacet.add(id, choice, owner);</span>
<span class="fc" id="L8878">	}</span>

	public void removeWeaponProf(Object owner, WeaponProf choice)
	{
<span class="fc" id="L8882">		alWeaponProfFacet.remove(id, choice, owner);</span>
<span class="fc" id="L8883">	}</span>

	/**
	 * WARNING: Use this method SPARINGLY... and only for transition to the
	 * facet model. It is NOT an excuse to throw around a PlayerCharacter object
	 * when unnecessary
	 *
	 * @return The id of the character as used by the facets.
	 */
	public CharID getCharID()
	{
<span class="fc" id="L8894">		return id;</span>
	}

	private int getSpellBookCount()
	{
<span class="nc" id="L8899">		return spellBookFacet.getCount(id);</span>
	}

	public boolean hasSpellBook(String bookName)
	{
<span class="nc" id="L8904">		return spellBookFacet.containsBookNamed(id, bookName);</span>
	}

	private Load getLoadType()
	{
<span class="nc" id="L8909">		return loadFacet.getLoadType(id);</span>
	}

	public void addArmorProf(Object owner, ArmorProf ap)
	{
<span class="fc" id="L8914">		armorProfListFacet.add(id, ap, owner);</span>
<span class="fc" id="L8915">	}</span>

	public void removeArmorProf(Object owner, ArmorProf ap)
	{
<span class="fc" id="L8919">		armorProfListFacet.remove(id, ap, owner);</span>
<span class="fc" id="L8920">	}</span>

	public void addShieldProf(Object owner, ShieldProf sp)
	{
<span class="fc" id="L8924">		shieldProfListFacet.add(id, sp, owner);</span>
<span class="fc" id="L8925">	}</span>

	public void removeShieldProf(Object owner, ShieldProf sp)
	{
<span class="fc" id="L8929">		shieldProfListFacet.remove(id, sp, owner);</span>
<span class="fc" id="L8930">	}</span>

	public boolean hasFollowers()
	{
<span class="nc bnc" id="L8934" title="All 2 branches missed.">		return !followerFacet.isEmpty(id);</span>
	}

	public void addAutoEquipment(Equipment e, Object obj)
	{
<span class="nc" id="L8939">		autoListEquipmentFacet.add(id, e, obj);</span>
<span class="nc" id="L8940">	}</span>

	public void removeAutoEquipment(Equipment e, Object obj)
	{
<span class="nc" id="L8944">		autoListEquipmentFacet.remove(id, e, obj);</span>
<span class="nc" id="L8945">	}</span>

	public void addMonCSkill(Skill skill, Object obj)
	{
<span class="fc" id="L8949">		monCSkillFacet.add(id, skill, obj);</span>
<span class="fc" id="L8950">	}</span>

	public void removeMonCSkill(Skill skill, Object obj)
	{
<span class="fc" id="L8954">		monCSkillFacet.remove(id, skill, obj);</span>
<span class="fc" id="L8955">	}</span>

	public Collection&lt;? extends SpellProhibitor&gt; getProhibitedSchools(PCClass source)
	{
<span class="nc" id="L8959">		List&lt;SpellProhibitor&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L8960">		list.addAll(prohibitedSchoolFacet.getSet(id, source));</span>
<span class="nc" id="L8961">		list.addAll(spellProhibitorFacet.getSet(id, source));</span>
<span class="nc" id="L8962">		return list;</span>
	}

	public boolean containsProhibitedSchools(Object source)
	{
<span class="nc" id="L8967">		return prohibitedSchoolFacet.containsFrom(id, source);</span>
	}

	public void addProhibitedSchool(SpellProhibitor prohibSchool, Object source)
	{
<span class="nc" id="L8972">		prohibitedSchoolFacet.add(id, prohibSchool, source);</span>
<span class="nc" id="L8973">	}</span>

	public void removeProhibitedSchools(Object source)
	{
<span class="nc" id="L8977">		prohibitedSchoolFacet.removeAll(id, source);</span>
<span class="nc" id="L8978">	}</span>

	private boolean hasCharacterSpells(CDOMObject cdo)
	{
<span class="nc" id="L8982">		return activeSpellsFacet.containsFrom(id, cdo);</span>
	}

	public Collection&lt;? extends CharacterSpell&gt; getCharacterSpells(CDOMObject cdo)
	{
<span class="nc" id="L8987">		return activeSpellsFacet.getSet(id, cdo);</span>
	}

	public Collection&lt;CharacterSpell&gt; getCharacterSpells(PObject spellSource, int level)
	{
<span class="nc" id="L8992">		List&lt;CharacterSpell&gt; csList = new ArrayList&lt;&gt;(getCharacterSpells(spellSource));</span>
		// Add in the spells granted by objects
<span class="nc" id="L8994">		addBonusKnownSpellsToList(spellSource, csList);</span>
<span class="nc" id="L8995">		List&lt;CharacterSpell&gt; aList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L8996" title="All 2 branches missed.">		for (CharacterSpell cs : csList)</span>
		{
<span class="nc bnc" id="L8998" title="All 2 branches missed.">			if (cs.hasSpellInfoFor(level))</span>
			{
<span class="nc" id="L9000">				aList.add(cs);</span>
			}
<span class="nc" id="L9002">		}</span>

<span class="nc" id="L9004">		return aList;</span>
	}

	public Collection&lt;CharacterSpell&gt; getCharacterSpells(PObject spellSource, String bookName)
	{
<span class="nc" id="L9009">		List&lt;CharacterSpell&gt; csList = new ArrayList&lt;&gt;(getCharacterSpells(spellSource));</span>
		// Add in the spells granted by objects
<span class="nc" id="L9011">		addBonusKnownSpellsToList(spellSource, csList);</span>

<span class="nc" id="L9013">		List&lt;CharacterSpell&gt; aList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L9014" title="All 2 branches missed.">		for (CharacterSpell cs : csList)</span>
		{
<span class="nc bnc" id="L9016" title="All 2 branches missed.">			if (cs.hasSpellInfoFor(bookName))</span>
			{
<span class="nc" id="L9018">				aList.add(cs);</span>
			}
<span class="nc" id="L9020">		}</span>

<span class="nc" id="L9022">		return aList;</span>
	}

	public int getCharacterSpellCount(CDOMObject cdo)
	{
<span class="nc" id="L9027">		return activeSpellsFacet.getCountFrom(id, cdo);</span>
	}

	public void addCharacterSpell(CDOMObject cdo, CharacterSpell cs)
	{
<span class="nc" id="L9032">		activeSpellsFacet.add(id, cs, cdo);</span>
<span class="nc" id="L9033">	}</span>

	public void removeCharacterSpell(CDOMObject cdo, CharacterSpell cs)
	{
<span class="nc" id="L9037">		activeSpellsFacet.remove(id, cs, cdo);</span>
<span class="nc" id="L9038">	}</span>

	private boolean containsCharacterSpell(CDOMObject cdo, CharacterSpell cs)
	{
<span class="nc" id="L9042">		return activeSpellsFacet.containsFrom(id, cs, cdo);</span>
	}

	public void addBonus(BonusObj bonus, CDOMObject source)
	{
<span class="nc" id="L9047">		addedBonusFacet.add(id, bonus, source);</span>
<span class="nc" id="L9048">	}</span>

	public List&lt;? extends BonusObj&gt; getAddedBonusList(CDOMObject source)
	{
<span class="fc" id="L9052">		return addedBonusFacet.getSet(id, source);</span>
	}

	public void addSaveableBonus(BonusObj bonus, CDOMObject source)
	{
<span class="nc" id="L9057">		saveableBonusFacet.add(id, bonus, source);</span>
<span class="nc" id="L9058">	}</span>

	public List&lt;? extends BonusObj&gt; getSaveableBonusList(CDOMObject source)
	{
<span class="fc" id="L9062">		return saveableBonusFacet.getSet(id, source);</span>
	}

	public void removeSaveableBonus(BonusObj bonus, CDOMObject source)
	{
<span class="nc" id="L9067">		saveableBonusFacet.remove(id, bonus, source);</span>
<span class="nc" id="L9068">	}</span>

	public void addGlobalCost(SkillCost sc, Skill skill, Object obj)
	{
<span class="fc" id="L9072">		globalAddedSkillCostFacet.add(id, sc, skill, obj);</span>
<span class="fc" id="L9073">	}</span>

	public void removeGlobalCost(SkillCost sc, Skill skill, Object obj)
	{
<span class="fc" id="L9077">		globalAddedSkillCostFacet.remove(id, sc, skill, obj);</span>
<span class="fc" id="L9078">	}</span>

	public void addLocalCost(PCClass pcc, Skill skill, SkillCost sc, Object owner)
	{
<span class="fc" id="L9082">		localAddedSkillCostFacet.add(id, pcc, sc, skill, owner);</span>
<span class="fc" id="L9083">	}</span>

	public void removeLocalCost(PCClass pcc, Skill skill, SkillCost sc, Object owner)
	{
<span class="fc" id="L9087">		localAddedSkillCostFacet.remove(id, pcc, sc, skill, owner);</span>
<span class="fc" id="L9088">	}</span>

	public String getSubClassName(PCClass cl)
	{
<span class="nc" id="L9092">		return subClassFacet.get(id, cl);</span>
	}

	public void setSubClassName(PCClass cl, String key)
	{
<span class="nc" id="L9097">		subClassFacet.set(id, cl, key);</span>
<span class="nc" id="L9098">	}</span>

	public boolean hasTempApplied(CDOMObject mod)
	{
<span class="nc" id="L9102">		return bonusManager.hasTempBonusesApplied(mod);</span>
	}

	public Collection&lt;BonusContainer&gt; getBonusContainerList()
	{
<span class="fc" id="L9107">		List&lt;BonusContainer&gt; list = new ArrayList&lt;&gt;(getCDOMObjectList());</span>
<span class="fc" id="L9108">		list.add(ageSetFacet.get(id));</span>
<span class="fc" id="L9109">		final GameMode gameMode = SettingsHandler.getGameAsProperty().get();</span>
<span class="pc bpc" id="L9110" title="1 of 2 branches missed.">		if (gameMode.isPurchaseStatMode())</span>
		{
<span class="nc" id="L9112">			PointBuyMethod pbm = gameMode.getContext().getReferenceContext()</span>
<span class="nc" id="L9113">				.silentlyGetConstructedCDOMObject(PointBuyMethod.class, gameMode.getPurchaseModeMethodName());</span>
<span class="nc" id="L9114">			list.add(pbm);</span>
		}
<span class="fc" id="L9116">		return list;</span>
	}

	public SkillCost skillCostForPCClass(Skill sk, PCClass aClass)
	{
		//For safety
<span class="nc" id="L9122">		PCClass cl = getClassKeyed(aClass.getKeyName());</span>
<span class="nc bnc" id="L9123" title="All 2 branches missed.">		return skillCostFacet.skillCostForPCClass(id, sk, cl == null ? aClass : cl);</span>
	}

	public boolean isClassSkill(PCClass aClass, Skill sk)
	{
		//For safety
<span class="nc" id="L9129">		PCClass cl = getClassKeyed(aClass.getKeyName());</span>
<span class="nc bnc" id="L9130" title="All 2 branches missed.">		return skillCostFacet.isClassSkill(id, cl == null ? aClass : cl, sk);</span>
	}

	public boolean isQualified(CDOMObject po)
	{
<span class="nc" id="L9135">		return po.qualifies(this, po);</span>
	}

	public void reInheritClassLevels(PCClass pcc)
	{
		try
		{
<span class="nc bnc" id="L9142" title="All 2 branches missed.">			for (PCClassLevel pcl : pcc.getOriginalClassLevelCollection())</span>
			{
<span class="nc" id="L9144">				classFacet.setClassLevel(id, pcc, pcl);</span>
<span class="nc" id="L9145">			}</span>
		}
<span class="nc" id="L9147">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L9149">			Logging.errorPrint(e.getLocalizedMessage(), e);</span>
<span class="nc" id="L9150">		}</span>
<span class="nc" id="L9151">	}</span>

	public void checkSkillModChange()
	{
<span class="nc" id="L9155">		List&lt;PCClass&gt; newClasses = getClassList();</span>
<span class="nc" id="L9156">		Collection&lt;PCLevelInfo&gt; levelInfo = getLevelInfo();</span>
<span class="nc" id="L9157">		int levelIndex = 1;</span>

<span class="nc bnc" id="L9159" title="All 2 branches missed.">		for (PCLevelInfo lvlInfo : levelInfo)</span>
		{
<span class="nc" id="L9161">			Map&lt;String, PCClass&gt; classMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L9162" title="All 2 branches missed.">			for (PCClass pcClass : newClasses)</span>
			{
<span class="nc" id="L9164">				classMap.put(pcClass.getKeyName(), pcClass);</span>
<span class="nc" id="L9165">			}</span>
<span class="nc" id="L9166">			final String classKeyName = lvlInfo.getClassKeyName();</span>
<span class="nc" id="L9167">			PCClass currClass = classMap.get(classKeyName);</span>
<span class="nc bnc" id="L9168" title="All 2 branches missed.">			if (currClass == null)</span>
			{
<span class="nc" id="L9170">				Logging</span>
<span class="nc" id="L9171">					.errorPrint(&quot;No PCClass found for '&quot; + classKeyName + &quot;' in character's class list: &quot; + newClasses);</span>
<span class="nc" id="L9172">				return;</span>
			}
<span class="nc" id="L9174">			PCClassLevel classLevel = getActiveClassLevel(currClass, lvlInfo.getClassLevel());</span>
<span class="nc" id="L9175">			checkSkillModChangeForLevel(currClass, lvlInfo, classLevel, levelIndex++);</span>
<span class="nc" id="L9176">		}</span>
<span class="nc" id="L9177">	}</span>

	public void checkSkillModChangeForLevel(PCClass pcClass, PCLevelInfo pi, PCClassLevel classLevel,
		int characterLevel)
	{
<span class="nc" id="L9182">		int newSkillPointsGained = pcClass.getSkillPointsForLevel(this, classLevel, characterLevel);</span>
<span class="nc bnc" id="L9183" title="All 2 branches missed.">		if (pi.getClassKeyName().equals(pcClass.getKeyName()))</span>
		{
<span class="nc" id="L9185">			final int formerGained = pi.getSkillPointsGained(this);</span>
<span class="nc bnc" id="L9186" title="All 2 branches missed.">			if (newSkillPointsGained != formerGained)</span>
			{
<span class="nc" id="L9188">				pi.setSkillPointsGained(this, newSkillPointsGained);</span>
<span class="nc" id="L9189">				newSkillPointsGained = pi.getSkillPointsGained(this);</span>
<span class="nc" id="L9190">				pi.setSkillPointsRemaining(pi.getSkillPointsRemaining() + newSkillPointsGained - formerGained);</span>
<span class="nc" id="L9191">				setSkillPool(pcClass, pcClass.getSkillPool(this) + newSkillPointsGained - formerGained);</span>
			}
		}
<span class="nc" id="L9194">	}</span>

	/**
	 * Add a chronicle entry.
	 * @param chronicleEntry The entry to be added.
	 */
	public void addChronicleEntry(ChronicleEntry chronicleEntry)
	{
<span class="nc" id="L9202">		chronicleEntryFacet.add(id, chronicleEntry);</span>
<span class="nc" id="L9203">	}</span>

	/**
	 * Remove a chronicle entry.
	 * @param chronicleEntry The entry to be removed.
	 */
	public void removeChronicleEntry(ChronicleEntry chronicleEntry)
	{
<span class="nc" id="L9211">		chronicleEntryFacet.remove(id, chronicleEntry);</span>
<span class="nc" id="L9212">	}</span>

	public BioSet getBioSet()
	{
<span class="nc" id="L9216">		return bioSetFacet.get(id);</span>
	}

	public HitDie getLevelHitDie(PCClass pcClass, final int classLevel)
	{
<span class="nc" id="L9221">		return hitPointFacet.getLevelHitDie(id, pcClass, classLevel);</span>
	}

	/**
	 * Rolls hp for the current level according to the rules set in options.
	 *
	 * @param pcClass TODO
	 * @param aLevel
	 * @param first
	 */
	/*
	 * REFACTOR This really needs to be part of the PCClassLevel importing into
	 * a PlayerCharacter? Some thought needs to be put into where this stuff is
	 * stored - should PCLevelInfo be adapted to store all of the non-static
	 * information about a PCClassLevel?
	 */
	public void rollHP(PCClass pcClass, int aLevel, boolean first)
	{
<span class="nc" id="L9239">		hitPointFacet.rollHP(id, pcClass, aLevel, first);</span>
<span class="nc" id="L9240">		setDirty(true);</span>
<span class="nc" id="L9241">	}</span>

	public void setHP(PCClassLevel pcl, Integer hp)
	{
<span class="nc" id="L9245">		hitPointFacet.set(id, pcl, hp);</span>
<span class="nc" id="L9246">	}</span>

	public Integer getHP(PCClassLevel pcl)
	{
<span class="nc" id="L9250">		return hitPointFacet.get(id, pcl);</span>
	}

	public void removeHP(PCClassLevel pcl)
	{
<span class="nc" id="L9255">		hitPointFacet.remove(id, pcl);</span>
<span class="nc" id="L9256">	}</span>

	public void addClassSpellList(CDOMListObject&lt;Spell&gt; list, PCClass pcClass)
	{
<span class="nc" id="L9260">		spellListFacet.add(id, list, pcClass);</span>
<span class="nc" id="L9261">	}</span>

	public List&lt;? extends CDOMList&lt;Spell&gt;&gt; getSpellLists(CDOMObject cdo)
	{
<span class="nc" id="L9265">		return spellListFacet.getSet(id, cdo);</span>
	}

	public boolean hasSpellList(CDOMObject cdo, CDOMList&lt;Spell&gt; list)
	{
<span class="nc" id="L9270">		return spellListFacet.containsFrom(id, list, cdo);</span>
	}

	public void setSpellLists(PCClass pcClass)
	{
<span class="nc" id="L9275">		classSpellListFacet.process(id, pcClass);</span>
<span class="nc" id="L9276">	}</span>

	public void addDefaultSpellList(PCClass pcc)
	{
<span class="nc" id="L9280">		classSpellListFacet.addDefaultSpellList(id, pcc);</span>
<span class="nc" id="L9281">	}</span>

	double getSizeBonusTo(SizeAdjustment sizeAdjustment, final String bonusType, final List&lt;String&gt; typeList,
		double defaultValue)
	{
<span class="nc bnc" id="L9286" title="All 2 branches missed.">		for (String type : typeList)</span>
		{
			/*
			 * TODO:  The standard for these bonuses should probably be TYPE=, but
			 * the bonus objects only correctly match TYPE.  The bonus objects
			 * probably need to be reevaluated to standardize this usage
			 */
<span class="nc" id="L9293">			final double a = BonusCalc.charBonusTo(sizeAdjustment, bonusType, &quot;TYPE.&quot; + type, this);</span>

<span class="nc bnc" id="L9295" title="All 2 branches missed.">			if (!CoreUtility.doublesEqual(a, 0.0))</span>
			{
<span class="nc" id="L9297">				defaultValue = a;</span>

<span class="nc" id="L9299">				break;</span>
			}
<span class="nc" id="L9301">		}</span>

<span class="nc" id="L9303">		return defaultValue;</span>
	}

	/**
	 * Adds to the provided list any spells that have been granted to the character's class by abilities
	 * through the use of SPELLKNOWN:CLASS tags.
	 *
	 * @param aClass The character class owning the spell list.
	 * @param cSpells The list of spells to be updated.
	 */
	public void addBonusKnownSpellsToList(CDOMObject aClass, List&lt;CharacterSpell&gt; cSpells)
	{
<span class="nc bnc" id="L9315" title="All 2 branches missed.">		if (!(aClass instanceof PCClass))</span>
		{
<span class="nc" id="L9317">			return;</span>
		}
<span class="nc" id="L9319">		ClassSpellList classSpellList = aClass.get(ObjectKey.CLASS_SPELLLIST);</span>
<span class="nc bnc" id="L9320" title="All 2 branches missed.">		for (Integer spellLevel : knownSpellFacet.getScopes2(id, classSpellList))</span>
		{
<span class="nc bnc" id="L9322" title="All 2 branches missed.">			for (Spell spell : knownSpellFacet.getSet(id, classSpellList, spellLevel))</span>
			{
<span class="nc" id="L9324">				CharacterSpell acs = null;</span>
<span class="nc" id="L9325">				Collection&lt;? extends CharacterSpell&gt; characterSpells = getCharacterSpells(GRANTED_SPELL_CACHE);</span>
<span class="nc bnc" id="L9326" title="All 2 branches missed.">				for (CharacterSpell cs : characterSpells)</span>
				{
<span class="nc" id="L9328">					Spell sp = cs.getSpell();</span>
<span class="nc bnc" id="L9329" title="All 4 branches missed.">					if (spell.equals(sp) &amp;&amp; (cs.getOwner().equals(aClass)))</span>
					{
<span class="nc" id="L9331">						acs = cs;</span>
<span class="nc" id="L9332">						break;</span>
					}
<span class="nc" id="L9334">				}</span>

<span class="nc bnc" id="L9336" title="All 2 branches missed.">				if (acs == null)</span>
				{
<span class="nc" id="L9338">					acs = new CharacterSpell(aClass, spell);</span>
<span class="nc" id="L9339">					acs.addInfo(spellLevel, 1, Globals.getDefaultSpellBook());</span>
<span class="nc" id="L9340">					addCharacterSpell(GRANTED_SPELL_CACHE, acs);</span>
				}
<span class="nc bnc" id="L9342" title="All 2 branches missed.">				if (!cSpells.contains(acs))</span>
				{
<span class="nc" id="L9344">					cSpells.add(acs);</span>
				}
<span class="nc" id="L9346">			}</span>
<span class="nc" id="L9347">		}</span>
<span class="nc" id="L9348">	}</span>

	public boolean hasBonusWeaponProfs(CDOMObject owner)
	{
<span class="nc" id="L9352">		return wpBonusFacet.containsFrom(id, owner);</span>
	}

	public void addUserSpecialAbility(SpecialAbility sa, CDOMObject source)
	{
<span class="nc" id="L9357">		userSpecialAbilityFacet.add(id, sa, source);</span>
<span class="nc" id="L9358">	}</span>

	public CharacterDisplay getDisplay()
	{
<span class="fc" id="L9362">		return display;</span>
	}

	public List&lt;WeaponProf&gt; getWeaponProfsInTarget(CDOMGroupRef&lt;WeaponProf&gt; master)
	{
<span class="nc" id="L9367">		return changeProfFacet.getWeaponProfsInTarget(id, master);</span>
	}

	public void setSubstitutionClassName(PCClassLevel lvl, String subClassKey)
	{
<span class="nc" id="L9372">		substitutionClassFacet.set(id, lvl, subClassKey);</span>
<span class="nc" id="L9373">	}</span>

	public void removeSubstitutionClassName(PCClassLevel lvl)
	{
<span class="nc" id="L9377">		substitutionClassFacet.remove(id, lvl);</span>
<span class="nc" id="L9378">	}</span>

	public void setStat(PCStat stat, int value)
	{
<span class="fc" id="L9382">		statValueFacet.set(id, stat, value);</span>
<span class="fc" id="L9383">	}</span>

	public int getStat(PCStat stat)
	{
<span class="fc" id="L9387">		return statValueFacet.get(id, stat).intValue();</span>
	}

	public int recalcSkillPointMod(PCClass pcClass, final int characterLevel)
	{
		// int spMod = getSkillPoints();
<span class="nc" id="L9393">		int spMod = pcClass.getSafe(FormulaKey.START_SKILL_POINTS).resolve(this, pcClass.getQualifiedKey()).intValue();</span>
<span class="nc" id="L9394">		int classSp = spMod; // retain class based skillpoints mod</span>

<span class="nc" id="L9396">		spMod += (int) getTotalBonusTo(&quot;SKILLPOINTS&quot;, &quot;NUMBER&quot;);</span>
<span class="nc" id="L9397">		int raceSp = spMod - classSp; // this should be the race based skillpoints mod</span>

<span class="nc bnc" id="L9399" title="All 2 branches missed.">		if (pcClass.isMonster())</span>
		{
<span class="nc" id="L9401">			int lockedMonsterSkillPoints = (int) getTotalBonusTo(&quot;MONSKILLPTS&quot;, &quot;LOCKNUMBER&quot;);</span>
<span class="nc bnc" id="L9402" title="All 2 branches missed.">			if (lockedMonsterSkillPoints &gt; 0)</span>
			{
<span class="nc" id="L9404">				spMod = lockedMonsterSkillPoints;</span>
			}
<span class="nc bnc" id="L9406" title="All 2 branches missed.">			else if (characterLevel == 1)</span>
			{
<span class="nc" id="L9408">				int monSkillPts = (int) getTotalBonusTo(&quot;MONSKILLPTS&quot;, &quot;NUMBER&quot;);</span>
<span class="nc bnc" id="L9409" title="All 2 branches missed.">				if (monSkillPts != 0)</span>
				{
<span class="nc" id="L9411">					spMod = monSkillPts;</span>
				}
			}

<span class="nc bnc" id="L9415" title="All 2 branches missed.">			if (characterLevel != 1)</span>
			{
				// If this level is one that is not entitled to skill points
				// based
				// on the monster's size, zero out the skills for this level
<span class="nc" id="L9420">				final int nonSkillHD = (int) getTotalBonusTo(&quot;MONNONSKILLHD&quot;, &quot;NUMBER&quot;);</span>
<span class="nc bnc" id="L9421" title="All 2 branches missed.">				if (characterLevel &lt;= nonSkillHD)</span>
				{
<span class="nc" id="L9423">					spMod = 0;</span>
				}
			}
		}

<span class="nc" id="L9428">		spMod = updateBaseSkillMod(pcClass, spMod);</span>
<span class="nc" id="L9429">		int otherSp = spMod - classSp - raceSp; // should mostly be stat related skillpoints</span>
<span class="nc" id="L9430">		final int classSpMin = (int) getTotalBonusTo(&quot;MINCLASSSKILLPOINTS&quot;, &quot;NUMBER&quot;);</span>
		// if a MINCLASSSKILLPOINTS.NUMBER is defined and spMod was lower due to INT penalty
<span class="nc bnc" id="L9432" title="All 4 branches missed.">		if (classSpMin&gt;0 &amp;&amp; (classSp+otherSp&lt;classSpMin))</span>
		{
<span class="nc" id="L9434">			spMod = Math.max(classSpMin,classSp+otherSp)+raceSp;</span>
		}

<span class="nc bnc" id="L9437" title="All 2 branches missed.">		if (characterLevel == 1)</span>
		{
<span class="nc bnc" id="L9439" title="All 2 branches missed.">			if (!SettingsHandler.getGameAsProperty().get().isPurchaseStatMode())</span>
			{
<span class="nc" id="L9441">				poolAmount = 0;</span>
			}

<span class="nc" id="L9444">			spMod *= getRace().getSafe(IntegerKey.INITIAL_SKILL_MULT);</span>
<span class="nc bnc" id="L9445" title="All 2 branches missed.">			if ((Integer) ChannelUtilities.readControlledChannel(getCharID(), CControl.AGEINPUT) &lt;= 0)</span>
			{
				// Only generate a random age if the user hasn't set one!
<span class="nc" id="L9448">				bioSetFacet.get(id).randomize(&quot;AGE&quot;, this);</span>
			}
		}
		else
		{
<span class="nc" id="L9453">			spMod *= Globals.getSkillMultiplierForLevel(characterLevel);</span>
		}

<span class="nc" id="L9456">		return spMod;</span>
	}

	private int updateBaseSkillMod(PCClass pcClass, int spMod)
	{
		// skill min is 1, unless class gets 0 skillpoints per level (for second
		// apprentice class)
<span class="nc bnc" id="L9463" title="All 2 branches missed.">		final int skillMin = (spMod &gt; 0) ? 1 : 0;</span>

<span class="nc bnc" id="L9465" title="All 2 branches missed.">		if (pcClass.getSafe(ObjectKey.MOD_TO_SKILLS))</span>
		{
<span class="nc" id="L9467">			spMod += (int) getStatBonusTo(&quot;MODSKILLPOINTS&quot;, &quot;NUMBER&quot;);</span>

<span class="nc bnc" id="L9469" title="All 2 branches missed.">			if (spMod &lt; 1)</span>
			{
<span class="nc" id="L9471">				spMod = 1;</span>
			}
		}

		// Race modifiers apply after Intellegence. BUG 577462
<span class="nc" id="L9476">		Formula safe = getRace().getSafe(FormulaKey.SKILL_POINTS_PER_LEVEL);</span>
<span class="nc" id="L9477">		spMod += safe.resolve(this, &quot;&quot;).intValue();</span>
<span class="nc" id="L9478">		spMod = Math.max(skillMin, spMod); // Minimum 1, not sure if bonus</span>

		// level can be &lt; 1, better safe than sorry
<span class="nc bnc" id="L9481" title="All 2 branches missed.">		for (PCTemplate template : getTemplateSet())</span>
		{
<span class="nc" id="L9483">			spMod += template.getSafe(IntegerKey.BONUS_CLASS_SKILL_POINTS);</span>
<span class="nc" id="L9484">		}</span>

<span class="nc" id="L9486">		return spMod;</span>
	}

	public void removeDomainSpellCount(PCClass pcc)
	{
<span class="nc" id="L9491">		domainSpellCountFacet.remove(id, pcc);</span>
<span class="nc" id="L9492">	}</span>

	public Integer getDomainSpellCount(PCClass pcc)
	{
<span class="nc" id="L9496">		return domainSpellCountFacet.get(id, pcc);</span>
	}

	public void setDomainSpellCount(PCClass pcc, int i)
	{
<span class="nc" id="L9501">		domainSpellCountFacet.set(id, pcc, i);</span>
<span class="nc" id="L9502">	}</span>

	public Integer getSkillPool(PCClass pcc)
	{
<span class="nc" id="L9506">		return skillPoolFacet.get(id, pcc);</span>
	}

	public void setSkillPool(PCClass pcc, int skillPool)
	{
<span class="nc" id="L9511">		skillPoolFacet.set(id, pcc, skillPool);</span>
<span class="nc" id="L9512">		setDirty(true);</span>
<span class="nc" id="L9513">	}</span>

	public void setSkillOrder(Skill skill, int outputindex)
	{
<span class="nc" id="L9517">		skillOutputOrderFacet.set(id, skill, outputindex);</span>
<span class="nc" id="L9518">	}</span>

	public Integer getSkillOrder(Skill skill)
	{
<span class="nc" id="L9522">		return skillOutputOrderFacet.get(id, skill);</span>
	}

	public int getBaseStatFor(PCStat stat)
	{
<span class="nc" id="L9527">		return statCalcFacet.getBaseStatFor(id, stat);</span>
	}

	public int getTotalStatFor(PCStat stat)
	{
<span class="nc" id="L9532">		return statCalcFacet.getTotalStatFor(id, stat);</span>
	}

	public int getStatModFor(PCStat stat)
	{
<span class="nc" id="L9537">		return statCalcFacet.getStatModFor(id, stat);</span>
	}

	public int getModForNumber(int aNum, PCStat stat)
	{
<span class="nc" id="L9542">		return statCalcFacet.getModFornumber(id, aNum, stat);</span>
	}

	public void removeNote(NoteItem note)
	{
<span class="nc" id="L9547">		noteItemFacet.remove(id, note);</span>
<span class="nc" id="L9548">		setDirty(true);</span>
<span class="nc" id="L9549">	}</span>

	public void removeSkillRankValue(Skill sk, PCClass cl)
	{
		//Hedge bets on the class
<span class="nc bnc" id="L9554" title="All 2 branches missed.">		PCClass localClass = (cl == null) ? null : getClassKeyed(cl.getKeyName());</span>
<span class="nc" id="L9555">		removeSkillRankForLocalClass(sk, localClass);</span>
<span class="nc" id="L9556">	}</span>

	public void removeSkillRankForLocalClass(Skill sk, PCClass localClass)
	{
<span class="nc" id="L9560">		skillRankFacet.remove(id, sk, localClass);</span>
<span class="nc" id="L9561">	}</span>

	public void setSkillRankValue(Skill sk, PCClass pcc, double value)
	{
		//hedge bets on the class
<span class="nc bnc" id="L9566" title="All 2 branches missed.">		PCClass localClass = (pcc == null) ? null : getClassKeyed(pcc.getKeyName());</span>
<span class="nc" id="L9567">		skillRankFacet.set(id, sk, localClass, value);</span>
<span class="nc" id="L9568">	}</span>

	/**
	 * Retrieve the classes that have ranks in this skill. NB: For granted ranks
	 * this may include null.
	 * @param sk The skill to be checked.
	 * @return The collection of classes with ranks - may include null as a PCClass.
	 */
	public Collection&lt;PCClass&gt; getSkillRankClasses(Skill sk)
	{
<span class="nc" id="L9578">		return skillRankFacet.getClasses(id, sk);</span>
	}

	/**
	 * returns ranks taken specifically in skill
	 *
	 * @return ranks taken in skill
	 */
	public Float getRank(Skill sk)
	{
<span class="nc" id="L9588">		return skillRankFacet.getRank(id, sk);</span>
	}

	/**
	 * @return the allowDebt
	 */
	public boolean isAllowDebt()
	{
<span class="nc" id="L9596">		Boolean ad = allowDebtFacet.get(id);</span>
<span class="nc bnc" id="L9597" title="All 2 branches missed.">		return (ad == null) ? SettingsHandler.getGearTab_AllowDebt() : ad;</span>
	}

	/**
	 * @return the ignoreCost
	 */
	public boolean isIgnoreCost()
	{
<span class="nc" id="L9605">		Boolean ic = ignoreCostFacet.get(id);</span>
<span class="nc bnc" id="L9606" title="All 2 branches missed.">		return (ic == null) ? SettingsHandler.getGearTab_IgnoreCost() : ic;</span>
	}

	public Double getSkillRankForClass(Skill sk, PCClass pcc)
	{
		//Yes, the check for &quot;local&quot; class is required (try down-ranking a skill)
<span class="nc bnc" id="L9612" title="All 2 branches missed.">		PCClass localClass = (pcc == null) ? null : getClassKeyed(pcc.getKeyName());</span>
<span class="nc" id="L9613">		return getSkillRankForLocalClass(sk, localClass);</span>
	}

	public Double getSkillRankForLocalClass(Skill sk, PCClass localClass)
	{
<span class="nc" id="L9618">		return skillRankFacet.get(id, sk, localClass);</span>
	}

	public int getKnownSpellCountForLevel(CDOMList&lt;Spell&gt; list, int level)
	{
<span class="nc" id="L9623">		return knownSpellFacet.getSize(id, list, level);</span>
	}

	public Collection&lt;Spell&gt; getSpellsIn(CDOMList&lt;Spell&gt; list, final int level)
	{
<span class="nc" id="L9628">		return availSpellFacet.getSet(id, list, level);</span>
	}

	public List&lt;Spell&gt; getAllSpellsInLists(List&lt;? extends CDOMList&lt;Spell&gt;&gt; spellLists)
	{
<span class="nc" id="L9633">		List&lt;Spell&gt; spellList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L9634" title="All 2 branches missed.">		for (CDOMList&lt;Spell&gt; list : availSpellFacet.getScopes1(id))</span>
		{
<span class="nc bnc" id="L9636" title="All 2 branches missed.">			if (spellLists.contains(list))</span>
			{
<span class="nc bnc" id="L9638" title="All 2 branches missed.">				for (int lvl : availSpellFacet.getScopes2(id, list))</span>
				{
<span class="nc" id="L9640">					spellList.addAll(availSpellFacet.getSet(id, list, lvl));</span>
<span class="nc" id="L9641">				}</span>
			}
<span class="nc" id="L9643">		}</span>

<span class="nc" id="L9645">		return spellList;</span>
	}

	public void calculateKnownSpellsForClassLevel(PCClass pcc)
	{
<span class="nc bnc" id="L9650" title="All 6 branches missed.">		if (!pcc.containsListFor(ListKey.KNOWN_SPELLS) || importing || !autoKnownSpells)</span>
		{
<span class="nc" id="L9652">			return;</span>
		}
		// If this class has at least one entry in the &quot;Known spells&quot; tag
		// And we are set up to automatically assign known spells...
<span class="nc" id="L9656">		List&lt;? extends CDOMList&lt;Spell&gt;&gt; spellLists = getSpellLists(pcc);</span>
<span class="nc" id="L9657">		SpellSupportForPCClass spellSupport = getSpellSupport(pcc);</span>

		// Recalculate the number of spells per day of each level
		// that this chracter can cast in this class.
<span class="nc" id="L9661">		spellSupport.calcCastPerDayMapForLevel(this);</span>

		// Get the maximum spell level that this character can cast.
<span class="nc" id="L9664">		final int maxCastableLevel = spellSupport.getMaxCastLevel();</span>

<span class="nc bnc" id="L9666" title="All 2 branches missed.">		for (CDOMList&lt;Spell&gt; list : spellLists)</span>
		{
<span class="nc bnc" id="L9668" title="All 2 branches missed.">			for (int spellLevel : availSpellFacet.getScopes2(id, list))</span>
			{
<span class="nc bnc" id="L9670" title="All 2 branches missed.">				if (spellLevel &lt;= maxCastableLevel)</span>
				{
<span class="nc bnc" id="L9672" title="All 2 branches missed.">					for (Spell spell : availSpellFacet.getSet(id, list, spellLevel))</span>
					{
<span class="nc bnc" id="L9674" title="All 2 branches missed.">						if (spellSupport.isAutoKnownSpell(spell, spellLevel, true, this))</span>
						{
<span class="nc" id="L9676">							CharacterSpell cs = getCharacterSpellForSpell(pcc, spell, pcc);</span>
<span class="nc bnc" id="L9677" title="All 2 branches missed.">							if (cs == null)</span>
							{
								// Create a new character spell for this level.
<span class="nc" id="L9680">								cs = new CharacterSpell(pcc, spell);</span>
<span class="nc" id="L9681">								cs.addInfo(spellLevel, 1, Globals.getDefaultSpellBook());</span>
<span class="nc" id="L9682">								addCharacterSpell(pcc, cs);</span>
							}
							else
							{
<span class="nc bnc" id="L9686" title="All 2 branches missed.">								if (cs.getSpellInfoFor(Globals.getDefaultSpellBook(), spellLevel) == null)</span>
								{
<span class="nc" id="L9688">									cs.addInfo(spellLevel, 1, Globals.getDefaultSpellBook());</span>
								}
								else
								{
									// already know this one
<span class="nc" id="L9693">									Logging.log(Logging.DEBUG, &quot;We already know about the level: &quot; + spellLevel + &quot; of this character spell, it's in the global default spellbook already.&quot;);</span>
								}
							}
						}
<span class="nc" id="L9697">					}</span>
				}
<span class="nc" id="L9699">			}</span>
<span class="nc" id="L9700">		}</span>

<span class="nc bnc" id="L9702" title="All 2 branches missed.">		for (Domain d : getDomainSet())</span>
		{
<span class="nc bnc" id="L9704" title="All 2 branches missed.">			if (pcc.getKeyName().equals(getDomainSource(d).getPcclass().getKeyName()))</span>
			{
<span class="nc" id="L9706">				DomainApplication.addSpellsToClassForLevels(this, d, pcc, 0, maxCastableLevel);</span>
			}
<span class="nc" id="L9708">		}</span>
<span class="nc" id="L9709">	}</span>

	public void removeKnownSpellsForClassLevel(PCClass pcc)
	{
<span class="nc bnc" id="L9713" title="All 6 branches missed.">		if (!pcc.containsListFor(ListKey.KNOWN_SPELLS) || importing || !autoKnownSpells)</span>
		{
<span class="nc" id="L9715">			return;</span>
		}

<span class="nc bnc" id="L9718" title="All 2 branches missed.">		if (!hasCharacterSpells(pcc))</span>
		{
<span class="nc" id="L9720">			return;</span>
		}

<span class="nc" id="L9723">		SpellSupportForPCClass spellSupport = getSpellSupport(pcc);</span>

<span class="nc" id="L9725">		List&lt;? extends CDOMList&lt;Spell&gt;&gt; lists = getSpellLists(pcc);</span>
<span class="nc" id="L9726">		List&lt;CharacterSpell&gt; spellsToBeRemoved = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L9728" title="All 2 branches missed.">		for (final CharacterSpell charSpell : getCharacterSpells(pcc))</span>
		{
<span class="nc" id="L9730">			final Spell aSpell = charSpell.getSpell();</span>

			// Check that the character can still cast spells of this level.
<span class="nc" id="L9733">			final Integer[] spellLevels = SpellLevel.levelForKey(aSpell, lists, this);</span>
<span class="nc bnc" id="L9734" title="All 2 branches missed.">			for (final Integer spellLevel : spellLevels)</span>
			{
<span class="nc bnc" id="L9736" title="All 2 branches missed.">				if (spellLevel == -1)</span>
				{
<span class="nc" id="L9738">					continue;</span>
				}

<span class="nc" id="L9741">				final boolean isKnownAtThisLevel = spellSupport.isAutoKnownSpell(aSpell, spellLevel, true, this);</span>

<span class="nc bnc" id="L9743" title="All 2 branches missed.">				if (!isKnownAtThisLevel)</span>
				{
<span class="nc" id="L9745">					spellsToBeRemoved.add(charSpell);</span>
				}
			}
<span class="nc" id="L9748">		}</span>

<span class="nc bnc" id="L9750" title="All 2 branches missed.">		for (CharacterSpell characterSpell : spellsToBeRemoved)</span>
		{
<span class="nc" id="L9752">			removeCharacterSpell(pcc, characterSpell);</span>
<span class="nc" id="L9753">		}</span>
<span class="nc" id="L9754">	}</span>

	public void addTemplateFeat(CDOMObject template, CNAbilitySelection as)
	{
<span class="nc" id="L9758">		templateFeatFacet.add(id, as, template);</span>
<span class="nc" id="L9759">	}</span>

	public List&lt;? extends CNAbilitySelection&gt; getTemplateFeatList(CDOMObject template)
	{
<span class="nc" id="L9763">		return templateFeatFacet.getSet(id, template);</span>
	}

	public Collection&lt;CNAbility&gt; getCNAbilities()
	{
<span class="nc" id="L9768">		return new HashSet&lt;&gt;(grantedAbilityFacet.getCNAbilities(id));</span>
	}

	public Collection&lt;CNAbility&gt; getCNAbilities(Category&lt;Ability&gt; cat, Nature n)
	{
<span class="nc bnc" id="L9773" title="All 2 branches missed.">		if (!cat.getParentCategory().equals(cat))</span>
		{
<span class="nc" id="L9775">			throw new IllegalArgumentException(&quot;Category for getCNAbilities must be parent category&quot;);</span>
		}
<span class="nc" id="L9777">		return new HashSet&lt;&gt;(grantedAbilityFacet.getCNAbilities(id, cat, n));</span>
	}

	public List&lt;?&gt; getDetailedAssociations(ChooseDriver cd)
	{
<span class="fc" id="L9782">		ChooseInformation&lt;?&gt; chooseInfo = cd.getChooseInfo();</span>
<span class="fc" id="L9783">		return chooseInfo.getChoiceActor().getCurrentlySelected(cd, this);</span>
	}

	public List&lt;CNAbility&gt; getMatchingCNAbilities(Ability ability)
	{
<span class="fc" id="L9788">		return new ArrayList&lt;&gt;(grantedAbilityFacet.getCNAbilities(id, ability));</span>
	}

	public List&lt;CNAbility&gt; getCNAbilities(Category&lt;Ability&gt; cat)
	{
<span class="nc bnc" id="L9793" title="All 2 branches missed.">		if (!cat.getParentCategory().equals(cat))</span>
		{
<span class="nc" id="L9795">			throw new IllegalArgumentException(&quot;Category for getCNAbilities must be parent category, was: &quot; + cat);</span>
		}
<span class="nc" id="L9797">		return new ArrayList&lt;&gt;(grantedAbilityFacet.getCNAbilities(id, cat));</span>
	}

	public List&lt;CNAbility&gt; getPoolAbilities(Category&lt;Ability&gt; cat)
	{
<span class="nc" id="L9802">		return new ArrayList&lt;&gt;(grantedAbilityFacet.getPoolAbilities(id, cat));</span>
	}

	public Collection&lt;CNAbility&gt; getPoolAbilities(Category&lt;Ability&gt; cat, Nature n)
	{
<span class="nc" id="L9807">		return new HashSet&lt;&gt;(grantedAbilityFacet.getPoolAbilities(id, cat, n));</span>
	}

	public Collection&lt;CNAbilitySelection&gt; getSaveAbilities()
	{
<span class="nc" id="L9812">		return svAbilityFacet.getSet(id);</span>
	}

	public CNAbility getBonusLanguageAbility()
	{
<span class="nc" id="L9817">		return bonusLanguageAbility;</span>
	}

	public void setAllowInteraction(boolean b)
	{
<span class="nc bnc" id="L9822" title="All 4 branches missed.">		if (!b &amp;&amp; !allowInteraction)</span>
		{
<span class="nc" id="L9824">			Logging.errorPrint(&quot;Internal Error: Re-entrant prohibition of interaction&quot;);</span>
		}
<span class="nc" id="L9826">		allowInteraction = b;</span>
<span class="nc" id="L9827">	}</span>

	public boolean isAllowInteraction()
	{
<span class="fc" id="L9831">		return allowInteraction;</span>
	}

	public void associateSelection(AbilitySelection as, CNAbilitySelection cnas)
	{
<span class="nc" id="L9836">		astocnasFacet.set(id, as, cnas);</span>
<span class="nc" id="L9837">	}</span>

	public CNAbilitySelection getAssociatedSelection(AbilitySelection as)
	{
<span class="nc" id="L9841">		return astocnasFacet.get(id, as);</span>
	}

	public void addSavedAbility(CNAbilitySelection cnas, Object owner, Object location)
	{
<span class="nc" id="L9846">		svAbilityFacet.add(id, cnas);</span>
<span class="nc" id="L9847">		addAbility(cnas, owner, location);</span>
<span class="nc" id="L9848">	}</span>

	public void addAbility(CNAbilitySelection cnas, @SuppressWarnings(&quot;UnusedParameters&quot;)
	final Object owner, Object location)
	{
		//TODO Need to handle owner
<span class="nc bnc" id="L9854" title="All 2 branches missed.">		if (cnas.hasPrerequisites())</span>
		{
<span class="nc" id="L9856">			conditionalFacet.add(id, cnas, location);</span>
		}
		else
		{
<span class="nc" id="L9860">			directAbilityFacet.add(id, cnas, location);</span>
		}
<span class="nc bnc" id="L9862" title="All 2 branches missed.">		if (!importing)</span>
		{
<span class="nc" id="L9864">			AbilityUtilities.finaliseAbility(this, cnas);</span>
		}
<span class="nc" id="L9866">	}</span>

	public void removeAbility(CNAbilitySelection cnas, @SuppressWarnings(&quot;UnusedParameters&quot;) Object owner,
		Object location)
	{
		//TODO Need to handle owner
<span class="nc bnc" id="L9872" title="All 2 branches missed.">		if (cnas.hasPrerequisites())</span>
		{
<span class="nc" id="L9874">			conditionalFacet.remove(id, cnas, location);</span>
		}
		else
		{
<span class="nc" id="L9878">			directAbilityFacet.remove(id, cnas, location);</span>
		}
<span class="nc" id="L9880">		CDOMObjectUtilities.removeAdds(cnas.getCNAbility().getAbility(), this);</span>
<span class="nc" id="L9881">		setDirty(true);</span>
<span class="nc" id="L9882">		calcActiveBonuses();</span>
<span class="nc" id="L9883">	}</span>

	public void removeSavedAbility(CNAbilitySelection cnas, Object owner, Object location)
	{
<span class="nc" id="L9887">		svAbilityFacet.remove(id, cnas);</span>
<span class="nc" id="L9888">		removeAbility(cnas, owner, location);</span>
<span class="nc" id="L9889">	}</span>

	public List&lt;String&gt; getConsolidatedAssociationList(CDOMObject cdo)
	{
<span class="nc bnc" id="L9893" title="All 2 branches missed.">		if (cdo instanceof Ability)</span>
		{
<span class="nc" id="L9895">			List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L9896">			List&lt;CNAbility&gt; cnabilities = getMatchingCNAbilities((Ability) cdo);</span>
<span class="nc bnc" id="L9897" title="All 2 branches missed.">			for (CNAbility cna : cnabilities)</span>
			{
<span class="nc" id="L9899">				list.addAll(getAssociationList(cna));</span>
<span class="nc" id="L9900">			}</span>
<span class="nc" id="L9901">			return list;</span>
		}
<span class="nc bnc" id="L9903" title="All 2 branches missed.">		else if (cdo instanceof ChooseDriver)</span>
		{
<span class="nc" id="L9905">			return getAssociationList((ChooseDriver) cdo);</span>
		}
		else
		{
			//Can't really do a message here because this is heavily done by BonusManager
			//			Logging
			//				.errorPrint(&quot;Consolidated Association List requested for object of type &quot;
			//					+ cdo.getClass() + &quot; but it is not a ChooseDriver&quot;);
<span class="nc" id="L9913">			return Collections.emptyList();</span>
		}
	}

	public boolean hasAbilityInPool(AbilityCategory aCategory)
	{
<span class="nc" id="L9919">		return grantedAbilityFacet.hasAbilityInPool(id, aCategory);</span>
	}

	public Object getGlobal(String varName)
	{
<span class="nc" id="L9924">		return resultFacet.getGlobalVariable(id, varName);</span>
	}

	public Object getLocal(CDOMObject owner, String varName)
	{
<span class="nc" id="L9929">		return resultFacet.getLocalVariable(id, owner, varName);</span>
	}

	public String getControl(String string)
	{
<span class="fc" id="L9934">		return controller.get(ObjectKey.getKeyFor(String.class, '*' + string));</span>
	}

	/**
	 * Returns the value of a CodeControl, or the default value if the code control has
	 * not been set in the data.
	 *
	 * @param control
	 *            The CodeControl for which the value should be returned
	 * @return The value of a CodeControl, or the default value if the code control has
	 *         not been set in the data
	 */
	public String getControl(CControl control)
	{
<span class="fc" id="L9948">		ObjectKey&lt;String&gt; ok = ObjectKey.getKeyFor(String.class,</span>
<span class="fc" id="L9949">			&quot;*&quot; + Objects.requireNonNull(control.getName()));</span>
<span class="fc" id="L9950">		return Optional.ofNullable(controller.get(ok))</span>
<span class="fc" id="L9951">			.orElse(control.getDefaultValue());</span>
	}

	public boolean hasControl(String string)
	{
<span class="nc bnc" id="L9956" title="All 2 branches missed.">		return controller.get(ObjectKey.getKeyFor(String.class, '*' + string)) != null;</span>
	}

	/**
	 * Returns true if a feature code control is enabled.
	 *
	 * @param feature
	 *            The feature code control for which the value should be returned
	 * @return true if a feature code control is enabled; false otherwise
	 */
	public boolean isFeatureEnabled(String feature)
	{
<span class="fc" id="L9968">		Boolean object = controller.get(ObjectKey.getKeyFor(Boolean.class,</span>
<span class="fc" id="L9969">			&quot;*&quot; + Objects.requireNonNull(feature)));</span>
<span class="pc bpc" id="L9970" title="1 of 4 branches missed.">		return (object != null) &amp;&amp; object;</span>
	}

	/**
	 * Directly solves the given NEPFormula in context to this PlayerCharacter.
	 *
	 * @param formula
	 *            The NEPFormula to be solved
	 * @return The result of solving the given NEPFormula in context to this
	 *         PlayerCharacter
	 */
	public &lt;T&gt; T solve(NEPFormula&lt;T&gt; formula)
	{
<span class="nc" id="L9983">		return solverManagerFacet.get(id).solve(formula);</span>
	}

	/**
	 *
	 * @return the racial size
	 */
	public int racialSizeInt()
	{
<span class="nc" id="L9992">		return sizeFacet.racialSizeInt(id);</span>
	}

	public String getGenderString()
	{
<span class="nc" id="L9997">		return genderFacet.getGender(id).toString();</span>
	}

	public Gender getGenderObject()
	{
<span class="nc" id="L10002">		return genderFacet.getGender(id);</span>
	}


	public void addPreviewSheetVar(String key, String value)
	{
<span class="nc" id="L10008">		setDirty(true);</span>
<span class="nc" id="L10009">		previewSheetVars.put(key, value);</span>
<span class="nc" id="L10010">	}</span>

	public String getPreviewSheetVar(String key)
	{
<span class="nc" id="L10014">		return previewSheetVars.get(key);</span>
	}

	public Map&lt;String, String&gt; getPreviewSheetVars()
	{
<span class="nc" id="L10019">		return previewSheetVars;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>