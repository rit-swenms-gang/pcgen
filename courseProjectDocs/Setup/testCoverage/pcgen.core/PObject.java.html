<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PObject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">PObject.java</span></div><h1>PObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Bryan McRoberts &lt;merton_monk@yahoo.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core;

import java.io.Serializable;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.StringJoiner;
import java.util.StringTokenizer;

import pcgen.base.lang.StringUtil;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.QualifyingObject;
import pcgen.cdom.enumeration.DataSetID;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.SourceFormat;
import pcgen.cdom.enumeration.StringKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.facet.FacetLibrary;
import pcgen.cdom.facet.HiddenTypeFacet;
import pcgen.core.analysis.OutputNameFormatting;
import pcgen.core.utils.KeyedListContainer;
import pcgen.persistence.lst.output.prereq.PrerequisiteWriter;
import pcgen.system.PCGenSettings;

/**
 * {@code PObject}&lt;br&gt;
 * This is the base class for several objects in the PCGen database.
 */
<span class="fc" id="L47">public class PObject extends CDOMObject</span>
		implements Cloneable, Serializable, Comparable&lt;Object&gt;, KeyedListContainer, QualifyingObject
{

<span class="fc" id="L51">	private HiddenTypeFacet hiddenTypeFacet = FacetLibrary.getFacet(HiddenTypeFacet.class);</span>

	/** Standard serialVersionUID for Serializable objects */
	private static final long serialVersionUID = 1;

<span class="fc" id="L56">	private final Class&lt;?&gt; myClass = getClass();</span>

	/* ************
	 * Methods
	 * ************/

	/**
	 * if a class implements the Cloneable interface then it should have a
	 * public&quot; 'clone ()' method It should be declared to throw
	 * CloneNotSupportedException', but subclasses do not need the &quot;throws&quot;
	 * declaration unless their 'clone ()' method will throw the exception
	 * Thus subclasses can decide to not support 'Cloneable' by implementing
	 * the 'clone ()' method to throw 'CloneNotSupportedException'
	 * If this rule were ignored and the parent did not have the &quot;throws&quot;
	 * declaration then subclasses that should not be cloned would be forced
	 * to implement a trivial 'clone ()' to satisfy inheritance
	 * final&quot; classes implementing 'Cloneable' should not be declared to
	 * throw 'CloneNotSupportedException&quot; because their implementation of
	 * clone ()' should be a fully functional method that will not
	 * throw the exception.
	 * @return cloned object
	 * @throws CloneNotSupportedException
	 */
	@Override
	public PObject clone() throws CloneNotSupportedException
	{
<span class="nc" id="L82">		return (PObject) super.clone();</span>
	}

	/**
	 * Compares the keys of the object.
	 */
	@Override
	public int compareTo(final Object obj)
	{
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (obj != null)</span>
		{
			//this should throw a ClassCastException for non-PObjects, like the Comparable interface calls for
<span class="nc" id="L94">			return this.getKeyName().compareToIgnoreCase(((PObject) obj).getKeyName());</span>
		}
<span class="nc" id="L96">		return 1;</span>
	}

	@Override
	public boolean equals(final Object obj)
	{
<span class="fc bfc" id="L102" title="All 4 branches covered.">		return obj instanceof PObject &amp;&amp; getKeyName().equalsIgnoreCase(((PObject) obj).getKeyName());</span>
	}

	//Temporarily commented out since unit tests are badly behaved, see COD#E-1895
	//	@Override
	//	public int hashCode()
	//	{
	//		return getKeyName().hashCode();
	//	}

	/**
	 * Set the name (sets keyname also)
	 * @param aString
	 */
	@Override
	public void setName(final String aString)
	{
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		if (!aString.endsWith(&quot;.MOD&quot;))</span>
		{
<span class="fc" id="L121">			super.setName(aString);</span>
<span class="fc" id="L122">			put(StringKey.KEY_NAME, aString);</span>
		}
<span class="fc" id="L124">	}</span>

	///////////////////////////////////////////////////////////////////////
	// Accessor(s) and Mutator(s)
	///////////////////////////////////////////////////////////////////////

	public final String getOutputName()
	{
<span class="nc" id="L132">		return OutputNameFormatting.getOutputName(this);</span>
	}

	/**
	 * Get the type of PObject
	 * 
	 * @return the type of PObject
	 */
	public String getType()
	{
<span class="nc" id="L142">		return StringUtil.join(getTrueTypeList(false), &quot;.&quot;);</span>
	}

	public final List&lt;Type&gt; getTrueTypeList(final boolean visibleOnly)
	{
<span class="fc" id="L147">		final List&lt;Type&gt; ret = getSafeListFor(ListKey.TYPE);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (visibleOnly)</span>
		{
<span class="nc bnc" id="L150" title="All 2 branches missed.">			for (Iterator&lt;Type&gt; it = ret.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L152">				DataSetID id = Globals.getContext().getDataSetID();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">				if (hiddenTypeFacet.contains(id, myClass, it.next()))</span>
				{
<span class="nc" id="L155">					it.remove();</span>
				}
<span class="nc" id="L157">			}</span>
		}
<span class="fc" id="L159">		return Collections.unmodifiableList(ret);</span>
	}

	/**
	 * If aType begins with an &amp;#34; (Exclamation Mark) the &amp;#34; will be
	 * removed before checking the type.
	 *
	 * @param aType
	 * @return Whether the item is of this type
	 * 
	 */
	@Override
	public boolean isType(final String aType)
	{
		final String myType;

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">		if (aType.isEmpty())</span>
		{
<span class="nc" id="L177">			return false;</span>
		}
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">		else if (aType.charAt(0) == '!')</span>
		{
<span class="nc" id="L181">			myType = aType.substring(1).toUpperCase();</span>
		}
<span class="pc bpc" id="L183" title="2 of 4 branches missed.">		else if (aType.startsWith(&quot;TYPE=&quot;) || aType.startsWith(&quot;TYPE.&quot;)) //$NON-NLS-1$ //$NON-NLS-2$</span>
		{
<span class="nc" id="L185">			myType = aType.substring(5).toUpperCase();</span>
		}
		else
		{
<span class="fc" id="L189">			myType = aType.toUpperCase();</span>
		}

		//
		// Must match all listed types in order to qualify
		//
<span class="fc" id="L195">		StringTokenizer tok = new StringTokenizer(myType, &quot;.&quot;);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">		while (tok.hasMoreTokens())</span>
		{
<span class="fc bfc" id="L198" title="All 2 branches covered.">			if (!containsInList(ListKey.TYPE, Type.getConstant(tok.nextToken())))</span>
			{
<span class="fc" id="L200">				return false;</span>
			}
		}
<span class="fc" id="L203">		return true;</span>
	}

	@Override
	public String toString()
	{
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (PCGenSettings.OPTIONS_CONTEXT.getBoolean(PCGenSettings.OPTION_SHOW_OUTPUT_NAME_FOR_OTHER_ITEMS, false))</span>
		{
<span class="nc" id="L211">			return getOutputName();</span>
		}

<span class="fc" id="L214">		return getDisplayName();</span>
	}

	/**
	 * @return true if the name of this item is Product Identity (i.e owned by the publisher)
	 */
	public boolean isNamePI()
	{
<span class="nc" id="L222">		return getSafe(ObjectKey.NAME_PI);</span>
	}

	/**
	 * Get the PCC text with the saved name
	 * @return the PCC text with the saved name
	 */
	public String getPCCText()
	{
<span class="nc" id="L231">		StringJoiner txt = new StringJoiner(&quot;\t&quot;);</span>
<span class="nc" id="L232">		txt.add(getDisplayName());</span>
<span class="nc" id="L233">		Globals.getContext().unparse(this).forEach(txt::add);</span>
<span class="nc" id="L234">		txt.add(PrerequisiteWriter.prereqsToString(this));</span>
<span class="nc" id="L235">		return txt.toString();</span>
	}

	public String getSource()
	{
<span class="nc" id="L240">		return SourceFormat.getFormattedString(this, Globals.getSourceDisplay(), true);</span>
	}

	public String getSourceForNodeDisplay()
	{
<span class="nc" id="L245">		return SourceFormat.getFormattedString(this, SourceFormat.LONG, false);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>