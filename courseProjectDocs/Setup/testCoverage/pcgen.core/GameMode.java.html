<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GameMode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">GameMode.java</span></div><h1>GameMode.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Greg Bingleman &lt;byngl@hotmail.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Stream;

import pcgen.base.util.HashMapToList;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.Loadable;
import pcgen.cdom.base.MasterListInterface;
import pcgen.cdom.content.ACControl;
import pcgen.cdom.content.RollMethod;
import pcgen.cdom.content.TabInfo;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.reference.ReferenceManufacturer;
import pcgen.cdom.reference.TransparentReference;
import pcgen.core.character.WieldCategory;
import pcgen.core.system.LoadInfo;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.rules.context.ConsolidatedListCommitStrategy;
import pcgen.rules.context.GameReferenceContext;
import pcgen.rules.context.LoadContext;
import pcgen.rules.context.RuntimeLoadContext;
import pcgen.rules.context.RuntimeReferenceContext;
import pcgen.rules.context.TrackingReferenceContext;
import pcgen.system.PCGenSettings;
import pcgen.system.PropertyContext;
import pcgen.util.Logging;
import pcgen.util.enumeration.Tab;

import org.apache.commons.lang3.StringUtils;

/**
 * Handles game modes.
 */
public final class GameMode implements Comparable&lt;Object&gt;
{
<span class="fc" id="L64">	private static PropertyContext prefsContext =</span>
<span class="fc" id="L65">			PCGenSettings.getInstance().createChildContext(&quot;gameMode&quot;); //$NON-NLS-1$</span>

<span class="fc" id="L67">	private PropertyContext gamemodePrefsContext = prefsContext.createChildContext(&quot;gameMode&quot;); //$NON-NLS-1$</span>
	private List&lt;String&gt; allowedModes;
<span class="fc" id="L69">	private List&lt;String&gt; bonusFeatLevels = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L70">	private List&lt;String&gt; bonusStackList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L71">	private List&lt;String&gt; bonusStatLevels = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L72">	private List&lt;String&gt; defaultDataSetList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L73">	private Map&lt;String, XPTable&gt; xpTableInfo = new HashMap&lt;&gt;();</span>
<span class="fc" id="L74">	private List&lt;String&gt; skillMultiplierLevels = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L75">	@Deprecated</span>
	private HashMapToList&lt;String, ACControl&gt; ACTypeAddMap = new HashMapToList&lt;&gt;();
<span class="fc" id="L77">	@Deprecated</span>
	private HashMapToList&lt;String, ACControl&gt; ACTypeRemoveMap = new HashMapToList&lt;&gt;();
	private Map&lt;Type, String&gt; plusCalcs;
<span class="fc" id="L80">	private Map&lt;String, String&gt; spellRangeMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L81">	private String acName = &quot;&quot;;</span>
<span class="fc" id="L82">	private String currencyUnitAbbrev = &quot;&quot;;</span>
<span class="fc" id="L83">	private String damageResistance = &quot;&quot;;</span>
<span class="fc" id="L84">	private String defaultSpellBook = &quot;Known Spells&quot;;</span>
<span class="fc" id="L85">	private String defaultUnitSet = Constants.STANDARD_UNITSET_NAME;</span>
<span class="fc" id="L86">	private UnitSet selectedUnitSet = null;</span>
	private String displayName;
	private final String folderName;
<span class="fc" id="L89">	private String levelUpMessage = &quot;&quot;;</span>
	private String name;
<span class="fc" id="L91">	private String spellBaseDC = &quot;0&quot;;</span>
<span class="fc" id="L92">	private String spellBaseConcentration = &quot;&quot;;</span>
<span class="fc" id="L93">	private List&lt;Type&gt; weaponCategories = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L94">	private Map&lt;Type, String&gt; weaponTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L95">	private String weaponReachFormula = &quot;&quot;;</span>
<span class="fc" id="L96">	private Map&lt;Integer, Integer&gt; xpAwardsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L97">	private Map&lt;Integer, String&gt; crStepsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L98">	private String crThreshold = null;</span>
<span class="fc" id="L99">	private String rankModFormula = &quot;&quot;;</span>
<span class="fc" id="L100">	private String addWithMetamagic = &quot;&quot;;</span>
<span class="fc" id="L101">	private boolean bonusStatAllowsStack = false;</span>
<span class="fc" id="L102">	private int babAttCyc = 5; //6</span>
<span class="fc" id="L103">	private int babMaxAtt = Integer.MAX_VALUE; //4</span>
<span class="fc" id="L104">	private int babMinVal = 1;</span>
<span class="fc" id="L105">	private int maxNonEpicLevel = Integer.MAX_VALUE;</span>
<span class="fc" id="L106">	private int displayOrder = Integer.MAX_VALUE;</span>

<span class="fc" id="L108">	private int skillCosts_Class = 1;</span>
<span class="fc" id="L109">	private int skillCost_CrossClass = 2;</span>
<span class="fc" id="L110">	private int skillCost_Exclusive = 0;</span>

<span class="fc" id="L112">	private String pointPoolName = &quot;&quot;;</span>

<span class="fc" id="L114">	private int nonProfPenalty = -4;</span>

<span class="fc" id="L116">	private double squareSize = 5;</span>

	/** no default distance for short range */
	private int shortRangeDistance;
	private int rangePenalty;

<span class="fc" id="L122">	private RollMethod activeRollMethod = null;</span>

<span class="fc" id="L124">	private SortedMap&lt;Integer, PointBuyCost&gt; pointBuyStatCosts = null;</span>
<span class="fc" id="L125">	private int[] abilityScoreCost = null;</span>
<span class="fc" id="L126">	private String purchaseMethodName = &quot;&quot;; //$NON-NLS-1$</span>

<span class="fc" id="L128">	private int rollMethod = Constants.CHARACTER_STAT_METHOD_USER;</span>

<span class="fc" id="L130">	private int allStatsValue = 10;</span>

	//
	// minimum and maximum stat values when creating new characters.
	//
<span class="fc" id="L135">	private int statMin = 3;</span>
<span class="fc" id="L136">	private int statMax = 18;</span>

<span class="fc" id="L138">	private TreeMap&lt;Integer, String&gt; statDisplayText = null;</span>
<span class="fc" id="L139">	private String statDisplayTextAppend = &quot;+&quot;;</span>
<span class="fc" id="L140">	private TreeMap&lt;Integer, String&gt; skillRankDisplayText = null;</span>

	private String thePreviewDir;
	private String theDefaultPreviewSheet;
	private String theInfoSheet;
	private String theInfoSheetSkill;

	private String outputSheetDirectory;
<span class="fc" id="L148">	private Map&lt;String, String&gt; outputSheetDefaultMap = new HashMap&lt;&gt;();</span>

	private int[] dieSizes;
<span class="fc" id="L151">	private int maxDieSize = 12;</span>
<span class="fc" id="L152">	private int minDieSize = 4;</span>

<span class="fc" id="L154">	private List&lt;Type&gt; resizableTypeList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L155">	private List&lt;String&gt; characterTypeList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L156">	private List&lt;String&gt; monsterRoleList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L157">	private String monsterRoleDefault = &quot;&quot;;</span>
<span class="fc" id="L158">	private Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; hiddenTypes = new HashMap&lt;&gt;();</span>

<span class="fc" id="L160">	private List&lt;String&gt; xpTableNames = new ArrayList&lt;&gt;();</span>
	private String defaultXPTableName;
	private String defaultCharacterType;

	/** The BioSet used for age calculations */
<span class="fc" id="L165">	private BioSet bioSet = new BioSet();</span>

<span class="fc" id="L167">	private Map&lt;String, String&gt; equipTypeIconMap = new HashMap&lt;&gt;();</span>

	/** Priority of the equipment types for icon use. */
<span class="fc" id="L170">	private Map&lt;String, Integer&gt; equipTypeIconPriorityMap = new HashMap&lt;&gt;();</span>

	/** A container for feat settings for this game mode. */
	private AbilityCategory featTemplate;

	/**
	 * Creates a new instance of GameMode.
	 *
	 * @param modeName the mode name
	 */
	public GameMode(final String modeName)
<span class="fc" id="L181">	{</span>
<span class="fc" id="L182">		name = modeName;</span>
<span class="fc" id="L183">		folderName = modeName;</span>
<span class="fc" id="L184">		displayName = modeName;</span>
<span class="fc" id="L185">		thePreviewDir = modeName;</span>
<span class="fc" id="L186">		theDefaultPreviewSheet = &quot;preview.html&quot;; //$NON-NLS-1$</span>
<span class="fc" id="L187">	}</span>

	/**
	 * Apply the stored preferences to the game mode. 
	 */
	public void applyPreferences()
	{
<span class="nc" id="L194">		gamemodePrefsContext = prefsContext.createChildContext(name);</span>
<span class="nc" id="L195">		String rollMethodExpr = gamemodePrefsContext.getProperty(&quot;rollMethodExpression&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		if (StringUtils.isNotBlank(rollMethodExpr))</span>
		{
<span class="nc" id="L198">			activeRollMethod = getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(RollMethod.class,</span>
				rollMethodExpr);
<span class="nc bnc" id="L200" title="All 2 branches missed.">			if (activeRollMethod == null)</span>
			{
<span class="nc" id="L202">				Logging.errorPrint(&quot;Could not find roll method '&quot; //$NON-NLS-1$</span>
					+ rollMethodExpr + &quot;' while loading game mode &quot; + name); //$NON-NLS-1$
			}
		}
<span class="nc" id="L206">		rollMethod = gamemodePrefsContext.getInt(&quot;rollMethod&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L207">		allStatsValue = gamemodePrefsContext.initInt(&quot;allStatsValue&quot;, 10); //$NON-NLS-1$</span>
<span class="nc" id="L208">		purchaseMethodName = gamemodePrefsContext.getProperty(&quot;purchaseMethodName&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L209">	}</span>

	/**
	 * Set the AC Text.
	 * @param aString
	 */
	public void setACText(final String aString)
	{
<span class="nc" id="L217">		acName = aString;</span>
<span class="nc" id="L218">	}</span>

	/**
	 * Add the AC Type as a string to the List.
	 * @param ACType
	 * @return List of AC Types
	 */
	@Deprecated
	public List&lt;ACControl&gt; getACTypeAddString(final String ACType)
	{
<span class="nc" id="L228">		return ACTypeAddMap.getListFor(ACType);</span>
	}

	/**
	 * Remove the AC Type as a string to the List.
	 * @param ACType
	 * @return List of AC Types
	 */
	@Deprecated
	public List&lt;ACControl&gt; getACTypeRemoveString(final String ACType)
	{
<span class="nc" id="L239">		return ACTypeRemoveMap.getListFor(ACType);</span>
	}

	/**
	 * Retrieve the correct case of the supplied ACType name. 
	 * @param acType The name to be found.
	 * @return The name in the correct case.
	 */
	@Deprecated
	public String getACTypeName(String acType)
	{
<span class="nc bnc" id="L250" title="All 4 branches missed.">		if (ACTypeAddMap.containsListFor(acType) || ACTypeRemoveMap.containsListFor(acType))</span>
		{
<span class="nc" id="L252">			return acType;</span>
		}
<span class="nc" id="L254">		return Stream.concat(ACTypeAddMap.getKeySet().stream(), ACTypeRemoveMap.getKeySet().stream()).</span>
<span class="nc" id="L255">				filter(acKey -&gt; acKey.equalsIgnoreCase(acType))</span>
<span class="nc" id="L256">		      .findFirst()</span>
<span class="nc" id="L257">		      .orElse(acType);</span>
	}


	/**
	 * Adds an Allowed Game Mode
	 */
	public void addAllowedMode(String modeName)
	{
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (allowedModes == null)</span>
		{
<span class="nc" id="L268">			allowedModes = new ArrayList&lt;&gt;();</span>
		}

<span class="nc" id="L271">		allowedModes.add(modeName);</span>
<span class="nc" id="L272">	}</span>

	/**
	 * Set BAB Minimum value
	 * @param arg
	 */
	public void setBabMinVal(final int arg)
	{
<span class="nc" id="L280">		babMinVal = arg;</span>
<span class="nc" id="L281">	}</span>

	/**
	 * Get BAB Minimum value.
	 * @return BAB Minimum value
	 */
	int getBabMinVal()
	{
<span class="nc" id="L289">		return babMinVal;</span>
	}

	/**
	 * Set Level at which you gain a bonus stat.
	 * @param aString
	 */
	public void setBonusStatLevels(final String aString)
	{
<span class="nc" id="L298">		bonusStatLevels.add(aString);</span>
<span class="nc" id="L299">	}</span>

	/**
	 * Get the class type by name.
	 * @param aClassKey
	 * @return ClassType
	 */
	public ClassType getClassTypeByName(final String aClassKey)
	{
<span class="fc bfc" id="L308" title="All 2 branches covered.">		if (aClassKey == null)</span>
		{
<span class="fc" id="L310">			return null;</span>
		}
<span class="fc" id="L312">		return getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(ClassType.class, aClassKey);</span>
	}

	/**
	 * Set the currency Unit abbreviation.
	 * @param aString
	 */
	public void setCurrencyUnitAbbrev(final String aString)
	{
<span class="nc" id="L321">		currencyUnitAbbrev = aString;</span>
<span class="nc" id="L322">	}</span>

	/**
	 * Set DR text.
	 * @param aString
	 */
	public void setDamageResistanceText(final String aString)
	{
<span class="nc" id="L330">		damageResistance = aString;</span>
<span class="nc" id="L331">	}</span>

	/**
	 * Set the default spell book.
	 * @param aString
	 */
	public void setDefaultSpellBook(final String aString)
	{
<span class="nc" id="L339">		defaultSpellBook = aString;</span>
<span class="nc" id="L340">	}</span>

	/**
	 * Define the default unit set for a game mode.
	 * @param aString
	 */
	public void setDefaultUnitSet(final String aString)
	{
<span class="nc" id="L348">		defaultUnitSet = aString;</span>
<span class="nc" id="L349">	}</span>

	/**
	 * Get the display name of the game mode.
	 * @return displayName
	 */
	public String getDisplayName()
	{
<span class="nc" id="L357">		return displayName;</span>
	}

	/**
	 * Used for Output sheets and GUI to order items in a list.
	 * @param aString
	 */
	public void setDisplayOrder(final String aString)
	{
		try
		{
<span class="nc" id="L368">			displayOrder = Integer.parseInt(aString);</span>
		}
<span class="nc" id="L370">		catch (NumberFormatException exc)</span>
		{
<span class="nc" id="L372">			Logging.errorPrint(&quot;Will use default for displayOrder: &quot; + displayOrder, exc);</span>
<span class="nc" id="L373">		}</span>
<span class="nc" id="L374">	}</span>

	/**
	 * Set the levels at which you gain bonus feats.
	 * @param aString
	 */
	public void setBonusFeatLevels(final String aString)
	{
<span class="fc" id="L382">		bonusFeatLevels.add(aString);</span>
<span class="fc" id="L383">	}</span>

	/**
	 * @return the folderName.
	 */
	public String getFolderName()
	{
<span class="nc" id="L390">		return folderName;</span>
	}

	/**
	 * Set the Rank Modifier Formula.
	 * @param aString
	 */
	public void setRankModFormula(final String aString)
	{
<span class="nc" id="L399">		rankModFormula = aString;</span>
<span class="nc" id="L400">	}</span>

	/**
	 * Obtain a map of LevelInfo objects.
	 *
	 * @param xpTableName the name of the XP table to be used
	 *
	 * @return level info map
	 */
	public XPTable getLevelInfo(final String xpTableName)
	{
<span class="fc" id="L411">		return xpTableInfo.get(xpTableName);</span>
	}

	/**
	 * Add new level info to an XP table.
	 *
	 * @param levInfo
	 */
	public void addLevelInfo(final String xpTableName, final LevelInfo levInfo)
	{
<span class="nc" id="L421">		XPTable xpTable = xpTableInfo.computeIfAbsent(xpTableName, XPTable::new);</span>
<span class="nc" id="L422">		xpTable.addLevelInfo(levInfo.getLevelString(), levInfo);</span>
<span class="nc" id="L423">	}</span>

	/**
	 * Set the level up message.
	 * @param aString
	 */
	public void setLevelUpMessage(final String aString)
	{
<span class="nc" id="L431">		levelUpMessage = aString;</span>
<span class="nc" id="L432">	}</span>

	/**
	 * Get the level up message.
	 * @return the level up message
	 */
	public String getLevelUpMessage()
	{
<span class="nc" id="L440">		return levelUpMessage;</span>
	}

	/**
	 * Set the game mode name.
	 * @param modeName The MENUENTRY value.
	 */
	public void setModeName(final String modeName)
	{
<span class="nc" id="L449">		displayName = modeName;</span>
<span class="nc" id="L450">	}</span>

	/**
	 * Get the game mode name.
	 * @return game mode name
	 */
	public String getName()
	{
<span class="fc" id="L458">		return name;</span>
	}

	/**
	 * Set the game mode name (aka key). Should not
	 * be used after game mode is loaded.
	 * @param name the name to set
	 */
	public void setName(String name)
	{
<span class="nc" id="L468">		this.name = name;</span>
<span class="nc" id="L469">	}</span>

	/**
	 * Get Plus calculation.
	 * @param type
	 * @return plus calculation
	 */
	String getPlusCalculation(Type type)
	{
<span class="nc" id="L478">		String aString = null;</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">		if (plusCalcs != null)</span>
		{
<span class="nc" id="L482">			aString = plusCalcs.get(type);</span>
		}

<span class="nc" id="L485">		return aString;</span>
	}

	/**
	 * Set the Short Range distance.
	 * @param aShortRange
	 */
	public void setShortRangeDistance(final int aShortRange)
	{
<span class="nc" id="L494">		shortRangeDistance = aShortRange;</span>
<span class="nc" id="L495">	}</span>

	/**
	 * Get the shortrange distance.
	 * @return the shortrange distance
	 */
	public int getShortRangeDistance()
	{
<span class="nc" id="L503">		return shortRangeDistance;</span>
	}

	/**
	 * Add a skill multiplier level.
	 */
	public void addSkillMultiplierLevel(String skillMult)
	{
<span class="nc" id="L511">		skillMultiplierLevels.add(skillMult);</span>
<span class="nc" id="L512">	}</span>

	/**
	 * Removes skill multiplier levels.
	 */
	public void removeSkillMultiplierLevels()
	{
<span class="nc" id="L519">		skillMultiplierLevels.clear();</span>
<span class="nc" id="L520">	}</span>

	/**
	 * Set the base DC for spells.
	 * @param arg
	 */
	public void setSpellBaseDC(final String arg)
	{
<span class="nc" id="L528">		spellBaseDC = arg;</span>
<span class="nc" id="L529">	}</span>

	/**
	 * Get the base DC for Spells.
	 * @return the base DC for Spells
	 */
	String getSpellBaseDC()
	{
<span class="nc" id="L537">		return spellBaseDC;</span>
	}

	/**
	 * Set the base concentration bonus for spells.
	 * @param arg
	 */
	public void setSpellBaseConcentration(final String arg)
	{
<span class="nc" id="L546">		spellBaseConcentration = arg;</span>
<span class="nc" id="L547">	}</span>

	/**
	 * Get the base concentration bonus for Spells.
	 * @return the base concentration bonus for Spells
	 */
	public String getSpellBaseConcentration()
	{
<span class="nc" id="L555">		return spellBaseConcentration;</span>
	}

	/**
	 * Adds a Spell Range
	 */
	public void addSpellRange(String aRange, String aFormula)
	{
<span class="nc" id="L563">		spellRangeMap.put(aRange, aFormula);</span>
<span class="nc" id="L564">	}</span>

	/**
	 * Returns the formula used for calculate the range of a spell.
	 * @param aRange
	 * @return spell range formula
	 */
	String getSpellRangeFormula(final String aRange)
	{
<span class="nc" id="L573">		String aString = null;</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (spellRangeMap != null)</span>
		{
<span class="nc" id="L577">			aString = spellRangeMap.get(aRange);</span>
		}

<span class="nc" id="L580">		return aString;</span>
	}

	/**
	 * Set the BAB Attack Bonus cycle.
	 * @param arg
	 */
	public void setBabAttCyc(final int arg)
	{
<span class="nc" id="L589">		babAttCyc = arg;</span>
<span class="nc" id="L590">	}</span>

	/**
	 * Get the BAB Attack Bonus cycle.
	 * @return the BAB Attack Bonus cycle
	 */
	int getBabAttCyc()
	{
<span class="nc" id="L598">		return babAttCyc;</span>
	}

	/**
	 * Set the maximum BAB attacks allowed.
	 * @param arg
	 */
	public void setBabMaxAtt(final int arg)
	{
<span class="nc" id="L607">		babMaxAtt = arg;</span>
<span class="nc" id="L608">	}</span>

	/**
	 * Get the max BAB attacks allowed.
	 * @return the max BAB attacks allowed
	 */
	int getBabMaxAtt()
	{
<span class="nc" id="L616">		return babMaxAtt;</span>
	}

	/**
	 * Get the weapon categories.
	 * @return the weapon categories
	 */
	public List&lt;Type&gt; getWeaponCategories()
	{
<span class="nc" id="L625">		return Collections.unmodifiableList(weaponCategories);</span>
	}

	/**
	 * Get the weapon types.
	 * @return the weapon types
	 */
	public Set&lt;Type&gt; getWeaponTypes()
	{
<span class="nc" id="L634">		return Collections.unmodifiableSet(weaponTypes.keySet());</span>
	}

	/**
	 * Gets the abbreviation for the given weapon Type.
	 * 
	 * @param type
	 *            The Type
	 * @return The abbreviation for the given Type
	 */
	public String getWeaponTypeAbbrev(Type type)
	{
<span class="nc" id="L646">		return weaponTypes.get(type);</span>
	}

	/**
	 * Get the weapon reach formula.
	 * @return String the weapon reach formula
	 * @deprecated due to EQREACH code control
	 */
	@Deprecated
	public String getWeaponReachFormula()
	{
<span class="nc" id="L657">		return this.weaponReachFormula;</span>
	}

	/**
	 * Get the XP awards.
	 * @return the XP awards
	 */
	public Map&lt;Integer, Integer&gt; getXPAwards()
	{
<span class="nc" id="L666">		return xpAwardsMap;</span>
	}

	/**
	 * Get the CR steps for CRs lower than CR 1.
	 * @return the CR steps
	 */
	public Map&lt;Integer, String&gt; getCRSteps()
	{
<span class="nc" id="L675">		return Collections.unmodifiableMap(crStepsMap);</span>
	}

	/**
	 * Get the internal Integer representation for a CR.
	 * @return the CR steps
	 */
	public Integer getCRInteger(String cr)
	{
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (cr.startsWith(&quot;1/&quot;))</span>
		{
<span class="nc" id="L686">			return crStepsMap.entrySet()</span>
<span class="nc" id="L687">			                 .stream()</span>
<span class="nc" id="L688">			                 .filter(entry -&gt; entry.getValue().equals(cr))</span>
<span class="nc" id="L689">			                 .findFirst()</span>
<span class="nc" id="L690">			                 .map(Map.Entry::getKey)</span>
<span class="nc" id="L691">			                 .orElse(null);</span>
		}
<span class="nc" id="L693">		return Integer.parseInt(cr);</span>
	}

	/**
	 * Get the CR steps for CRs lower than CR 1.
	 * @return the CR steps
	 */
	public String getCRThreshold()
	{
<span class="nc" id="L702">		return crThreshold;</span>
	}

	/**
	 * Return true if the AC Type is Valid.
	 * @param ACType
	 * @return true if the AC Type is Valid
	 */
	@Deprecated
	public boolean isValidACType(final String ACType)
	{
<span class="nc bnc" id="L713" title="All 4 branches missed.">		return ACTypeAddMap.containsListFor(ACType) || ACTypeRemoveMap.containsListFor(ACType);</span>
	}

	/**
	 * Appends to the ACTypeRemoveMap.
	 * @param ACType
	 * @param controls
	 */
	@Deprecated
	public void addACRemoves(final String ACType, Collection&lt;ACControl&gt; controls)
	{
<span class="nc" id="L724">		ACTypeRemoveMap.addAllToListFor(ACType, controls);</span>
<span class="nc" id="L725">	}</span>

	/**
	 * Appends to the ACTypeAddMap.
	 * @param ACType
	 * @param controls
	 */
	@Deprecated
	public void addACAdds(final String ACType, Collection&lt;ACControl&gt; controls)
	{
<span class="nc" id="L735">		ACTypeAddMap.addAllToListFor(ACType, controls);</span>
<span class="nc" id="L736">	}</span>

	/**
	 * Add a data set to the list of Default Data Sets.
	 * @param dataSetKey The key of the data set to add.
	 */
	public void addDefaultDataSet(final String dataSetKey)
	{
<span class="nc bnc" id="L744" title="All 2 branches missed.">		if (defaultDataSetList == null)</span>
		{
<span class="nc" id="L746">			defaultDataSetList = new ArrayList&lt;&gt;();</span>
		}

<span class="nc" id="L749">		defaultDataSetList.add(dataSetKey);</span>
<span class="nc" id="L750">	}</span>

	/**
	 * Empty the list of Default Data Sets.
	 */
	public void clearDefaultDataSetList()
	{
<span class="nc" id="L757">		defaultDataSetList.clear();</span>
<span class="nc" id="L758">	}</span>

	/**
	 * Add Plus calculation.
	 * @param type
	 * @param formula
	 */
	public void addPlusCalculation(Type type, String formula)
	{
<span class="nc bnc" id="L767" title="All 2 branches missed.">		if (plusCalcs == null)</span>
		{
<span class="nc" id="L769">			plusCalcs = new HashMap&lt;&gt;();</span>
		}

<span class="nc" id="L772">		plusCalcs.put(type, formula);</span>
<span class="nc" id="L773">	}</span>

	/**
	 * Add a Weapon Category.
	 * @param category
	 */
	public void addWeaponCategory(Type category)
	{
<span class="nc" id="L781">		weaponCategories.add(category);</span>
<span class="nc" id="L782">	}</span>

	/**
	 * Add a Weapon Type.
	 * @param type
	 * @param abbrev
	 */
	public void addWeaponType(Type type, String abbrev)
	{
<span class="nc" id="L791">		weaponTypes.put(type, abbrev);</span>
<span class="nc" id="L792">	}</span>

	/**
	 * Wield Categories.
	 * @param wCat
	 */
	public void addWieldCategory(final WieldCategory wCat)
	{
<span class="nc" id="L800">		getModeContext().getReferenceContext().importObject(wCat);</span>
<span class="nc" id="L801">	}</span>

	/**
	 * Adds an XP Award
	 */
	public void addXPaward(Integer crInteger, Integer value)
	{
<span class="nc" id="L808">		xpAwardsMap.put(crInteger, value);</span>
<span class="nc" id="L809">	}</span>

	/**
	 * Add the CR steps for CRs lower than CR 1.
	 */
	public void addCRstep(Integer index, String crstep)
	{
<span class="nc" id="L816">		crStepsMap.put(index, crstep);</span>
<span class="nc" id="L817">	}</span>

	/**
	 * Set the CR key class threshold.
	 * @param aString
	 */
	public void setCRThreshold(final String aString)
	{
<span class="nc" id="L825">		crThreshold = aString;</span>
<span class="nc" id="L826">	}</span>

	@Override
	public int compareTo(final Object obj)
	{
<span class="nc bnc" id="L831" title="All 2 branches missed.">		if (obj != null)</span>
		{
<span class="nc" id="L833">			final int iOrder = ((GameMode) obj).getDisplayOrder();</span>

<span class="nc bnc" id="L835" title="All 2 branches missed.">			if (iOrder &lt; displayOrder)</span>
			{
<span class="nc" id="L837">				return 1;</span>
			}
<span class="nc bnc" id="L839" title="All 2 branches missed.">			else if (iOrder &gt; displayOrder)</span>
			{
<span class="nc" id="L841">				return -1;</span>
			}

			//
			// Order matches, so put in alphabetical order
			//
			// should throw a ClassCastException for non-PObjects,
			// like the Comparable interface calls for
<span class="nc" id="L849">			return name.compareToIgnoreCase(((GameMode) obj).name);</span>
		}
<span class="nc" id="L851">		return 1;</span>
	}

	/**
	 * Set the weapon reach formula.
	 * @param aString	the new weapon reach formula
	 * @deprecated due to EQREACH code control
	 */
	@Deprecated
	public void setWeaponReachFormula(String aString)
	{
<span class="nc" id="L862">		this.weaponReachFormula = aString;</span>
<span class="nc" id="L863">	}</span>

	/**
	 * Answer the information about AC.
	 * @return AC text
	 */
	public String getACText()
	{
<span class="nc" id="L871">		return acName;</span>
	}

	public List&lt;String&gt; getAllowedModes()
	{
<span class="nc bnc" id="L876" title="All 2 branches missed.">		if (allowedModes == null)</span>
		{
<span class="nc" id="L878">			final List&lt;String&gt; modes = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L879">			modes.add(name);</span>

<span class="nc" id="L881">			return modes;</span>
		}

<span class="nc" id="L884">		return allowedModes;</span>
	}

	/**
	 * Levels at which all characters get bonus feats.
	 * @return List
	 */
	List&lt;String&gt; getBonusFeatLevels()
	{
<span class="nc" id="L893">		return bonusFeatLevels;</span>
	}

	/**
	 * Levels at which all characters get bonus to stats.
	 * @return List
	 */
	List&lt;String&gt; getBonusStatLevels()
	{
<span class="nc" id="L902">		return bonusStatLevels;</span>
	}

	/**
	 * Currency abbreviation.
	 * @return currency unit abbreviation
	 */
	public String getCurrencyDisplay()
	{
<span class="nc" id="L911">		return currencyUnitAbbrev;</span>
	}

	/**
	 * Get Damage Resistance Text.
	 * @return Get Damage Resistance Text
	 */
	public String getDamageResistanceText()
	{
<span class="nc" id="L920">		return damageResistance;</span>
	}

	/**
	 * Default spell book name.
	 * @return default spell book
	 */
	String getDefaultSpellBook()
	{
<span class="fc" id="L929">		return defaultSpellBook;</span>
	}

	/**
	 * Default unit set.
	 * @return default unit set
	 */
	String getDefaultUnitSet()
	{
<span class="fc" id="L938">		return defaultUnitSet;</span>
	}

	/**
	 * Gets the list of default data sets.
	 *
	 * @return the default data set list
	 */
	public List&lt;String&gt; getDefaultDataSetList()
	{
<span class="nc" id="L948">		return defaultDataSetList;</span>
	}

	/**
	 * Answer the preferred display order.
	 * @return default unit set
	 */
	int getDisplayOrder()
	{
<span class="nc" id="L957">		return displayOrder;</span>
	}

	public String getRankModFormula()
	{
<span class="nc" id="L962">		return rankModFormula;</span>
	}

	List&lt;String&gt; getSkillMultiplierLevels()
	{
<span class="nc" id="L967">		return skillMultiplierLevels;</span>
	}

	/**
	 * Set the range increment penalty for ranged weapons.
	 *
	 * @param value
	 *            For penalties set this to be a negative number, for bonuses to
	 *            long range set this to be a positive number, for no range
	 *            penalty set this to be 0
	 */
	public void setRangePenalty(int value)
	{
<span class="nc" id="L980">		rangePenalty = value;</span>
<span class="nc" id="L981">	}</span>

	/**
	 * Get the range penalty.
	 * @return range penalty
	 */
	public int getRangePenalty()
	{
<span class="nc" id="L989">		return rangePenalty;</span>
	}

	/**
	 * Set the cost for class skills
	 * @param value
	 */
	public void setSkillCost_Class(int value)
	{
<span class="nc" id="L998">		skillCosts_Class = value;</span>
<span class="nc" id="L999">	}</span>

	/**
	 * Set the cost for cross class skills.
	 * @param value
	 */
	public void setSkillCost_CrossClass(int value)
	{
<span class="nc" id="L1007">		skillCost_CrossClass = value;</span>
<span class="nc" id="L1008">	}</span>

	/**
	 * Set the cost for exclusive skills.
	 * @param value
	 */
	public void setSkillCost_Exclusive(int value)
	{
<span class="nc" id="L1016">		skillCost_Exclusive = value;</span>
<span class="nc" id="L1017">	}</span>

	/**
	 * Get the cost for class skills.
	 * @return cost for class skills
	 */
	public int getSkillCost_Class()
	{
<span class="nc" id="L1025">		return skillCosts_Class;</span>
	}

	/**
	 * Get the cost for cross class skills.
	 * @return cost for cross class skills
	 */

	public int getSkillCost_CrossClass()
	{
<span class="nc" id="L1035">		return skillCost_CrossClass;</span>
	}

	/**
	 * Get the cost for exclusive skills.
	 * @return cost for exclusive skills
	 */
	public int getSkillCost_Exclusive()
	{
<span class="nc" id="L1044">		return skillCost_Exclusive;</span>
	}

	/**
	 * Set the point pool name.
	 * @param argPoolName
	 */
	public void setPointPoolName(final String argPoolName)
	{
<span class="nc" id="L1053">		pointPoolName = argPoolName;</span>
<span class="nc" id="L1054">	}</span>

	/**
	 * Get the point pool name.
	 * @return point pool name
	 */
	String getPointPoolName()
	{
<span class="nc" id="L1062">		return pointPoolName;</span>
	}

	/**
	 * Set the penalty for non proficiency.
	 * @param argPenalty
	 */
	public void setNonProfPenalty(final int argPenalty)
	{
<span class="nc" id="L1071">		nonProfPenalty = argPenalty;</span>
<span class="nc" id="L1072">	}</span>

	/**
	 * Get the penalty for non proficiency.
	 * @return the penalty for non proficiency
	 */
	public int getNonProfPenalty()
	{
<span class="fc" id="L1080">		return nonProfPenalty;</span>
	}

	/**
	 * Set Add with meta magic message.
	 * @param argMsg
	 */
	public void setAddWithMetamagicMessage(final String argMsg)
	{
<span class="nc" id="L1089">		addWithMetamagic = argMsg;</span>
<span class="nc" id="L1090">	}</span>

	/**
	 * Get add with meta magic message.
	 * @return add with meta magic message
	 */
	public String getAddWithMetamagicMessage()
	{
<span class="nc" id="L1098">		return addWithMetamagic;</span>
	}

	/**
	 * Set square size.
	 * @param argSize
	 */
	public void setSquareSize(final double argSize)
	{
<span class="nc" id="L1107">		squareSize = argSize;</span>
<span class="nc" id="L1108">	}</span>

	/**
	 * Get square size.
	 * @return square size
	 */
	public double getSquareSize()
	{
<span class="nc" id="L1116">		return squareSize;</span>
	}

	/**
	 * Get the set unit.
	 * @return the unti that is set
	 */
	public UnitSet getUnitSet()
	{
<span class="nc" id="L1125">		return selectedUnitSet;</span>
	}

	/**
	 * Return true if the unit has been set.
	 * @param unitSetName
	 * @return true if the unit has been set
	 */
	public boolean selectUnitSet(final String unitSetName)
	{
<span class="fc" id="L1135">		final UnitSet ui =</span>
<span class="fc" id="L1136">				getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(UnitSet.class, unitSetName);</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">		if (ui == null)</span>
		{
<span class="fc" id="L1139">			return false;</span>
		}
<span class="nc" id="L1141">		selectedUnitSet = ui;</span>
<span class="nc" id="L1142">		return true;</span>
	}

	/**
	 * Return true if the default unit has been set.
	 * @return true if the unit has been set
	 */
	public boolean selectDefaultUnitSet()
	{
<span class="fc" id="L1151">		final UnitSet ui =</span>
<span class="fc" id="L1152">				getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(UnitSet.class, defaultUnitSet);</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">		if (ui == null)</span>
		{
<span class="fc" id="L1155">			return false;</span>
		}
<span class="nc" id="L1157">		selectedUnitSet = ui;</span>
<span class="nc" id="L1158">		return true;</span>
	}

	/**
	 * Add a PointBuyCost object to purchase mode stat costs.
	 * @param pbc
	 */
	public void addPointBuyStatCost(final PointBuyCost pbc)
	{
<span class="nc bnc" id="L1167" title="All 2 branches missed.">		if (pointBuyStatCosts == null)</span>
		{
			// Sort NUMERICALLY, not alphabetically!
<span class="nc" id="L1170">			pointBuyStatCosts = new TreeMap&lt;&gt;();</span>
		}
<span class="nc" id="L1172">		abilityScoreCost = null;</span>
<span class="nc" id="L1173">		pointBuyStatCosts.put(pbc.getStatValue(), pbc);</span>
<span class="nc" id="L1174">	}</span>

	/**
	 * Clear purchase mode stat costs.
	 */
	public void clearPointBuyStatCosts()
	{
<span class="nc" id="L1181">		pointBuyStatCosts = null;</span>
<span class="nc" id="L1182">		abilityScoreCost = null;</span>
<span class="nc" id="L1183">	}</span>

	/**
	 * Get the point buy by stat mapping.
	 * @return the point buy by stat mapping
	 */
	SortedMap&lt;Integer, PointBuyCost&gt; getPointBuyStatCostMap()
	{
<span class="nc" id="L1191">		return pointBuyStatCosts;</span>
	}

	/**
	 * Find a user-defined purchase method by name.
	 * @param methodName
	 * @return the purchase method or null
	 */
	public PointBuyMethod getPurchaseMethodByName(final String methodName)
	{
<span class="nc" id="L1201">		return getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(PointBuyMethod.class,</span>
			methodName);
	}

	/**
	 * Set the purchase mode method name.
	 * @param argMethodName
	 */
	public void setPurchaseMethodName(final String argMethodName)
	{
<span class="nc bnc" id="L1211" title="All 2 branches missed.">		if (!argMethodName.isEmpty())</span>
		{
<span class="nc" id="L1213">			setRollMethod(Constants.CHARACTER_STAT_METHOD_PURCHASE);</span>
		}

<span class="nc" id="L1216">		purchaseMethodName = argMethodName;</span>
<span class="nc" id="L1217">		gamemodePrefsContext.setProperty(&quot;purchaseMethodName&quot;, argMethodName); //$NON-NLS-1$</span>
<span class="nc" id="L1218">	}</span>

	/**
	 * Get the highest stat score that can be purchased free.
	 * @param aPC
	 * @return purchase mode base score
	 */
	@SuppressWarnings(&quot;PMD.OneDeclarationPerLine&quot;)
	public int getPurchaseModeBaseStatScore(final PlayerCharacter aPC)
	{
<span class="nc" id="L1228">		int minVal = getPurchaseScoreMin(aPC);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">		for (int i = 0, x = getPurchaseScoreMax() - getPurchaseScoreMin() + 1; i &lt; x; ++i)</span>
		{
<span class="nc bnc" id="L1231" title="All 2 branches missed.">			if (getAbilityScoreCost(i) == 0)</span>
			{
<span class="nc bnc" id="L1233" title="All 2 branches missed.">				if ((getPurchaseScoreMin() + i) &gt;= minVal)</span>
				{
<span class="nc" id="L1235">					return getPurchaseScoreMin() + i;</span>
				}
			}
		}

		//
		// Make sure that the minimum stat value is legal. This could happen if there are no
		// stat values that are considered to be free.
		//
<span class="nc bnc" id="L1244" title="All 2 branches missed.">		if (getPurchaseScoreMin() == minVal)</span>
		{
<span class="nc" id="L1246">			minVal -= 1;</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">			if (minVal &lt; statMin)</span>
			{
<span class="nc" id="L1249">				minVal = statMin;</span>
			}
		}

<span class="nc" id="L1253">		return minVal;</span>
	}

	/**
	 * Get the purchase mode method name.
	 * @return the purchase mode method name
	 */
	public String getPurchaseModeMethodName()
	{
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (!isPurchaseStatMode())</span>
		{
<span class="nc" id="L1264">			return null;</span>
		}

<span class="nc" id="L1267">		return purchaseMethodName;</span>
	}

	/**
	 * Get the purchase mode method pool formula.
	 * @return the purchase mode method pool formula
	 */
	public String getPurchaseModeMethodPoolFormula()
	{
<span class="nc bnc" id="L1276" title="All 2 branches missed.">		if (!isPurchaseStatMode())</span>
		{
<span class="nc" id="L1278">			return &quot;-1&quot;;</span>
		}

<span class="nc" id="L1281">		return getPurchaseMethodByName(purchaseMethodName).getPointFormula();</span>
	}

	/**
	 * Get the highest stat value in the purchase mode stat table.
	 * @return purchase mode maximum
	 */
	public int getPurchaseScoreMax()
	{
<span class="nc bnc" id="L1290" title="All 2 branches missed.">		if (pointBuyStatCosts == null)</span>
		{
<span class="nc" id="L1292">			return -1;</span>
		}

<span class="nc" id="L1295">		return pointBuyStatCosts.lastKey();</span>
	}

	/**
	 * Get the maximum score you can purchase.
	 * @param pc
	 * @return the maximum score you can purchase
	 */
	public int getPurchaseScoreMax(final PlayerCharacter pc)
	{
<span class="nc bnc" id="L1305" title="All 2 branches missed.">		if (pc == null)</span>
		{
<span class="nc" id="L1307">			return getPurchaseScoreMax();</span>
		}

<span class="nc" id="L1310">		int lastStat = -1;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">		if (pointBuyStatCosts != null)</span>
		{
<span class="nc bnc" id="L1313" title="All 2 branches missed.">			for (Integer statValue : pointBuyStatCosts.keySet())</span>
			{
<span class="nc" id="L1315">				final PointBuyCost pbc = pointBuyStatCosts.get(statValue);</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">				if (pbc.qualifies(pc, null))</span>
				{
<span class="nc" id="L1318">					lastStat = statValue;</span>
				}
<span class="nc" id="L1320">			}</span>
		}
<span class="nc" id="L1322">		return lastStat;</span>
	}

	/**
	 * Get the lowest stat value in the purchase mode stat table.
	 * @return purchase score minimum
	 */
	public int getPurchaseScoreMin()
	{
<span class="nc bnc" id="L1331" title="All 2 branches missed.">		if (pointBuyStatCosts == null)</span>
		{
<span class="nc" id="L1333">			return -1;</span>
		}

<span class="nc" id="L1336">		return pointBuyStatCosts.firstKey();</span>
	}

	/**
	 * Get the minimum score you can purchase.
	 * @param pc
	 * @return the minimum score you can purchase
	 */
	public int getPurchaseScoreMin(final PlayerCharacter pc)
	{
<span class="nc bnc" id="L1346" title="All 2 branches missed.">		if (pc == null)</span>
		{
<span class="nc" id="L1348">			return getPurchaseScoreMin();</span>
		}

<span class="nc" id="L1351">		int lastStat = -1;</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">		if (pointBuyStatCosts != null)</span>
		{
<span class="nc bnc" id="L1354" title="All 2 branches missed.">			for (int statValue : pointBuyStatCosts.keySet())</span>
			{
<span class="nc" id="L1356">				final PointBuyCost pbc = pointBuyStatCosts.get(statValue);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">				if (pbc.qualifies(pc, null))</span>
				{
<span class="nc" id="L1359">					lastStat = statValue;</span>
<span class="nc" id="L1360">					break;</span>
				}
<span class="nc" id="L1362">			}</span>
		}
<span class="nc" id="L1364">		return lastStat;</span>
	}

	/**
	 * Returns true if we are in a stat purchase mode.
	 * @return true if we are in a stat purchase mode
	 */
	public boolean isPurchaseStatMode()
	{
		// Can't have purchase mode if no costs specified
<span class="pc bpc" id="L1374" title="3 of 4 branches missed.">		if ((pointBuyStatCosts == null) || (pointBuyStatCosts.isEmpty())</span>
<span class="nc bnc" id="L1375" title="All 4 branches missed.">			|| (getRollMethod() != Constants.CHARACTER_STAT_METHOD_PURCHASE) || (purchaseMethodName.isEmpty()))</span>
		{
<span class="fc" id="L1377">			return false;</span>
		}

<span class="nc bnc" id="L1380" title="All 2 branches missed.">		return getPurchaseMethodByName(purchaseMethodName) != null;</span>
	}

	/**
	 *
	 * @param argRollMethod
	 */
	public void setRollMethod(final int argRollMethod)
	{
<span class="nc" id="L1389">		rollMethod = argRollMethod;</span>
<span class="nc" id="L1390">		gamemodePrefsContext.setInt(&quot;rollMethod&quot;, argRollMethod); //$NON-NLS-1$</span>

<span class="nc bnc" id="L1392" title="All 2 branches missed.">		if (argRollMethod != Constants.CHARACTER_STAT_METHOD_PURCHASE)</span>
		{
<span class="nc" id="L1394">			setPurchaseMethodName(&quot;&quot;); //$NON-NLS-1$</span>
		}
<span class="nc" id="L1396">	}</span>

	/**
	 *
	 * @return roll method
	 */
	public int getRollMethod()
	{
<span class="fc" id="L1404">		return rollMethod;</span>
	}

	/**
	 * Get the cost for an ability score.
	 * @return the cost for an ability score
	 */
	public int[] getAbilityScoreCost()
	{
<span class="nc bnc" id="L1413" title="All 2 branches missed.">		if (!isPurchaseStatModeAllowed())</span>
		{
			//better to return a Zero length array than null.
<span class="nc" id="L1416">			return null;</span>
		}

		// Only build this list once
<span class="nc bnc" id="L1420" title="All 2 branches missed.">		if (abilityScoreCost != null)</span>
		{
<span class="nc" id="L1422">			return abilityScoreCost;</span>
		}
											// Should be 1 value for each stat in range
<span class="nc" id="L1425">		abilityScoreCost = new int[getPurchaseScoreMax() - getPurchaseScoreMin() + 1];</span>
<span class="nc" id="L1426">		int i = 0;</span>
<span class="nc" id="L1427">		int lastStat = Integer.MIN_VALUE;</span>
<span class="nc" id="L1428">		int lastCost = 0;</span>

<span class="nc bnc" id="L1430" title="All 2 branches missed.">		for (int statValue : pointBuyStatCosts.keySet())</span>
		{
			// Fill in any holes in the stat list by using the previous stat cost
<span class="nc bnc" id="L1433" title="All 4 branches missed.">			if ((lastStat != Integer.MIN_VALUE) &amp;&amp; (lastStat + 1 != statValue))</span>
			{
<span class="nc bnc" id="L1435" title="All 2 branches missed.">				for (int x = lastStat + 1; x &lt; statValue; ++x)</span>
				{
<span class="nc" id="L1437">					abilityScoreCost[i++] = lastCost;</span>
				}
			}

<span class="nc" id="L1441">			final int statCost = pointBuyStatCosts.get(statValue).getBuyCost();</span>
<span class="nc" id="L1442">			lastStat = statValue;</span>
<span class="nc" id="L1443">			lastCost = statCost;</span>
<span class="nc" id="L1444">			abilityScoreCost[i++] = lastCost;</span>
<span class="nc" id="L1445">		}</span>

<span class="nc" id="L1447">		return abilityScoreCost;</span>
	}

	/**
	 * Get the cost for an ability score.
	 * @param abilityScoreIndex
	 * @return the cost for an ability score
	 */
	public int getAbilityScoreCost(final int abilityScoreIndex)
	{
<span class="nc" id="L1457">		final int[] asc = getAbilityScoreCost();</span>

<span class="nc bnc" id="L1459" title="All 2 branches missed.">		if (asc == null)</span>
		{
<span class="nc" id="L1461">			return 0;</span>
		}

<span class="nc" id="L1464">		return asc[abilityScoreIndex];</span>
	}

	/**
	 * Set the roll method expression by name.
	 * @param aString
	 */
	public void setRollMethodExpressionByName(final String aString)
	{
<span class="nc" id="L1473">		activeRollMethod =</span>
<span class="nc" id="L1474">				getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(RollMethod.class, aString);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">		if (activeRollMethod == null)</span>
		{
<span class="nc" id="L1477">			setRollMethod(Constants.CHARACTER_STAT_METHOD_USER);</span>
		}
		else
		{
<span class="nc" id="L1481">			setRollMethod(Constants.CHARACTER_STAT_METHOD_ROLLED);</span>
		}
<span class="nc" id="L1483">		gamemodePrefsContext.setProperty(&quot;rollMethodExpression&quot;, aString); //$NON-NLS-1$</span>
<span class="nc" id="L1484">	}</span>

	/**
	 * Get the cost for an ability score.
	 * @return the cost for an ability score
	 */
	public String getRollMethodExpression()
	{
<span class="nc bnc" id="L1492" title="All 2 branches missed.">		if (activeRollMethod != null)</span>
		{
<span class="nc" id="L1494">			return activeRollMethod.getMethodRoll();</span>
		}
<span class="nc" id="L1496">		return &quot;&quot;;</span>
	}

	/**
	 * Get roll method expression name.
	 * @return roll method expression name
	 */
	public String getRollMethodExpressionName()
	{
<span class="nc bnc" id="L1505" title="All 2 branches missed.">		if (activeRollMethod != null)</span>
		{
<span class="nc" id="L1507">			return activeRollMethod.getDisplayName();</span>
		}
<span class="nc" id="L1509">		return &quot;&quot;;</span>
	}

	/**
	 * Return true if the purchasing of stats mode is allowed.
	 * @return true if the purchasing of stats mode is allowed
	 */
	private boolean isPurchaseStatModeAllowed()
	{
<span class="nc bnc" id="L1518" title="All 4 branches missed.">		return !((pointBuyStatCosts == null) || (pointBuyStatCosts.isEmpty()));</span>
	}

	/**
	 * Set the value for all stats.
	 * @param argAllStatsValue
	 */
	public void setAllStatsValue(final int argAllStatsValue)
	{
<span class="nc" id="L1527">		allStatsValue = argAllStatsValue;</span>
<span class="nc" id="L1528">		gamemodePrefsContext.setInt(&quot;allStatsValue&quot;, argAllStatsValue); //$NON-NLS-1$</span>
<span class="nc" id="L1529">	}</span>

	/**
	 * Get the value of all stats.
	 * @return the value of all stats
	 */
	public int getAllStatsValue()
	{
<span class="nc" id="L1537">		return allStatsValue;</span>
	}

	/**
	 * Returns the currently set rolling method for character stats.
	 *
	 * @return RollMethod the current rolling method
	 */
	public RollMethod getCurrentRollingMethod()
	{
<span class="fc" id="L1547">		return activeRollMethod;</span>
	}

	/**
	 * Set the minimum stat.
	 * @param argMin
	 */
	public void setStatMin(final int argMin)
	{
<span class="nc" id="L1556">		statMin = argMin;</span>
<span class="nc" id="L1557">	}</span>

	/**
	 * Get the minimum stat.
	 * @return minimum stat
	 */
	public int getStatMin()
	{
<span class="nc" id="L1565">		return statMin;</span>
	}

	/**
	 * Set the maximum stat.
	 * @param argMax
	 */
	public void setStatMax(final int argMax)
	{
<span class="nc" id="L1574">		statMax = argMax;</span>
<span class="nc" id="L1575">	}</span>

	/**
	 * Get the maximum stat.
	 * @return maximum stat
	 */
	public int getStatMax()
	{
<span class="nc" id="L1583">		return statMax;</span>
	}

	/**
	 * Add the display text for a stat.
	 * @param statValue
	 * @param statText
	 */
	public void addStatDisplayText(final int statValue, final String statText)
	{
<span class="nc bnc" id="L1593" title="All 2 branches missed.">		if (statDisplayText == null)</span>
		{
			// Sort NUMERICALLY, not alphabetically!
<span class="nc" id="L1596">			statDisplayText = new TreeMap&lt;&gt;();</span>
		}
<span class="nc" id="L1598">		statDisplayText.put(statValue, statText);</span>
<span class="nc" id="L1599">	}</span>

	/**
	 * Get the display text of a stat.
	 * @param statValue
	 * @return the display text of a stat
	 */
	public String getStatDisplayText(final int statValue)
	{
		String statText;
		//
		// If no alternate text available, then display the number only
		//
<span class="nc bnc" id="L1612" title="All 2 branches missed.">		if (statDisplayText == null)</span>
		{
<span class="nc" id="L1614">			statText = Integer.toString(statValue);</span>
		}
		else
		{
<span class="nc" id="L1618">			statText = statDisplayText.get(statValue);</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">			if (statText == null)</span>
			{
<span class="nc" id="L1621">				final int firstKey = statDisplayText.firstKey();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">				if (statValue &lt; firstKey)</span>
				{
<span class="nc" id="L1624">					statText = &quot;???&quot; + statValue + &quot;???&quot;;</span>
				}
				else
				{
<span class="nc" id="L1628">					final int lastKey = statDisplayText.lastKey();</span>

<span class="nc" id="L1630">					statText = getStatDisplayText(lastKey) + statDisplayTextAppend</span>
<span class="nc" id="L1631">						+ getStatDisplayText(statValue - lastKey);</span>
				}
			}
		}
<span class="nc" id="L1635">		return statText;</span>
	}

	/**
	 * Return true if the skill rank display text is there.
	 * @return true if the skill rank display text is there
	 */
	public boolean hasSkillRankDisplayText()
	{
<span class="nc bnc" id="L1644" title="All 2 branches missed.">		return skillRankDisplayText != null;</span>
	}

	/**
	 * Add display text for a skill rank.
	 * @param rankValue
	 * @param rankText
	 */
	public void addSkillRankDisplayText(final int rankValue, final String rankText)
	{
<span class="nc bnc" id="L1654" title="All 2 branches missed.">		if (skillRankDisplayText == null)</span>
		{
			// Sort NUMERICALLY, not alphabetically!
<span class="nc" id="L1657">			skillRankDisplayText = new TreeMap&lt;&gt;();</span>
		}
<span class="nc" id="L1659">		skillRankDisplayText.put(rankValue, rankText);</span>
<span class="nc" id="L1660">	}</span>

	/**
	 * Get display text for a skill rank.
	 * @param rankValue
	 * @return display text for a skill rank
	 */
	public String getSkillRankDisplayText(final int rankValue)
	{
		String rankText;
		//
		// If no alternate text available, then display the number only
		//
<span class="nc bnc" id="L1673" title="All 2 branches missed.">		if (skillRankDisplayText == null)</span>
		{
<span class="nc" id="L1675">			rankText = Integer.toString(rankValue);</span>
		}
		else
		{
<span class="nc" id="L1679">			rankText = skillRankDisplayText.get(rankValue);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">			if (rankText == null)</span>
			{
<span class="nc" id="L1682">				final int firstKey = skillRankDisplayText.firstKey();</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">				if (rankValue &lt; firstKey)</span>
				{
<span class="nc" id="L1685">					rankText = &quot;???&quot; + rankValue + &quot;???&quot;;</span>
				}
				else
				{
<span class="nc" id="L1689">					final int lastKey = skillRankDisplayText.lastKey();</span>

<span class="nc" id="L1691">					rankText = getSkillRankDisplayText(lastKey) + statDisplayTextAppend</span>
<span class="nc" id="L1692">						+ getSkillRankDisplayText(rankValue - lastKey);</span>
				}
			}
		}
<span class="nc" id="L1696">		return rankText;</span>
	}

	//BONUSSTACKLIST

	/**
	 * Add an item to the bonus stacking list.
	 * @param item
	 */
	public void addToBonusStackList(final String item)
	{
<span class="nc bnc" id="L1707" title="All 2 branches missed.">		if (!bonusStackList.contains(item))</span>
		{
<span class="nc" id="L1709">			bonusStackList.add(item);</span>
		}
<span class="nc" id="L1711">	}</span>

	/**
	 * Clears the bonus stacking list.
	 */
	public void clearBonusStacksList()
	{
<span class="nc" id="L1718">		bonusStackList.clear();</span>
<span class="nc" id="L1719">	}</span>

	/**
	 * Return an &lt;b&gt;unmodifiable&lt;/b&gt; version of the bonus stacking list.
	 * @return an &lt;b&gt;unmodifiable&lt;/b&gt; version of the bonus stacking list.
	 */
	List&lt;String&gt; getUnmodifiableBonusStackList()
	{
<span class="nc" id="L1727">		return Collections.unmodifiableList(bonusStackList);</span>
	}

	/**
	 * Gets the &lt;tt&gt;AbilityCategory&lt;/tt&gt; for the given key.
	 *
	 * @param aKey The key of the &lt;tt&gt;AbilityCategory&lt;/tt&gt; to retreive.
	 *
	 * @return The requested &lt;tt&gt;AbilityCategory&lt;/tt&gt; or &lt;tt&gt;null&lt;/tt&gt; if the
	 * category is not found in this game mode.
	 */
	public AbilityCategory getAbilityCategory(final String aKey)
	{
<span class="fc" id="L1740">		AbilityCategory ac = silentlyGetAbilityCategory(aKey);</span>
		// Empty aKey indicates return null because
		// PreAbilityTester.buildAbilityList uses that as a global
		// (all Category) getch
<span class="pc bpc" id="L1744" title="4 of 6 branches missed.">		if (aKey == null || (ac == null &amp;&amp; !aKey.isEmpty()))</span>
		{
<span class="nc" id="L1746">			Logging.errorPrint(&quot;Attempt to fetch AbilityCategory: &quot; + aKey + &quot;... but it does not exist&quot;);</span>
		}
<span class="fc" id="L1748">		return ac;</span>
	}

	private AbilityCategory silentlyGetAbilityCategory(final String aKey)
	{
<span class="fc" id="L1753">		AbilityCategory cat =</span>
<span class="fc" id="L1754">				getContext().getReferenceContext().silentlyGetConstructedCDOMObject(AbilityCategory.class, aKey);</span>
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">		if (cat != null)</span>
		{
<span class="fc" id="L1757">			return cat;</span>
		}
<span class="nc bnc" id="L1759" title="All 2 branches missed.">		if (AbilityCategory.LANGBONUS.getKeyName().equals(aKey))</span>
		{
<span class="nc" id="L1761">			return AbilityCategory.LANGBONUS;</span>
		}
<span class="nc" id="L1763">		return null;</span>
	}

	/**
	 * Returns a &lt;tt&gt;Collection&lt;/tt&gt; of &lt;tt&gt;AbilityCategory&lt;/tt&gt; objects defined
	 * by this game mode.
	 *
	 * @return A &lt;tt&gt;Collection&lt;/tt&gt; of &lt;tt&gt;AbilityCategory&lt;/tt&gt; objects.
	 */
	public Collection&lt;AbilityCategory&gt; getAllAbilityCategories()
	{
<span class="fc" id="L1774">		return getContext().getReferenceContext().getConstructedCDOMObjects(AbilityCategory.class);</span>
	}

	public void setPreviewDir(final String aDir)
	{
<span class="nc" id="L1779">		thePreviewDir = aDir;</span>
<span class="nc" id="L1780">	}</span>

	public void setDefaultPreviewSheet(final String aSheet)
	{
<span class="nc" id="L1784">		theDefaultPreviewSheet = aSheet;</span>
<span class="nc" id="L1785">	}</span>

	public String getDefaultPreviewSheet()
	{
<span class="fc" id="L1789">		return theDefaultPreviewSheet;</span>
	}

	/**
	 * Get's current gamemodes MaxDieSize.
	 * @return maxDieSize
	 */
	public int getMaxDieSize()
	{
<span class="nc" id="L1798">		return maxDieSize;</span>
	}

	/**
	 * Sets's current gamemodes MaxDieSize.
	 * @param dice
	 */
	public void setMaxDieSize(final int dice)
	{
<span class="nc" id="L1807">		maxDieSize = dice;</span>
<span class="nc" id="L1808">	}</span>

	/**
	 * Get's current gamemodes MinDieSize.
	 * @return minDieSize
	 */
	public int getMinDieSize()
	{
<span class="nc" id="L1816">		return minDieSize;</span>
	}

	/**
	 * Sets's current gamemodes MinDieSize.
	 * @param dice
	 */
	public void setMinDieSize(final int dice)
	{
<span class="nc" id="L1825">		minDieSize = dice;</span>
<span class="nc" id="L1826">	}</span>

	/**
	 * Get's current gamemodes DieSizes.
	 * @return dieSizes array
	 */
	public int[] getDieSizes()
	{
<span class="nc" id="L1834">		return dieSizes;</span>
	}

	/**
	 * Set's DieSizes available for the gamemode.
	 * @param die The parsed integer diesizes
	 */
	public void setDieSizes(int[] die)
	{
<span class="nc" id="L1843">		this.dieSizes = die;</span>
<span class="nc" id="L1844">	}</span>

	/**
	 * Retrieve the list of equipment types which flag it as able to
	 * be resized by the automatic resize feature.
	 * @return the resizableTypeList
	 */
	List&lt;Type&gt; getResizableTypeList()
	{
<span class="nc" id="L1853">		return Collections.unmodifiableList(resizableTypeList);</span>
	}

	/**
	 * Set the list of equipment types which flag it as able to
	 * be resized by the automatic resize feature.
	 *
	 * @param resizableTypeList the resizableTypeList to set
	 */
	public void setResizableTypeList(List&lt;Type&gt; resizableTypeList)
	{
<span class="nc" id="L1864">		this.resizableTypeList = resizableTypeList;</span>
<span class="nc" id="L1865">	}</span>

	/**
	 * Retrieve the list of character types (e.g. PC or NPC).
	 * @return the characterTypeList
	 */
	public List&lt;String&gt; getCharacterTypeList()
	{
<span class="nc" id="L1873">		return Collections.unmodifiableList(characterTypeList);</span>
	}

	/**
	 * Set the list of character types (e.g. PC or NPC).
	 *
	 * @param characterTypeList the characterTypeList to set
	 */
	public void setCharacterTypeList(List&lt;String&gt; characterTypeList)
	{
<span class="nc" id="L1883">		this.characterTypeList = characterTypeList;</span>
<span class="nc" id="L1884">	}</span>

	/**
	 * Retrieve the list of monster roles.
	 * @return the monsterRoleList
	 */
	public List&lt;String&gt; getMonsterRoleList()
	{
<span class="nc" id="L1892">		return Collections.unmodifiableList(monsterRoleList);</span>
	}

	/**
	 * Set the list of known monster roles.
	 *
	 * @param monsterRoleList the monsterRoleList to set
	 */
	public void setMonsterRoleList(List&lt;String&gt; monsterRoleList)
	{
<span class="nc" id="L1902">		this.monsterRoleList = monsterRoleList;</span>
<span class="nc" id="L1903">	}</span>

	/**
	 * Retrieve the default monster role.
	 * @return the monsterRoleDefault
	 */
	public List&lt;String&gt; getMonsterRoleDefaultList()
	{
<span class="nc" id="L1911">		return new ArrayList&lt;&gt;(Collections.singletonList(monsterRoleDefault));</span>
	}

	/**
	 * Set the list of known monster roles.
	 *
	 * @param monsterRoleDefault the monsterRoleDefault to set.
	 */
	public void setMonsterRoleDefault(String monsterRoleDefault)
	{
<span class="nc" id="L1921">		this.monsterRoleDefault = monsterRoleDefault;</span>
<span class="nc" id="L1922">	}</span>

<span class="fc" id="L1924">	private ConsolidatedListCommitStrategy masterLCS = new ConsolidatedListCommitStrategy();</span>
<span class="fc" id="L1925">	private LoadContext context = new RuntimeLoadContext(getRefContext(), masterLCS);</span>
<span class="fc" id="L1926">	private GameReferenceContext gameRefContext = GameReferenceContext.createGameReferenceContext();</span>
<span class="fc" id="L1927">	private LoadContext modeContext = new RuntimeLoadContext(gameRefContext, masterLCS);</span>
	private String defaultSourceTitle;

	public void clearLoadContext()
	{
<span class="fc" id="L1932">		masterLCS = new ConsolidatedListCommitStrategy();</span>
<span class="fc" id="L1933">		AbstractReferenceContext referenceContext = getRefContext();</span>
<span class="fc" id="L1934">		resolveInto(referenceContext);</span>
<span class="fc" id="L1935">		context = new RuntimeLoadContext(referenceContext, masterLCS);</span>
<span class="fc" id="L1936">	}</span>

	/**
	 * Takes references and abbreviations that have been placed into the
	 * LoadContext for this GameMode and copies those references and
	 * abbreviations into the given ReferenceContext
	 * 
	 * @param referenceContext
	 *            The Reference Context into which the references from this
	 *            GameMode should be copied.
	 */
	public void resolveInto(AbstractReferenceContext referenceContext)
	{
<span class="fc" id="L1949">		gameRefContext.getAllManufacturers().forEach(rm -&gt; resolveReferenceManufacturer(referenceContext, rm));</span>
<span class="fc" id="L1950">	}</span>

	private AbstractReferenceContext getRefContext()
	{
<span class="fc bfc" id="L1954" title="All 2 branches covered.">		return SettingsHandler.inputUnconstructedMessages() ? TrackingReferenceContext.createTrackingReferenceContext()</span>
<span class="fc" id="L1955">			: RuntimeReferenceContext.createRuntimeReferenceContext();</span>
	}

	static &lt;T extends Loadable&gt; void resolveReferenceManufacturer(AbstractReferenceContext rc,
		ReferenceManufacturer&lt;T&gt; rm)
	{
<span class="fc" id="L1961">		String identityName = rm.getPersistentFormat();</span>
<span class="fc" id="L1962">		ReferenceManufacturer&lt;T&gt; mfg = rc.getManufacturerByFormatName(identityName, rm.getReferenceClass());</span>
		// If format fails, fall back to class
<span class="pc bpc" id="L1964" title="1 of 4 branches missed.">		if ((mfg == null) &amp;&amp; (identityName.indexOf('=') == -1))</span>
		{
<span class="fc" id="L1966">			Class&lt;T&gt; cl = rm.getReferenceClass();</span>
<span class="fc" id="L1967">			mfg = rc.getManufacturer(cl);</span>
		}
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">		if (mfg!=null) {</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">			for (CDOMReference&lt;T&gt; ref : rm.getAllReferences()) {</span>
<span class="nc" id="L1971">				((TransparentReference&lt;T&gt;) ref).resolve(mfg);</span>
<span class="nc" id="L1972">			}</span>
<span class="fc" id="L1973">			rm.injectConstructed(mfg);</span>
		}
		else
<span class="nc" id="L1976">			System.out.println(&quot;idname=&quot;+identityName+&quot; had a null mfg - skipping&quot;);</span>
<span class="fc" id="L1977">	}</span>

	public LoadContext getContext()
	{
<span class="fc" id="L1981">		return context;</span>
	}

	public LoadContext getModeContext()
	{
<span class="fc" id="L1986">		return modeContext;</span>
	}

	public MasterListInterface getMasterLists()
	{
<span class="fc" id="L1991">		return masterLCS;</span>
	}

	public void addHiddenType(Class&lt;?&gt; cl, String s)
	{
<span class="nc" id="L1996">		Set&lt;String&gt; set = hiddenTypes.computeIfAbsent(cl, k -&gt; new TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER));</span>
<span class="nc" id="L1997">		set.add(s);</span>
<span class="nc" id="L1998">	}</span>

	/**
	 * Gets the name of the currently selected default XP table.
	 *
	 * @return the XP table name
	 */
	public String getDefaultXPTableName()
	{
<span class="pc bpc" id="L2007" title="2 of 6 branches missed.">		if (defaultXPTableName == null || defaultXPTableName.isEmpty() || !xpTableNames.contains(defaultXPTableName))</span>
		{
<span class="fc bfc" id="L2009" title="All 2 branches covered.">			if (xpTableNames.isEmpty())</span>
			{
<span class="fc" id="L2011">				xpTableNames.add(&quot;Default&quot;);</span>
			}
<span class="fc" id="L2013">			defaultXPTableName = xpTableNames.get(0);</span>
		}
<span class="fc" id="L2015">		return defaultXPTableName;</span>
	}

	/**
	 * Sets the default experience table by name.
	 *
	 * @param xpTableName the new XP table name
	 */
	public void setDefaultXPTableName(String xpTableName)
	{
<span class="fc" id="L2025">		defaultXPTableName = xpTableName;</span>
<span class="fc" id="L2026">	}</span>

	/**
	 * Gets a list of names of all defined XP tables.
	 *
	 * @return the list of XP table names
	 */
	public List&lt;String&gt; getXPTableNames()
	{
<span class="nc" id="L2035">		return xpTableNames;</span>
	}

	/**
	 * Add a name for an XP tables.
	 *
	 * @param xpTableName the new XP table name
	 */
	public void addXPTableName(String xpTableName)
	{
<span class="nc" id="L2045">		xpTableNames.add(xpTableName);</span>
<span class="nc" id="L2046">	}</span>

	/**
	 * Gets the name of the currently selected default character type.
	 *
	 * @return the character type
	 */
	public String getDefaultCharacterType()
	{
<span class="pc bpc" id="L2055" title="1 of 4 branches missed.">		if (defaultCharacterType == null || defaultCharacterType.isEmpty()</span>
<span class="pc bpc" id="L2056" title="1 of 2 branches missed.">			|| !characterTypeList.contains(defaultCharacterType))</span>
		{
<span class="fc bfc" id="L2058" title="All 2 branches covered.">			if (characterTypeList.isEmpty())</span>
			{
<span class="fc" id="L2060">				characterTypeList.add(&quot;Default&quot;);</span>
			}
<span class="fc" id="L2062">			defaultCharacterType = characterTypeList.get(0);</span>
		}
<span class="fc" id="L2064">		return defaultCharacterType;</span>
	}

	/**
	 * Sets the default character type.
	 *
	 * @param characterType the new character type
	 */
	public void setDefaultCharacterType(String characterType)
	{
<span class="fc" id="L2074">		defaultCharacterType = characterType;</span>
<span class="fc" id="L2075">	}</span>

	/**
	 * Checks if bonus stat stacking is allowed.
	 *
	 * @return true, if is bonus stat stacking allowed
	 */
	public boolean isBonusStatAllowsStack()
	{
<span class="nc" id="L2084">		return bonusStatAllowsStack;</span>
	}

	/**
	 * Sets the bonus stat stacking allowed value.
	 *
	 * @param bonusStatAllowsStack the new bonus stat allows stack
	 */
	public void setBonusStatAllowsStack(boolean bonusStatAllowsStack)
	{
<span class="nc" id="L2094">		this.bonusStatAllowsStack = bonusStatAllowsStack;</span>
<span class="nc" id="L2095">	}</span>

	/**
	 *
	 * @return the bioSet
	 */
	public BioSet getBioSet()
	{
<span class="fc" id="L2103">		return bioSet;</span>
	}

	/**
	 *
	 * @param bioSet the bioSet to set
	 */
	public void setBioSet(BioSet bioSet)
	{
<span class="nc" id="L2112">		this.bioSet = bioSet;</span>
<span class="nc" id="L2113">	}</span>

	@Override
	public String toString()
	{
<span class="nc" id="L2118">		return name;</span>
	}

	/**
	 * Sets the title of the default source (used on the quick sources dialog).
	 *
	 * @param title the new title
	 */
	public void setDefaultSourceTitle(String title)
	{
<span class="nc" id="L2128">		this.defaultSourceTitle = title;</span>
<span class="nc" id="L2129">	}</span>

	/**
	 * Gets the default source title.
	 *
	 * @return the default source title
	 */
	public String getDefaultSourceTitle()
	{
<span class="nc" id="L2138">		return defaultSourceTitle;</span>
	}

	public String getTabName(Tab tab)
	{
<span class="nc" id="L2143">		TabInfo ti = getContext().getReferenceContext().silentlyGetConstructedCDOMObject(TabInfo.class, tab.toString());</span>
<span class="nc" id="L2144">		return ti.getResolvedName();</span>
	}

	public boolean getTabShown(Tab tab)
	{
<span class="nc" id="L2149">		TabInfo ti = getContext().getReferenceContext().silentlyGetConstructedCDOMObject(TabInfo.class, tab.toString());</span>
<span class="nc" id="L2150">		return ti.isVisible();</span>
	}

	public LoadInfo getLoadInfo()
	{
<span class="nc" id="L2155">		return getModeContext().getReferenceContext().silentlyGetConstructedCDOMObject(LoadInfo.class, getName());</span>
	}

	/**
	 *
	 * @return the file name of the InfoSheet relative to the base pcgen directory
	 */
	public String getInfoSheet()
	{
<span class="nc" id="L2164">		return theInfoSheet;</span>
	}

	/**
	 *
	 * @param theInfoSheet the file name of the InfoSheet relative to the base pcgen directory
	 */
	public void setInfoSheet(String theInfoSheet)
	{
<span class="nc" id="L2173">		this.theInfoSheet = theInfoSheet;</span>
<span class="nc" id="L2174">	}</span>

	/**
	 *
	 * @return the file name of the skill InfoSheet relative to the base pcgen directory
	 */
	public String getInfoSheetSkill()
	{
<span class="nc" id="L2182">		return theInfoSheetSkill;</span>
	}

	/**
	 *
	 * @param theInfoSheetSkill the file name of the skill InfoSheet relative to the base pcgen directory
	 */
	public void setInfoSheetSkill(String theInfoSheetSkill)
	{
<span class="nc" id="L2191">		this.theInfoSheetSkill = theInfoSheetSkill;</span>
<span class="nc" id="L2192">	}</span>

	/**
	 *
	 * @param theOutputSheetDirectory the directory for output sheets for the current game mode
	 */
	public void setOutputSheetDirectory(String theOutputSheetDirectory)
	{
<span class="nc" id="L2200">		this.outputSheetDirectory = theOutputSheetDirectory;</span>
<span class="nc" id="L2201">	}</span>

	/**
	 *
	 * @return the directory for output sheets for the current game mode
	 */
	public String getOutputSheetDirectory()
	{
<span class="nc" id="L2209">		return outputSheetDirectory;</span>
	}

	/**
	 *
	 * @param sheet the file name of the InfoSheet relative to the base pcgen directory
	 */
	public void setOutputSheetDefault(String type, String sheet)
	{
<span class="nc" id="L2218">		this.outputSheetDefaultMap.put(type, sheet);</span>
<span class="nc" id="L2219">	}</span>

	/**
	 *
	 * @return the directory for output sheets for the current game mode
	 */
	public String getOutputSheetDefault(String type)
	{
<span class="nc" id="L2227">		return outputSheetDefaultMap.get(type);</span>
	}

	/**
	 * Register an icon to be used for equipment of the listed type.
	 * @param equipType The equipment type
	 * @param iconPath The path relative to the pcgen folder of the icon.
	 * @param priority The importance of this icon, higher means more important
	 */
	public void setEquipTypeIcon(String equipType, String iconPath, int priority)
	{
<span class="nc" id="L2238">		this.equipTypeIconMap.put(equipType.toUpperCase(), iconPath);</span>
<span class="nc" id="L2239">		this.equipTypeIconPriorityMap.put(equipType.toUpperCase(), priority);</span>
<span class="nc" id="L2240">	}</span>

	/**
	 * Retrieve the default icon to be used for equipment of the listed type.
	 * @param equipType The equipment type
	 * @return The path relative to the pcgen folder of the icon, null if none exists.
	 */
	public String getEquipTypeIcon(String equipType)
	{
<span class="nc" id="L2249">		return this.equipTypeIconMap.get(equipType.toUpperCase());</span>
	}

	/**
	 * Retrieve the priority of the listed type;s icon. A higher number means a higher 
	 * priority, generally the highest priority icon will be used.
	 * @param equipType The equipment type
	 * @return The priority, or 0 if none is known.
	 */
	int getEquipTypeIconPriority(String equipType)
	{
<span class="nc" id="L2260">		Integer priority = this.equipTypeIconPriorityMap.get(equipType.toUpperCase());</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">		return priority == null ? 0 : priority;</span>
	}

	public String getCharSheetDir()
	{
<span class="nc" id="L2266">		return thePreviewDir;</span>
	}

	public String getDefaultCharSheet()
	{
<span class="nc" id="L2271">		return getDefaultPreviewSheet();</span>
	}

	public String getHeightUnit()
	{
<span class="nc bnc" id="L2276" title="All 2 branches missed.">		return &quot;ftin&quot;.equals(getUnitSet().getHeightUnit()) ? &quot;inches&quot; : getUnitSet().getHeightUnit();</span>
	}

	public String getWeightUnit()
	{
<span class="nc" id="L2281">		return getUnitSet().getWeightUnit();</span>
	}

	AbilityCategory getFeatTemplate()
	{
<span class="fc" id="L2286">		return featTemplate;</span>
	}

	public void setFeatTemplate(AbilityCategory featTemplate)
	{
<span class="nc" id="L2291">		this.featTemplate = featTemplate;</span>
<span class="nc" id="L2292">	}</span>

	public void setMaxNonEpicLevel(int i)
	{
<span class="nc" id="L2296">		maxNonEpicLevel = i;</span>
<span class="nc" id="L2297">	}</span>

	public int getMaxNonEpicLevel()
	{
<span class="nc" id="L2301">		return maxNonEpicLevel;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>