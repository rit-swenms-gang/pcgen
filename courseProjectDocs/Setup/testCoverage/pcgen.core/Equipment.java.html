<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Equipment.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">Equipment.java</span></div><h1>Equipment.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Bryan McRoberts &lt;merton.monk@codemonkeypublishing.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.core;

import java.io.BufferedWriter;
import java.io.File;
import java.io.Serializable;
import java.math.BigDecimal;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import pcgen.base.formula.Formula;
import pcgen.base.lang.StringUtil;
import pcgen.base.util.FixedStringList;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.Constants;
import pcgen.cdom.base.PrereqObject;
import pcgen.cdom.enumeration.AssociationListKey;
import pcgen.cdom.enumeration.CharID;
import pcgen.cdom.enumeration.EqModFormatCat;
import pcgen.cdom.enumeration.EquipmentLocation;
import pcgen.cdom.enumeration.FormulaKey;
import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.StringKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.facet.FacetLibrary;
import pcgen.cdom.facet.analysis.ResultFacet;
import pcgen.cdom.formula.PCGenScoped;
import pcgen.cdom.helper.Capacity;
import pcgen.cdom.inst.EqSizePenalty;
import pcgen.cdom.inst.EquipmentHead;
import pcgen.cdom.processor.ChangeArmorType;
import pcgen.cdom.reference.CDOMDirectSingleRef;
import pcgen.cdom.reference.CDOMSingleRef;
import pcgen.cdom.util.CControl;
import pcgen.core.analysis.BonusActivation;
import pcgen.core.analysis.BonusCalc;
import pcgen.core.analysis.EqModCost;
import pcgen.core.analysis.EqModSpellInfo;
import pcgen.core.analysis.EquipmentChoiceDriver;
import pcgen.core.analysis.SizeUtilities;
import pcgen.core.bonus.BonusObj;
import pcgen.core.bonus.BonusUtilities;
import pcgen.core.character.EquipSlot;
import pcgen.core.character.WieldCategory;
import pcgen.core.prereq.PrereqHandler;
import pcgen.core.prereq.Prerequisite;
import pcgen.core.utils.CoreUtility;
import pcgen.core.utils.MessageType;
import pcgen.core.utils.ShowMessageDelegate;
import pcgen.facade.core.EquipmentFacade;
import pcgen.io.FileAccess;
import pcgen.io.exporttoken.EqToken;
import pcgen.rules.context.AbstractReferenceContext;
import pcgen.util.BigDecimalHelper;
import pcgen.util.JEPResourceChecker;
import pcgen.util.Logging;
import pcgen.util.PJEP;
import pcgen.util.PjepPool;
import pcgen.util.enumeration.Load;
import pcgen.util.enumeration.View;
import pcgen.util.enumeration.Visibility;

import org.apache.commons.lang3.StringUtils;

/**
 * Represents Equipment for a PC.
 */
public final class Equipment extends PObject
		implements Serializable, Comparable&lt;Object&gt;, VariableContainer, EquipmentFacade, PCGenScoped
{

	private static final long serialVersionUID = 1;

	private static final String EQMOD_WEIGHT = &quot;_WEIGHTADD&quot;;

	private static final String EQMOD_DAMAGE = &quot;_DAMAGE&quot;;

<span class="fc" id="L112">	private static final SortedSet&lt;String&gt; S_EQUIPMENT_TYPES = new TreeSet&lt;&gt;();</span>

<span class="fc" id="L114">	private AssociationSupport assocSupt = new AssociationSupport();</span>

<span class="fc" id="L116">	private BigDecimal costMod = BigDecimal.ZERO;</span>

	private Equipment d_parent;

<span class="fc" id="L120">	private List&lt;Equipment&gt; d_containedEquipment = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L122">	private Float carried = (float) 0; // OwnedItem</span>

<span class="fc" id="L124">	private EquipmentLocation location = EquipmentLocation.NOT_CARRIED; // OwnedItem</span>

	private boolean equipped; // OwnedItem

	private int numberEquipped;

<span class="fc" id="L130">	private Map&lt;String, Float&gt; d_childTypes = new HashMap&lt;&gt;();</span>

<span class="fc" id="L132">	private String containerCapacityString = null;</span>

<span class="fc" id="L134">	private String containerContentsString = &quot;&quot;;</span>

<span class="fc" id="L136">	private String appliedBonusName = &quot;&quot;;</span>

<span class="fc" id="L138">	private String indexedUnderType = &quot;&quot;;</span>

<span class="fc" id="L140">	private String wholeItemName = &quot;&quot;;</span>

<span class="fc" id="L142">	private String modifiedName = &quot;&quot;;</span>

<span class="fc" id="L144">	private String moveString = &quot;&quot;;</span>

	// player added note
<span class="fc" id="L147">	private String noteString = &quot;&quot;;</span>

	private boolean automatic;

<span class="fc" id="L151">	private boolean bonusPrimary = true;</span>

	private boolean calculatingCost;

	private boolean weightAlreadyUsed;

	private double qty;

	private int outputIndex;

	private int outputSubindex;

	private List&lt;String&gt; typeListCachePrimary;

	private List&lt;String&gt; typeListCacheSecondary;

	private boolean usePrimaryCache;

	private boolean useSecondaryCache;

	private boolean dirty;

	private String cachedNameWithoutCharges;

	private String cachedNameWithCharges;

	/** Map of the bonuses for the object  */
	private Map&lt;String, String&gt; bonusMap;

	private boolean virtualItem;

	public Equipment()
<span class="fc" id="L183">	{</span>
<span class="fc" id="L184">		final SizeAdjustment sizeAdj = SizeUtilities.getDefaultSizeAdjustment();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">		if (sizeAdj != null)</span>
		{
<span class="fc" id="L187">			put(ObjectKey.SIZE, CDOMDirectSingleRef.getRef(sizeAdj));</span>
		}
<span class="fc" id="L189">	}</span>

	//
	// Name functions
	//
	/**
	 * Set's the Temporary Bonuses name used for Display on Output Sheets
	 * 
	 * @param aString
	 *            Name to use for temp bonus
	 */
	public void setAppliedName(final String aString)
	{
<span class="nc" id="L202">		appliedBonusName = aString;</span>
<span class="nc" id="L203">	}</span>

	/**
	 * Get Applied Name
	 * 
	 * @return Applied name
	 */
	public String getAppliedName()
	{
<span class="nc bnc" id="L212" title="All 2 branches missed.">		if (!appliedBonusName.isEmpty())</span>
		{

<span class="nc" id="L215">			return &quot; [&quot; + appliedBonusName + &quot;]&quot;;</span>
		}

<span class="nc" id="L218">		return &quot;&quot;;</span>
	}

	//
	// TYPE queries
	//
	/**
	 * Gets the ammunition attribute of the Equipment object
	 * 
	 * @return The ammunition value
	 */
	public boolean isAmmunition()
	{
<span class="nc" id="L231">		return isType(&quot;AMMUNITION&quot;);</span>
	}

	/**
	 * Gets the armor attribute of the Equipment object
	 * 
	 * @return The armor value
	 */
	public boolean isArmor()
	{
<span class="nc" id="L241">		return isType(&quot;ARMOR&quot;);</span>
	}

	/**
	 * Gets the double attribute of the Equipment object
	 * 
	 * @return The double value
	 */
	public boolean isDouble()
	{
<span class="nc" id="L251">		return isType(&quot;DOUBLE&quot;);</span>
	}

	/**
	 * Gets the eitherType attribute of the Equipment object
	 * 
	 * @param aType
	 *            Description of the Parameter
	 * @return The eitherType value
	 */
	public boolean isEitherType(final String aType)
	{
<span class="nc bnc" id="L263" title="All 4 branches missed.">		return isType(aType, true) || isType(aType, false);</span>
	}

	/**
	 * Gets the extra attribute of the Equipment object
	 * 
	 * @return The extra value
	 */
	public boolean isExtra()
	{
<span class="nc" id="L273">		return isType(&quot;EXTRA&quot;);</span>
	}

	/**
	 * Gets the heavy attribute of the Equipment object
	 * 
	 * @return The heavy value
	 */
	public boolean isHeavy()
	{
<span class="nc" id="L283">		return isType(&quot;HEAVY&quot;);</span>
	}

	/**
	 * Gets the medium attribute of the Equipment object
	 * 
	 * @return The medium value
	 */
	public boolean isMedium()
	{
<span class="nc" id="L293">		return isType(&quot;MEDIUM&quot;);</span>
	}

	/**
	 * Gets the light attribute of the Equipment object
	 * 
	 * @return The light value
	 */
	public boolean isLight()
	{
<span class="nc" id="L303">		return isType(&quot;LIGHT&quot;);</span>
	}

	/**
	 * Gets the magic attribute of the Equipment object
	 * 
	 * @return The magic value
	 */
	public boolean isMagic()
	{
<span class="nc" id="L313">		return isType(&quot;MAGIC&quot;);</span>
	}

	/**
	 * Gets the melee attribute of the Equipment object
	 * 
	 * @return The melee value
	 */
	public boolean isMelee()
	{
<span class="nc" id="L323">		return isType(&quot;MELEE&quot;);</span>
	}

	/**
	 * Gets the monk attribute of the Equipment object
	 * 
	 * @return The monk value
	 */
	public boolean isMonk()
	{
<span class="nc" id="L333">		return isType(&quot;MONK&quot;);</span>
	}

	/**
	 * Gets the natural weapon attribute of the Equipment object
	 * 
	 * @return The natural value
	 */
	public boolean isNatural()
	{
<span class="fc" id="L343">		return isType(&quot;NATURAL&quot;);</span>
	}

	/**
	 * Identify if this is a primary natural weapon.
	 * @return true for a primary natural weapons, false if not natural or a secondary natural weapon.
	 */
	public boolean isPrimaryNaturalWeapon()
	{
		// The name is generated by the NATURALATTACKS token, so we place some trust in it.
<span class="nc bnc" id="L353" title="All 4 branches missed.">		return isNatural() &amp;&amp; modifiedName().endsWith(&quot;Primary&quot;); //$NON-NLS-1$</span>
	}

	/**
	 * Gets the ranged attribute of the Equipment object
	 * 
	 * @return The ranged value
	 */
	public boolean isRanged()
	{
<span class="nc" id="L363">		return isType(&quot;RANGED&quot;);</span>
	}

	/**
	 * Gets the shield attribute of the Equipment object
	 * 
	 * @return The shield value
	 */
	public boolean isShield()
	{
<span class="nc" id="L373">		return isType(&quot;SHIELD&quot;);</span>
	}

	/**
	 * Gets the suit attribute of the Equipment object
	 * 
	 * @return The suit value
	 */
	private boolean isSuit()
	{
<span class="nc" id="L383">		return isType(&quot;SUIT&quot;);</span>
	}

	/**
	 * Gets the thrown attribute of the Equipment object
	 * 
	 * @return The thrown value
	 */
	public boolean isThrown()
	{
<span class="nc" id="L393">		return isType(&quot;THROWN&quot;);</span>
	}

	/**
	 * Gets the type attribute of the Equipment object
	 * 
	 * @return The type
	 */
	@Override
	public String getType()
	{
<span class="nc" id="L404">		return getType(true);</span>
	}

	/**
	 * Gets the type attribute of the Equipment object
	 * 
	 * @param aType
	 *            Description of the Parameter
	 * @return The type value
	 */
	@Override
	public boolean isType(final String aType)
	{
<span class="fc" id="L417">		return isType(aType, true);</span>
	}

	/**
	 * Gets the type attribute of the Equipment object
	 * 
	 * @param aType
	 *            Description of the Parameter
	 * @param bPrimary
	 *            Description of the Parameter
	 * @return The type value
	 */
	public boolean isType(final String aType, final boolean bPrimary)
	{
<span class="pc bpc" id="L431" title="3 of 4 branches missed.">		if (!bPrimary &amp;&amp; !isDouble())</span>
		{
<span class="nc" id="L433">			return false;</span>
		}

<span class="fc" id="L436">		final List&lt;String&gt; tList = typeList(bPrimary);</span>
		final String myType;

<span class="pc bpc" id="L439" title="2 of 4 branches missed.">		if (aType.startsWith(&quot;TYPE=&quot;) || aType.startsWith(&quot;TYPE.&quot;)) //$NON-NLS-1$ //$NON-NLS-2$</span>
		{
<span class="nc" id="L441">			myType = aType.substring(5).toUpperCase();</span>
		}
		else
		{
<span class="fc" id="L445">			myType = aType.toUpperCase();</span>
		}

		//
		// Must match all listed types in order to qualify
		//
<span class="fc" id="L451">		StringTokenizer tok = new StringTokenizer(myType, &quot;.&quot;);</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">		if (tok.hasMoreTokens())</span>
		{
<span class="fc bfc" id="L454" title="All 2 branches covered.">			while (tok.hasMoreTokens())</span>
			{
<span class="fc" id="L456">				final String type = tok.nextToken();</span>
				//CONSIDER Faster method? Case sensitivity is a problem for containsInList
<span class="fc" id="L458">				boolean found = false;</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">				if (tList != null)</span>
				{
<span class="fc" id="L461">					found = tList.stream().anyMatch(type::equalsIgnoreCase);</span>
				}
<span class="fc bfc" id="L463" title="All 2 branches covered.">				if (!found)</span>
				{
<span class="fc" id="L465">					return false;</span>
				}
<span class="fc" id="L467">			}</span>
<span class="fc" id="L468">			return true;</span>
		}
<span class="nc" id="L470">		return tList.contains(aType);</span>
	}

	/**
	 * Gets the unarmed attribute of the Equipment object
	 * 
	 * @return The unarmed value
	 */
	public boolean isUnarmed()
	{
<span class="nc" id="L480">		return isType(&quot;UNARMED&quot;);</span>
	}

	/**
	 * Gets the weapon attribute of the Equipment object
	 * 
	 * @return The weapon value
	 */
	public boolean isWeapon()
	{
<span class="nc" id="L490">		return isType(&quot;WEAPON&quot;);</span>
	}

	/**
	 * Gets the masterwork attribute of the Equipment object
	 * 
	 * @return The masterwork value
	 */
	boolean isMasterwork()
	{
<span class="nc" id="L500">		return isType(&quot;MASTERWORK&quot;);</span>
	}

	/**
	 * Identifies if this item is one that is sold like cash (e.g. coins, trade goods)
	 * @return true if the item is tradeable
	 */
	public boolean isSellAsCash()
	{
<span class="nc bnc" id="L509" title="All 4 branches missed.">		return isType(&quot;Coin&quot;) || isType(&quot;Gem&quot;) //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">			|| isType(&quot;Trade&quot;); //$NON-NLS-1$</span>
	}

	/**
	 * Description of the Method
	 * 
	 * @param aString
	 *            Description of the Parameter
	 * @return Description of the Return Value
	 */
	public boolean typeStringContains(final String aString)
	{
<span class="nc" id="L522">		return isType(aString);</span>
	}

	/**
	 * Gets the projectile attribute of the Equipment object
	 * 
	 * @return The projectile value
	 */
	public boolean isProjectile()
	{
		// return isType(&quot;PROJECTILE&quot;);
<span class="nc bnc" id="L533" title="All 4 branches missed.">		return isRanged() &amp;&amp; !isThrown();</span>
	}

	/**
	 * returns all BonusObj's that are &quot;active&quot;
	 * 
	 * @param aPC
	 *            PlayerCharacter used to check prereqs for bonuses
	 * @return active bonuses
	 */
	@Override
	public List&lt;BonusObj&gt; getActiveBonuses(final PlayerCharacter aPC)
	{
<span class="nc" id="L546">		final List&lt;BonusObj&gt; aList = getRawBonusList(aPC).stream().filter(aPC::isApplied).collect(Collectors.toList());</span>

<span class="nc" id="L548">		List&lt;EquipmentModifier&gt; eqModList = getEqModifierList(true);</span>

<span class="nc" id="L550">		eqModList.stream().map(eqMod -&gt; eqMod.getActiveBonuses(this, aPC)).forEach(aList::addAll);</span>

<span class="nc" id="L552">		eqModList = getEqModifierList(false);</span>

<span class="nc" id="L554">		eqModList.stream().map(eqMod -&gt; eqMod.getActiveBonuses(this, aPC)).forEach(aList::addAll);</span>

<span class="nc" id="L556">		return aList;</span>
	}

	/**
	 * get a list of BonusObj's of aType and aName
	 * @param pc
	 *            The PC with the Equipment 
	 * @param aType
	 *            a TYPE of bonus (such as &quot;COMBAT&quot; or &quot;SKILL&quot;)
	 * @param aName
	 *            the NAME of the bonus (such as &quot;ATTACKS&quot; or &quot;SPOT&quot;)
	 * @param bPrimary
	 *            used for double weapons (head1 vs head2)
	 * 
	 * @return a list of bonusObj's of aType and aName
	 */
	List&lt;BonusObj&gt; getBonusListOfType(PlayerCharacter pc, final String aType, final String aName,
		final boolean bPrimary)
	{

<span class="nc" id="L576">		final List&lt;BonusObj&gt; aList = new ArrayList&lt;&gt;(BonusUtilities.getBonusFromList(getBonusList(pc), aType, aName));</span>

<span class="nc" id="L578">		getEqModifierList(bPrimary).stream()</span>
<span class="nc" id="L579">			.map(eqMod -&gt; BonusUtilities.getBonusFromList(eqMod.getBonusList(this), aType, aName))</span>
<span class="nc" id="L580">			.forEach(aList::addAll);</span>

<span class="nc" id="L582">		return aList;</span>
	}

	//
	// Misc properties
	//

	public boolean isAutomatic()
	{
<span class="nc" id="L591">		return automatic;</span>
	}

	/**
	 * Set Automatic
	 * 
	 * @param arg sets the isAutomatic property of the Equipment
	 */
	public void setAutomatic(final boolean arg)
	{
<span class="nc" id="L601">		automatic = arg;</span>
<span class="nc" id="L602">	}</span>

	/**
	 * Gets the baseItemName attribute of the Equipment object
	 * 
	 * @return The baseItemName value
	 */
	public String getBaseItemName()
	{
<span class="nc" id="L611">		CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">		if (baseItem == null)</span>
		{
<span class="nc" id="L614">			return getKeyName();</span>
		}
<span class="nc" id="L616">		return baseItem.get().getDisplayName();</span>
	}

	/**
	 * Gets the keyName attribute of the base item of this Equipment object.
	 * 
	 * @return The base item's keyName value
	 */
	public String getBaseItemKeyName()
	{
<span class="nc" id="L626">		CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">		if (baseItem == null)</span>
		{
<span class="nc" id="L629">			return getKeyName();</span>
		}
<span class="nc" id="L631">		return baseItem.get().getKeyName();</span>
	}

	/**
	 * Gets the cost attribute of the Equipment object
	 * 
	 * @param aPC The PC with the Equipment
	 * 
	 * @return The cost value
	 */
	public BigDecimal getCost(final PlayerCharacter aPC)
	{
<span class="nc" id="L643">		BigDecimal c = BigDecimal.ZERO;</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">		if (this.isVirtual())</span>
		{
<span class="nc" id="L647">			return c;</span>
		}

		//
		// Do pre-sizing cost increment.
		// eg. in the case of adamantine armor, want to add
		// the cost of the metal before the armor gets resized.
		//
<span class="nc" id="L655">		c = c.add(getPreSizingCostForHead(aPC, true));</span>
<span class="nc" id="L656">		c = c.add(getPreSizingCostForHead(aPC, false));</span>

		// c has cost of the item's modifications at the item's original size

<span class="nc" id="L660">		BigDecimal currentcost = get(ObjectKey.CURRENT_COST);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">		if (currentcost == null)</span>
		{
<span class="nc" id="L663">			currentcost = getSafe(ObjectKey.COST);</span>
		}
<span class="nc" id="L665">		BigDecimal itemCost = currentcost.add(c);</span>

<span class="nc" id="L667">		final List&lt;BigDecimal&gt; modifierCosts = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L669">		calculatingCost = true;</span>
<span class="nc" id="L670">		weightAlreadyUsed = false;</span>

<span class="nc" id="L672">		EquipmentHeadCostSummary costSum = getPostSizingCostForHead(aPC, modifierCosts, true);</span>
<span class="nc" id="L673">		BigDecimal nonDoubleCost = costSum.nonDoubleCost;</span>
<span class="nc" id="L674">		BigDecimal c1 = costSum.postSizeCost;</span>
<span class="nc" id="L675">		int iPlus = costSum.headPlus;</span>

		//
		// Get costs from lowest to highest
		//
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (modifierCosts.size() &gt; 1)</span>
		{
<span class="nc" id="L682">			Collections.sort(modifierCosts);</span>
		}

		// Note: When calculating the second head's costs we expect not to see 
		// any modifier costs and discard them if they do occur. These should be 
		// applicable for weapons, which are the only dual headed items currently.
<span class="nc" id="L688">		EquipmentHeadCostSummary altCostSum = getPostSizingCostForHead(aPC, new ArrayList&lt;&gt;(), false);</span>
<span class="nc" id="L689">		nonDoubleCost = nonDoubleCost.add(altCostSum.nonDoubleCost);</span>
<span class="nc" id="L690">		c1 = c1.add(altCostSum.postSizeCost);</span>
<span class="nc" id="L691">		int altPlus = altCostSum.headPlus;</span>

<span class="nc" id="L693">		calculatingCost = false;</span>

<span class="nc" id="L695">		c1 = c1.add(getCostFromPluses(iPlus, altPlus));</span>

		// Items with values less than 1 gp have their prices rounded up to 1 gp
		// per item
		// eg. 20 Arrows cost 1 gp, or 5 cp each. 1 MW Arrow costs 7 gp.
		//
		// Masterwork and Magical ammo is made in batches of 50, so the MW cost
		// per item should be 6 gp. This would give a cost of 6.05 gp per arrow,
		// 6.1 gp per bolt and 6.01 gp per bullet.
		//
		// if (c.compareTo(BigDecimal.ZERO) != 0)
		// {
		// //
		// // Convert to double and use math.ceil as ROUND_CEILING doesn't appear to work
		// // on BigDecimal.divide
		// final int baseQ = getBaseQty();
		// itemCost = new BigDecimal(Math.ceil(itemCost.doubleValue() / baseQ) *
		// baseQ);
		// }

<span class="nc bnc" id="L715" title="All 8 branches missed.">		if (!isAmmunition() &amp;&amp; !isArmor() &amp;&amp; !isShield() &amp;&amp; !isWeapon())</span>
		{
			//
			// If item doesn't occupy a fixed location, then double the cost of
			// the modifications
			// DMG p.243
			//
<span class="nc bnc" id="L722" title="All 2 branches missed.">			if (!isMagicLimitedType())</span>
			{
				//
				// TODO: Multiple similar abilities. 100% of costliest, 75% of
				// next, and 50% of rest
				//
<span class="nc bnc" id="L728" title="All 2 branches missed.">				if (!ignoresCostDouble())</span>
				{
<span class="nc" id="L730">					c1 = c1.subtract(nonDoubleCost).multiply(BigDecimal.TWO);</span>
<span class="nc" id="L731">					c1 = c1.add(nonDoubleCost);</span>

					// c = c.multiply(new BigDecimal(&quot;2&quot;));
				}
			}
			else
			{
				//
				// Add in the cost of 2nd, 3rd, etc. modifiers again (gives
				// times 2)
				//
<span class="nc bnc" id="L742" title="All 2 branches missed.">				for (int i = modifierCosts.size() - 2; i &gt;= 0; --i)</span>
				{
<span class="nc" id="L744">					c1 = c1.add(modifierCosts.get(i));</span>
				}
			}
		}

		// Don't allow the cost modifier to push the value further into the negatives
<span class="nc bnc" id="L750" title="All 4 branches missed.">		if (c1.compareTo(BigDecimal.ZERO) &gt;= 0 &amp;&amp; c1.add(itemCost).add(costMod).compareTo(BigDecimal.ZERO) &lt; 0)</span>
		{
<span class="nc" id="L752">			return BigDecimal.ZERO;</span>
		}

<span class="nc" id="L755">		return c1.add(itemCost).add(costMod);</span>
	}

	/**
	 * Calculate the parts of the cost for the equipment's head that are 
	 * affected by size.
	 *  
	 * @param aPC The character who owns the equipment.
	 * @param primaryHead Are we calculating for the primary or alternate head.
	 * @return The cost of the head
	 */
	private BigDecimal getPreSizingCostForHead(final PlayerCharacter aPC, boolean primaryHead)
	{
<span class="nc" id="L768">		BigDecimal c = BigDecimal.ZERO;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">		EquipmentHead head = getEquipmentHeadReference(primaryHead ? 1 : 2);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (head != null)</span>
		{
<span class="nc" id="L772">			bonusPrimary = primaryHead;</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">			for (EquipmentModifier eqMod : head.getSafeListFor(ListKey.EQMOD))</span>
			{
<span class="nc" id="L775">				int iCount = getSelectCorrectedAssociationCount(eqMod);</span>

<span class="nc bnc" id="L777" title="All 2 branches missed.">				if (iCount &lt; 1)</span>
				{
<span class="nc" id="L779">					iCount = 1;</span>
				}

<span class="nc" id="L782">				Formula baseCost = eqMod.getSafe(FormulaKey.BASECOST);</span>
<span class="nc" id="L783">				Number bc = baseCost.resolve(this, primaryHead, aPC, &quot;&quot;);</span>
<span class="nc" id="L784">				final BigDecimal eqModCost = new BigDecimal(bc.toString());</span>
<span class="nc" id="L785">				c = c.add(</span>
<span class="nc" id="L786">					eqModCost.multiply(new BigDecimal(Integer.toString(getSafe(IntegerKey.BASE_QUANTITY) * iCount))));</span>
<span class="nc" id="L787">				c = c.add(</span>
<span class="nc" id="L788">					EqModCost.addItemCosts(eqMod, aPC, &quot;ITEMCOST&quot;, getSafe(IntegerKey.BASE_QUANTITY) * iCount, this));</span>
<span class="nc" id="L789">			}</span>
		}
<span class="nc" id="L791">		return c;</span>
	}

	/**
	 * Calculate the parts of the cost for the equipment's head that are not 
	 * affected by size.
	 *  
	 * @param aPC The character who owns the equipment.
	 * @param modifierCosts The array of costs to be doubled if the location demands it
	 * @param primaryHead Are we calculating for the primary or alternate head.
	 * @return The cost, non doubling cost and total plus of the head
	 */
	private EquipmentHeadCostSummary getPostSizingCostForHead(final PlayerCharacter aPC,
		final List&lt;BigDecimal&gt; modifierCosts, boolean primaryHead)
	{
<span class="nc" id="L806">		EquipmentHeadCostSummary costSum = new EquipmentHeadCostSummary();</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">		EquipmentHead head = getEquipmentHeadReference(primaryHead ? 1 : 2);</span>

<span class="nc bnc" id="L809" title="All 2 branches missed.">		if (head != null)</span>
		{
<span class="nc bnc" id="L811" title="All 2 branches missed.">			for (EquipmentModifier eqMod : head.getSafeListFor(ListKey.EQMOD))</span>
			{
<span class="nc" id="L813">				int iCount = getSelectCorrectedAssociationCount(eqMod);</span>

<span class="nc bnc" id="L815" title="All 2 branches missed.">				if (iCount &lt; 1)</span>
				{
<span class="nc" id="L817">					iCount = 1;</span>
				}

				BigDecimal eqModCost;
<span class="nc" id="L821">				Formula cost = eqMod.getSafe(FormulaKey.COST);</span>
<span class="nc" id="L822">				String costFormula = cost.toString();</span>

<span class="nc bnc" id="L824" title="All 4 branches missed.">				if (hasAssociations(eqMod) &amp;&amp; !costFormula.equals(EqModCost.getCost(eqMod, getFirstAssociation(eqMod))))</span>
				{
<span class="nc" id="L826">					eqModCost = BigDecimal.ZERO;</span>

<span class="nc bnc" id="L828" title="All 2 branches missed.">					for (String assoc : getAssociationList(eqMod))</span>
					{
<span class="nc" id="L830">						String v = calcEqModCost(aPC, EqModCost.getCost(eqMod, assoc), primaryHead);</span>
<span class="nc" id="L831">						final BigDecimal thisModCost = new BigDecimal(v);</span>
<span class="nc" id="L832">						eqModCost = eqModCost.add(thisModCost);</span>

<span class="nc bnc" id="L834" title="All 2 branches missed.">						if (!EqModCost.getCostDouble(eqMod))</span>
						{
<span class="nc" id="L836">							costSum.nonDoubleCost = costSum.nonDoubleCost.add(thisModCost);</span>
						}
						else
						{
<span class="nc" id="L840">							modifierCosts.add(thisModCost);</span>
						}
<span class="nc" id="L842">					}</span>

<span class="nc" id="L844">					iCount = 1;</span>
				}
				else
				{
<span class="nc" id="L848">					String v = calcEqModCost(aPC, cost.toString(), primaryHead);</span>
<span class="nc" id="L849">					eqModCost = new BigDecimal(v);</span>

<span class="nc bnc" id="L851" title="All 2 branches missed.">					if (EqModCost.getCostDouble(eqMod))</span>
					{
<span class="nc" id="L853">						modifierCosts.add(eqModCost);</span>
					}
					else
					{
<span class="nc" id="L857">						costSum.nonDoubleCost = costSum.nonDoubleCost.add(eqModCost);</span>
					}
				}

				// Per D20 FAQ adjustments for special materials are per piece;
<span class="nc bnc" id="L862" title="All 2 branches missed.">				if (eqMod.isType(&quot;BaseMaterial&quot;))</span>
				{
<span class="nc" id="L864">					eqModCost = eqModCost.multiply(new BigDecimal(getSafe(IntegerKey.BASE_QUANTITY)));</span>
				}
<span class="nc" id="L866">				costSum.postSizeCost = costSum.postSizeCost.add(eqModCost);</span>

<span class="nc" id="L868">				costSum.headPlus += (eqMod.getSafe(IntegerKey.PLUS) * iCount);</span>
<span class="nc" id="L869">			}</span>
		}
<span class="nc" id="L871">		return costSum;</span>
	}

	/**
	 * Calculates the value of a formula. Does some preprocesing for variables 
	 * that cannot be properly evaluated with just the equipment context that 
	 * is held by the variable processor.  
	 * @param aPC The character we are calculating the cost for.
	 * @param costFormula The formula to be evaluated.
	 * @param primaryHead Is the formula for an eqmod on the main (or only) head  
	 * @return The value of the formula
	 */
	private String calcEqModCost(final PlayerCharacter aPC, String costFormula, boolean primaryHead)
	{
<span class="nc" id="L885">		Pattern pat = Pattern.compile(&quot;BASECOST&quot;);</span>
<span class="nc" id="L886">		Matcher mat = pat.matcher(costFormula);</span>

		// make string (BASECOST/X) which will be substituted into
		// the cost string which is then converted to a number
<span class="nc" id="L890">		String sB = &quot;(BASECOST/&quot; + getSafe(IntegerKey.BASE_QUANTITY)</span>
				+ &quot;)&quot;;
<span class="nc" id="L892">		String s = mat.replaceAll(sB);</span>

<span class="nc" id="L894">		return getVariableValue(s, &quot;&quot;, primaryHead, aPC).toString();</span>
	}

	/**
	 * Set cost mod
	 * 
	 * @param aString the cost modifier in String form
	 */
	public void setCostMod(final String aString)
	{

		try
		{
<span class="nc" id="L907">			costMod = new BigDecimal(aString);</span>
		}
<span class="nc" id="L909">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L911">			costMod = BigDecimal.ZERO;</span>
<span class="nc" id="L912">		}</span>
<span class="nc" id="L913">	}</span>

	/**
	 * Set cost mod
	 * 
	 * @param aCost the cost modifier in BigDecimal form
	 */
	public void setCostMod(final BigDecimal aCost)
	{
<span class="nc" id="L922">		costMod = aCost;</span>
<span class="nc" id="L923">	}</span>

	// ---------------------------
	// Equipment Modifier Support
	// ---------------------------

	/**
	 * Gets the eqModifierKeyed attribute of the Equipment object
	 * 
	 * @param eqModKey
	 *            Description of the Parameter
	 * @param bPrimary
	 *            if True then deal with the primary head
	 * @return The eqModifierKeyed value
	 */
	public EquipmentModifier getEqModifierKeyed(final Object eqModKey, final boolean bPrimary)
	{

<span class="fc" id="L941">		final List&lt;EquipmentModifier&gt; eqModList = getEqModifierList(bPrimary);</span>

<span class="pc" id="L943">		return eqModList.stream().filter(eqMod -&gt; eqMod.getKeyName().equals(eqModKey)).findFirst().orElse(null);</span>

	}

	/**
	 * Gets the eqModifierList attribute of the Equipment object
	 * 
	 * @param bPrimary
	 *            if true, get the equipment modifiers for the primary head of
	 *            the weapon
	 * 
	 * @return The eqModifierList value
	 */
	public List&lt;EquipmentModifier&gt; getEqModifierList(final boolean bPrimary)
	{
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">		return getEquipmentHead(bPrimary ? 1 : 2).getSafeListFor(ListKey.EQMOD);</span>
	}

	/**
	 * Add an EquipmentModifier object to the list
	 * 
	 * @param eqMod
	 *            The equipment modifier to add to list
	 * @param bPrimary
	 *            if True then deal with the primary head
	 */
	public void addToEqModifierList(final EquipmentModifier eqMod, final boolean bPrimary)
	{
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">		if (bPrimary)</span>
		{
<span class="fc" id="L973">			usePrimaryCache = false;</span>
		}
		else
		{
<span class="nc" id="L977">			useSecondaryCache = false;</span>
		}
<span class="fc" id="L979">		eqMod.setVariableParent(this);</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">		getEquipmentHead(bPrimary ? 1 : 2).addToListFor(ListKey.EQMOD, eqMod);</span>
<span class="fc" id="L981">		setDirty(true);</span>
<span class="fc" id="L982">	}</span>

	/**
	 * Get display information for all &quot;interesting&quot; properties.
	 * 
	 * @param aPC The PC with the Equipment
	 * 
	 * @return display string of bonuses and special properties
	 */
	public String getInterestingDisplayString(final PlayerCharacter aPC)
	{
<span class="nc" id="L993">		final StringBuilder s = new StringBuilder(100);</span>
<span class="nc" id="L994">		String t = getSpecialProperties(aPC);</span>

<span class="nc" id="L996">		getActiveBonuses(aPC).stream().map(BonusObj::toString)</span>
<span class="nc bnc" id="L997" title="All 4 branches missed.">			.filter(eqBonus -&gt; (!eqBonus.isEmpty()) &amp;&amp; !eqBonus.startsWith(&quot;EQM&quot;)).forEach(eqBonus -&gt; {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">				if (s.length() != 0)</span>
				{
<span class="nc" id="L1000">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1002">				s.append(eqBonus);</span>
<span class="nc" id="L1003">			});</span>

		// for (final Iterator&lt;EquipmentModifier&gt; e = eqModifierList.iterator();
		// e.hasNext();)
		// {
		// final EquipmentModifier eqMod = e.next();
		// for (final Iterator&lt;BonusObj&gt; mI = eqMod.getBonusList().iterator();
		// mI.hasNext();)
		// {
		// final BonusObj aBonus = mI.next();
		// final String eqModBonus = aBonus.toString();
		// if ((eqModBonus.length() != 0) &amp;&amp; !eqModBonus.startsWith(&quot;EQM&quot;))
		// {
		// if (s.length() != 0)
		// {
		// s.append(&quot;, &quot;);
		// }
		// s.append(eqModBonus);
		// }
		// }
		// }
<span class="nc bnc" id="L1024" title="All 2 branches missed.">		if (!t.isEmpty())</span>
		{
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			if (s.length() != 0)</span>
			{
<span class="nc" id="L1028">				s.append('|');</span>
			}

<span class="nc" id="L1031">			s.append(t);</span>
		}

<span class="nc" id="L1034">		return s.toString();</span>
	}

	/**
	 * Sets the isEquipped attribute of the Equipment object.
	 * 
	 * @param aFlag
	 *            The new isEquipped value
	 * @param aPC
	 *            The PC with the Equipment
	 */
	public void setIsEquipped(final boolean aFlag, final PlayerCharacter aPC)
	{

<span class="nc" id="L1048">		equipped = aFlag;</span>

<span class="nc bnc" id="L1050" title="All 2 branches missed.">		if (equipped)</span>
		{
<span class="nc" id="L1052">			activateBonuses(aPC);</span>
		}
		else
		{
<span class="nc" id="L1056">			BonusActivation.deactivateBonuses(this, aPC);</span>
		}
<span class="nc" id="L1058">	}</span>

	/**
	 * Get the item name based off the modifiers
	 * 
	 * @return item name based off the modifiers
	 */
	public String getItemNameFromModifiers()
	{
<span class="nc" id="L1067">		return getItemNameFromModifiers(getBaseItemName());</span>
	}

	/**
	 * Get the item name based off the modifiers
	 * 
	 * @param baseName base name of the object, may instead be the base key if generating a key
	 * @return item name based off the modifiers
	 */
	private String getItemNameFromModifiers(String baseName)
	{
<span class="nc" id="L1078">		CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">		if (baseItem == null)</span>
		{
<span class="nc" id="L1081">			return getName();</span>
		}
		final List&lt;EquipmentModifier&gt; modList;
<span class="nc" id="L1084">		EquipmentHead head = getEquipmentHeadReference(1);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">		if (head == null)</span>
		{
<span class="nc" id="L1087">			modList = Collections.emptyList();</span>
		}
		else
		{
<span class="nc" id="L1091">			modList = head.getSafeListFor(ListKey.EQMOD);</span>
		}
<span class="nc" id="L1093">		EquipmentHead althead = getEquipmentHeadReference(2);</span>
		final List&lt;EquipmentModifier&gt; altModList;
<span class="nc bnc" id="L1095" title="All 2 branches missed.">		if (althead == null)</span>
		{
<span class="nc" id="L1097">			altModList = Collections.emptyList();</span>
		}
		else
		{
<span class="nc" id="L1101">			altModList = althead.getSafeListFor(ListKey.EQMOD);</span>
		}
<span class="nc" id="L1103">		final List&lt;EquipmentModifier&gt; commonList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1104">		final List&lt;List&lt;EquipmentModifier&gt;&gt; modListByFC = initSplitModList();</span>
<span class="nc" id="L1105">		final List&lt;List&lt;EquipmentModifier&gt;&gt; altModListByFC = initSplitModList();</span>
<span class="nc" id="L1106">		final List&lt;List&lt;EquipmentModifier&gt;&gt; commonListByFC = initSplitModList();</span>
<span class="nc" id="L1107">		final Equipment baseEquipment = baseItem.get();</span>
		// Remove any modifiers on the base item so they don't confuse the
		// naming
<span class="nc bnc" id="L1110" title="All 2 branches missed.">		if (baseEquipment != null)</span>
		{
<span class="nc" id="L1112">			modList.removeAll(baseEquipment.getEqModifierList(true));</span>
<span class="nc" id="L1113">			altModList.removeAll(baseEquipment.getEqModifierList(false));</span>
		}
<span class="nc" id="L1115">		modList.removeIf(eqMod -&gt; eqMod.getSafe(ObjectKey.VISIBILITY).equals(Visibility.HIDDEN));</span>
<span class="nc" id="L1116">		extractListFromCommon(commonList, modList);</span>
<span class="nc" id="L1117">		removeCommonFromList(altModList, commonList, &quot;eqMod expected but not found: &quot;);</span>
		// Remove masterwork from the list if magic is present
<span class="nc" id="L1119">		suppressMasterwork(commonList);</span>
		// Split the eqmod lists by format category
<span class="nc" id="L1121">		splitModListByFormatCat(commonList, commonListByFC);</span>
<span class="nc" id="L1122">		splitModListByFormatCat(modList, modListByFC);</span>
<span class="nc" id="L1123">		splitModListByFormatCat(altModList, altModListByFC);</span>
<span class="nc" id="L1124">		final StringBuilder itemName = new StringBuilder(100);</span>
		// Add in front eq mods
<span class="nc" id="L1126">		int fcf = EqModFormatCat.FRONT.ordinal();</span>
<span class="nc" id="L1127">		itemName.append(buildEqModDesc(commonListByFC.get(fcf), modListByFC.get(fcf), altModListByFC.get(fcf)));</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">		if (itemName.length() &gt; 0)</span>
		{
<span class="nc" id="L1130">			itemName.append(' ');</span>
		}
		// Add in the base name, less any modifiers
<span class="nc" id="L1133">		baseName = baseName.trim();</span>
<span class="nc" id="L1134">		int idx = baseName.indexOf('(');</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">		if (idx &gt;= 0)</span>
		{
<span class="nc" id="L1137">			itemName.append(baseName.substring(0, idx - 1).trim());</span>
		}
		else
		{
<span class="nc" id="L1141">			itemName.append(baseName);</span>
		}
		// Add in middle mods
<span class="nc" id="L1144">		int fcm = EqModFormatCat.MIDDLE.ordinal();</span>
<span class="nc" id="L1145">		String eqmodDesc1 = buildEqModDesc(commonListByFC.get(fcm), modListByFC.get(fcm), altModListByFC.get(fcm));</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">		if (!eqmodDesc1.isEmpty())</span>
		{
<span class="nc" id="L1148">			itemName.append(' ').append(eqmodDesc1);</span>
		}
		// Tack on the original modifiers
<span class="nc bnc" id="L1151" title="All 2 branches missed.">		if (idx &gt;= 0)</span>
		{
<span class="nc" id="L1153">			itemName.append(' ');</span>
<span class="nc" id="L1154">			itemName.append(baseName.substring(idx));</span>
		}
		// Strip off the ending ')' in anticipation of more modifiers
<span class="nc" id="L1157">		final int idx1 = itemName.toString().lastIndexOf(')');</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if (idx1 &gt;= 0)</span>
		{
<span class="nc" id="L1160">			itemName.setLength(idx1);</span>
<span class="nc" id="L1161">			itemName.append('/');</span>
		}
		else
		{
<span class="nc" id="L1165">			itemName.append(&quot; (&quot;);</span>
		}
		//
		// Put size in name if not the same as the base item
		//
<span class="nc" id="L1170">		SizeAdjustment thisSize = getSizeAdjustment();</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">		if (!getSafe(ObjectKey.BASESIZE).get().equals(thisSize))</span>
		{
<span class="nc" id="L1173">			itemName.append(thisSize.getDisplayName());</span>
<span class="nc" id="L1174">			itemName.append('/');</span>
		}
		// Put in parens mods
<span class="nc" id="L1177">		int fcp = EqModFormatCat.PARENS.ordinal();</span>
<span class="nc" id="L1178">		itemName.append(buildEqModDesc(commonListByFC.get(fcp), modListByFC.get(fcp), altModListByFC.get(fcp)));</span>
		//
		// If there were no modifiers, then drop the trailing '/'
		//
<span class="nc bnc" id="L1182" title="All 4 branches missed.">		if (itemName.toString().endsWith(&quot;/&quot;) || itemName.toString().endsWith(&quot;;&quot;))</span>
		{
<span class="nc" id="L1184">			itemName.setLength(itemName.length() - 1);</span>
		}
<span class="nc" id="L1186">		itemName.append(')');</span>
		// If there were no modifiers, then strip the empty parenthesis
<span class="nc" id="L1188">		final int idx2 = itemName.toString().indexOf(&quot; ()&quot;);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">		if (idx2 &gt;= 0)</span>
		{
<span class="nc" id="L1191">			itemName.setLength(idx2);</span>
		}
<span class="nc" id="L1193">		return itemName.toString();</span>
	}
	/**
	 * Where a magic eqmod is present, remove the masterwork eqmod from the
	 * list.
	 * 
	 * @param commonList
	 *            The list of eqmods on both heads (or only head)
	 */
	private void suppressMasterwork(Collection&lt;EquipmentModifier&gt; commonList)
	{
		// Look for a modifier named &quot;masterwork&quot; (assumption: this is marked as
		// &quot;assigntoall&quot;)
<span class="nc" id="L1206">		EquipmentModifier eqMaster = commonList.stream()</span>
<span class="nc bnc" id="L1207" title="All 4 branches missed.">			.filter(eqMod -&gt; &quot;MASTERWORK&quot;.equalsIgnoreCase(eqMod.getDisplayName()) || eqMod.isIType(Type.MASTERWORK))</span>
<span class="nc" id="L1208">			.findFirst().orElse(null);</span>

<span class="nc bnc" id="L1210" title="All 2 branches missed.">		if (eqMaster == null)</span>
		{
<span class="nc" id="L1212">			return;</span>
		}
<span class="nc bnc" id="L1214" title="All 4 branches missed.">		if (heads.stream().anyMatch(head -&gt; getMagicBonus(head.getListFor(ListKey.EQMOD)) != null))</span>
		{
<span class="nc" id="L1216">			commonList.remove(eqMaster);</span>
		}
<span class="nc" id="L1218">	}</span>
	/**
	 * Build up the description of the listed equipmods for this equipment item.
	 * Takes into account if the item is a double weapon or not.
	 * 
	 * @param commonList
	 *            The list of common equipment modifiers.
	 * @param modList
	 *            The list of eqmods on the primary head.
	 * @param altModList
	 *            The list of eqmods on the secondary head.
	 * @return The description of these equipment modifiers.
	 */
	private String buildEqModDesc(List&lt;EquipmentModifier&gt; commonList, List&lt;EquipmentModifier&gt; modList,
		List&lt;EquipmentModifier&gt; altModList)
	{
<span class="nc" id="L1234">		StringBuilder desc = new StringBuilder(250);</span>

<span class="nc" id="L1236">		String commonDesc = getNameFromModifiers(commonList);</span>
<span class="nc" id="L1237">		String modDesc = getNameFromModifiers(modList);</span>
<span class="nc" id="L1238">		String altModDesc = getNameFromModifiers(altModList);</span>

<span class="nc bnc" id="L1240" title="All 4 branches missed.">		if ((modList.isEmpty()) &amp;&amp; (altModList.isEmpty()))</span>
		{
<span class="nc" id="L1242">			desc.append(commonDesc);</span>
		}
<span class="nc bnc" id="L1244" title="All 2 branches missed.">		else if (!isDouble())</span>
		{
<span class="nc" id="L1246">			desc.append(modDesc);</span>
<span class="nc bnc" id="L1247" title="All 4 branches missed.">			if (!modList.isEmpty() &amp;&amp; !commonList.isEmpty())</span>
			{
<span class="nc" id="L1249">				desc.append('/');</span>
			}
<span class="nc" id="L1251">			desc.append(commonDesc);</span>
		}
		else
		{
<span class="nc bnc" id="L1255" title="All 2 branches missed.">			if (!commonDesc.isEmpty())</span>
			{
<span class="nc" id="L1257">				desc.append(commonDesc).append(';');</span>
			}

<span class="nc bnc" id="L1260" title="All 2 branches missed.">			if (!modDesc.isEmpty())</span>
			{
<span class="nc" id="L1262">				desc.append(modDesc);</span>
			}
			else
			{
<span class="nc" id="L1266">				desc.append('-');</span>
			}

<span class="nc" id="L1269">			desc.append(';');</span>

<span class="nc bnc" id="L1271" title="All 2 branches missed.">			if (!altModDesc.isEmpty())</span>
			{
<span class="nc" id="L1273">				desc.append(altModDesc);</span>
			}
			else
			{
<span class="nc" id="L1277">				desc.append('-');</span>
			}
		}
<span class="nc" id="L1280">		return desc.toString();</span>
	}

	/**
	 * OwnedItem Sets the location attribute of the Equipment object
	 * @param newLocation
	 *            EquipmentLocation containing the new location value
	 */
	public void setLocation(final EquipmentLocation newLocation)
	{
<span class="nc bnc" id="L1290" title="All 2 branches missed.">		if (EquipmentLocation.CONTAINED.equals(newLocation))</span>
		{
<span class="nc" id="L1292">			location = EquipmentLocation.CARRIED_NEITHER;</span>
		}
		else
		{
<span class="nc" id="L1296">			location = newLocation;</span>
		}
<span class="nc" id="L1298">		equipped = location.isEquipped();</span>
<span class="nc" id="L1299">	}</span>

	/**
	 * OwnedItem Gets the hand attribute of the Equipment object
	 * 
	 * @return EquipmentLocation containing the location value
	 */
	public EquipmentLocation getLocation()
	{
<span class="nc" id="L1308">		return location;</span>
	}

	/**
	 * Get maximum charges
	 * 
	 * @return maximum charges
	 */
	public int getMaxCharges()
	{
<span class="nc" id="L1318">		return getEqModifierList(true).stream().map(eqMod -&gt; eqMod.get(IntegerKey.MAX_CHARGES))</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">			.filter(max -&gt; max != null &amp;&amp; max &gt; 0).findFirst().orElse(0);</span>

	}

	/**
	 * Get minimum charges
	 * 
	 * @return minimum charges
	 */
	public int getMinCharges()
	{
<span class="nc" id="L1330">		return getEqModifierList(true).stream().map(eqMod -&gt; eqMod.get(IntegerKey.MIN_CHARGES)).filter(Objects::nonNull)</span>
<span class="nc" id="L1331">			.findFirst().orElse(0);</span>

	}

	/**
	 * Set the name (sets keyname also)
	 *
	 * @param aString The new name
	 */

	@Override
	public void setName(final String aString)
	{
<span class="fc" id="L1344">		super.setName(aString);</span>
<span class="fc" id="L1345">		setDirty(true);</span>
<span class="fc" id="L1346">	}</span>

	/**
	 * Sets the modifiedName attribute of the Equipment object
	 * 
	 * @param nameString
	 *            The new modifiedName value
	 */
	public void setModifiedName(final String nameString)
	{
<span class="fc" id="L1356">		modifiedName = nameString;</span>
<span class="fc" id="L1357">		setDirty(true);</span>
<span class="fc" id="L1358">	}</span>

	/**
	 * Sets the moveString attribute of the Equipment object
	 * 
	 * @param aString
	 *            The new moveString value
	 */
	private void setMoveString(final String aString)
	{
<span class="nc" id="L1368">		moveString = aString;</span>
<span class="nc" id="L1369">	}</span>

	/**
	 * Gets the name attribute of the Equipment object. Note 
	 * this is separate from toStirng to avoid side effects on keys.
	 * 
	 * @return The name value
	 */
	public String getName()
	{
<span class="nc" id="L1379">		final StringBuilder buffer = new StringBuilder(100);</span>

<span class="nc" id="L1381">		buffer.append(getDisplayName());</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">		if (!modifiedName.isEmpty())</span>
		{
<span class="nc" id="L1384">			buffer.append(&quot; (&quot;).append(modifiedName).append(&quot;)&quot;);</span>
		}

<span class="nc" id="L1387">		return buffer.toString();</span>
	}

	/**
	 * set's the player added note for this item
	 * 
	 * @param aString the value of the note
	 */
	public void setNote(final String aString)
	{
<span class="nc" id="L1397">		noteString = aString;</span>
<span class="nc" id="L1398">	}</span>

	/**
	 * return the player added note for this item
	 * 
	 * @return note
	 */
	public String getNote()
	{
<span class="nc" id="L1407">		return noteString;</span>
	}

	/**
	 * Sets the numberCarried attribute of the Equipment object.
	 * 
	 * @param aNumber
	 *            The new numberCarried value
	 */
	public void setNumberCarried(final Float aNumber)
	{
<span class="fc" id="L1418">		carried = aNumber;</span>
<span class="fc" id="L1419">	}</span>

	/**
	 * Sets the numberEquipped attribute of the Equipment object.
	 * @param num
	 *            The new numberEquipped value
	 */
	public void setNumberEquipped(final int num)
	{
<span class="nc" id="L1428">		numberEquipped = num;</span>

<span class="nc bnc" id="L1430" title="All 2 branches missed.">		if (num &gt; 0)</span>
		{
<span class="nc" id="L1432">			equipped = true;</span>
		}
<span class="nc" id="L1434">	}</span>

	/**
	 * Gets the numberEquipped attribute of the Equipment object.
	 * 
	 * @return The numberEquipped value
	 */
	public int getNumberEquipped()
	{
<span class="nc" id="L1443">		return numberEquipped;</span>
	}

	/**
	 * Set this item's output index, which controls the order in which the
	 * equipment appears on a character sheet. Note: -1 means hidden and 0 means
	 * not set &lt;p&gt; &lt;br&gt;
	 * author: James Dempsey 17-Jun-02
	 * 
	 * @param newIndex
	 *            the new output index for this equipment item (-1=hidden, 0=not
	 *            set)
	 */
	public void setOutputIndex(final int newIndex)
	{
<span class="fc" id="L1458">		outputIndex = newIndex;</span>
<span class="fc" id="L1459">	}</span>

	/**
	 * Return the output index, which controls the order in which the equipment
	 * appears on a character sheet. Note: -1 means hidden and 0 means not set
	 * &lt;p&gt; &lt;br&gt;
	 * author: James Dempsey 17-Jun-02
	 * 
	 * @return the output index for this equipment item (-1=hidden, 0=not set)
	 */
	public int getOutputIndex()
	{
<span class="nc" id="L1471">		return outputIndex;</span>
	}

	/**
	 * Set this item's output subindex, which controls the order in which
	 * equipment with the same output index appears on a character sheet. This
	 * basically applies to natural weapons only, since they have output index 0
	 * &lt;p&gt; &lt;br&gt;
	 * author: Stefan Radermacher 11-Feb-05
	 * 
	 * @param newSubindex
	 *            the new output subindex for this equipment item
	 */
	public void setOutputSubindex(final int newSubindex)
	{
<span class="fc" id="L1486">		outputSubindex = newSubindex;</span>
<span class="fc" id="L1487">	}</span>

	/**
	 * Return the output subindex, which controls the order in which equipment
	 * with the same output index appears on a character sheet. This basically
	 * applies to natural weapons only, since they have output index 0 &lt;p&gt; &lt;br&gt;
	 * author: Stefan Radermacher 11-Feb-05
	 * 
	 * @return the output subindex for this equipment item
	 */
	public int getOutputSubindex()
	{
<span class="nc" id="L1499">		return outputSubindex;</span>
	}

	/**
	 * Sets the parent attribute of the Equipment object
	 * 
	 * @param parent
	 *            The new parent value
	 */
	public void setParent(final Equipment parent)
	{
<span class="nc" id="L1510">		d_parent = parent;</span>
<span class="nc" id="L1511">	}</span>

	/**
	 * Gets the parent of the Equipment object
	 * 
	 * @return The parent
	 */
	public Equipment getParent()
	{
<span class="nc" id="L1520">		return d_parent;</span>
	}

	/**
	 * Gets the parentName of the Equipment object
	 * 
	 * @return The parentName
	 */
	public String getParentName()
	{
<span class="nc" id="L1530">		final Equipment anEquip = getParent();</span>

<span class="nc bnc" id="L1532" title="All 2 branches missed.">		if (anEquip != null)</span>
		{
<span class="nc" id="L1534">			return anEquip.toString();</span>
		}

<span class="nc bnc" id="L1537" title="All 2 branches missed.">		if (isEquipped())</span>
		{
<span class="nc" id="L1539">			return &quot;Equipped&quot;;</span>
		}

<span class="nc bnc" id="L1542" title="All 2 branches missed.">		if (numberCarried().intValue() &gt; 0)</span>
		{
<span class="nc" id="L1544">			return &quot;Carried&quot;;</span>
		}

<span class="nc" id="L1547">		return &quot;&quot;;</span>
	}

	/**
	 * Callback function from PObject.passesPreReqToGainForList()
	 * 
	 * @param aType The string to be tested for PRETYPEness
	 *              PRETYPE:EQMODTYPE=MagicalEnhancement
	 *              PRETYPE:[EQMOD=Holy],EQMOD=WEAP+5
	 *              PRETYPE:.IF.TYPE=Armor.Shield.Weapon.THEN.EQMODTYPE=MagicalEnhancement.ELSE.
	 *
	 * @return true if the Equipment's types match the aType string
	 */
	public boolean isPreType(String aType)
	{

<span class="nc" id="L1563">		String tString = aType;</span>

		// PRETYPE:EQMODTYPE=MagicalEnhancement
		// PRETYPE:[EQMOD=Holy],EQMOD=WEAP+5
		// PRETYPE:.IF.TYPE=Armor.Shield.Weapon.THEN.EQMODTYPE=MagicalEnhancement.ELSE.

<span class="nc bnc" id="L1569" title="All 2 branches missed.">		if (tString.startsWith(&quot;.IF.TYPE=&quot;))</span>
		{

<span class="nc" id="L1572">			final StringTokenizer aTok = new StringTokenizer(tString.substring(9), &quot;.&quot;);</span>

<span class="nc" id="L1574">			int idx = tString.indexOf(&quot;.THEN.&quot;);</span>

<span class="nc bnc" id="L1576" title="All 2 branches missed.">			if (idx &lt; 0)</span>
			{
<span class="nc" id="L1578">				return false;</span>
			}

<span class="nc" id="L1581">			String truePart = tString.substring(idx + 6);</span>
<span class="nc" id="L1582">			int idx1 = truePart.indexOf(&quot;.ELSE.&quot;);</span>

<span class="nc" id="L1584">			String falsePart = &quot;&quot;;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">			if (idx1 &gt;= 0)</span>
			{
<span class="nc" id="L1587">				falsePart = truePart.substring(idx1 + 6);</span>
<span class="nc" id="L1588">				truePart = truePart.substring(0, idx1);</span>
			}

<span class="nc" id="L1591">			boolean typeFound = false;</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">			while (aTok.hasMoreTokens())</span>
			{
<span class="nc" id="L1594">				final String aString = aTok.nextToken();</span>

<span class="nc bnc" id="L1596" title="All 2 branches missed.">				if (isType(aString, bonusPrimary))</span>
				{
<span class="nc" id="L1598">					typeFound = true;</span>

<span class="nc" id="L1600">					break;</span>
				}
<span class="nc" id="L1602">			}</span>

<span class="nc bnc" id="L1604" title="All 2 branches missed.">			if (typeFound)</span>
			{
<span class="nc" id="L1606">				tString = truePart;</span>
			}
			else
			{
<span class="nc" id="L1610">				tString = falsePart;</span>
			}

<span class="nc bnc" id="L1613" title="All 2 branches missed.">			if (tString.isEmpty())</span>
			{
<span class="nc" id="L1615">				return true;</span>
			}
		}

<span class="nc bnc" id="L1619" title="All 4 branches missed.">		if (tString.startsWith(&quot;EQMODTYPE=&quot;) || tString.startsWith(&quot;EQMODTYPE.&quot;))</span>
		{
<span class="nc" id="L1621">			tString = tString.substring(10);</span>

<span class="nc bnc" id="L1623" title="All 2 branches missed.">			for (EquipmentModifier eqMod : getEqModifierList(bonusPrimary))</span>
			{
<span class="nc bnc" id="L1625" title="All 2 branches missed.">				if (eqMod.isType(tString))</span>
				{
<span class="nc" id="L1627">					return true;</span>
				}
<span class="nc" id="L1629">			}</span>

<span class="nc" id="L1631">			return false;</span>
		}
<span class="nc bnc" id="L1633" title="All 4 branches missed.">		else if (tString.startsWith(&quot;EQMOD=&quot;) || tString.startsWith(&quot;EQMOD.&quot;))</span>
		{
<span class="nc" id="L1635">			String key = tString.substring(6);</span>
<span class="nc" id="L1636">			String choice = &quot;&quot;;</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">			if (key.indexOf('(') &gt; 0)</span>
			{
<span class="nc" id="L1639">				int i = key.indexOf('(');</span>
<span class="nc" id="L1640">				choice = key.substring(i + 1, key.lastIndexOf(')'));</span>
<span class="nc" id="L1641">				key = key.substring(0, i);</span>
			}

<span class="nc" id="L1644">			EquipmentModifier eqMod = getEqModifierKeyed(key, bonusPrimary);</span>
<span class="nc bnc" id="L1645" title="All 2 branches missed.">			if (eqMod != null)</span>
			{
<span class="nc bnc" id="L1647" title="All 2 branches missed.">				if (StringUtils.isEmpty(choice))</span>
				{
<span class="nc" id="L1649">					return true;</span>
				}
<span class="nc bnc" id="L1651" title="All 4 branches missed.">				return (hasAssociations(eqMod) &amp;&amp; choice.equalsIgnoreCase(getFirstAssociation(eqMod)));</span>
			}
<span class="nc" id="L1653">			return false;</span>
		}

<span class="nc" id="L1656">		return isType(tString, bonusPrimary);</span>
	}

	/**
	 * Sets the qty attribute of the Equipment object
	 * 
	 * @param aString
	 *            The new qty value
	 */
	public void setQty(final String aString)
	{
		try
		{
<span class="nc" id="L1669">			setQty(Double.parseDouble(aString));</span>
		}
<span class="nc" id="L1671">		catch (NumberFormatException nfe)</span>
		{
<span class="nc" id="L1673">			qty = 0.0;</span>
<span class="nc" id="L1674">		}</span>
<span class="nc" id="L1675">	}</span>

	/**
	 * Sets the qty attribute of the Equipment object
	 * 
	 * @param aFloat
	 *            The new qty value
	 */
	public void setQty(final Float aFloat)
	{
<span class="fc" id="L1685">		setQty(aFloat.doubleValue());</span>
<span class="fc" id="L1686">	}</span>

	/**
	 * Get the quantity of items
	 * 
	 * @return return a Float of the quantity
	 */
	public Float getQty()
	{
<span class="nc" id="L1695">		return (float) qty;</span>
	}

	/**
	 * Gets the rawCritRange attribute of the Equipment object
	 * 
	 * @param bPrimary
	 *            True=Primary Head
	 * @return The rawCritRange value
	 * @deprecated due to CRITRANGE code control
	 */
	@Deprecated
	public int getRawCritRange(final boolean bPrimary)
	{
<span class="nc bnc" id="L1709" title="All 2 branches missed.">		int range = getHeadInfo(bPrimary ? 1 : 2, IntegerKey.CRIT_RANGE);</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">		if (range == 0)</span>
		{
<span class="nc" id="L1712">			String cr = getWeaponInfo(&quot;CRITRANGE&quot;, bPrimary);</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">			if (!cr.isEmpty())</span>
			{
				try
				{
<span class="nc" id="L1717">					range = Integer.parseInt(cr);</span>
				}
<span class="nc" id="L1719">				catch (NumberFormatException ignore)</span>
				{
					//ignore
<span class="nc" id="L1722">				}</span>
			}
		}
<span class="nc" id="L1725">		return range;</span>
	}

	/**
	 * Get the raw special properties
	 * 
	 * @return raw special propertie
	 */
	@Override
	public String getRawSpecialProperties()
	{
		//CONSIDER standardize this with other joins?
<span class="nc" id="L1737">		final StringBuilder retString = new StringBuilder(200);</span>
<span class="nc" id="L1738">		boolean first = true;</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">		for (SpecialProperty sprop : getSafeListFor(ListKey.SPECIAL_PROPERTIES))</span>
		{
<span class="nc bnc" id="L1741" title="All 2 branches missed.">			if (!first)</span>
			{
<span class="nc" id="L1743">				retString.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L1745">			first = false;</span>
<span class="nc" id="L1746">			retString.append(sprop.getText());</span>
<span class="nc" id="L1747">		}</span>
<span class="nc" id="L1748">		return retString.toString();</span>
	}

	/**
	 * Set the remaining charges
	 * 
	 * @param remainingCharges The number of charges remaining
	 */
	public void setRemainingCharges(final int remainingCharges)
	{

<span class="nc bnc" id="L1759" title="All 2 branches missed.">		for (EquipmentModifier eqMod : getEqModifierList(true))</span>
		{

<span class="nc" id="L1762">			Integer min = eqMod.get(IntegerKey.MIN_CHARGES);</span>

<span class="nc bnc" id="L1764" title="All 4 branches missed.">			if (min != null &amp;&amp; min &gt; 0)</span>
			{
<span class="nc" id="L1766">				EqModSpellInfo.setRemainingCharges(this, eqMod, remainingCharges);</span>
			}
<span class="nc" id="L1768">		}</span>
<span class="nc" id="L1769">	}</span>

	/**
	 * Get the remaining charges
	 * 
	 * @return remaining charges
	 */
	public int getRemainingCharges()
	{
<span class="nc bnc" id="L1778" title="All 2 branches missed.">		for (EquipmentModifier eqMod : getEqModifierList(true))</span>
		{
<span class="nc" id="L1780">			Integer min = eqMod.get(IntegerKey.MIN_CHARGES);</span>
<span class="nc bnc" id="L1781" title="All 4 branches missed.">			if (min != null &amp;&amp; min &gt; 0)</span>
			{
<span class="nc" id="L1783">				return EqModSpellInfo.getRemainingCharges(this, eqMod);</span>
			}
<span class="nc" id="L1785">		}</span>

<span class="nc" id="L1787">		return -1;</span>
	}

	/**
	 * Gets the simple name attribute of the Equipment object
	 * 
	 * @return The name value
	 */
	public String getSimpleName()
	{
<span class="nc" id="L1797">		return getDisplayName();</span>
	}

	/**
	 * Gets the size attribute of the Equipment object
	 * 
	 * @return The size value
	 */
	public String getSize()
	{
<span class="nc" id="L1807">		return getSizeAdjustment().getKeyName();</span>
	}

	public SizeAdjustment getSizeAdjustment()
	{
<span class="nc" id="L1812">		return getSafe(ObjectKey.SIZE).get();</span>
	}

	/**
	 * The number of &quot;Slots&quot; that this item requires The slot type is derived
	 * from system/special/equipmentslot.lst
	 * 
	 * @param aPC the PC with the Equipment
	 * @return slots
	 */
	public int getSlots(final PlayerCharacter aPC)
	{
<span class="nc" id="L1824">		int iSlots = getSafe(IntegerKey.SLOTS);</span>

<span class="nc" id="L1826">		EquipmentHead head = getEquipmentHeadReference(1);</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">		if (head != null)</span>
		{
<span class="nc bnc" id="L1829" title="All 2 branches missed.">			for (EquipmentModifier eqMod : head.getSafeListFor(ListKey.EQMOD))</span>
			{
<span class="nc" id="L1831">				iSlots += (int) eqMod.bonusTo(aPC, &quot;EQM&quot;, &quot;HANDS&quot;, this);</span>
<span class="nc" id="L1832">				iSlots += (int) eqMod.bonusTo(aPC, &quot;EQM&quot;, &quot;SLOTS&quot;, this);</span>
<span class="nc" id="L1833">			}</span>
		}

<span class="nc bnc" id="L1836" title="All 2 branches missed.">		if (iSlots &lt; 0)</span>
		{
<span class="nc" id="L1838">			iSlots = 0;</span>
		}

<span class="nc" id="L1841">		return iSlots;</span>
	}

	public String getSlot()
	{
<span class="nc" id="L1846">		return SystemCollections.getUnmodifiableEquipSlotList().stream().filter(es -&gt; es.canContainType(getType()))</span>
<span class="nc" id="L1847">			.findFirst().map(EquipSlot::getSlotName).orElse(null);</span>
	}

	/**
	 * Returns special properties of an Equipment.
	 * 
	 * @param aPC The PC with the Equipment
	 * @return special properties of an Equipment.
	 */
	public String getSpecialProperties(final PlayerCharacter aPC)
	{
		final List&lt;EquipmentModifier&gt; modList;
<span class="nc" id="L1859">		EquipmentHead head = getEquipmentHeadReference(1);</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">		if (head == null)</span>
		{
<span class="nc" id="L1862">			modList = Collections.emptyList();</span>
		}
		else
		{
<span class="nc" id="L1866">			modList = head.getSafeListFor(ListKey.EQMOD);</span>
		}

<span class="nc" id="L1869">		EquipmentHead althead = getEquipmentHeadReference(2);</span>
		final List&lt;EquipmentModifier&gt; altModList;
<span class="nc bnc" id="L1871" title="All 2 branches missed.">		if (althead == null)</span>
		{
<span class="nc" id="L1873">			altModList = Collections.emptyList();</span>
		}
		else
		{
<span class="nc" id="L1877">			altModList = althead.getSafeListFor(ListKey.EQMOD);</span>
		}
<span class="nc" id="L1879">		final List&lt;EquipmentModifier&gt; comn = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1881">		extractListFromCommon(comn, modList);</span>

<span class="nc" id="L1883">		removeCommonFromList(altModList, comn, &quot;SPROP: eqMod expected but not found: &quot;);</span>

<span class="nc" id="L1885">		final String common = StringUtil.join(getSpecialAbilityTimesList(getSpecialAbilityList(comn, aPC)), &quot;, &quot;);</span>
<span class="nc" id="L1886">		final String saList1 = StringUtil.join(getSpecialAbilityTimesList(getSpecialAbilityList(modList, aPC)), &quot;, &quot;);</span>
<span class="nc" id="L1887">		final String saList2 =</span>
<span class="nc" id="L1888">				StringUtil.join(getSpecialAbilityTimesList(getSpecialAbilityList(altModList, aPC)), &quot;, &quot;);</span>
<span class="nc" id="L1889">		final StringBuilder sp = new StringBuilder(200);</span>

<span class="nc" id="L1891">		boolean first = true;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">		for (SpecialProperty sprop : getSafeListFor(ListKey.SPECIAL_PROPERTIES))</span>
		{
<span class="nc" id="L1894">			final String text = sprop.getParsedText(aPC, this, this);</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">			if (!&quot;&quot;.equals(text))</span>
			{
<span class="nc bnc" id="L1897" title="All 2 branches missed.">				if (!first)</span>
				{
<span class="nc" id="L1899">					sp.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1901">				first = false;</span>
<span class="nc" id="L1902">				sp.append(text);</span>
			}
<span class="nc" id="L1904">		}</span>

<span class="nc bnc" id="L1906" title="All 2 branches missed.">		if (!common.isEmpty())</span>
		{
<span class="nc bnc" id="L1908" title="All 2 branches missed.">			if (!first)</span>
			{
<span class="nc" id="L1910">				sp.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L1912">			first = false;</span>

<span class="nc" id="L1914">			sp.append(common);</span>
		}

<span class="nc bnc" id="L1917" title="All 2 branches missed.">		if (!saList1.isEmpty())</span>
		{
<span class="nc bnc" id="L1919" title="All 2 branches missed.">			if (!first)</span>
			{
<span class="nc" id="L1921">				sp.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L1923">			first = false;</span>

<span class="nc bnc" id="L1925" title="All 2 branches missed.">			if (isDouble())</span>
			{
<span class="nc" id="L1927">				sp.append(&quot;Head1: &quot;);</span>
			}

<span class="nc" id="L1930">			sp.append(saList1);</span>
		}

<span class="nc bnc" id="L1933" title="All 4 branches missed.">		if (isDouble() &amp;&amp; (!saList2.isEmpty()))</span>
		{
<span class="nc bnc" id="L1935" title="All 2 branches missed.">			if (!first)</span>
			{
<span class="nc" id="L1937">				sp.append(&quot;, &quot;);</span>
			}

<span class="nc" id="L1940">			sp.append(&quot;Head2: &quot;).append(saList2);</span>
		}

<span class="nc" id="L1943">		return sp.toString();</span>
	}

	/**
	 * Gets the uberParent attribute of the Equipment object
	 * 
	 * @return The uberParent value
	 */
	public Equipment getUberParent()
	{
<span class="nc bnc" id="L1953" title="All 2 branches missed.">		if (getParent() == null)</span>
		{
<span class="nc" id="L1955">			return this;</span>
		}

<span class="nc" id="L1958">		Equipment anEquip = getParent();</span>

<span class="nc bnc" id="L1960" title="All 2 branches missed.">		while (anEquip.getParent() != null)</span>
		{
<span class="nc" id="L1962">			anEquip = anEquip.getParent();</span>
		}

<span class="nc" id="L1965">		return anEquip;</span>
	}

	/**
	 * Get used charges
	 * 
	 * @return used charges
	 */
	public int getUsedCharges()
	{
<span class="nc bnc" id="L1975" title="All 2 branches missed.">		for (EquipmentModifier eqMod : getEqModifierList(true))</span>
		{
<span class="nc" id="L1977">			Integer min = eqMod.get(IntegerKey.MIN_CHARGES);</span>
<span class="nc bnc" id="L1978" title="All 4 branches missed.">			if (min != null &amp;&amp; min &gt; 0)</span>
			{
<span class="nc" id="L1980">				return EqModSpellInfo.getUsedCharges(this, eqMod);</span>
			}
<span class="nc" id="L1982">		}</span>

<span class="nc" id="L1984">		return -1;</span>
	}

	/**
	 * Get the value of a variable passed as aString. This uses a different
	 * variable processor than Player character because equipment has different
	 * &quot;hard coded&quot; variables than a Player Character.
	 * 
	 * @param varName
	 *            The name of the variable to look up
	 * @param src The Source of the variable
	 * @param aPC
	 *            The PC this equipment is associated with
	 * 
	 * @return the value of the variable
	 */
	@Override
	public Float getVariableValue(final String varName, final String src, final PlayerCharacter aPC)
	{
<span class="nc" id="L2003">		return getVariableValue(varName, src, bonusPrimary, aPC);</span>
	}

	/**
	 * Get the value of a variable passed as aString. This uses a different
	 * variable processor than Player character because equipment has different
	 * &quot;hard coded&quot; variables than a Player Character.
	 * 
	 * @param varName
	 *            The name of the variable to look up
	 * @param src The Source of the variable
	 * @param bPrimary
	 *            If the head of the weapon has any effect on the variable
	 *            value, this flag stipulates which head to use (true means use
	 *            the primary head).
	 * @param aPC
	 *            The PC this equipment is associated with
	 * 
	 * @return The value of the variable
	 */
	public Float getVariableValue(String varName, final String src, final boolean bPrimary, final PlayerCharacter aPC)
	{
<span class="nc" id="L2025">		VariableProcessor vp = new VariableProcessorEq(this, aPC, bPrimary);</span>
<span class="nc" id="L2026">		return vp.getVariableValue(null, varName, src, 0);</span>
	}

	/**
	 * Returns true if the equipment modifier is visible
	 * 
	 * @param eqMod
	 *            The equipment modifier
	 * @return The visible value
	 */
	public boolean isVisible(final EquipmentModifier eqMod, View v)
	{
<span class="nc" id="L2038">		Visibility vis = eqMod.getSafe(ObjectKey.VISIBILITY);</span>

<span class="nc bnc" id="L2040" title="All 2 branches missed.">		if (Visibility.QUALIFY.equals(vis))</span>
		{
<span class="nc" id="L2042">			bonusPrimary = true;</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">			if (PrereqHandler.passesAll(eqMod, this, null))</span>
			{
<span class="nc" id="L2045">				return true;</span>
			}
			//
			// Check the secondary head if the primary head doesn't qualify (and
			// the item has a secondary head)
			//
<span class="nc bnc" id="L2051" title="All 2 branches missed.">			if (isDouble())</span>
			{
<span class="nc" id="L2053">				bonusPrimary = false;</span>
<span class="nc" id="L2054">				return PrereqHandler.passesAll(eqMod, this, null);</span>
			}
<span class="nc" id="L2056">			return false;</span>
		}

<span class="nc" id="L2059">		return vis.isVisibleTo(v);</span>
	}

	/**
	 * Returns true if the equipment modifier is visible
	 * 
	 * @param eqMod
	 *            The equipment modifier
	 * @param primaryHead
	 * 			  Is this for the main head (true), or the secondary one (false)?
	 * @return The visible value
	 */
	public boolean isVisible(PlayerCharacter pc, EquipmentModifier eqMod, boolean primaryHead, View v)
	{
<span class="nc" id="L2073">		Visibility vis = eqMod.getSafe(ObjectKey.VISIBILITY);</span>

<span class="nc bnc" id="L2075" title="All 2 branches missed.">		if (Visibility.QUALIFY.equals(vis))</span>
		{
<span class="nc" id="L2077">			bonusPrimary = primaryHead;</span>
<span class="nc" id="L2078">			return PrereqHandler.passesAll(eqMod, this, pc);</span>
		}

<span class="nc" id="L2081">		return vis.isVisibleTo(v);</span>
	}

	/**
	 * Gets the weight attribute of the Equipment object.
	 * 
	 * @param aPC The PC that has this Equipment
	 * 
	 * @return The weight value
	 */
	public Float getWeight(final PlayerCharacter aPC)
	{
<span class="nc bnc" id="L2093" title="All 2 branches missed.">		if (virtualItem)</span>
		{
<span class="nc" id="L2095">			return (float) 0.0;</span>
		}
<span class="nc" id="L2097">		return (float) getWeightAsDouble(aPC);</span>
	}

	/**
	 * get base weight as double
	 * 
	 * @return base weight (as a double)
	 */
	private BigDecimal getBaseWeight()
	{
<span class="nc bnc" id="L2107" title="All 2 branches missed.">		if (this.isVirtual())</span>
		{
<span class="nc" id="L2109">			return BigDecimal.ZERO;</span>
		}
<span class="nc" id="L2111">		return getWeightInPounds().add(getSafe(ObjectKey.WEIGHT_MOD));</span>
	}

	/**
	 * Get the weight as a double
	 * 
	 * @param aPC The PC that has this Equipment
	 * @return weight as double
	 */
	public double getWeightAsDouble(final PlayerCharacter aPC)
	{
<span class="nc bnc" id="L2122" title="All 2 branches missed.">		if (isVirtual())</span>
		{
<span class="nc" id="L2124">			return 0.0;</span>
		}

<span class="nc" id="L2127">		double d1 = bonusTo(aPC, &quot;EQM&quot;, &quot;WEIGHTMULT&quot;, true);</span>

<span class="nc" id="L2129">		double aWeight = getWeightInPounds().doubleValue();</span>

<span class="nc bnc" id="L2131" title="All 2 branches missed.">		if (!CoreUtility.doublesEqual(d1, 0.0))</span>
		{
<span class="nc" id="L2133">			aWeight *= d1;</span>
		}

<span class="nc" id="L2136">		double d2 = bonusTo(aPC, &quot;EQM&quot;, &quot;WEIGHTDIV&quot;, true);</span>

<span class="nc bnc" id="L2138" title="All 2 branches missed.">		if (!CoreUtility.doublesEqual(d2, 0))</span>
		{
<span class="nc" id="L2140">			aWeight /= d2;</span>
		}

<span class="nc" id="L2143">		aWeight += bonusTo(aPC, &quot;EQM&quot;, &quot;WEIGHTADD&quot;, true);</span>
<span class="nc" id="L2144">		aWeight += getSafe(ObjectKey.WEIGHT_MOD).doubleValue();</span>

<span class="nc" id="L2146">		return aWeight;</span>
	}

	/**
	 * Get wield
	 * 
	 * @return wield
	 */
	public String getWieldName()
	{
<span class="nc" id="L2156">		WieldCategory wield = get(ObjectKey.WIELD);</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">		return wield == null ? &quot;&quot; : wield.getKeyName();</span>
	}

	/**
	 * Description of the Method
	 * 
	 * @param aPC The PC that has this Equipment
	 * 
	 * @return Description of the Return Value
	 * @deprecated due to ACCHECK code control
	 */
	@Deprecated
	public Integer preFormulaAcCheck(final PlayerCharacter aPC)
	{
<span class="nc" id="L2171">		return Math.min(getSafe(IntegerKey.AC_CHECK) + (int) bonusTo(aPC, &quot;EQMARMOR&quot;, &quot;ACCHECK&quot;, true), 0);</span>
	}

	/**
	 * Returns true if the Equipment can take children.
	 * 
	 * @return true if the Equipment can take children.
	 */
	public boolean isContainer()
	{
<span class="nc bnc" id="L2181" title="All 2 branches missed.">		return get(ObjectKey.CONTAINER_WEIGHT_CAPACITY) != null;</span>
	}

	/**
	 * Add an equipment modifier and its associated information eg:
	 * Bane|Vermin|Fey eg: Keen Adds a feature to the EqModifier attribute of
	 * the Equipment object
	 * 
	 * @param aString
	 *            The feature to be added to the EqModifier attribute
	 * @param bPrimary
	 *            The feature to be added to the EqModifier attribute
	 * @param isLoading Is the equipment item being loaded currently. 
	 */
	private void addEqModifier(final String aString, final boolean bPrimary, final boolean isLoading)
	{
<span class="nc" id="L2197">		final StringTokenizer aTok = new StringTokenizer(aString, &quot;|&quot;);</span>

		// The type of EqMod, eg: ABILITYPLUS
<span class="nc" id="L2200">		final String eqModKey = aTok.nextToken();</span>

<span class="nc" id="L2202">		EquipmentModifier eqMod = getEqModifierKeyed(eqModKey, bPrimary);</span>

		// If not already attached, then add a new one
<span class="nc bnc" id="L2205" title="All 2 branches missed.">		if (eqMod == null)</span>
		{
<span class="nc bnc" id="L2207" title="All 2 branches missed.">			if (eqModKey.equals(EQMOD_WEIGHT))</span>
			{
<span class="nc bnc" id="L2209" title="All 2 branches missed.">				if (aTok.hasMoreTokens())</span>
				{
<span class="nc" id="L2211">					put(ObjectKey.WEIGHT_MOD, new BigDecimal(aTok.nextToken().replace(',', '.')));</span>
				}
<span class="nc" id="L2213">				return;</span>
			}

<span class="nc bnc" id="L2216" title="All 2 branches missed.">			if (eqModKey.equals(EQMOD_DAMAGE))</span>
			{
<span class="nc bnc" id="L2218" title="All 2 branches missed.">				if (aTok.hasMoreTokens())</span>
				{
<span class="nc" id="L2220">					put(StringKey.DAMAGE_OVERRIDE, aTok.nextToken());</span>
				}
<span class="nc" id="L2222">				return;</span>
			}

<span class="nc" id="L2225">			eqMod = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(EquipmentModifier.class,</span>
				eqModKey);

<span class="nc bnc" id="L2228" title="All 2 branches missed.">			if (eqMod == null)</span>
			{
<span class="nc" id="L2230">				Logging.errorPrint(&quot;Could not find EquipmentModifier: &quot; + eqModKey);</span>

<span class="nc" id="L2232">				return;</span>
			}

			// only make a copy if we need to
			// add qualifiers to modifier
<span class="nc bnc" id="L2237" title="All 2 branches missed.">			if (!eqMod.getSafe(StringKey.CHOICE_STRING).isEmpty())</span>
			{
<span class="nc" id="L2239">				eqMod = eqMod.clone();</span>
			}

<span class="nc" id="L2242">			addToEqModifierList(eqMod, bPrimary);</span>
		}

		// Add the associated choices
<span class="nc bnc" id="L2246" title="All 2 branches missed.">		if (!eqMod.getSafe(StringKey.CHOICE_STRING).isEmpty())</span>
		{
<span class="nc bnc" id="L2248" title="All 2 branches missed.">			while (aTok.hasMoreTokens())</span>
			{
<span class="nc" id="L2250">				final String x = aTok.nextToken();</span>
<span class="nc" id="L2251">				Integer min = eqMod.get(IntegerKey.MIN_CHARGES);</span>
<span class="nc bnc" id="L2252" title="All 4 branches missed.">				if (min != null &amp;&amp; min &gt; 0</span>
<span class="nc bnc" id="L2253" title="All 4 branches missed.">					|| (eqMod.getSafe(StringKey.CHOICE_STRING).startsWith(&quot;EQBUILDER&quot;) &amp;&amp; !isLoading))</span>
				{
					// We clear the associated info to avoid a buildup of info
					// like number of charges.
<span class="nc" id="L2257">					removeAllAssociations(eqMod);</span>
				}
<span class="nc" id="L2259">				addAssociation(eqMod, x.replace('=', '|'));</span>
<span class="nc" id="L2260">			}</span>
		}
<span class="nc" id="L2262">	}</span>

	/**
	 * Adds a feature to the EqModifier attribute of the Equipment object. If a
	 * choice is required, a dialog will be displayed asking the user for the
	 * choice.
	 * 
	 * @param eqMod
	 *            The feature to be added to the EqModifier attribute
	 * @param bPrimary
	 *            The feature to be added to the EqModifier attribute
	 * @param aPC
	 *            The PC that the modifier is being added for.
	 */
	public void addEqModifier(final EquipmentModifier eqMod, final boolean bPrimary, final PlayerCharacter aPC)
	{
<span class="nc" id="L2278">		addEqModifier(eqMod, bPrimary, aPC, null, null);</span>
<span class="nc" id="L2279">	}</span>

	/**
	 * Adds a feature to the EqModifier attribute of the Equipment object. If a
	 * non-null selectedChoice is supplied, this method will not be interactive,
	 * and will not show a dialog if a choice is required. Instead, the provided
	 * value will be used.
	 * 
	 * @param eqMod
	 *            The feature to be added to the EqModifier attribute
	 * @param bPrimary
	 *            The feature to be added to the EqModifier attribute
	 * @param aPC
	 *            The PC that the modifier is being added for.
	 * @param selectedChoice
	 *            The choice to be used instead of asking the user, should a
	 *            choice be required.
	 * @param equipChoice
	 *            The details of the choice to be made. Used when there are
	 *            secondary options.
	 */
	void addEqModifier(final EquipmentModifier eqMod, final boolean bPrimary, final PlayerCharacter aPC,
		final String selectedChoice, final EquipmentChoice equipChoice)
	{
<span class="nc" id="L2303">		boolean bImporting = false;</span>

<span class="nc bnc" id="L2305" title="All 4 branches missed.">		if ((aPC != null) &amp;&amp; aPC.isImporting())</span>
		{
<span class="nc" id="L2307">			bImporting = true;</span>
		}

<span class="nc bnc" id="L2310" title="All 4 branches missed.">		if (!bImporting &amp;&amp; !canAddModifier(aPC, eqMod, bPrimary))</span>
		{
<span class="nc" id="L2312">			return;</span>
		}

<span class="nc" id="L2315">		List&lt;CDOMSingleRef&lt;EquipmentModifier&gt;&gt; replaces = eqMod.getListFor(ListKey.REPLACED_KEYS);</span>

<span class="nc bnc" id="L2317" title="All 2 branches missed.">		EquipmentHead head = getEquipmentHead(bPrimary ? 1 : 2);</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">		if (replaces != null)</span>
		{
			//
			// Remove any modifiers that this one will replace
			//
<span class="nc" id="L2323">			replaces.stream().map(CDOMSingleRef::get).map(CDOMObject::getKeyName)</span>
<span class="nc" id="L2324">				.forEach(key -&gt; head.getSafeListFor(ListKey.EQMOD).stream()</span>
<span class="nc" id="L2325">					.filter(aMod -&gt; key.equalsIgnoreCase(aMod.getKeyName())).forEach(aMod -&gt; {</span>
<span class="nc" id="L2326">						head.removeFromListFor(ListKey.EQMOD, aMod);</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">						if (bPrimary)</span>
						{
<span class="nc" id="L2329">							usePrimaryCache = false;</span>
						}
						else
						{
<span class="nc" id="L2333">							useSecondaryCache = false;</span>
						}
<span class="nc" id="L2335">						setDirty(true);</span>
<span class="nc" id="L2336">					}));</span>
		}

<span class="nc bnc" id="L2339" title="All 2 branches missed.">		if (eqMod.isType(&quot;BaseMaterial&quot;))</span>
		{
<span class="nc" id="L2341">			head.getSafeListFor(ListKey.EQMOD).stream().filter(aMod -&gt; aMod.isType(&quot;BaseMaterial&quot;)).forEach(aMod -&gt; {</span>
<span class="nc" id="L2342">				head.removeFromListFor(ListKey.EQMOD, aMod);</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">				if (bPrimary)</span>
				{
<span class="nc" id="L2345">					usePrimaryCache = false;</span>
				}
				else
				{
<span class="nc" id="L2349">					useSecondaryCache = false;</span>
				}
<span class="nc" id="L2351">				setDirty(true);</span>
<span class="nc" id="L2352">			});</span>
		}
<span class="nc bnc" id="L2354" title="All 2 branches missed.">		else if (eqMod.isType(&quot;MagicalEnhancement&quot;))</span>
		{
<span class="nc" id="L2356">			head.getSafeListFor(ListKey.EQMOD).stream().filter(aMod -&gt; aMod.isType(&quot;MagicalEnhancement&quot;))</span>
<span class="nc" id="L2357">				.forEach(aMod -&gt; {</span>
<span class="nc" id="L2358">					head.removeFromListFor(ListKey.EQMOD, aMod);</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">					if (bPrimary)</span>
					{
<span class="nc" id="L2361">						usePrimaryCache = false;</span>
					}
					else
					{
<span class="nc" id="L2365">						useSecondaryCache = false;</span>
					}
<span class="nc" id="L2367">				});</span>
		}

		//
		// Add the modifier if it's not already there
		//
<span class="nc" id="L2373">		EquipmentModifier aMod = getEqModifierKeyed(eqMod.getKeyName(), bPrimary);</span>

<span class="nc bnc" id="L2375" title="All 2 branches missed.">		if (aMod == null)</span>
		{
			//
			// only make a copy if we need to add qualifiers to modifier
			//
<span class="nc bnc" id="L2380" title="All 2 branches missed.">			if (eqMod.getSafe(StringKey.CHOICE_STRING).isEmpty())</span>
			{
<span class="nc" id="L2382">				aMod = eqMod;</span>
			}
			else
			{
<span class="nc" id="L2386">				aMod = eqMod.clone();</span>

<span class="nc bnc" id="L2388" title="All 2 branches missed.">				if (aMod == null)</span>
				{
<span class="nc" id="L2390">					return;</span>
				}
			}

<span class="nc" id="L2394">			addToEqModifierList(aMod, bPrimary);</span>
		}

		//
		// If a choice is required, either get a response from user or
		// apply the provided choice.
		// Remove the modifier if all associated choices are deleted
		//
<span class="nc bnc" id="L2402" title="All 2 branches missed.">		if (!bImporting)</span>
		{
<span class="nc" id="L2404">			boolean allRemoved = false;</span>
<span class="nc bnc" id="L2405" title="All 4 branches missed.">			if (selectedChoice != null &amp;&amp; !selectedChoice.isEmpty())</span>
			{
<span class="nc bnc" id="L2407" title="All 2 branches missed.">				if (!eqMod.getSafe(StringKey.CHOICE_STRING).startsWith(&quot;EQBUILDER.&quot;))</span>
				{
<span class="nc" id="L2409">					EquipmentChoiceDriver.setChoice(this, aMod, selectedChoice, equipChoice);</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">					allRemoved = !hasAssociations(aMod);</span>
				}
			}
<span class="nc bnc" id="L2413" title="All 2 branches missed.">			else if (!EquipmentChoiceDriver.getChoice(1, this, aMod, true, aPC))</span>
			{
<span class="nc" id="L2415">				allRemoved = true;</span>
			}

<span class="nc bnc" id="L2418" title="All 2 branches missed.">			if (allRemoved)</span>
			{
<span class="nc" id="L2420">				head.removeFromListFor(ListKey.EQMOD, aMod);</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">				if (bPrimary)</span>
				{
<span class="nc" id="L2423">					usePrimaryCache = false;</span>
				}
				else
				{
<span class="nc" id="L2427">					useSecondaryCache = false;</span>
				}
			}
		}

<span class="nc" id="L2432">		setBase();</span>
<span class="nc" id="L2433">	}</span>

	/**
	 * Add a list equipment modifiers and their associated information eg:
	 * Bane|Vermin|Fey.Keen.Vorpal.ABILITYPLUS|CHA=+6 &lt;p&gt; Adds a feature to the
	 * EqModifiers attribute of the Equipment object
	 * 
	 * @param aString
	 *            The feature to be added to the EqModifiers attribute
	 * @param bPrimary
	 *            The feature to be added to the EqModifiers attribute
	 */
	public void addEqModifiers(final String aString, final boolean bPrimary)
	{
<span class="nc" id="L2447">		addEqModifiers(aString, bPrimary, false);</span>
<span class="nc" id="L2448">	}</span>

	/**
	 * Add a list equipment modifiers and their associated information eg:
	 * Bane|Vermin|Fey.Keen.Vorpal.ABILITYPLUS|CHA=+6 &lt;p&gt; Adds a feature to the
	 * EqModifiers attribute of the Equipment object
	 * 
	 * @param aString
	 *            The feature to be added to the EqModifiers attribute
	 * @param bPrimary
	 *            The feature to be added to the EqModifiers attribute
	 * @param isLoading Is the equipment item being loaded currently. 
	 */
	private void addEqModifiers(final String aString, final boolean bPrimary, final boolean isLoading)
	{
<span class="nc" id="L2463">		final StringTokenizer aTok = new StringTokenizer(aString, &quot;.&quot;);</span>

<span class="nc bnc" id="L2465" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L2467">			final String aEqModName = aTok.nextToken();</span>

<span class="nc bnc" id="L2469" title="All 2 branches missed.">			if (!aEqModName.equalsIgnoreCase(Constants.NONE))</span>
			{
<span class="nc" id="L2471">				addEqModifier(aEqModName, bPrimary, isLoading);</span>
			}
<span class="nc" id="L2473">		}</span>
<span class="nc" id="L2474">	}</span>

	/**
	 * Description of the Method
	 * 
	 * @param aPC
	 *            The PC that has this Equipment
	 * @param aType
	 *            a TYPE of BONUS (such as &quot;COMBAT&quot; or &quot;AC&quot;)
	 * @param aName
	 *            the NAME of the BONUS (such as &quot;ATTACKS&quot; or &quot;ARMOR&quot;)
	 * @param bPrimary
	 *            should we ask the parent object also?
	 * @return returns a double which is the sum of all bonuses
	 */
	public double bonusTo(final PlayerCharacter aPC, final String aType, final String aName, final boolean bPrimary)
	{
<span class="nc" id="L2491">		return bonusTo(aPC, aType, aName, this, bPrimary);</span>
	}

	/**
	 * Add bonuses
	 * 
	 * @param aPC
	 *          The PC that has this Equipment
	 * @param aType
	 *          The type of the Bonus
	 * @param aName
	 *          The name of the Bonus
	 * @param anObj
	 *          An object used in the bonus calculations, should be a 
	 *          PC or a piece of Equipment.
	 * @param bPrimary
	 *          If true get bonuses for primary head
	 * @return bonus
	 */
	private double bonusTo(final PlayerCharacter aPC, final String aType, final String aName, final Object anObj,
		final boolean bPrimary)
	{

<span class="nc" id="L2514">		final String aBonusKey = aType.toUpperCase() + '.'</span>
<span class="nc" id="L2515">				+ aName.toUpperCase()</span>
				+ '.';

		// go through bonus hashmap and zero out all
		// entries that deal with this bonus request
<span class="nc" id="L2520">		getBonusMap().keySet().stream().filter(aKey -&gt; aKey.startsWith(aBonusKey))</span>
<span class="nc" id="L2521">			.forEach(aKey -&gt; putBonusMap(aKey, &quot;0&quot;));</span>

<span class="nc" id="L2523">		bonusPrimary = bPrimary;</span>

<span class="nc bnc" id="L2525" title="All 2 branches missed.">		if (bPrimary)</span>
		{
<span class="nc" id="L2527">			BonusCalc.equipBonusTo(this, aType, aName, aPC);</span>

			// now do temp bonuses
<span class="nc" id="L2530">			final List&lt;BonusObj&gt; tbList = getTempBonusList().stream().distinct().collect(Collectors.toList());</span>

<span class="nc" id="L2532">			BonusCalc.bonusTo(this, aType, aName, anObj, tbList, aPC);</span>
		}

		// If using 3.5 weapon penalties, add them in also
<span class="nc bnc" id="L2536" title="All 2 branches missed.">		if (Globals.checkRule(RuleConstants.SYS_35WP))</span>
		{
<span class="nc bnc" id="L2538" title="All 2 branches missed.">			for (EqSizePenalty esp : Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L2539">				.getConstructedCDOMObjects(EqSizePenalty.class))</span>
			{
<span class="nc" id="L2541">				BonusCalc.bonusTo(this, aType, aName, this, esp.getBonuses(), aPC);</span>
<span class="nc" id="L2542">			}</span>
		}

<span class="nc" id="L2545">		final List&lt;EquipmentModifier&gt; eqModList = getEqModifierList(bPrimary);</span>

<span class="nc bnc" id="L2547" title="All 2 branches missed.">		for (EquipmentModifier eqMod : eqModList)</span>
		{
<span class="nc" id="L2549">			eqMod.bonusTo(aPC, aType, aName, this);</span>
<span class="nc" id="L2550">		}</span>

<span class="nc" id="L2552">		return getBonusMap().keySet().stream().filter(key -&gt; key.startsWith(aBonusKey))</span>
<span class="nc" id="L2553">			.mapToDouble(key -&gt; Float.parseFloat(getBonusMap().get(key))).sum();</span>
	}

	/**
	 * Calculates the plus value fo the specified head
	 * 
	 * @param bPrimary Which head is required, the primary (true) or the secondary (false)
	 * @return The plus for the equipment head
	 */
	public int calcPlusForHead(boolean bPrimary)
	{
<span class="nc" id="L2564">		int iPlus = 0;</span>

<span class="nc bnc" id="L2566" title="All 2 branches missed.">		int headnum = bPrimary ? 1 : 2;</span>
<span class="nc" id="L2567">		EquipmentHead head = getEquipmentHeadReference(headnum);</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">		if (head == null)</span>
		{
<span class="nc" id="L2570">			return iPlus;</span>
		}

<span class="nc bnc" id="L2573" title="All 2 branches missed.">		for (EquipmentModifier eqMod : head.getSafeListFor(ListKey.EQMOD))</span>
		{
<span class="nc" id="L2575">			int iCount = getSelectCorrectedAssociationCount(eqMod);</span>

<span class="nc bnc" id="L2577" title="All 2 branches missed.">			if (iCount &lt; 1)</span>
			{
<span class="nc" id="L2579">				iCount = 1;</span>
			}

<span class="nc" id="L2582">			iPlus += (iCount * eqMod.getSafe(IntegerKey.PLUS));</span>
<span class="nc" id="L2583">		}</span>

<span class="nc" id="L2585">		return iPlus;</span>
	}

	/**
	 * Can we add eqMod to this equipment?
	 * 
	 * @param eqMod
	 *            The Equipment Modifier we would like to add
	 * @param bPrimary
	 *            whether adding to the primary or secondary head
	 * 
	 * @return True if eqMod is addable
	 */
	public boolean canAddModifier(PlayerCharacter pc, PrereqObject eqMod, boolean bPrimary)
	{

		// Make sure we are qualified
<span class="nc" id="L2602">		bonusPrimary = bPrimary;</span>

<span class="nc bnc" id="L2604" title="All 4 branches missed.">		return getSafe(ObjectKey.MOD_CONTROL).getModifiersAllowed() &amp;&amp; PrereqHandler.passesAll(eqMod, this, pc);</span>
	}

	/**
	 * Returns 0 on object error, 1 on can fit, 2 on too heavy, 3 on properties
	 * problem (unimplemented), 4 on capacity error
	 * 
	 * @param aPC
	 *          The PC that has the Equipment
	 * @param obj
	 *          The equipment to check
	 * @return 0 on object error, 1 on can fit, 2 on too heavy, 3 on properties
	 *         problem (unimplemented), 4 on capacity error
	 */
	public int canContain(final PlayerCharacter aPC, final Object obj)
	{

<span class="nc bnc" id="L2621" title="All 2 branches missed.">		if (obj instanceof final Equipment anEquip)</span>
		{

<span class="nc" id="L2624">			Float f = (float) (anEquip.getWeightAsDouble(aPC) * anEquip.numberCarried());</span>

<span class="nc bnc" id="L2626" title="All 2 branches missed.">			if (checkChildWeight(aPC, f))</span>
			{

				// canHold(my HashMap())) //quick hack since the properties
				// hashmap doesn't exist
<span class="nc bnc" id="L2631" title="All 2 branches missed.">				if (checkContainerCapacity(anEquip.eqTypeList(), anEquip.numberCarried()))</span>
				{

					// the qty value is a temporary hack - insert all or
					// nothing. should reset person to be a container, with
					// capacity=capacity
<span class="nc" id="L2637">					return 1;</span>
				}
<span class="nc" id="L2639">				return 4;</span>
			}
<span class="nc" id="L2641">			return 2;</span>
		}
<span class="nc" id="L2643">		return 0;</span>
	}

	/**
	 * Description of the Method
	 *
	 * FIXME: PMD Check is false as the parent of this class does implement Cloneable, so we suppress the warning
	 *
	 * @return Description of the Return Value
	 */
	@Override
	@SuppressWarnings(&quot;PMD.CloneMethodMustImplementCloneable&quot;)
	public Equipment clone()
	{
<span class="nc" id="L2657">		Equipment eq = null;</span>

		try
		{
<span class="nc" id="L2661">			eq = (Equipment) super.clone();</span>

<span class="nc" id="L2663">			eq.heads = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">			for (EquipmentHead head : heads)</span>
			{
<span class="nc bnc" id="L2666" title="All 2 branches missed.">				if (head == null)</span>
				{
<span class="nc" id="L2668">					eq.heads.add(null);</span>
				}
				else
				{
<span class="nc" id="L2672">					EquipmentHead eh = new EquipmentHead(eq, head.getHeadIndex());</span>
<span class="nc" id="L2673">					eh.overlayCDOMObject(head);</span>
<span class="nc" id="L2674">					eq.heads.add(eh);</span>
				}
<span class="nc" id="L2676">			}</span>

			//
<span class="nc bnc" id="L2679" title="All 2 branches missed.">			if (bonusMap != null)</span>
			{
<span class="nc" id="L2681">				eq.bonusMap = new HashMap&lt;&gt;(bonusMap);</span>
			}
<span class="nc" id="L2683">			eq.setMoveString(moveString());</span>

			// eq.setTypeString(super.getType());
			// none of the types associated with modifiers
<span class="nc" id="L2687">			eq.carried = carried;</span>
<span class="nc" id="L2688">			eq.equipped = equipped;</span>
<span class="nc" id="L2689">			eq.location = location;</span>
<span class="nc" id="L2690">			eq.numberEquipped = numberEquipped;</span>
<span class="nc" id="L2691">			eq.qty = qty;</span>
<span class="nc" id="L2692">			eq.outputIndex = outputIndex;</span>

<span class="nc" id="L2694">			eq.d_childTypes = new HashMap&lt;&gt;(d_childTypes);</span>

<span class="nc" id="L2696">			eq.d_containedEquipment = new ArrayList&lt;&gt;(d_containedEquipment);</span>

<span class="nc" id="L2698">			eq.assocSupt = assocSupt.clone();</span>
<span class="nc" id="L2699">			eq.getEquipmentHead(1).removeListFor(ListKey.EQMOD);</span>
<span class="nc" id="L2700">			eq.getEquipmentHead(2).removeListFor(ListKey.EQMOD);</span>
<span class="nc" id="L2701">			eq.getEquipmentHead(1).addAllToListFor(ListKey.EQMOD, cloneEqModList(eq, true));</span>
<span class="nc" id="L2702">			eq.getEquipmentHead(2).addAllToListFor(ListKey.EQMOD, cloneEqModList(eq, false));</span>
		}
<span class="nc" id="L2704">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L2706">			ShowMessageDelegate.showMessageDialog(e.getMessage(), Constants.APPLICATION_NAME, MessageType.ERROR);</span>
<span class="nc" id="L2707">		}</span>

<span class="nc" id="L2709">		return eq;</span>
	}

	/**
	 * Description of the Method
	 * 
	 * @param o
	 *            Description of the Parameter
	 * @return Description of the Return Value
	 */
	@Override
	public int compareTo(final Object o)
	{
<span class="nc" id="L2722">		final Equipment e = (Equipment) o;</span>

<span class="nc" id="L2724">		return getName().compareToIgnoreCase(e.getName());</span>
	}

	@Override
	public boolean equals(Object obj)
	{
<span class="fc bfc" id="L2730" title="All 2 branches covered.">		if (this == obj)</span>
		{
<span class="fc" id="L2732">			return true;</span>
		}
<span class="pc bpc" id="L2734" title="1 of 2 branches missed.">		if (!super.equals(obj))</span>
		{
<span class="fc" id="L2736">			return false;</span>
		}
<span class="nc bnc" id="L2738" title="All 2 branches missed.">		if (getClass() != obj.getClass())</span>
		{
<span class="nc" id="L2740">			return false;</span>
		}
<span class="nc" id="L2742">		Equipment other = (Equipment) obj;</span>

<span class="nc" id="L2744">		String displayName = getDisplayName();</span>
<span class="nc bnc" id="L2745" title="All 2 branches missed.">		if (displayName == null)</span>
		{
<span class="nc bnc" id="L2747" title="All 2 branches missed.">			if (other.getDisplayName() != null)</span>
			{
<span class="nc" id="L2749">				return false;</span>
			}
		}
<span class="nc bnc" id="L2752" title="All 2 branches missed.">		else if (!displayName.equals(other.getDisplayName()))</span>
		{
<span class="nc" id="L2754">			return false;</span>
		}

<span class="nc bnc" id="L2757" title="All 2 branches missed.">		if (modifiedName == null)</span>
		{
<span class="nc bnc" id="L2759" title="All 2 branches missed.">			return other.modifiedName == null;</span>
		}
		else
		{
<span class="nc" id="L2763">			return modifiedName.equals(other.modifiedName);</span>
		}
	}

	/**
	 * Build a String used to save this items special properties in a .pcg file
	 * 
	 * @param sep used to separate the items in the string
	 * @param endPart
	 *          used as a separatot between the label and the data for
	 *          each item in the string
	 * @return String
	 */
	public String formatSaveLine(final char sep, final char endPart)
	{

<span class="nc" id="L2779">		final StringBuilder sbuf = new StringBuilder(100);</span>

		final Equipment base;

<span class="nc" id="L2783">		CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">		if (baseItem == null)</span>
		{
<span class="nc" id="L2786">			base = this;</span>
<span class="nc" id="L2787">			sbuf.append(getBaseItemName());</span>
		}
		else
		{
<span class="nc" id="L2791">			base = baseItem.get();</span>
<span class="nc" id="L2792">			sbuf.append(base.getKeyName());</span>
<span class="nc" id="L2793">			sbuf.append(sep).append(&quot;NAME&quot;).append(endPart).append(toString(false));</span>
		}

		// When you customise a piece of equipment using the customiser, it sets
		// the keyName equal to the Name. The autoresizer doesn't do that, it
		// makes a new key. This is to cope with the auto resizer.

<span class="nc bnc" id="L2800" title="All 2 branches missed.">		if (!this.getKeyName().equals(this.getName()))</span>
		{
<span class="nc" id="L2802">			sbuf.append(sep).append(&quot;KEY&quot;).append(endPart).append(this.getKeyName());</span>
		}

<span class="nc" id="L2805">		SizeAdjustment thisSize = getSizeAdjustment();</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">		if (!thisSize.equals(base.getSizeAdjustment()))</span>
		{
<span class="nc" id="L2808">			sbuf.append(sep).append(&quot;SIZE&quot;).append(endPart).append(thisSize.getKeyName());</span>
		}

<span class="nc" id="L2811">		String string1 = getEqModifierString(true); // key1.key2|assoc1|assoc2.key3.key4</span>

<span class="nc bnc" id="L2813" title="All 2 branches missed.">		if (!string1.isEmpty())</span>
		{
<span class="nc" id="L2815">			sbuf.append(sep).append(&quot;EQMOD&quot;).append(endPart).append(string1);</span>
		}

<span class="nc" id="L2818">		String string2 = getEqModifierString(false); // key1.key2|assoc1|assoc2.key3.key4</span>

<span class="nc bnc" id="L2820" title="All 2 branches missed.">		if (!string2.isEmpty())</span>
		{
<span class="nc" id="L2822">			sbuf.append(sep).append(&quot;ALTEQMOD&quot;).append(endPart).append(string2);</span>
		}

<span class="nc" id="L2825">		String string3 = getRawSpecialProperties();</span>

<span class="nc bnc" id="L2827" title="All 4 branches missed.">		if ((!string3.isEmpty()) &amp;&amp; !string3.equals(base.getRawSpecialProperties()))</span>
		{
<span class="nc" id="L2829">			sbuf.append(sep).append(&quot;SPROP&quot;).append(endPart).append(string3);</span>
		}

<span class="nc bnc" id="L2832" title="All 2 branches missed.">		if (!costMod.equals(BigDecimal.ZERO))</span>
		{
<span class="nc" id="L2834">			sbuf.append(sep).append(&quot;COSTMOD&quot;).append(endPart).append(costMod.toString());</span>
		}

<span class="nc" id="L2837">		return sbuf.toString();</span>
	}

	@Override
	public int hashCode()
	{
<span class="nc" id="L2843">		final int prime = 31;</span>
<span class="nc" id="L2844">		int result = 1;</span>
<span class="nc" id="L2845">		String displayName = getDisplayName();</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">		result = prime * result + ((displayName == null) ? 0 : displayName.hashCode());</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">		result = prime * result + ((modifiedName == null) ? 0 : modifiedName.hashCode());</span>
<span class="nc" id="L2848">		return result;</span>
	}

	/**
	 * Gets the index of a child
	 * 
	 * @param child
	 *            The child
	 * @return the index of the child
	 */
	private int indexOfChild(final Object child)
	{
<span class="nc bnc" id="L2860" title="All 2 branches missed.">		if (!(child instanceof Equipment))</span>
		{
<span class="nc" id="L2862">			return -1;</span>
		}

<span class="nc" id="L2865">		return getContainedEquipmentIndexOf((Equipment) child);</span>
	}

	/**
	 * Adds a child to this Equipment
	 * 
	 * @param aPC The PC that has the Equipment
	 * @param child
	 *            The child to add
	 */
	public void insertChild(final PlayerCharacter aPC, final Object child)
	{

<span class="nc bnc" id="L2878" title="All 2 branches missed.">		if (child == null)</span>
		{
<span class="nc" id="L2880">			return;</span>
		}

<span class="nc" id="L2883">		Equipment anEquip = (Equipment) child;</span>
<span class="nc" id="L2884">		Float aFloat = anEquip.numberCarried();</span>
<span class="nc" id="L2885">		Float bFloat = aFloat;</span>

<span class="nc" id="L2887">		final String aString = pickChildType(anEquip.eqTypeList(), aFloat);</span>

<span class="nc bnc" id="L2889" title="All 2 branches missed.">		if (containsChildType(aString))</span>
		{
<span class="nc" id="L2891">			aFloat = getChildType(aString) + aFloat;</span>
		}

<span class="nc" id="L2894">		bFloat = getChildType(&quot;Total&quot;) + bFloat;</span>
<span class="nc" id="L2895">		setChildType(aString, aFloat);</span>
<span class="nc" id="L2896">		setChildType(&quot;Total&quot;, bFloat);</span>
<span class="nc" id="L2897">		addContainedEquipment(anEquip);</span>
<span class="nc" id="L2898">		anEquip.setIndexedUnderType(aString);</span>
<span class="nc" id="L2899">		anEquip.setParent(this);</span>

		// hmm probably not needed; but as it currently isn't hurting
		// anything...
<span class="nc" id="L2903">		updateContainerContentsString(aPC);</span>

<span class="nc bnc" id="L2905" title="All 2 branches missed.">		while (anEquip.getParent() != null)</span>
		{
<span class="nc" id="L2907">			anEquip = anEquip.getParent();</span>
<span class="nc" id="L2908">			anEquip.updateContainerContentsString(aPC);</span>
		}
<span class="nc" id="L2910">	}</span>

	/**
	 * Returns how 'deep' in a structure an Equipment is.
	 * 
	 * @return how 'deep' in a structure an Equipment is.
	 */
	public int itemDepth()
	{
<span class="nc bnc" id="L2919" title="All 2 branches missed.">		if (getParent() == null)</span>
		{
<span class="nc" id="L2921">			return 0;</span>
		}

<span class="nc" id="L2924">		int i = 1;</span>
<span class="nc" id="L2925">		Equipment anEquip = getParent();</span>

<span class="nc bnc" id="L2927" title="All 2 branches missed.">		while (anEquip.getParent() != null)</span>
		{
<span class="nc" id="L2929">			anEquip = anEquip.getParent();</span>
<span class="nc" id="L2930">			++i;</span>
		}

<span class="nc" id="L2933">		return i;</span>
	}

	/**
	 * load a &quot;line&quot; i.e. a String and use its data to populate the attributes
	 * of this Equipment
	 * 
	 * @param aLine
	 *             The data to parse
	 * @param sep  
	 *             The item separator used in the data
	 * @param endPart
	 *             The separator used between a label and its associated data
	 * @param aPC
	 *             The PC used to size the Equipment (may be null)
	 */
	public void load(final String aLine, final String sep, final String endPart, final PlayerCharacter aPC)
	{

<span class="nc" id="L2952">		final StringTokenizer aTok = new StringTokenizer(aLine, sep);</span>
<span class="nc" id="L2953">		final int endPartLen = endPart.length();</span>
<span class="nc" id="L2954">		CDOMSingleRef&lt;SizeAdjustment&gt; size = getSafe(ObjectKey.SIZE);</span>
<span class="nc" id="L2955">		boolean firstSprop = true;</span>

<span class="nc bnc" id="L2957" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L2959">			final String aString = aTok.nextToken();</span>

<span class="nc bnc" id="L2961" title="All 2 branches missed.">			if (aString.startsWith(&quot;NAME&quot; + endPart))</span>
			{
<span class="nc" id="L2963">				setName(aString.substring(4 + endPartLen));</span>
<span class="nc" id="L2964">				put(StringKey.OUTPUT_NAME, getDisplayName());</span>
			}
<span class="nc bnc" id="L2966" title="All 2 branches missed.">			else if (aString.startsWith(&quot;KEY&quot; + endPart))</span>
			{
<span class="nc" id="L2968">				put(StringKey.KEY_NAME, aString.substring(3 + endPartLen));</span>
			}
<span class="nc bnc" id="L2970" title="All 2 branches missed.">			else if (aString.startsWith(&quot;SIZE&quot; + endPart))</span>
			{
<span class="nc" id="L2972">				size = Globals.getContext().getReferenceContext().getCDOMReference(SizeAdjustment.class,</span>
<span class="nc" id="L2973">					aString.substring(4 + endPartLen));</span>
			}
<span class="nc bnc" id="L2975" title="All 2 branches missed.">			else if (aString.startsWith(&quot;EQMOD&quot; + endPart))</span>
			{
<span class="nc" id="L2977">				addEqModifiers(aString.substring(5 + endPartLen), true, true);</span>
			}
<span class="nc bnc" id="L2979" title="All 2 branches missed.">			else if (aString.startsWith(&quot;ALTEQMOD&quot; + endPart))</span>
			{
<span class="nc" id="L2981">				addEqModifiers(aString.substring(8 + endPartLen), false);</span>
			}
<span class="nc bnc" id="L2983" title="All 2 branches missed.">			else if (aString.startsWith(&quot;SPROP&quot; + endPart))</span>
			{
<span class="nc bnc" id="L2985" title="All 2 branches missed.">				if (firstSprop)</span>
				{
<span class="nc" id="L2987">					removeListFor(ListKey.SPECIAL_PROPERTIES);</span>
<span class="nc" id="L2988">					firstSprop = false;</span>
				}
<span class="nc" id="L2990">				addToListFor(ListKey.SPECIAL_PROPERTIES,</span>
<span class="nc" id="L2991">					SpecialProperty.createFromLst(aString.substring(5 + endPartLen)));</span>
			}
<span class="nc bnc" id="L2993" title="All 2 branches missed.">			else if (aString.startsWith(&quot;COSTMOD&quot; + endPart))</span>
			{
<span class="nc" id="L2995">				setCostMod(aString.substring(7 + endPartLen));</span>
			}
<span class="nc bnc" id="L2997" title="All 2 branches missed.">			else if (aString.startsWith(&quot;WEIGHTMOD&quot; + endPart))</span>
			{
<span class="nc" id="L2999">				put(ObjectKey.WEIGHT_MOD, new BigDecimal(aString.substring(9 + endPartLen)));</span>
			}
<span class="nc" id="L3001">		}</span>
<span class="nc" id="L3002">		put(ObjectKey.CUSTOMSIZE, size);</span>
<span class="nc" id="L3003">	}</span>

	/**
	 * Sets this Equipment to the size defined in ObjectKey.CUSTOMSIZE. This
	 * should be done after equipment load but before use of the Equipment.
	 * 
	 * Note that this *should not* be done until full data load is complete to
	 * ensure that there is not a race condition on resolving sizes.
	 */
	public void setToCustomSize(PlayerCharacter pc)
	{
<span class="nc" id="L3014">		CDOMSingleRef&lt;SizeAdjustment&gt; csr = get(ObjectKey.CUSTOMSIZE);</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">		if (csr != null)</span>
		{
<span class="nc" id="L3017">			SizeAdjustment customSize = csr.get();</span>
<span class="nc bnc" id="L3018" title="All 2 branches missed.">			if (!getSizeAdjustment().equals(customSize))</span>
			{
<span class="nc" id="L3020">				resizeItem(pc, customSize);</span>
			}
		}
<span class="nc" id="L3023">	}</span>

	/**
	 * Get the long name of this piece of equipment
	 * 
	 * @return the verbose name
	 */
	public String longName()
	{
<span class="nc" id="L3032">		return toString(true);</span>
	}

	/**
	 * Is the PC qualified to use this equipment
	 * 
	 * @param pc The PC to check the prerequisites against
	 * 
	 * @return Description of the Return Value
	 */
	public boolean meetsPreReqs(PlayerCharacter pc)
	{
<span class="nc" id="L3044">		return PrereqHandler.passesAll(this, this, pc);</span>
	}

	/**
	 * Get the modified name e.g. &quot;Natural/Primary&quot; of this Equipment.
	 * Is mostly unset and (if set) is added to the display name when
	 * producing the long name
	 * 
	 * @return the modified name
	 */
	public String modifiedName()
	{
<span class="nc" id="L3056">		return modifiedName;</span>
	}

	/**
	 * Process and return a movement string
	 * 
	 * @return the Movement string
	 */
	public String moveString()
	{
<span class="nc bnc" id="L3066" title="All 2 branches missed.">		if (!moveString.isEmpty())</span>
		{
			final Load eqLoad;

<span class="nc bnc" id="L3070" title="All 2 branches missed.">			if (isHeavy())</span>
			{
<span class="nc" id="L3072">				eqLoad = Load.HEAVY;</span>
			}
<span class="nc bnc" id="L3074" title="All 2 branches missed.">			else if (isMedium())</span>
			{
<span class="nc" id="L3076">				eqLoad = Load.MEDIUM;</span>
			}
<span class="nc bnc" id="L3078" title="All 2 branches missed.">			else if (isLight())</span>
			{
<span class="nc" id="L3080">				eqLoad = Load.LIGHT;</span>
			}
			else
			{
<span class="nc" id="L3084">				eqLoad = Load.OVERLOAD;</span>
			}

			//
			// This will generate a list for base moves 30,20
			// or 60,50,40 depending on how many tokens are
			// in the original tag
			//
<span class="nc" id="L3092">			final StringTokenizer aTok = new StringTokenizer(moveString, &quot;,&quot;);</span>
<span class="nc" id="L3093">			int baseMove = -1;</span>
<span class="nc" id="L3094">			int tokenCount = aTok.countTokens();</span>

<span class="nc bnc" id="L3096" title="All 3 branches missed.">			switch (tokenCount)</span>
			{
<span class="nc" id="L3098">				case 2 -&gt; baseMove = 30;</span>
<span class="nc" id="L3099">				case 3 -&gt; baseMove = 60;</span>
<span class="nc" id="L3100">				default -&gt; tokenCount = -1;</span>
			}

<span class="nc bnc" id="L3103" title="All 2 branches missed.">			if (tokenCount &gt; 0)</span>
			{
<span class="nc" id="L3105">				final StringBuilder retString = new StringBuilder(moveString.length());</span>

<span class="nc bnc" id="L3107" title="All 2 branches missed.">				for (int i = 0; i &lt; tokenCount; ++i)</span>
				{
<span class="nc bnc" id="L3109" title="All 2 branches missed.">					if (i != 0)</span>
					{
<span class="nc" id="L3111">						retString.append(',');</span>
					}

<span class="nc" id="L3114">					retString.append(eqLoad.calcEncumberedMove(baseMove));</span>
<span class="nc" id="L3115">					baseMove -= 10;</span>
				}

<span class="nc" id="L3118">				return retString.toString();</span>
			}
		}

<span class="nc" id="L3122">		return moveString;</span>
	}

	/**
	 * Generate a name from the Base Equipement name and any EqMods that 
	 * have been applied.
	 * 
	 * @param pc the PC that has the equipment
	 * 
	 * @return a name generated from the Base Equipement type and any EqMods applied
	 */
	public String nameItemFromModifiers(final PlayerCharacter pc)
	{

<span class="nc" id="L3136">		final String itemName = getItemNameFromModifiers(getBaseItemName());</span>
<span class="nc" id="L3137">		setDefaultCrit(pc);</span>
<span class="nc" id="L3138">		setName(itemName);</span>
<span class="nc" id="L3139">		String itemKey = getItemNameFromModifiers(getBaseItemKeyName()).replaceAll(&quot;[^A-Za-z0-9/_() +-]&quot;, &quot;_&quot;);</span>
<span class="nc" id="L3140">		setKeyName(itemKey);</span>
<span class="nc" id="L3141">		remove(StringKey.OUTPUT_NAME);</span>

<span class="nc" id="L3143">		return getKeyName();</span>
	}

	/**
	 * Get the number of items of this Equipment being carried
	 * 
	 * @return the number of this Equipment carried
	 */
	public Float numberCarried()
	{
<span class="nc" id="L3153">		Equipment eqParent = getParent();</span>

<span class="nc bnc" id="L3155" title="All 4 branches missed.">		if (isEquipped() || (eqParent == null))</span>
		{
<span class="nc" id="L3157">			return carried;</span>
		}

<span class="nc bnc" id="L3160" title="All 2 branches missed.">		for (; eqParent != null; eqParent = eqParent.getParent())</span>
		{

<span class="nc bnc" id="L3163" title="All 6 branches missed.">			if (eqParent.isEquipped() || ((eqParent.getParent() == null) &amp;&amp; (eqParent.numberCarried().intValue() != 0)))</span>
			{
<span class="nc" id="L3165">				return carried;</span>
			}
		}

<span class="nc" id="L3169">		return (float) 0;</span>
	}

	/**
	 * Get the quantity of items
	 * 
	 * @return the quantity of items
	 */
	public double qty()
	{
<span class="nc" id="L3179">		return qty;</span>
	}

	/**
	 * Removes a child from the Equipment
	 * 
	 * @param pc
	 *            The PC carrying the item
	 * 
	 * @param child
	 *            The child to remove
	 */
	public void removeChild(final PlayerCharacter pc, final Object child)
	{

<span class="nc" id="L3194">		final int i = indexOfChild(child);</span>
<span class="nc" id="L3195">		Equipment anEquip = (Equipment) child;</span>
<span class="nc" id="L3196">		final Float qtyRemoved = anEquip.numberCarried();</span>
<span class="nc" id="L3197">		setChildType(&quot;Total&quot;, getChildType(&quot;Total&quot;) - qtyRemoved);</span>

<span class="nc" id="L3199">		final String aString = anEquip.isIndexedUnderType();</span>
<span class="nc" id="L3200">		setChildType(aString, getChildType(aString) - qtyRemoved);</span>
<span class="nc" id="L3201">		anEquip.setParent(null);</span>
<span class="nc" id="L3202">		removeContainedEquipment(i);</span>
<span class="nc" id="L3203">		updateContainerContentsString(pc);</span>

<span class="nc" id="L3205">		Equipment equipment = this;</span>

<span class="nc bnc" id="L3207" title="All 2 branches missed.">		while (equipment.getParent() != null)</span>
		{
<span class="nc" id="L3209">			equipment = equipment.getParent();</span>
<span class="nc" id="L3210">			equipment.updateContainerContentsString(pc);</span>
		}
<span class="nc" id="L3212">	}</span>

	/**
	 * Description of the Method
	 * 
	 * @param eqMod
	 *            Description of the Parameter
	 * @param bPrimary
	 *            Description of the Parameter
	 * @param pc
	 *            The PC carrying the item
	 */
	public void removeEqModifier(final EquipmentModifier eqMod, final boolean bPrimary, PlayerCharacter pc)
	{

<span class="nc" id="L3227">		final EquipmentModifier aMod = getEqModifierKeyed(eqMod.getKeyName(), bPrimary);</span>

<span class="nc bnc" id="L3229" title="All 2 branches missed.">		if (aMod == null)</span>
		{
<span class="nc" id="L3231">			return;</span>
		}

		// Get a response from user (if one required)
		// Remove the modifier if all associated choices are deleted
<span class="nc bnc" id="L3236" title="All 4 branches missed.">		if (!hasAssociations(aMod) || !EquipmentChoiceDriver.getChoice(0, this, aMod, false, pc))</span>
		{
<span class="nc bnc" id="L3238" title="All 2 branches missed.">			EquipmentHead head = getEquipmentHead(bPrimary ? 1 : 2);</span>
<span class="nc" id="L3239">			head.removeFromListFor(ListKey.EQMOD, aMod);</span>
<span class="nc bnc" id="L3240" title="All 2 branches missed.">			if (bPrimary)</span>
			{
<span class="nc" id="L3242">				usePrimaryCache = false;</span>
			}
			else
			{
<span class="nc" id="L3246">				useSecondaryCache = false;</span>
			}

<span class="nc" id="L3249">			restoreEqModsAfterRemove(pc, eqMod, bPrimary, head);</span>

<span class="nc" id="L3251">			setDirty(true);</span>
		}
<span class="nc" id="L3253">	}</span>

	/**
	 * Add back in modifiers that this one previously removed.
	 * 
	 * @param eqMod The equipment modifier being removed.
	 * @param bPrimary Which head is this for?
	 * @param head The head being updated.
	 */
	private void restoreEqModsAfterRemove(PlayerCharacter pc, final EquipmentModifier eqMod, final boolean bPrimary,
		EquipmentHead head)
	{
<span class="nc" id="L3265">		CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L3266" title="All 2 branches missed.">		if (baseItem == null)</span>
		{
<span class="nc" id="L3268">			return;</span>
		}

<span class="nc" id="L3271">		List&lt;CDOMSingleRef&lt;EquipmentModifier&gt;&gt; replaces = eqMod.getListFor(ListKey.REPLACED_KEYS);</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">		if (replaces != null)</span>
		{
			//
			// Add back in modifiers that this one previously removed
			//
<span class="nc" id="L3277">			replaces.stream().map(CDOMSingleRef::get).map(CDOMObject::getKeyName)</span>
<span class="nc bnc" id="L3278" title="All 2 branches missed.">				.forEach(key -&gt; baseItem.get().getEquipmentHead(bPrimary ? 1 : 2).getSafeListFor(ListKey.EQMOD).stream()</span>
<span class="nc" id="L3279">					.filter(baseMod -&gt; key.equalsIgnoreCase(baseMod.getKeyName())).forEach(baseMod -&gt; head.addToListFor(ListKey.EQMOD, baseMod)));</span>
		}

<span class="nc bnc" id="L3282" title="All 2 branches missed.">		if (eqMod.isType(&quot;BaseMaterial&quot;))</span>
		{
<span class="nc bnc" id="L3284" title="All 2 branches missed.">			baseItem.get().getEquipmentHead(bPrimary ? 1 : 2).getSafeListFor(ListKey.EQMOD).stream()</span>
<span class="nc" id="L3285">				.filter(baseMod -&gt; baseMod.isType(&quot;BaseMaterial&quot;)).forEach(baseMod -&gt; head.addToListFor(ListKey.EQMOD, baseMod));</span>
		}
<span class="nc bnc" id="L3287" title="All 2 branches missed.">		else if (eqMod.isType(&quot;MagicalEnhancement&quot;))</span>
		{
<span class="nc bnc" id="L3289" title="All 2 branches missed.">			baseItem.get().getEquipmentHead(bPrimary ? 1 : 2).getSafeListFor(ListKey.EQMOD).stream()</span>
<span class="nc" id="L3290">				.filter(baseMod -&gt; baseMod.isType(&quot;MagicalEnhancement&quot;)).forEach(baseMod -&gt; head.addToListFor(ListKey.EQMOD, baseMod));</span>
		}
<span class="nc" id="L3292">	}</span>

	/**
	 * Remove a list equipment modifiers and their associated information eg:
	 * Bane|Vermin|Fey.Keen.Vorpal.ABILITYPLUS|CHA=+6 &lt;p&gt; Removes a feature
	 * from the EqModifiers attribute of the Equipment object
	 * 
	 * @param aString
	 *            The feature to be removed from the EqModifiers attribute
	 * @param bPrimary
	 *            The feature to be removed from the EqModifiers attribute
	 * @param pc
	 *            The PC carrying the item
	 */
	public void removeEqModifiers(final String aString, final boolean bPrimary, PlayerCharacter pc)
	{

<span class="nc" id="L3309">		final StringTokenizer aTok = new StringTokenizer(aString, &quot;.&quot;);</span>

<span class="nc bnc" id="L3311" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L3313">			final String aEqModName = aTok.nextToken();</span>

<span class="nc bnc" id="L3315" title="All 2 branches missed.">			if (!aEqModName.equalsIgnoreCase(Constants.NONE))</span>
			{
<span class="nc" id="L3317">				removeEqModifier(aEqModName, bPrimary, pc);</span>
			}
<span class="nc" id="L3319">		}</span>
<span class="nc" id="L3320">	}</span>

	/**
	 * Change the size of an item
	 * 
	 * @param pc
	 *            The PC carrying the item
	 * @param newSize
	 *            The new size for the item
	 */
	public void resizeItem(final PlayerCharacter pc, SizeAdjustment newSize)
	{
<span class="nc" id="L3332">		setBase();</span>

<span class="nc" id="L3334">		final int iOldSize = sizeInt();</span>
<span class="nc" id="L3335">		int iNewSize = newSize.get(IntegerKey.SIZEORDER);</span>

<span class="nc bnc" id="L3337" title="All 2 branches missed.">		if (iNewSize != iOldSize)</span>
		{
<span class="nc" id="L3339">			put(ObjectKey.SIZE, CDOMDirectSingleRef.getRef(newSize));</span>
<span class="nc" id="L3340">			CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>

			Equipment eq;
<span class="nc bnc" id="L3343" title="All 2 branches missed.">			if (baseItem == null)</span>
			{
<span class="nc" id="L3345">				eq = this;</span>
			}
			else
			{
<span class="nc" id="L3349">				eq = baseItem.get();</span>
			}

<span class="nc" id="L3352">			put(ObjectKey.CURRENT_COST, eq.getCostAdjustedForSize(pc, newSize));</span>
<span class="nc" id="L3353">			put(ObjectKey.WEIGHT, eq.getWeightAdjustedForSize(pc, newSize));</span>
<span class="nc" id="L3354">			String dam = eq.getDamageAdjustedForSize(iNewSize, true);</span>
<span class="nc bnc" id="L3355" title="All 4 branches missed.">			if (dam != null &amp;&amp; !dam.isEmpty())</span>
			{
<span class="nc" id="L3357">				getEquipmentHead(1).put(StringKey.DAMAGE, dam);</span>
			}
<span class="nc" id="L3359">			String adam = eq.getDamageAdjustedForSize(iNewSize, false);</span>
<span class="nc bnc" id="L3360" title="All 4 branches missed.">			if (adam != null &amp;&amp; !adam.isEmpty())</span>
			{
<span class="nc" id="L3362">				getEquipmentHead(2).put(StringKey.DAMAGE, adam);</span>
			}
			//
			// Adjust the capacity of the container (if it is one)
			//
<span class="nc" id="L3367">			BigDecimal weightCap = get(ObjectKey.CONTAINER_WEIGHT_CAPACITY);</span>
<span class="nc bnc" id="L3368" title="All 2 branches missed.">			if (weightCap != null)</span>
			{
<span class="nc" id="L3370">				double mult = 1.0;</span>

<span class="nc bnc" id="L3372" title="All 2 branches missed.">				if (pc != null)</span>
				{
<span class="nc" id="L3374">					mult = pc.getSizeBonusTo(newSize, &quot;ITEMCAPACITY&quot;, eq.typeList(), 1.0);</span>
				}

<span class="nc" id="L3377">				BigDecimal multbd = new BigDecimal(String.valueOf(mult));</span>
<span class="nc bnc" id="L3378" title="All 2 branches missed.">				if (!Capacity.UNLIMITED.equals(weightCap))</span>
				{
					// CONSIDER ICK, ICK, direct access bad
<span class="nc" id="L3381">					put(ObjectKey.CONTAINER_WEIGHT_CAPACITY, weightCap.multiply(multbd));</span>
				}
<span class="nc" id="L3383">				List&lt;Capacity&gt; capacity = removeListFor(ListKey.CAPACITY);</span>
<span class="nc bnc" id="L3384" title="All 2 branches missed.">				if (capacity != null)</span>
				{
<span class="nc bnc" id="L3386" title="All 2 branches missed.">					for (Capacity cap : capacity)</span>
					{
<span class="nc" id="L3388">						BigDecimal content = cap.getCapacity();</span>
<span class="nc bnc" id="L3389" title="All 2 branches missed.">						if (!Capacity.UNLIMITED.equals(content))</span>
						{
<span class="nc" id="L3391">							content = content.multiply(multbd);</span>
						}
						// CONSIDER ICK, ICK, direct access bad
<span class="nc" id="L3394">						addToListFor(ListKey.CAPACITY, new Capacity(cap.getType(), content));</span>
<span class="nc" id="L3395">					}</span>
				}

<span class="nc" id="L3398">				updateContainerCapacityString();</span>
			}
		}

		//
		// Since we've just resized the item, we need to modify any PRESIZE
		// prerequisites
		//
<span class="nc bnc" id="L3406" title="All 2 branches missed.">		if (hasPrerequisites())</span>
		{
<span class="nc" id="L3408">			AbstractReferenceContext ref = Globals.getContext().getReferenceContext();</span>
<span class="nc" id="L3409">			int maxIndex = ref.getConstructedObjectCount(SizeAdjustment.class);</span>
<span class="nc bnc" id="L3410" title="All 2 branches missed.">			for (Prerequisite aBonus : getPrerequisiteList())</span>
			{
<span class="nc bnc" id="L3412" title="All 2 branches missed.">				if (&quot;SIZE&quot;.equalsIgnoreCase(aBonus.getKind()))</span>
				{
<span class="nc" id="L3414">					SizeAdjustment sa = ref.silentlyGetConstructedCDOMObject(SizeAdjustment.class, aBonus.getOperand());</span>
<span class="nc" id="L3415">					final int iOldPre = sa.get(IntegerKey.SIZEORDER);</span>
<span class="nc" id="L3416">					iNewSize += (iOldPre - iOldSize);</span>

<span class="nc bnc" id="L3418" title="All 4 branches missed.">					if ((iNewSize &gt;= 0) &amp;&amp; (iNewSize &lt;= maxIndex))</span>
					{
						// Note: This actually impacts the Prereq in this
						// Equipment, since it is returned
						// by reference from the get above ... thus no need to
						// perform a set
<span class="nc" id="L3424">						SizeAdjustment size =</span>
<span class="nc" id="L3425">								ref.getSortedList(SizeAdjustment.class, IntegerKey.SIZEORDER).get(iNewSize);</span>
<span class="nc" id="L3426">						aBonus.setOperand(size.getKeyName());</span>
					}
				}
<span class="nc" id="L3429">			}</span>
		}
<span class="nc" id="L3431">	}</span>

	/**
	 * Get the int size of the Equipment object
	 * 
	 * @return size as int
	 */
	public int sizeInt()
	{
<span class="nc" id="L3440">		SizeAdjustment size = getSizeAdjustment();</span>
<span class="nc" id="L3441">		return size.get(IntegerKey.SIZEORDER);</span>
	}

	/**
	 * Returns the Equipment as a String
	 * 
	 * @return the Equipment as a String
	 */
	@Override
	public String toString()
	{
<span class="nc" id="L3452">		return toString(true);</span>
	}

	/**
	 * Returns a String representation of the Equipment
	 * 
	 * @param addCharges
	 *             if true include the number of charges the Item has in the
	 *             returned string
	 * 
	 * @return the Equipment as a String
	 */
	private String toString(final boolean addCharges)
	{
<span class="nc bnc" id="L3466" title="All 6 branches missed.">		if (isDirty() || (cachedNameWithCharges == null &amp;&amp; cachedNameWithoutCharges == null))</span>
		{
			// If we have modified the equipment details with
			// respect to the name then rebuid the names
<span class="nc" id="L3470">			final StringBuilder buffer = new StringBuilder(100);</span>

<span class="nc bnc" id="L3472" title="All 2 branches missed.">			if (SettingsHandler.guiUsesOutputNameEquipment())</span>
			{
<span class="nc" id="L3474">				buffer.append(getOutputName());</span>
			}
			else
			{
<span class="nc" id="L3478">				buffer.append(getDisplayName());</span>
			}

<span class="nc bnc" id="L3481" title="All 2 branches missed.">			if (!modifiedName.isEmpty())</span>
			{
<span class="nc" id="L3483">				buffer.append(&quot; (&quot;).append(modifiedName).append(&quot;)&quot;);</span>
			}
<span class="nc" id="L3485">			cachedNameWithoutCharges = buffer.toString();</span>

<span class="nc bnc" id="L3487" title="All 2 branches missed.">			if (addCharges)</span>
			{
<span class="nc" id="L3489">				int rem = getRemainingCharges();</span>
<span class="nc bnc" id="L3490" title="All 4 branches missed.">				if ((rem &gt; 0) &amp;&amp; (rem &lt; getMaxCharges()))</span>
				{
<span class="nc" id="L3492">					buffer.append(&quot;(&quot;).append(rem).append(&quot;)&quot;);</span>
				}
			}
<span class="nc" id="L3495">			cachedNameWithCharges = buffer.toString();</span>
<span class="nc" id="L3496">			setDirty(false);</span>
		}

		// Return the cached names.
<span class="nc bnc" id="L3500" title="All 2 branches missed.">		if (addCharges)</span>
		{
<span class="nc" id="L3502">			return cachedNameWithCharges;</span>
		}
<span class="nc" id="L3504">		return cachedNameWithoutCharges;</span>
	}

	private boolean isDirty()
	{
<span class="nc" id="L3509">		return dirty;</span>
	}

	private void setDirty(final boolean dirty)
	{
<span class="fc" id="L3514">		this.dirty = dirty;</span>
<span class="fc" id="L3515">	}</span>

	/**
	 * Returns the type with the requested index
	 * 
	 * @param index
	 *            the index
	 * @return the type with the requested index
	 */
	public String typeIndex(final int index)
	{
<span class="nc" id="L3526">		final List&lt;String&gt; tList = typeList();</span>

<span class="nc bnc" id="L3528" title="All 4 branches missed.">		if ((index &lt; 0) || (index &gt;= tList.size()))</span>
		{
<span class="nc" id="L3530">			return &quot;&quot;;</span>
		}

<span class="nc" id="L3533">		return tList.get(index);</span>
	}

	/**
	 * Returns a list of the types of this item.
	 * 
	 * @return a list of the types of this item.
	 */
	public List&lt;String&gt; typeList()
	{
<span class="nc" id="L3543">		return typeList(true);</span>
	}

	/**
	 * Updates the containerContentsString from children of this item
	 * 
	 * @param pc The PC carrying the item
	 */
	void updateContainerContentsString(final PlayerCharacter pc)
	{
<span class="nc" id="L3553">		final StringBuilder tempStringBuilder = new StringBuilder(getChildCount() * 20);</span>

		// Make sure there's no bug here.
<span class="nc bnc" id="L3556" title="All 6 branches missed.">		if (pc != null &amp;&amp; isContainer() &amp;&amp; (getContainedWeight(pc, true) &gt;= 0.0f))</span>
		{
<span class="nc" id="L3558">			tempStringBuilder</span>
<span class="nc" id="L3559">				.append(Globals.getGameModeUnitSet().displayWeightInUnitSet(getContainedWeight(pc, true).doubleValue()))</span>
<span class="nc" id="L3560">				.append(Globals.getGameModeUnitSet().getWeightUnit());</span>
		}
		else
		{
			// have to put something
<span class="nc" id="L3565">			tempStringBuilder.append(&quot;0.0 &quot;);</span>
<span class="nc" id="L3566">			tempStringBuilder.append(Globals.getGameModeUnitSet().getWeightUnit());</span>
		}

		// karianna os bug 1414564
<span class="nc" id="L3570">		IntStream.range(0, getChildCount()).mapToObj(e -&gt; (Equipment) getChild(e))</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">			.filter(anEquip -&gt; anEquip.getQty() &gt; 0.0f).forEach(anEquip -&gt; {</span>
<span class="nc" id="L3572">				tempStringBuilder.append(&quot;, &quot;);</span>
<span class="nc" id="L3573">				tempStringBuilder.append(BigDecimalHelper.trimZeros(anEquip.getQty().toString()));</span>
<span class="nc" id="L3574">				tempStringBuilder.append(&quot; &quot;);</span>
<span class="nc" id="L3575">				tempStringBuilder.append(anEquip.getOutputName());</span>
<span class="nc" id="L3576">			});</span>

<span class="nc" id="L3578">		containerContentsString = tempStringBuilder.toString();</span>
<span class="nc" id="L3579">	}</span>

	/**
	 * @param aPC The PC carrying the item
	 */
	private void setDefaultCrit(final PlayerCharacter aPC)
	{

<span class="nc bnc" id="L3587" title="All 2 branches missed.">		if (isWeapon())</span>
		{
<span class="nc bnc" id="L3589" title="All 4 branches missed.">			if (aPC != null &amp;&amp; EqToken.getOldBonusedCritRange(aPC, this, true) == 0)</span>
			{
<span class="nc" id="L3591">				getEquipmentHead(1).put(IntegerKey.CRIT_RANGE, 1);</span>
			}

<span class="nc bnc" id="L3594" title="All 2 branches missed.">			if (getCritMultiplier() == 0)</span>
			{
<span class="nc" id="L3596">				getEquipmentHead(1).put(IntegerKey.CRIT_MULT, 2);</span>
			}
		}
<span class="nc" id="L3599">	}</span>

	/**
	 * Set the quantity of items
	 * 
	 * @param argQty the quantity of items to set
	 */
	public void setQty(final double argQty)
	{
<span class="fc" id="L3608">		qty = argQty;</span>
<span class="fc" id="L3609">	}</span>

	/**
	 * Clear out the Equipment types 
	 */
	static void clearEquipmentTypes()
	{
<span class="fc" id="L3616">		S_EQUIPMENT_TYPES.clear();</span>
<span class="fc" id="L3617">	}</span>

	/**
	 * Get the type list as a period-delimited string
	 * 
	 * @param bPrimary
	 *            if true the types for the porimary head, otherwise the
	 *            secondary head.
	 * @return The type value
	 */
	String getType(final boolean bPrimary)
	{

<span class="nc" id="L3630">		final List&lt;String&gt; typeList = typeList(bPrimary);</span>

<span class="nc" id="L3632">		return String.join(&quot;.&quot;, typeList); // just a guess</span>
	}

	boolean save(final BufferedWriter output)
	{
<span class="nc" id="L3637">		FileAccess.write(output, &quot;BASEITEM:&quot; + formatSaveLine('\t', ':'));</span>
<span class="nc" id="L3638">		FileAccess.newLine(output);</span>

<span class="nc" id="L3640">		return true;</span>
	}

	/**
	 * Sets the base attribute of the Equipment object
	 * 
	 * Todo remove the pc parameter, it is unused.
	 */
	public void setBase()
	{

<span class="nc bnc" id="L3651" title="All 2 branches missed.">		if (get(ObjectKey.BASE_ITEM) == null)</span>
		{
<span class="nc" id="L3653">			Equipment eq = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(Equipment.class,</span>
<span class="nc" id="L3654">				getKeyName());</span>
<span class="nc bnc" id="L3655" title="All 2 branches missed.">			if (eq != null)</span>
			{
<span class="nc" id="L3657">				put(ObjectKey.BASE_ITEM, CDOMDirectSingleRef.getRef(eq));</span>
			}
			else
			{
<span class="nc" id="L3661">				Logging</span>
<span class="nc" id="L3662">					.errorPrint(&quot;Unable to find base item for &quot; + this.getDisplayName() + &quot; with key &quot; + getKeyName());</span>
			}
		}

<span class="nc bnc" id="L3666" title="All 2 branches missed.">		if (hasConsolidatedProfName())</span>
		{
<span class="nc" id="L3668">			CDOMSingleRef&lt;Equipment&gt; baseItem = get(ObjectKey.BASE_ITEM);</span>
<span class="nc bnc" id="L3669" title="All 2 branches missed.">			if (baseItem != null)</span>
			{
<span class="nc" id="L3671">				Equipment eq = baseItem.get();</span>
<span class="nc" id="L3672">				CDOMSingleRef&lt;WeaponProf&gt; wpRef = eq.get(ObjectKey.WEAPON_PROF);</span>
<span class="nc bnc" id="L3673" title="All 2 branches missed.">				if (wpRef != null)</span>
				{
<span class="nc" id="L3675">					put(ObjectKey.WEAPON_PROF, wpRef);</span>
				}
<span class="nc" id="L3677">				CDOMSingleRef&lt;ArmorProf&gt; apRef = eq.get(ObjectKey.ARMOR_PROF);</span>
<span class="nc bnc" id="L3678" title="All 2 branches missed.">				if (apRef != null)</span>
				{
<span class="nc" id="L3680">					put(ObjectKey.ARMOR_PROF, apRef);</span>
				}
<span class="nc" id="L3682">				CDOMSingleRef&lt;ShieldProf&gt; spRef = eq.get(ObjectKey.SHIELD_PROF);</span>
<span class="nc bnc" id="L3683" title="All 2 branches missed.">				if (spRef != null)</span>
				{
<span class="nc" id="L3685">					put(ObjectKey.SHIELD_PROF, spRef);</span>
				}
			}
		}
<span class="nc" id="L3689">	}</span>

	public String consolidatedProfName()
	{
<span class="nc bnc" id="L3693" title="All 2 branches missed.">		if (isWeapon())</span>
		{
<span class="nc" id="L3695">			CDOMSingleRef&lt;WeaponProf&gt; wpRef = get(ObjectKey.WEAPON_PROF);</span>
<span class="nc bnc" id="L3696" title="All 2 branches missed.">			if (wpRef != null)</span>
			{
<span class="nc" id="L3698">				return wpRef.get().getKeyName();</span>
			}
<span class="nc" id="L3700">		}</span>
<span class="nc bnc" id="L3701" title="All 2 branches missed.">		else if (isArmor())</span>
		{
<span class="nc" id="L3703">			return getArmorProf().getKeyName();</span>
		}
<span class="nc bnc" id="L3705" title="All 2 branches missed.">		else if (isShield())</span>
		{
<span class="nc" id="L3707">			return getShieldProf().getKeyName();</span>
		}
<span class="nc" id="L3709">		return &quot;&quot;;</span>
	}

	private boolean hasConsolidatedProfName()
	{
<span class="nc bnc" id="L3714" title="All 2 branches missed.">		if (isWeapon())</span>
		{
<span class="nc bnc" id="L3716" title="All 2 branches missed.">			return get(ObjectKey.WEAPON_PROF) != null;</span>
		}
<span class="nc bnc" id="L3718" title="All 2 branches missed.">		else if (isArmor())</span>
		{
<span class="nc bnc" id="L3720" title="All 2 branches missed.">			return get(ObjectKey.ARMOR_PROF) != null;</span>
		}
<span class="nc bnc" id="L3722" title="All 2 branches missed.">		else if (isShield())</span>
		{
<span class="nc bnc" id="L3724" title="All 2 branches missed.">			return get(ObjectKey.SHIELD_PROF) != null;</span>
		}
<span class="nc" id="L3726">		return false;</span>
	}

	/**
	 * Gets the acceptsTypes attribute of the Equipment object
	 * 
	 * @param aType the Type of Equipment that may be contained in this one
	 *            
	 * @return the number of aType that may be contained in this Equipement
	 */
	private Float getChildType(final String aType)
	{
<span class="nc" id="L3738">		return d_childTypes.get(aType);</span>
	}

	/**
	 * Get the index of a piece of Equipment contained in this one. 
	 * 
	 * @param e the contained equipment
	 * 
	 * @return index of containedEquipment object
	 */
	private int getContainedEquipmentIndexOf(final Equipment e)
	{
<span class="nc" id="L3750">		return d_containedEquipment.indexOf(e);</span>
	}

	/**
	 * @param aPC The PC with the equipment
	 * @param saSize The size to adjust for
	 * @return The costAdjustedForSize value
	 */
	private BigDecimal getCostAdjustedForSize(final PlayerCharacter aPC, final SizeAdjustment saSize)
	{
<span class="nc" id="L3760">		BigDecimal c = getSafe(ObjectKey.COST);</span>

		//
		// Scale everything to medium before conversion
		//
<span class="nc" id="L3765">		SizeAdjustment saBase = getSafe(ObjectKey.BASESIZE).get();</span>

<span class="nc bnc" id="L3767" title="All 2 branches missed.">		if (saSize == null)</span>
		{
<span class="nc" id="L3769">			return c;</span>
		}

<span class="nc bnc" id="L3772" title="All 2 branches missed.">		if (aPC != null)</span>
		{
<span class="nc" id="L3774">			String costMultiplierVar = aPC.getControl(CControl.COSTMULTIPLIER);</span>
<span class="nc bnc" id="L3775" title="All 2 branches missed.">			if (costMultiplierVar == null)</span>
			{
<span class="nc" id="L3777">				final double saDbl = aPC.getSizeBonusTo(saSize, &quot;ITEMCOST&quot;, typeList(), 1.0);</span>
<span class="nc" id="L3778">				final double saBaseDbl = aPC.getSizeBonusTo(saBase, &quot;ITEMCOST&quot;, typeList(), 1.0);</span>
<span class="nc" id="L3779">				final double mult = saDbl / saBaseDbl;</span>
<span class="nc" id="L3780">				c = c.multiply(BigDecimal.valueOf(mult));</span>
<span class="nc" id="L3781">			}</span>
			else
			{
<span class="nc" id="L3784">				final double mult = ((Number) getLocalVariable(aPC.getCharID(), costMultiplierVar)).doubleValue();</span>
<span class="nc" id="L3785">				c = c.multiply(BigDecimal.valueOf(mult));</span>

			}
		}

		//
		// TODO:Non-humanoid races can also double the cost (armor)
		//
<span class="nc" id="L3793">		return c;</span>
	}

	/**
	 * return the list of modifier keys as a period-delimeted string
	 * 
	 * @param bPrimary
	 *            Description of the Parameter
	 * @return The eqModifierString value
	 */
	private String getEqModifierString(final boolean bPrimary)
	{
<span class="nc" id="L3805">		final List&lt;EquipmentModifier&gt; eqModList = getEqModifierList(bPrimary);</span>
<span class="nc" id="L3806">		final StringBuilder aString = new StringBuilder(eqModList.size() * 10);</span>

<span class="nc bnc" id="L3808" title="All 2 branches missed.">		for (EquipmentModifier eqMod : eqModList)</span>
		{
<span class="nc bnc" id="L3810" title="All 2 branches missed.">			if (aString.length() != 0)</span>
			{
<span class="nc" id="L3812">				aString.append('.');</span>
			}

<span class="nc" id="L3815">			aString.append(eqMod.getKeyName());</span>

			// Add the modifiers
<span class="nc bnc" id="L3818" title="All 2 branches missed.">			for (String strMod : getAssociationList(eqMod))</span>
			{
<span class="nc" id="L3820">				aString.append('|').append(strMod.replace('|', '='));</span>
<span class="nc" id="L3821">			}</span>
<span class="nc" id="L3822">		}</span>

<span class="nc bnc" id="L3824" title="All 2 branches missed.">		if (bPrimary)</span>
		{
<span class="nc" id="L3826">			BigDecimal mod = get(ObjectKey.WEIGHT_MOD);</span>
<span class="nc bnc" id="L3827" title="All 2 branches missed.">			if (mod != null)</span>
			{
<span class="nc bnc" id="L3829" title="All 2 branches missed.">				if (aString.length() != 0)</span>
				{
<span class="nc" id="L3831">					aString.append('.');</span>
				}
<span class="nc" id="L3833">				aString.append(EQMOD_WEIGHT).append('|').append(mod.toString().replace('.', ','));</span>
			}
		}

<span class="nc" id="L3837">		String dmg = get(StringKey.DAMAGE_OVERRIDE);</span>
<span class="nc bnc" id="L3838" title="All 2 branches missed.">		if (dmg != null)</span>
		{
<span class="nc bnc" id="L3840" title="All 2 branches missed.">			if (aString.length() != 0)</span>
			{
<span class="nc" id="L3842">				aString.append('.');</span>
			}
<span class="nc" id="L3844">			aString.append(EQMOD_DAMAGE).append('|').append(dmg.replace('.', ','));</span>
		}
<span class="nc" id="L3846">		return aString.toString();</span>
	}

	/**
	 * Set the Type this item will be indexed under
	 *
	 * @param aType the Type this item is indexed under
	 */
	private void setIndexedUnderType(final String aType)
	{
<span class="nc" id="L3856">		indexedUnderType = aType;</span>
<span class="nc" id="L3857">	}</span>

	/**
	 * Gets the Type this item is indexed under
	 * 
	 * @return The Type
	 */
	private String isIndexedUnderType()
	{
<span class="nc" id="L3866">		return indexedUnderType;</span>
	}

	/**
	 * Look for a modifier that grants type &quot;magic&quot;
	 * 
	 * @param eqModList
	 *            Description of the Parameter
	 * @return The magicBonus value
	 */
	private static EquipmentModifier getMagicBonus(final Iterable&lt;EquipmentModifier&gt; eqModList)
	{

<span class="nc bnc" id="L3879" title="All 2 branches missed.">		if (eqModList != null)</span>
		{

<span class="nc bnc" id="L3882" title="All 2 branches missed.">			for (EquipmentModifier eqMod : eqModList)</span>
			{
<span class="nc bnc" id="L3884" title="All 4 branches missed.">				if (eqMod.isType(&quot;MagicalEnhancement&quot;) || (eqMod.isIType(Type.MAGIC)))</span>
				{
<span class="nc" id="L3886">					return eqMod;</span>
				}
<span class="nc" id="L3888">			}</span>
		}

<span class="nc" id="L3891">		return null;</span>
	}

	/**
	 * Gets the nameFromModifiers attribute of the Equipment object
	 * 
	 * @param eqModList
	 *            The list of modifiers
	 * @return The nameFromModifiers value
	 */
	private String getNameFromModifiers(final List&lt;EquipmentModifier&gt; eqModList)
	{
		//
		// Get a sorted list so that the description will always come
		// out the same reguardless of the order we've added the modifiers
		//
<span class="nc" id="L3907">		final List&lt;EquipmentModifier&gt; eqList = new ArrayList&lt;&gt;(eqModList);</span>
<span class="nc" id="L3908">		Globals.sortPObjectList(eqList);</span>

<span class="nc" id="L3910">		final StringBuilder sMod = new StringBuilder(70);</span>

<span class="nc" id="L3912">		eqList.stream().map(eqMod -&gt; eqMod.getSafe(ObjectKey.NAME_OPT).returnName(this, eqMod)).forEach(modDesc -&gt; {</span>
<span class="nc bnc" id="L3913" title="All 4 branches missed.">			if (sMod.length() &gt; 0 &amp;&amp; !modDesc.isEmpty())</span>
			{
<span class="nc" id="L3915">				sMod.append('/');</span>
			}
<span class="nc" id="L3917">			sMod.append(modDesc);</span>
<span class="nc" id="L3918">		});</span>

<span class="nc" id="L3920">		return sMod.toString();</span>
	}

	/**
	 * Gets the specialAbilityList attribute of the Equipment object
	 * 
	 * @param eqModList
	 *            Description of the Parameter
	 * @param pc
	 *            The PC with the equipment
	 * @return The specialAbilityList value
	 */
	private List&lt;String&gt; getSpecialAbilityList(final Iterable&lt;EquipmentModifier&gt; eqModList, final PlayerCharacter pc)
	{

<span class="nc" id="L3935">		final List&lt;String&gt; saList = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3937" title="All 2 branches missed.">		for (EquipmentModifier eqMod : eqModList)</span>
		{
<span class="nc" id="L3939">			saList.addAll(eqMod.getSpecialProperties(this, pc));</span>
<span class="nc" id="L3940">		}</span>

<span class="nc" id="L3942">		return saList;</span>
	}

	/**
	 * Tack on the cost of the magical enhancement(s).
	 * 
	 * @param iPlus the Pluses of the primary head
	 * @param altPlus the Pluses of the secondary head
	 * @return cost from pluses
	 */
	private BigDecimal getCostFromPluses(final int iPlus, final int altPlus)
	{

<span class="nc bnc" id="L3955" title="All 6 branches missed.">		if (((iPlus != 0) || (altPlus != 0)) &amp;&amp; (JEPResourceChecker.getMissingResourceCount() == 0))</span>
		{
<span class="nc" id="L3957">			PJEP myParser = null;</span>
			try
			{
<span class="nc" id="L3960">				myParser = PjepPool.getInstance().aquire();</span>
<span class="nc" id="L3961">				myParser.addVariable(&quot;PLUS&quot;, iPlus);</span>
<span class="nc" id="L3962">				myParser.addVariable(&quot;ALTPLUS&quot;, altPlus);</span>
<span class="nc" id="L3963">				myParser.addVariable(&quot;BASECOST&quot;, getSafe(ObjectKey.COST).doubleValue());</span>

<span class="nc bnc" id="L3965" title="All 2 branches missed.">				if (isAmmunition())</span>
				{
<span class="nc" id="L3967">					myParser.addVariable(&quot;BASEQTY&quot;, getSafe(IntegerKey.BASE_QUANTITY));</span>
				}

				// Look for an expression for all of this item's types
				// If there is more than 1, use the most expensive.
				String costExpr;
<span class="nc" id="L3973">				BigDecimal maxCost = null;</span>
<span class="nc" id="L3974">				final List&lt;String&gt; itemTypes = typeList();</span>

<span class="nc bnc" id="L3976" title="All 2 branches missed.">                for (String typeMatched : itemTypes)</span>
                {
<span class="nc" id="L3978">                    costExpr = SettingsHandler.getGameAsProperty().get().getPlusCalculation(Type.getConstant(typeMatched));</span>

<span class="nc bnc" id="L3980" title="All 2 branches missed.">                    if (costExpr != null)</span>
                    {
<span class="nc" id="L3982">                        final BigDecimal thisCost = evaluateCost(myParser, costExpr);</span>

<span class="nc bnc" id="L3984" title="All 4 branches missed.">                        if ((maxCost == null) || (thisCost.compareTo(maxCost) &gt; 1))</span>
                        {
<span class="nc" id="L3986">                            maxCost = thisCost;</span>
                        }
                    }
<span class="nc" id="L3989">                }</span>

<span class="nc bnc" id="L3991" title="All 2 branches missed.">				if (maxCost != null)</span>
				{
<span class="nc" id="L3993">					return maxCost;</span>
				}

				//
				// No cost formula found, check for catch-all definition
				//
<span class="nc" id="L3999">				costExpr = SettingsHandler.getGameAsProperty().get().getPlusCalculation(Type.ANY);</span>

<span class="nc bnc" id="L4001" title="All 2 branches missed.">				if (costExpr != null)</span>
				{
<span class="nc" id="L4003">					return evaluateCost(myParser, costExpr);</span>
				}
			}
			finally
			{
<span class="nc" id="L4008">				PjepPool.getInstance().release(myParser);</span>
			}
		}

<span class="nc" id="L4012">		return BigDecimal.ZERO;</span>
	}

	/**
	 * As per p.176 of DMG.
	 * 
	 * @return TRUE if limited, else FALSE
	 */
	private boolean isMagicLimitedType()
	{
<span class="nc" id="L4022">		boolean limited = false;</span>

<span class="nc bnc" id="L4024" title="All 12 branches missed.">		if (isType(&quot;HEADGEAR&quot;) || isType(&quot;EYEGEAR&quot;) || isType(&quot;CAPE&quot;) || isType(&quot;AMULET&quot;) || isSuit() || isType(&quot;ROBE&quot;)</span>
<span class="nc bnc" id="L4025" title="All 10 branches missed.">			|| isType(&quot;SHIRT&quot;) || isType(&quot;BRACER&quot;) || isType(&quot;GLOVE&quot;) || isType(&quot;RING&quot;) || isType(&quot;BELT&quot;)</span>
<span class="nc bnc" id="L4026" title="All 2 branches missed.">			|| isType(&quot;BOOT&quot;))</span>
		{
<span class="nc" id="L4028">			limited = true;</span>
		}

<span class="nc" id="L4031">		return limited;</span>
	}

	/**
	 * same as getSpecialAbilityList except if you have the same ability
	 * twice, it only lists it once with (2) at the end.
	 * 
	 * @param abilityList The list of abilities
	 * @return The specialAbilityTimesList value
	 */
	private List&lt;String&gt; getSpecialAbilityTimesList(final List&lt;String&gt; abilityList)
	{

<span class="nc" id="L4044">		final List&lt;String&gt; sortList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4045">		final int[] numTimes = new int[abilityList.size()];</span>

<span class="nc bnc" id="L4047" title="All 2 branches missed.">		for (int i = 0; i &lt; abilityList.size(); i++)</span>
		{
<span class="nc" id="L4049">			final String ability = abilityList.get(i);</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">			if (!sortList.contains(ability))</span>
			{
<span class="nc" id="L4052">				sortList.add(ability);</span>
<span class="nc" id="L4053">				numTimes[i] = 1;</span>
			}
			else
			{
<span class="nc bnc" id="L4057" title="All 2 branches missed.">				for (int j = 0; j &lt; sortList.size(); j++)</span>
				{
<span class="nc" id="L4059">					final String testAbility = sortList.get(j);</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">					if (testAbility.equals(ability))</span>
					{
<span class="nc" id="L4062">						numTimes[j]++;</span>
					}
				}
			}
		}

<span class="nc" id="L4068">		final List&lt;String&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4069" title="All 2 branches missed.">		for (int i = 0; i &lt; sortList.size(); i++)</span>
		{
<span class="nc" id="L4071">			String ability = sortList.get(i);</span>
<span class="nc bnc" id="L4072" title="All 2 branches missed.">			if (numTimes[i] &gt; 1)</span>
			{
<span class="nc" id="L4074">				ability = ability + &quot; (&quot; + numTimes[i] + &quot;)&quot;;</span>
			}
<span class="nc" id="L4076">			retList.add(ability);</span>
		}

<span class="nc" id="L4079">		return retList;</span>
	}

	/**
	 * Gets the weightAdjustedForSize attribute of the Equipment object
	 * 
	 * @param aPC the PC with the Equipment
	 * @param newSA the size to adjust for
	 * @return The weightAdjustedForSize value
	 */
	private BigDecimal getWeightAdjustedForSize(final PlayerCharacter aPC, final SizeAdjustment newSA)
	{

<span class="nc bnc" id="L4092" title="All 2 branches missed.">		if (this.virtualItem)</span>
		{
<span class="nc" id="L4094">			return BigDecimal.ZERO;</span>
		}

<span class="nc" id="L4097">		BigDecimal weight = getBaseWeight();</span>
<span class="nc bnc" id="L4098" title="All 4 branches missed.">		if ((newSA == null) || (getSizeAdjustment() == null))</span>
		{
<span class="nc" id="L4100">			return weight;</span>
		}

<span class="nc bnc" id="L4103" title="All 2 branches missed.">		if (aPC != null)</span>
		{
<span class="nc" id="L4105">			final double mult = getWeightMultiplier(aPC, newSA);</span>
<span class="nc" id="L4106">			weight = weight.multiply(new BigDecimal(String.valueOf(mult)));</span>
		}

<span class="nc" id="L4109">		return weight;</span>
	}

	private double getWeightMultiplier(final PlayerCharacter aPC,
		final SizeAdjustment newSA)
	{
<span class="nc" id="L4115">		String multiplierVar = aPC.getControl(CControl.WEIGHTMULTIPLIER);</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">		if (multiplierVar == null)</span>
		{
<span class="nc" id="L4118">			return aPC.getSizeBonusTo(newSA, &quot;ITEMWEIGHT&quot;, typeList(), 1.0)</span>
<span class="nc" id="L4119">					/ aPC.getSizeBonusTo(getSizeAdjustment(), &quot;ITEMWEIGHT&quot;, typeList(), 1.0);</span>
		}
<span class="nc" id="L4121">		return ((Number) getLocalVariable(aPC.getCharID(), multiplierVar)).doubleValue();</span>
	}

	/**
	 * Add a piece of Equipment
	 * 
	 * @param e the Equipment to add
	 */
	private void addContainedEquipment(final Equipment e)
	{
<span class="nc" id="L4131">		d_containedEquipment.add(e);</span>
<span class="nc" id="L4132">	}</span>

	/**
	 * Test whether the container would be within its weight limits if we 
	 * added an item of weight aFloat
	 * 
	 * @param aPC 
	 *            The PC with the Equipment
	 * @param aFloat
	 *            The weight of the item we want to add to the container
	 * @return 
	 *            True if the container is capable of holding the item
	 */
	private boolean checkChildWeight(final PlayerCharacter aPC, final Float aFloat)
	{

<span class="nc" id="L4148">		BigDecimal weightCap = get(ObjectKey.CONTAINER_WEIGHT_CAPACITY);</span>
<span class="nc bnc" id="L4149" title="All 2 branches missed.">		return weightCap != null</span>
<span class="nc bnc" id="L4150" title="All 4 branches missed.">			&amp;&amp; (Capacity.UNLIMITED.equals(weightCap) || (aFloat + getContainedWeight(aPC)) &lt;= weightCap.doubleValue());</span>
	}

	/**
	 * Does this item fit in this container
	 * 
	 * @param aTypeList
	 *            The type list
	 * @param aQuant 
	 *            The total number of the item
	 * @return Does the item fit
	 */
	private boolean checkContainerCapacity(final SortedSet&lt;String&gt; aTypeList, final Float aQuant)
	{

<span class="nc bnc" id="L4165" title="All 4 branches missed.">		return Capacity.ANY.equals(get(ObjectKey.TOTAL_CAPACITY)) || !(&quot;&quot;.equals(pickChildType(aTypeList, aQuant)));</span>
	}

	private List&lt;EquipmentModifier&gt; cloneEqModList(Equipment other, boolean primary)
	{

<span class="nc" id="L4171">		final List&lt;EquipmentModifier&gt; clonedList = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L4173" title="All 2 branches missed.">		for (EquipmentModifier eqMod : getEqModifierList(primary))</span>
		{

			// only make a copy if we need to add qualifiers to modifier
<span class="nc bnc" id="L4177" title="All 2 branches missed.">			if (!eqMod.getSafe(StringKey.CHOICE_STRING).isEmpty())</span>
			{
<span class="nc" id="L4179">				EquipmentModifier newEqMod = eqMod.clone();</span>
<span class="nc" id="L4180">				other.assocSupt.convertAssociations(eqMod, newEqMod);</span>
<span class="nc" id="L4181">				eqMod = newEqMod;</span>
			}

<span class="nc" id="L4184">			clonedList.add(eqMod);</span>
<span class="nc" id="L4185">		}</span>

<span class="nc" id="L4187">		return clonedList;</span>
	}

	/**
	 * Checks whether the child type is possessed
	 * 
	 * @param aType the Type to check
	 *            
	 * @return true if has child type
	 */
	private boolean containsChildType(final String aType)
	{
<span class="nc" id="L4199">		return d_childTypes.containsKey(aType);</span>
	}

	/**
	 * a set which is a sorted collection of the types in the Equipment
	 * 
	 * @return a sorted set of the types
	 */
	private SortedSet&lt;String&gt; eqTypeList()
	{
<span class="nc" id="L4209">		return new TreeSet&lt;&gt;(typeList());</span>
	}

	/**
	 * Get all the modifiers that apply to the entire item into a separate list
	 * 
	 * @param commonList
	 *            The list to extract from
	 * @param extractList
	 *            The list to extract.
	 */
	private static void extractListFromCommon(final List&lt;EquipmentModifier&gt; commonList,
		final List&lt;EquipmentModifier&gt; extractList)
	{
<span class="nc bnc" id="L4223" title="All 2 branches missed.">		for (int i = extractList.size() - 1; i &gt;= 0; --i)</span>
		{
<span class="nc" id="L4225">			final EquipmentModifier eqMod = extractList.get(i);</span>

<span class="nc bnc" id="L4227" title="All 2 branches missed.">			if (!eqMod.getSafe(ObjectKey.ASSIGN_TO_ALL))</span>
			{
<span class="nc" id="L4229">				continue;</span>
			}

<span class="nc" id="L4232">			commonList.add(0, eqMod);</span>
<span class="nc" id="L4233">			extractList.remove(i);</span>
		}
<span class="nc" id="L4235">	}</span>

	private BigDecimal evaluateCost(final PJEP myParser, final String costExpr)
	{
<span class="nc" id="L4239">		myParser.parseExpression(costExpr);</span>

<span class="nc bnc" id="L4241" title="All 2 branches missed.">		if (!myParser.hasError())</span>
		{
<span class="nc" id="L4243">			final Object result = myParser.getValueAsObject();</span>

<span class="nc bnc" id="L4245" title="All 2 branches missed.">			if (result != null)</span>
			{
<span class="nc" id="L4247">				return new BigDecimal(result.toString());</span>
			}
		}

<span class="nc" id="L4251">		Logging.errorPrint(&quot;Bad equipment cost expression: &quot; + costExpr);</span>

<span class="nc" id="L4253">		return BigDecimal.ZERO;</span>
	}

	private boolean ignoresCostDouble()
	{
<span class="nc" id="L4258">		boolean noDouble = false;</span>

<span class="nc bnc" id="L4260" title="All 2 branches missed.">		if (isType(&quot;MANTLE&quot;) // Mantle of Spell Resistance doesn't double</span>
			// cost
<span class="nc bnc" id="L4262" title="All 8 branches missed.">			|| isType(&quot;POTION&quot;) || isType(&quot;SCROLL&quot;) || isType(&quot;STAFF&quot;) || isType(&quot;WAND&quot;))</span>
		{
<span class="nc" id="L4264">			noDouble = true;</span>
		}

<span class="nc" id="L4267">		return noDouble;</span>
	}

	/**
	 * Checks whether the Equipment can hold quantToAdd more of an item which
	 * has the types in aTypeList
	 *  
	 * @param aTypeList The types of the Equipment we want to add
	 *            
	 * @param quantToAdd how many to add
	 *            
	 * @return true if the Equipement can hold quantToAdd more of the item
	 */
	private String pickChildType(final SortedSet&lt;String&gt; aTypeList, final Float quantToAdd)
	{

<span class="nc" id="L4283">		Capacity totalCap = get(ObjectKey.TOTAL_CAPACITY);</span>
<span class="nc bnc" id="L4284" title="All 2 branches missed.">		BigDecimal capValue = totalCap == null ? BigDecimal.ZERO : totalCap.getCapacity();</span>

<span class="nc bnc" id="L4286" title="All 2 branches missed.">		if (getChildType(&quot;Total&quot;) == null)</span>
		{
<span class="nc" id="L4288">			setChildType(&quot;Total&quot;, 0.0f);</span>
		}

<span class="nc" id="L4291">		String canContain = &quot;&quot;;</span>
<span class="nc bnc" id="L4292" title="All 2 branches missed.">		if ((getChildType(&quot;Total&quot;) + quantToAdd) &lt;= capValue.doubleValue())</span>
		{
<span class="nc" id="L4294">			boolean anyContain = false;</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">			float childType = containsChildType(&quot;Any&quot;) ? getChildType(&quot;Any&quot;) : 0.0f;</span>
<span class="nc bnc" id="L4296" title="All 2 branches missed.">			CAPFOR: for (Capacity c : getSafeListFor(ListKey.CAPACITY))</span>
			{
<span class="nc" id="L4298">				String capType = c.getType();</span>
<span class="nc" id="L4299">				double val = c.getCapacity().doubleValue();</span>
<span class="nc bnc" id="L4300" title="All 2 branches missed.">				for (String aType : aTypeList)</span>
				{
<span class="nc bnc" id="L4302" title="All 2 branches missed.">					if (capType.equalsIgnoreCase(aType))</span>
					{
<span class="nc bnc" id="L4304" title="All 4 branches missed.">						if (containsChildType(aType) &amp;&amp; ((getChildType(aType) + quantToAdd) &lt;= val)</span>
<span class="nc bnc" id="L4305" title="All 2 branches missed.">							|| quantToAdd &lt;= val)</span>
						{
<span class="nc" id="L4307">							canContain = aType;</span>
<span class="nc" id="L4308">							break CAPFOR;</span>
						}
					}
<span class="nc bnc" id="L4311" title="All 2 branches missed.">					else if (&quot;Any&quot;.equalsIgnoreCase(capType))</span>
					{
<span class="nc bnc" id="L4313" title="All 2 branches missed.">						if ((childType + quantToAdd) &lt;= val)</span>
						{
<span class="nc" id="L4315">							anyContain = true;</span>
						}
					}
<span class="nc" id="L4318">				}</span>
<span class="nc" id="L4319">			}</span>

<span class="nc bnc" id="L4321" title="All 4 branches missed.">			if ((&quot;&quot;.equals(canContain)) &amp;&amp; anyContain)</span>
			{
<span class="nc bnc" id="L4323" title="All 2 branches missed.">				if (!containsChildType(&quot;Any&quot;))</span>
				{
<span class="nc" id="L4325">					setChildType(&quot;Any&quot;, (float) 0);</span>
				}
<span class="nc" id="L4327">				canContain = &quot;Any&quot;;</span>
			}
		}

<span class="nc" id="L4331">		return canContain;</span>
	}

	/**
	 * Remove the common modifiers from the alternate list.
	 * 
	 * @param altList the list of modifiers on the secondary head
	 * @param commonList The list of modifiers common between the two heads
	 * @param errMsg the error message to print if something goes wrong
	 */
	private void removeCommonFromList(final List&lt;EquipmentModifier&gt; altList, final List&lt;EquipmentModifier&gt; commonList,
		final String errMsg)
	{

<span class="nc bnc" id="L4345" title="All 2 branches missed.">		for (int i = altList.size() - 1; i &gt;= 0; --i)</span>
		{
<span class="nc" id="L4347">			final EquipmentModifier eqMod = altList.get(i);</span>

<span class="nc bnc" id="L4349" title="All 2 branches missed.">			if (!eqMod.getSafe(ObjectKey.ASSIGN_TO_ALL))</span>
			{
<span class="nc" id="L4351">				continue;</span>
			}

<span class="nc" id="L4354">			final int j = commonList.indexOf(eqMod);</span>

<span class="nc bnc" id="L4356" title="All 2 branches missed.">			if (j &gt;= 0)</span>
			{
<span class="nc" id="L4358">				altList.remove(i);</span>
			}
			else
			{
<span class="nc" id="L4362">				Logging.errorPrint(errMsg + eqMod.getDisplayName());</span>
			}
		}
<span class="nc" id="L4365">	}</span>

	/**
	 * Initialise an array of equipment modifier lists with an entry for each
	 * format category.
	 * 
	 * @return An array of equipmod lists.
	 */
	private List&lt;List&lt;EquipmentModifier&gt;&gt; initSplitModList()
	{

<span class="nc" id="L4376">		return IntStream.range(0, EqModFormatCat.values().length)</span>
<span class="nc" id="L4377">			.&lt;List&lt;EquipmentModifier&gt;&gt; mapToObj(i -&gt; new ArrayList&lt;&gt;()).collect(Collectors.toList());</span>
	}

	/**
	 * Split the equipmod list into seperate lists by format category.
	 * 
	 * @param modList
	 *            The list to be split.
	 * @param splitModList
	 *            The array of receiving lists, one for each format cat.
	 */
	private void splitModListByFormatCat(final List&lt;EquipmentModifier&gt; modList,
		final List&lt;List&lt;EquipmentModifier&gt;&gt; splitModList)
	{

<span class="nc bnc" id="L4392" title="All 2 branches missed.">		for (EquipmentModifier aModList : modList)</span>
		{
<span class="nc" id="L4394">			int o = aModList.getSafe(ObjectKey.FORMAT).ordinal();</span>
<span class="nc" id="L4395">			splitModList.get(o).add(aModList);</span>
<span class="nc" id="L4396">		}</span>
<span class="nc" id="L4397">	}</span>

	/**
	 * remove contained Equipment
	 * 
	 * @param i the index of the item to remove
	 */
	private void removeContainedEquipment(final int i)
	{
<span class="nc" id="L4406">		d_containedEquipment.remove(i);</span>
<span class="nc" id="L4407">	}</span>

	/**
	 * Remove an equipment modifier and specified associated information eg.
	 * Bane|Vermin|Fey eg. Keen Removes a feature from the EqModifier attribute
	 * of the Equipment object
	 * 
	 * @param aString
	 *            The feature to be removed from the EqModifier attribute
	 * @param bPrimary
	 *            The feature to be removed from the EqModifier attribute
	 * @param aPC
	 *            the PC that has the Equipment
	 */
	private void removeEqModifier(final String aString, final boolean bPrimary, PlayerCharacter aPC)
	{

<span class="nc" id="L4424">		final StringTokenizer aTok = new StringTokenizer(aString, &quot;|&quot;);</span>
<span class="nc" id="L4425">		final String eqModKey = aTok.nextToken();</span>
<span class="nc" id="L4426">		final EquipmentModifier eqMod = getEqModifierKeyed(eqModKey, bPrimary);</span>

<span class="nc bnc" id="L4428" title="All 2 branches missed.">		if (eqMod == null)</span>
		{
<span class="nc" id="L4430">			return;</span>
		}

		//
		// Remove the associated choices
		//
<span class="nc bnc" id="L4436" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L4438">			final String x = aTok.nextToken().replace('=', '|');</span>

<span class="nc" id="L4440">			getAssociationList(eqMod).stream().filter(aChoice -&gt; aChoice.startsWith(x))</span>
<span class="nc" id="L4441">				.forEach(aChoice -&gt; removeAssociation(eqMod, aChoice));</span>
<span class="nc" id="L4442">		}</span>

<span class="nc bnc" id="L4444" title="All 2 branches missed.">		if (!hasAssociations(eqMod))</span>
		{
<span class="nc" id="L4446">			removeEqModifier(eqMod, bPrimary, aPC);</span>
		}
<span class="nc" id="L4448">	}</span>

	/**
	 * Returns a list of the types of this item.
	 * 
	 * @param bPrimary
	 *            if true return the types if the primary head, otherwise
	 *            return the types of the secondary head
	 * @return a list of the types of this item.
	 */
	private List&lt;String&gt; typeList(final boolean bPrimary)
	{

<span class="pc bpc" id="L4461" title="1 of 4 branches missed.">		if (bPrimary &amp;&amp; usePrimaryCache)</span>
		{
<span class="fc" id="L4463">			return typeListCachePrimary;</span>
		}
<span class="pc bpc" id="L4465" title="3 of 4 branches missed.">		if (!bPrimary &amp;&amp; useSecondaryCache)</span>
		{
<span class="nc" id="L4467">			return typeListCacheSecondary;</span>
		}

		// Use the primary type(s) if none defined for secondary
<span class="fc" id="L4471">		List&lt;Type&gt; initializingList = getEquipmentHead(2).getListFor(ListKey.TYPE);</span>
<span class="pc bpc" id="L4472" title="5 of 6 branches missed.">		if (bPrimary || (initializingList == null) || initializingList.isEmpty())</span>
		{
<span class="fc" id="L4474">			initializingList = getTrueTypeList(false);</span>
		}
<span class="nc bnc" id="L4476" title="All 2 branches missed.">		else if (!isDouble())</span>
		{
<span class="nc" id="L4478">			return new ArrayList&lt;&gt;();</span>
		}

<span class="fc" id="L4481">		Set&lt;String&gt; calculatedTypeList = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L4482" title="All 2 branches covered.">		for (Type t : initializingList)</span>
		{
<span class="fc" id="L4484">			calculatedTypeList.add(t.getComparisonString());</span>
<span class="fc" id="L4485">		}</span>
<span class="fc" id="L4486">		final Collection&lt;String&gt; modTypeList = new ArrayList&lt;&gt;();</span>

		//
		// Add in all type modfiers from &quot;ADDTYPE&quot; modifier
		//
<span class="fc" id="L4491">		EquipmentModifier aEqMod = getEqModifierKeyed(&quot;ADDTYPE&quot;, bPrimary);</span>

<span class="pc bpc" id="L4493" title="1 of 2 branches missed.">		if (aEqMod != null)</span>
		{
<span class="nc bnc" id="L4495" title="All 2 branches missed.">			for (String aType : getAssociationList(aEqMod))</span>
			{
<span class="nc" id="L4497">				aType = aType.toUpperCase();</span>

<span class="nc bnc" id="L4499" title="All 2 branches missed.">				if (!calculatedTypeList.contains(aType))</span>
				{
<span class="nc" id="L4501">					modTypeList.add(aType);</span>
				}
<span class="nc" id="L4503">			}</span>
		}

		/*
		 * CONSIDER I think there is a weird order of operations issue nere, need to check
		 * if it existed way back, e.g. SVN 6206.  The issue is if a Type is introduced by a 
		 * MOD, then the ChangeArmorType system doesn't seem to be able to grab/modify it
		 * Is that correct? - thpr 10/3/08
		 */
		//
		// Add in all of the types from each EquipmentModifier
		// currently applied to this piece of equipment
		//
<span class="fc" id="L4516">		final List&lt;EquipmentModifier&gt; eqModList = getEqModifierList(bPrimary);</span>

<span class="pc bpc" id="L4518" title="1 of 2 branches missed.">		for (EquipmentModifier eqMod : eqModList)</span>
		{
			//
			// If we've just replaced the armor type, then make sure it is
			// not in the equipment modifier list
			//
<span class="nc" id="L4524">			Set&lt;String&gt; newTypeList = new LinkedHashSet&lt;&gt;(calculatedTypeList);</span>
<span class="nc bnc" id="L4525" title="All 2 branches missed.">			for (ChangeArmorType cat : eqMod.getSafeListFor(ListKey.ARMORTYPE))</span>
			{
<span class="nc" id="L4527">				List&lt;String&gt; tempTypeList = cat.applyProcessor(newTypeList);</span>
<span class="nc" id="L4528">				LinkedHashSet&lt;String&gt; tempTypeSet = new LinkedHashSet&lt;&gt;(tempTypeList);</span>
<span class="nc bnc" id="L4529" title="All 4 branches missed.">				boolean noMatch = newTypeList.size() != tempTypeList.size() || newTypeList.equals(tempTypeSet);</span>
<span class="nc" id="L4530">				newTypeList = tempTypeSet;</span>
<span class="nc bnc" id="L4531" title="All 2 branches missed.">				if (!noMatch)</span>
				{
<span class="nc" id="L4533">					break;</span>
				}
<span class="nc" id="L4535">			}</span>

<span class="nc" id="L4537">			Collection&lt;String&gt; removedTypeList = new ArrayList&lt;&gt;(calculatedTypeList);</span>
<span class="nc" id="L4538">			removedTypeList.removeAll(newTypeList);</span>
<span class="nc" id="L4539">			modTypeList.removeAll(removedTypeList);</span>
<span class="nc" id="L4540">			calculatedTypeList = newTypeList;</span>

<span class="nc bnc" id="L4542" title="All 2 branches missed.">			for (Type type : eqMod.getSafeListFor(ListKey.ITEM_TYPES))</span>
			{
<span class="nc" id="L4544">				String aType = type.toString().toUpperCase();</span>

				// If it's BOTH &amp; MELEE, we cannot add RANGED or THROWN to
				// it
				// BOTH is only used after the split of a Thrown weapon in 2
				// (melee and ranged)
<span class="nc bnc" id="L4550" title="All 4 branches missed.">				if (calculatedTypeList.contains(&quot;BOTH&quot;) &amp;&amp; calculatedTypeList.contains(&quot;MELEE&quot;)</span>
<span class="nc bnc" id="L4551" title="All 4 branches missed.">					&amp;&amp; (Type.RANGED.equals(type) || Type.THROWN.equals(type)))</span>
				{
<span class="nc" id="L4553">					continue;</span>
				}

<span class="nc bnc" id="L4556" title="All 4 branches missed.">				if (!calculatedTypeList.contains(aType) &amp;&amp; !modTypeList.contains(aType))</span>
				{
<span class="nc" id="L4558">					modTypeList.add(aType);</span>
				}
<span class="nc" id="L4560">			}</span>
<span class="nc" id="L4561">		}</span>

<span class="fc" id="L4563">		calculatedTypeList.addAll(modTypeList);</span>

		//
		// Make sure MAGIC tag is the 1st entry
		//
<span class="fc" id="L4568">		List&lt;String&gt; resultingTypeList = new ArrayList&lt;&gt;(calculatedTypeList);</span>
<span class="fc" id="L4569">		final int idx = resultingTypeList.indexOf(&quot;MAGIC&quot;);</span>

<span class="pc bpc" id="L4571" title="1 of 2 branches missed.">		if (idx &gt; 0)</span>
		{
<span class="nc" id="L4573">			resultingTypeList.remove(idx);</span>
<span class="nc" id="L4574">			resultingTypeList.add(0, &quot;MAGIC&quot;);</span>
		}

<span class="pc bpc" id="L4577" title="1 of 2 branches missed.">		if (bPrimary)</span>
		{
<span class="fc" id="L4579">			typeListCachePrimary = resultingTypeList;</span>
<span class="fc" id="L4580">			usePrimaryCache = true;</span>
		}
		else
		{
<span class="nc" id="L4584">			typeListCacheSecondary = resultingTypeList;</span>
<span class="nc" id="L4585">			useSecondaryCache = true;</span>
		}
<span class="fc" id="L4587">		return resultingTypeList;</span>
	}

	/**
	 * Creates the containerCapacityString from children of this object
	 */
	private void updateContainerCapacityString()
	{
<span class="nc" id="L4595">		final StringBuilder tempStringBuilder = new StringBuilder(100);</span>
<span class="nc" id="L4596">		boolean comma = false;</span>

<span class="nc" id="L4598">		BigDecimal weightCap = get(ObjectKey.CONTAINER_WEIGHT_CAPACITY);</span>
<span class="nc bnc" id="L4599" title="All 4 branches missed.">		if (weightCap != null &amp;&amp; !Capacity.UNLIMITED.equals(weightCap))</span>
		{
<span class="nc" id="L4601">			tempStringBuilder.append(weightCap).append(' ').append(Globals.getGameModeUnitSet().getWeightUnit());</span>
<span class="nc" id="L4602">			comma = true;</span>
		}

<span class="nc" id="L4605">		List&lt;Capacity&gt; capacity = getListFor(ListKey.CAPACITY);</span>
<span class="nc bnc" id="L4606" title="All 2 branches missed.">		if (capacity != null)</span>
		{
<span class="nc bnc" id="L4608" title="All 2 branches missed.">			for (Capacity c : capacity)</span>
			{
<span class="nc bnc" id="L4610" title="All 2 branches missed.">				if (comma)</span>
				{
<span class="nc" id="L4612">					tempStringBuilder.append(&quot;, &quot;);</span>
<span class="nc" id="L4613">					comma = false;</span>
				}

<span class="nc" id="L4616">				BigDecimal capValue = c.getCapacity();</span>
<span class="nc bnc" id="L4617" title="All 2 branches missed.">				if (!Capacity.UNLIMITED.equals(capValue))</span>
				{
<span class="nc" id="L4619">					tempStringBuilder.append(capValue).append(' ');</span>
<span class="nc" id="L4620">					tempStringBuilder.append(c.getType());</span>
<span class="nc" id="L4621">					comma = true;</span>
				}
<span class="nc bnc" id="L4623" title="All 2 branches missed.">				else if (c.getType() != null)</span>
				{
<span class="nc" id="L4625">					comma = true;</span>
<span class="nc" id="L4626">					tempStringBuilder.append(c.getType());</span>
				}
<span class="nc" id="L4628">			}</span>
		}

<span class="nc" id="L4631">		containerCapacityString = tempStringBuilder.toString();</span>
<span class="nc" id="L4632">	}</span>

	/**
	 * Sets all the BonusObj's to &quot;active&quot;. Note this version overrides the
	 * PObject implementation as it will check the bonuses against the
	 * equipment, rather than the PC.
	 * 
	 * @param aPC
	 *            The character being checked.
	 */
	@Override
	public void activateBonuses(final PlayerCharacter aPC)
	{
<span class="nc bnc" id="L4645" title="All 2 branches missed.">		for (final BonusObj bonus : getRawBonusList(aPC))</span>
		{
<span class="nc" id="L4647">			aPC.setApplied(bonus, PrereqHandler.passesAll(bonus, this, aPC));</span>
<span class="nc" id="L4648">		}</span>
<span class="nc" id="L4649">	}</span>

	public boolean isCalculatingCost()
	{
<span class="nc" id="L4653">		return calculatingCost;</span>
	}

	public boolean isWeightAlreadyUsed()
	{
<span class="nc" id="L4658">		return weightAlreadyUsed;</span>
	}

	public BigDecimal getWeightInPounds()
	{
<span class="nc bnc" id="L4663" title="All 2 branches missed.">		return isVirtual() ? BigDecimal.ZERO : getSafe(ObjectKey.WEIGHT);</span>
	}

	public void setWeightAlreadyUsed(boolean weightAlreadyUsed)
	{
<span class="nc" id="L4668">		this.weightAlreadyUsed = weightAlreadyUsed;</span>
<span class="nc" id="L4669">	}</span>

	/**
	 * Get non headed name
	 * 
	 * @return non headed name
	 */
	public String getNonHeadedName()
	{
<span class="nc bnc" id="L4678" title="All 4 branches missed.">		if (wholeItemName == null || wholeItemName.isEmpty())</span>
		{
<span class="nc" id="L4680">			return getName();</span>
		}
<span class="nc" id="L4682">		return wholeItemName;</span>
	}

	/**
	 * Get whole item name
	 * 
	 * @return whole item name
	 */
	public String getWholeItemName()
	{
<span class="nc" id="L4692">		return wholeItemName;</span>
	}

	/**
	 * Set whole item name
	 * 
	 * @param wholeItemName the name to set
	 */
	void setWholeItemName(String wholeItemName)
	{
<span class="nc" id="L4702">		this.wholeItemName = wholeItemName;</span>
<span class="nc" id="L4703">	}</span>

	/**
	 * Create a Key for the new custom piece of resized equipment. The new key
	 * will start with the auto resized constant and then the size abbreviation
	 * (as per SizeAdjustment) followed by the existing key. This should
	 * generate a unique name unless we've already auto resized this piece of
	 * equipment to this size in which case it already exists in the equipment
	 * list and does not need to be created.
	 * 
	 * @param newSize
	 *            The size of equipment to make a key for. This needs to be the
	 *            abbreviated form, not the full name.
	 * @return The generated key
	 */

	public String createKeyForAutoResize(SizeAdjustment newSize)
	{
		// Make sure newSize is not null
<span class="nc bnc" id="L4722" title="All 2 branches missed.">		if (newSize == null)</span>
		{
<span class="nc" id="L4724">			return getKeyName();</span>
		}

<span class="nc" id="L4727">		String displayName = newSize.getDisplayName();</span>

		// Make sure finalSize is a single upper case letter
<span class="nc" id="L4730">		String finalSize = displayName.toUpperCase().substring(0, 1);</span>

<span class="nc" id="L4732">		String thisKey = getKeyName();</span>

<span class="nc bnc" id="L4734" title="All 2 branches missed.">		if (thisKey.startsWith(Constants.AUTO_RESIZE_PREFIX))</span>
		{
<span class="nc" id="L4736">			int index = Constants.AUTO_RESIZE_PREFIX.length();</span>
<span class="nc" id="L4737">			String keySize = thisKey.substring(index, index + 1).toUpperCase();</span>

			// If the key of this object already has the finalSize in the correct
			// place then just return it, the item has already been adjusted.
			// This should never happen because if the key has an AUTO_RESIZE_PREFIX
			// prefix and the correct size then it should already be finalSize
<span class="nc bnc" id="L4743" title="All 2 branches missed.">			if (keySize.equals(finalSize))</span>
			{
<span class="nc" id="L4745">				return thisKey;</span>
			}

			// remove the AUTO_RESIZE_PREFIX and the following size abbreviation
			// from the key
<span class="nc" id="L4750">			thisKey = thisKey.substring(index + 1);</span>
		}

<span class="nc" id="L4753">		return Constants.AUTO_RESIZE_PREFIX + finalSize + thisKey;</span>
	}

	/**
	 * Create a Name for the new custom piece of resized equipment. The name
	 * will be constructed by searching for the size of the equipment in its
	 * name. If found (and surrounded by '(', '/', or ')', it will be replaced.
	 * If not found, it will be added to the end surrounded by parenthesis.
	 * 
	 * @param newSize
	 *            The size of equipment to make a key for
	 * @return The generated Name
	 */

	public String createNameForAutoResize(SizeAdjustment newSize)
	{
		// Make sure newSize is not null
<span class="nc bnc" id="L4770" title="All 2 branches missed.">		if (newSize == null)</span>
		{
<span class="nc" id="L4772">			return getName();</span>
		}

<span class="nc" id="L4775">		String displayName = newSize.getDisplayName();</span>
<span class="nc" id="L4776">		String thisName = getName();</span>
<span class="nc" id="L4777">		String upName = thisName.toUpperCase();</span>

<span class="nc" id="L4779">		String upThisSize = getSizeAdjustment().getDisplayName().toUpperCase();</span>

<span class="nc" id="L4781">		int start = upName.indexOf(upThisSize);</span>
<span class="nc" id="L4782">		int end = start + upThisSize.length();</span>

		/*
		 * if the name contains thisSize surrounded by /, ( or ) then replace
		 * thisSize with newSize
		 */
<span class="nc bnc" id="L4788" title="All 6 branches missed.">		if (start &gt; -1 &amp;&amp; (upName.substring(start - 1).startsWith(&quot;(&quot;) || upName.substring(start - 1).startsWith(&quot;/&quot;))</span>
<span class="nc bnc" id="L4789" title="All 4 branches missed.">			&amp;&amp; (upName.substring(end).startsWith(&quot;)&quot;) || upName.substring(end).startsWith(&quot;/&quot;)))</span>
		{
<span class="nc" id="L4791">			return thisName.substring(0, start) + displayName + thisName.substring(end);</span>
		}

<span class="nc" id="L4794">		return thisName + &quot; (&quot; + displayName + &quot;)&quot;;</span>
	}

	/**
	 * Make this item virtual i.e. one that doesn't really exist and is only
	 * used to hold temporary bonuses
	 */
	public void makeVirtual()
	{
<span class="nc" id="L4803">		this.virtualItem = true;</span>
<span class="nc" id="L4804">	}</span>

	/**
	 * Does this item really exist, or is it a phantom created to hold a bonus
	 * 
	 * @return Returns the virtualItem.
	 */
	private boolean isVirtual()
	{
<span class="nc" id="L4813">		return virtualItem;</span>
	}

	/**
	 * Gets the critMultiplier attribute of the Equipment object
	 * 
	 * @return The critMultiplier value
	 * @deprecated due to CRITMULT code control
	 */
	@Deprecated
	public int getCritMultiplier()
	{
<span class="nc" id="L4825">		int mult = getHeadInfo(1, IntegerKey.CRIT_MULT);</span>
<span class="nc bnc" id="L4826" title="All 2 branches missed.">		if (mult == 0)</span>
		{
<span class="nc" id="L4828">			final String cm = getWeaponInfo(&quot;CRITMULT&quot;, true);</span>

<span class="nc bnc" id="L4830" title="All 2 branches missed.">			if (!cm.isEmpty())</span>
			{
<span class="nc" id="L4832">				mult = Integer.parseInt(cm);</span>
			}
		}
<span class="nc" id="L4835">		return mult;</span>
	}

	/**
	 * Gets the altCritMultiplier attribute of the Equipment object
	 * 
	 * @return The altCritMultiplier value
	 * @deprecated due to CRITMULT code control
	 */
	@Deprecated
	public int getAltCritMultiplier()
	{
<span class="nc" id="L4847">		int mult = getHeadInfo(2, IntegerKey.CRIT_MULT);</span>
<span class="nc bnc" id="L4848" title="All 2 branches missed.">		if (mult == 0)</span>
		{
<span class="nc" id="L4850">			final String cm = getWeaponInfo(&quot;CRITMULT&quot;, false);</span>

<span class="nc bnc" id="L4852" title="All 2 branches missed.">			if (!cm.isEmpty())</span>
			{
<span class="nc" id="L4854">				mult = Integer.parseInt(cm);</span>
			}
		}
<span class="nc" id="L4857">		return mult;</span>
	}

	/**
	 * @deprecated due to CRITMULT and CRITRANGE code controls
	 */
	@Deprecated
	private int getHeadInfo(int headnum, IntegerKey ik)
	{
<span class="nc" id="L4866">		EquipmentHead head = getEquipmentHeadReference(headnum);</span>
<span class="nc bnc" id="L4867" title="All 2 branches missed.">		return head == null ? 0 : head.getSafe(ik);</span>
	}

	/**
	 * Test to see if a weapon is Finesseable or not for a PC
	 *
	 * @param pc The PlayerCharacter wielding the weapon.
	 * @return true if finessable
	 */
	public boolean isFinessable(final PlayerCharacter pc)
	{
<span class="nc" id="L4878">		WieldCategory wCat = getEffectiveWieldCategory(pc);</span>
<span class="nc bnc" id="L4879" title="All 6 branches missed.">		return isType(&quot;Finesseable&quot;) || (wCat != null &amp;&amp; wCat.isFinessable());</span>
	}

	/**
	 * Tests if this weapon is a light weapon for the specied PC.
	 * 
	 * @param pc The PlayerCharacter wielding the weapon.
	 * @return true if the weapon is light for the specified pc.
	 */
	public boolean isWeaponLightForPC(final PlayerCharacter pc)
	{

<span class="nc bnc" id="L4891" title="All 4 branches missed.">		if (pc == null || !isWeapon())</span>
		{
<span class="nc" id="L4893">			return false;</span>
		}
<span class="nc" id="L4895">		WieldCategory wc = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L4896">			.silentlyGetConstructedCDOMObject(WieldCategory.class, &quot;Light&quot;);</span>
<span class="nc bnc" id="L4897" title="All 4 branches missed.">		return (wc != null) &amp;&amp; wc.equals(getEffectiveWieldCategory(pc));</span>
	}

	/**
	 * Tests if this weapon can be used in one hand by the specified PC.
	 * 
	 * @param pc The PlayerCharacter wielding the weapon.
	 * @return true if the weapon can be used one handed.
	 */
	public boolean isWeaponOneHanded(PlayerCharacter pc)
	{

<span class="nc bnc" id="L4909" title="All 4 branches missed.">		if (pc == null &amp;&amp; !isWeapon())</span>
		{
<span class="nc" id="L4911">			return false;</span>
		}

<span class="nc" id="L4914">		WieldCategory wCat = getEffectiveWieldCategory(pc);</span>
<span class="nc bnc" id="L4915" title="All 4 branches missed.">		return wCat != null &amp;&amp; getHandsRequired(pc, wCat) == 1;</span>
	}

	private int getHandsRequired(PlayerCharacter pc, WieldCategory wCat)
	{
<span class="nc" id="L4920">		String handsControl = pc.getControl(CControl.WEAPONHANDS);</span>
<span class="nc bnc" id="L4921" title="All 2 branches missed.">		if (handsControl != null)</span>
		{
<span class="nc" id="L4923">			return ((Number) getLocalVariable(pc.getCharID(), handsControl)).intValue();</span>
		}
		else
		{
<span class="nc" id="L4927">			return wCat.getHandsRequired();</span>
		}
	}

	/**
	 * Tests if the weapon is either too large OR too small for the specified PC
	 * to wield.
	 * 
	 * @param pc The PlayerCharacter wielding the weapon.
	 * @return true if the weapon is too large or too small.
	 */
	public boolean isWeaponOutsizedForPC(PlayerCharacter pc)
	{

<span class="nc bnc" id="L4941" title="All 4 branches missed.">		if (pc == null || !isWeapon())</span>
		{
<span class="nc" id="L4943">			return true;</span>
		}

<span class="nc" id="L4946">		final WieldCategory wCat = getEffectiveWieldCategory(pc);</span>
<span class="nc bnc" id="L4947" title="All 2 branches missed.">		if (wCat == null)</span>
		{
<span class="nc" id="L4949">			return false;</span>
		}
<span class="nc" id="L4951">		int handsRequired = getHandsRequired(pc, wCat);</span>
<span class="nc bnc" id="L4952" title="All 4 branches missed.">		return (handsRequired &gt; 2 || handsRequired &lt; 0);</span>
	}

	/**
	 * Tests if this weapon requires two hands to use.
	 * 
	 * @param pc -
	 *            The PlayerCharacter wielding the weapon.
	 * @return true if the weapon is two-handed for the specified pc
	 */
	public boolean isWeaponTwoHanded(PlayerCharacter pc)
	{

<span class="nc bnc" id="L4965" title="All 4 branches missed.">		if (pc == null || !isWeapon())</span>
		{
<span class="nc" id="L4967">			return false;</span>
		}

<span class="nc" id="L4970">		WieldCategory wieldCategory = getEffectiveWieldCategory(pc);</span>
<span class="nc bnc" id="L4971" title="All 4 branches missed.">		return wieldCategory != null &amp;&amp; getHandsRequired(pc, wieldCategory) == 2;</span>
	}

	/**
	 * Gets the minimum WieldCategory this weapon can be used at. Accounts for
	 * all modifiers that affect WieldCategory. 3.0 weapon sizes are mapped to
	 * appropriate WieldCategories.
	 * 
	 * @param aPC The PlayerCharacter using the weapon
	 * @return The minimum WieldCategory required to use the weapon.
	 */
	public WieldCategory getEffectiveWieldCategory(final PlayerCharacter aPC)
	{
<span class="nc" id="L4984">		CDOMSingleRef&lt;WeaponProf&gt; ref = get(ObjectKey.WEAPON_PROF);</span>
<span class="nc bnc" id="L4985" title="All 2 branches missed.">		WeaponProf wp = ref == null ? null : ref.get();</span>

<span class="nc" id="L4987">		WieldCategory wCat = get(ObjectKey.WIELD);</span>
<span class="nc bnc" id="L4988" title="All 4 branches missed.">		if (wCat != null &amp;&amp; !Globals.checkRule(RuleConstants.SIZEOBJ))</span>
		{
			// Get the starting effective wield category
<span class="nc" id="L4991">			wCat = wCat.adjustForSize(aPC, this);</span>
		}
		else
		{
<span class="nc" id="L4995">			int pcSize = aPC.sizeInt();</span>

<span class="nc bnc" id="L4997" title="All 2 branches missed.">			if (wp != null)</span>
			{
<span class="nc" id="L4999">				pcSize += aPC.getTotalBonusTo(&quot;WEAPONPROF=&quot; + wp.getKeyName(), &quot;PCSIZE&quot;);</span>
			}

			int sizeDiff;
<span class="nc bnc" id="L5003" title="All 4 branches missed.">			if (wCat != null &amp;&amp; Globals.checkRule(RuleConstants.SIZEOBJ))</span>
			{
				// In this case we have a 3.5 style equipments size.
				// We need to map to a 3.0 style
<span class="nc" id="L5007">				sizeDiff = wCat.getObjectSizeInt(this) - pcSize;</span>
			}
			else
			{
<span class="nc" id="L5011">				sizeDiff = sizeInt() - pcSize;</span>
			}

<span class="nc bnc" id="L5014" title="All 2 branches missed.">			if (sizeDiff &gt; 1)</span>
			{
<span class="nc" id="L5016">				wCat = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(WieldCategory.class,</span>
					&quot;TooLarge&quot;);
			}
<span class="nc bnc" id="L5019" title="All 2 branches missed.">			else if (sizeDiff == 1)</span>
			{
<span class="nc" id="L5021">				wCat = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(WieldCategory.class,</span>
					&quot;TwoHanded&quot;);
			}
<span class="nc bnc" id="L5024" title="All 2 branches missed.">			else if (sizeDiff == 0)</span>
			{
<span class="nc" id="L5026">				wCat = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(WieldCategory.class,</span>
					&quot;OneHanded&quot;);
			}
			else
			{
<span class="nc" id="L5031">				wCat = Globals.getContext().getReferenceContext().silentlyGetConstructedCDOMObject(WieldCategory.class,</span>
					&quot;Light&quot;);
			}
		}

<span class="nc bnc" id="L5036" title="All 2 branches missed.">		assert wCat != null;</span>
<span class="nc" id="L5037">		int aBump = 0;</span>

		// TODO Remove this code when support for this &quot;feature&quot; goes away
<span class="nc bnc" id="L5040" title="All 2 branches missed.">		if (wp != null)</span>
		{
<span class="nc" id="L5042">			int iHands = wp.getSafe(IntegerKey.HANDS);</span>

<span class="nc bnc" id="L5044" title="All 2 branches missed.">			if (iHands == Constants.HANDS_SIZE_DEPENDENT)</span>
			{
<span class="nc bnc" id="L5046" title="All 2 branches missed.">				if (aPC.sizeInt() &gt; sizeInt())</span>
				{
<span class="nc" id="L5048">					iHands = 1;</span>
				}
				else
				{
<span class="nc" id="L5052">					iHands = 2;</span>
				}
			}
<span class="nc bnc" id="L5055" title="All 2 branches missed.">			while (getHandsRequired(aPC, wCat) &lt; iHands)</span>
			{
<span class="nc" id="L5057">				wCat = wCat.getWieldCategoryStep(1);</span>
			}

			// See if there is a bonus associated with just this weapon
<span class="nc" id="L5061">			final String expProfName = wp.getKeyName();</span>
<span class="nc" id="L5062">			aBump += (int) aPC.getTotalBonusTo(&quot;WEAPONPROF=&quot; + expProfName, &quot;WIELDCATEGORY&quot;);</span>

			// loops for each equipment type
<span class="nc" id="L5065">			int modWield = 0;</span>
<span class="nc bnc" id="L5066" title="All 2 branches missed.">			for (String eqType : typeList())</span>
			{

				// get the type bonus (ex TYPE.MARTIAL)
<span class="nc" id="L5070">				final int i = (int) aPC.getTotalBonusTo(&quot;WEAPONPROF=TYPE.&quot; + eqType</span>
						// get the type bonus (ex TYPE.MARTIAL)
						, &quot;WIELDCATEGORY&quot;);

				// get the highest bonus
<span class="nc bnc" id="L5075" title="All 2 branches missed.">				if (i &lt; modWield)</span>
				{
<span class="nc" id="L5077">					modWield = i;</span>
				}
<span class="nc" id="L5079">			}</span>
<span class="nc" id="L5080">			aBump += modWield;</span>
		}

		// or a bonus from the weapon itself
<span class="nc" id="L5084">		aBump += (int) bonusTo(aPC, &quot;WEAPON&quot;, &quot;WIELDCATEGORY&quot;, true);</span>

<span class="nc bnc" id="L5086" title="All 2 branches missed.">		if (aBump == 0)</span>
		{
<span class="nc" id="L5088">			return wCat;</span>
		}

<span class="nc" id="L5091">		return wCat.getWieldCategoryStep(aBump);</span>
	}

	//
	// Protective Item Support
	//
	/**
	 * Gets the acMod attribute of the Equipment object
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @return The acMod value
	 */
	public Integer getACMod(final PlayerCharacter aPC)
	{
<span class="nc" id="L5106">		String acMod = aPC.getControl(CControl.EQACMOD);</span>
<span class="nc bnc" id="L5107" title="All 2 branches missed.">		if (acMod != null)</span>
		{
<span class="nc" id="L5109">			Object o = aPC.getLocal(this, acMod);</span>
<span class="nc" id="L5110">			return ((Number) o).intValue();</span>
		}
		//TODO This should be documented
<span class="nc" id="L5113">		return (int) bonusTo(aPC, &quot;EQMARMOR&quot;, &quot;AC&quot;, true) + (int) bonusTo(aPC, &quot;COMBAT&quot;, &quot;AC&quot;, true);</span>
	}

	//
	// Weapon Support
	//

	/**
	 * Gets the damage attribute of the Equipment object
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @return The damage value
	 */
	public String getDamage(final PlayerCharacter aPC)
	{
<span class="nc" id="L5129">		return getDamage(aPC, true);</span>
	}

	private String getDamage(PlayerCharacter apc, boolean bPrimary)
	{
<span class="nc bnc" id="L5134" title="All 2 branches missed.">		int headnum = bPrimary ? 1 : 2;</span>
<span class="nc" id="L5135">		EquipmentHead head = getEquipmentHeadReference(headnum);</span>
<span class="nc bnc" id="L5136" title="All 2 branches missed.">		if (head == null)</span>
		{
<span class="nc" id="L5138">			return &quot;&quot;;</span>
		}
<span class="nc" id="L5140">		String dam = head.get(StringKey.DAMAGE);</span>
<span class="nc bnc" id="L5141" title="All 6 branches missed.">		if (!isWeapon() || (!bPrimary &amp;&amp; !isDouble()))</span>
		{
<span class="nc bnc" id="L5143" title="All 2 branches missed.">			return dam == null ? &quot;&quot; : dam;</span>
		}
<span class="nc bnc" id="L5145" title="All 4 branches missed.">		if (bPrimary &amp;&amp; dam == null)</span>
		{
			// No need to grab reference, always exists due to if above
<span class="nc" id="L5148">			EquipmentHead altHead = getEquipmentHead(2);</span>
<span class="nc" id="L5149">			dam = altHead.get(StringKey.DAMAGE);</span>
		}
<span class="nc" id="L5151">		String override = get(StringKey.DAMAGE_OVERRIDE);</span>
<span class="nc bnc" id="L5152" title="All 4 branches missed.">		if (bPrimary &amp;&amp; override != null)</span>
		{
			// this overides the base damage
<span class="nc" id="L5155">			dam = override;</span>
		}

<span class="nc bnc" id="L5158" title="All 2 branches missed.">		if (dam == null)</span>
		{
<span class="nc" id="L5160">			dam = getWeaponInfo(&quot;DAMAGE&quot;, bPrimary);</span>
		}

<span class="nc" id="L5163">		final int iSize = sizeInt();</span>
<span class="nc" id="L5164">		int iMod = iSize + (int) bonusTo(apc, &quot;EQMWEAPON&quot;, &quot;DAMAGESIZE&quot;, bPrimary);</span>
<span class="nc" id="L5165">		iMod += (int) bonusTo(apc, &quot;WEAPON&quot;, &quot;DAMAGESIZE&quot;, bPrimary);</span>

<span class="nc" id="L5167">		AbstractReferenceContext ref = Globals.getContext().getReferenceContext();</span>
<span class="nc bnc" id="L5168" title="All 2 branches missed.">		if (iMod &lt; 0)</span>
		{
<span class="nc" id="L5170">			iMod = 0;</span>
		}
		else
		{
<span class="nc" id="L5174">			int maxIndex = ref.getConstructedObjectCount(SizeAdjustment.class) - 1;</span>
<span class="nc bnc" id="L5175" title="All 2 branches missed.">			if (iMod &gt; maxIndex)</span>
			{
<span class="nc" id="L5177">				iMod = maxIndex;</span>
			}
		}
<span class="nc" id="L5180">		return adjustDamage(dam, iMod);</span>
	}

	/**
	 * Returns the alternate damage for this item.
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @return the alternate damage for this item.
	 */
	public String getAltDamage(final PlayerCharacter aPC)
	{
<span class="nc" id="L5192">		return getDamage(aPC, false);</span>
	}

	/**
	 * Gets the bonusToDamage attribute of the Equipment object
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @param bPrimary
	 *            if true get info about the priomary head, else get info
	 *            about the secondary head.
	 * @return The bonusToDamage value
	 */
	public int getBonusToDamage(final PlayerCharacter aPC, final boolean bPrimary)
	{
<span class="nc" id="L5207">		return (int) bonusTo(aPC, &quot;WEAPON&quot;, &quot;DAMAGE&quot;, bPrimary);</span>
	}

	/**
	 * Gets the bonusToHit attribute of the Equipment object
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @param bPrimary
	 *            if true get info about the priomary head, else get info
	 *            about the secondary head.
	 * @return The bonusToHit value
	 */
	public int getBonusToHit(final PlayerCharacter aPC, final boolean bPrimary)
	{
<span class="nc" id="L5222">		return (int) bonusTo(aPC, &quot;WEAPON&quot;, &quot;TOHIT&quot;, bPrimary);</span>
	}

	// ---------------------------
	// Owned Equipment
	// ---------------------------
	/**
	 * Sets the number of items of this type that are carried.
	 * 
	 * @param argCarried
	 *            the number of items of this type that are carried.
	 */
	public void setCarried(final Float argCarried)
	{
<span class="nc" id="L5236">		carried = argCarried;</span>
<span class="nc" id="L5237">	}</span>

	/**
	 * Returns the number of items of this type that are carried.
	 * 
	 * @return the number of items of this type that are carried.
	 */
	public Float getCarried()
	{
<span class="nc" id="L5246">		return carried;</span>
	}

	/**
	 * Gets the equipped attribute of the Equipment object
	 * 
	 * @return The equipped value
	 */
	public boolean isEquipped()
	{
<span class="nc" id="L5256">		return equipped;</span>
	}

	// ---------------------------
	// Container Support
	// ---------------------------

	/**
	 * Gets a child of the Equipment object
	 * 
	 * @param childIndex
	 *            The index of the child to get
	 * @return The child value
	 */
	private Object getChild(final int childIndex)
	{
<span class="nc" id="L5272">		return getContainedEquipment(childIndex);</span>
	}

	/**
	 * Gets the childCount attribute of the Equipment object
	 * 
	 * @return The childCount value
	 */
	public int getChildCount()
	{
<span class="nc" id="L5282">		return getContainedEquipmentCount();</span>
	}

	/**
	 * Sets how many of a child the Equipment currently holds
	 * 
	 * @param aType
	 *            A type of Equiupment that may be contained in this one
	 * @param quantity
	 *            How many of the Child Type are currently contained
	 */
	private void setChildType(final String aType, final Float quantity)
	{
<span class="nc" id="L5295">		d_childTypes.put(aType, quantity);</span>
<span class="nc" id="L5296">	}</span>

	/**
	 * @param index
	 *            integer indicating which object (contained in this object) to
	 *            return
	 * @return the equipment object contained at this position.
	 */
	public Equipment getContainedByIndex(final int index)
	{

<span class="nc" id="L5307">		final List&lt;Equipment&gt; contents = new ArrayList&lt;&gt;(getContents());</span>

<span class="nc bnc" id="L5309" title="All 2 branches missed.">		if (!contents.isEmpty())</span>
		{
<span class="nc bnc" id="L5311" title="All 2 branches missed.">			if (index &lt;= contents.size())</span>
			{
<span class="nc" id="L5313">				return contents.get(index);</span>
			}
		}

<span class="nc" id="L5317">		return null;</span>
	}

	/**
	 * Get a piece of contained equipment
	 * 
	 * @param i the index of the contained equipment
	 * 
	 * @return containedEquipment object
	 */
	public Equipment getContainedEquipment(final int i)
	{
<span class="nc" id="L5329">		return d_containedEquipment.get(i);</span>
	}

	/**
	 * count
	 * 
	 * @return number of containedEquipment objects
	 */
	public int getContainedEquipmentCount()
	{
<span class="nc" id="L5339">		return d_containedEquipment.size();</span>
	}

	/**
	 * Gets the contained Weight this object recursis all child objects to get
	 * their contained weight
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @return The containedWeight value
	 */
	public Float getContainedWeight(final PlayerCharacter aPC)
	{
<span class="nc" id="L5352">		return getContainedWeight(aPC, false);</span>
	}

	/**
	 * Get Base contained weight
	 * 
	 * @return Base contained weight
	 */
	public Float getBaseContainedWeight()
	{

<span class="nc" id="L5363">		float total = 0.0f;</span>

<span class="nc bnc" id="L5365" title="All 4 branches missed.">		if ((getSafe(ObjectKey.CONTAINER_CONSTANT_WEIGHT)) || (getChildCount() == 0))</span>
		{
<span class="nc" id="L5367">			return total;</span>
		}

<span class="nc bnc" id="L5370" title="All 2 branches missed.">		for (int e = 0; e &lt; getContainedEquipmentCount(); ++e)</span>
		{
<span class="nc" id="L5372">			final Equipment anEquip = getContainedEquipment(e);</span>

<span class="nc bnc" id="L5374" title="All 2 branches missed.">			if (anEquip.getContainedEquipmentCount() &gt; 0)</span>
			{
<span class="nc" id="L5376">				total = total + anEquip.getBaseWeight().floatValue() + anEquip.getBaseContainedWeight();</span>
			}
			else
			{
<span class="nc" id="L5380">				total += anEquip.getBaseWeight().floatValue() * anEquip.getCarried();</span>
			}
		}

<span class="nc" id="L5384">		Integer crw = get(IntegerKey.CONTAINER_REDUCE_WEIGHT);</span>
<span class="nc bnc" id="L5385" title="All 4 branches missed.">		if (crw != null &amp;&amp; crw != 0)</span>
		{
<span class="nc" id="L5387">			total *= (crw.floatValue() / 100);</span>
		}

<span class="nc" id="L5390">		return total;</span>
	}

	/**
	 * Gets the contained Weight this object recursis all child objects to get
	 * their contained weight
	 * 
	 * @param aPC The PC that has the Equipment
	 * 
	 * @param effective
	 *            Should we recurse child objects?
	 * @return The containedWeight value
	 */
	public Float getContainedWeight(final PlayerCharacter aPC, final boolean effective)
	{
<span class="nc" id="L5405">		float total = 0.0f;</span>

<span class="nc bnc" id="L5407" title="All 6 branches missed.">		if ((getSafe(ObjectKey.CONTAINER_CONSTANT_WEIGHT) &amp;&amp; !effective) || (getChildCount() == 0))</span>
		{
<span class="nc" id="L5409">			return total;</span>
		}

<span class="nc bnc" id="L5412" title="All 2 branches missed.">		for (int e = 0; e &lt; getContainedEquipmentCount(); ++e)</span>
		{

<span class="nc" id="L5415">			final Equipment anEquip = getContainedEquipment(e);</span>

<span class="nc bnc" id="L5417" title="All 2 branches missed.">			if (anEquip.getContainedEquipmentCount() &gt; 0)</span>
			{
<span class="nc" id="L5419">				total = (float) (total + anEquip.getWeightAsDouble(aPC) + anEquip.getContainedWeight(aPC));</span>
			}
			else
			{
<span class="nc" id="L5423">				total = (float) (total + (anEquip.getWeightAsDouble(aPC) * anEquip.getQty()));</span>
			}
		}

<span class="nc" id="L5427">		Integer crw = get(IntegerKey.CONTAINER_REDUCE_WEIGHT);</span>
<span class="nc bnc" id="L5428" title="All 4 branches missed.">		if (crw != null &amp;&amp; crw != 0)</span>
		{
<span class="nc" id="L5430">			total *= (crw.floatValue() / 100);</span>
		}

<span class="nc" id="L5433">		return total;</span>
	}

	/**
	 * @param aType
	 *            Type and sequencer (e.g. Liquid3)
	 * @param aSubTag
	 *            SubTag (NAME or SPROP)
	 * @return a String containing the specified subtag
	 */
	public String getContainerByType(String aType, final String aSubTag)
	{

<span class="nc" id="L5446">		final List&lt;Equipment&gt; contents = new ArrayList&lt;&gt;(getContents());</span>

		// Separate the Type from the sequencer (Liquid from 3)
<span class="nc" id="L5449">		int numCharToRemove = 0;</span>

<span class="nc bnc" id="L5451" title="All 2 branches missed.">		for (int i = aType.length() - 1; i &gt; 0; i--)</span>
		{

<span class="nc bnc" id="L5454" title="All 4 branches missed.">			if ((aType.charAt(i) &gt;= '0') &amp;&amp; (aType.charAt(i) &lt;= '9'))</span>
			{
<span class="nc" id="L5456">				numCharToRemove++;</span>
			}
			else
			{
				break;
			}
		}

		int typeIndex;
		String type;

<span class="nc bnc" id="L5467" title="All 2 branches missed.">		if (numCharToRemove &gt; 0)</span>
		{
<span class="nc" id="L5469">			int l = aType.length() - numCharToRemove;</span>

<span class="nc" id="L5471">			type = aType.substring(0, l);</span>
<span class="nc" id="L5472">			typeIndex = Integer.parseInt(aType.substring(l));</span>

<span class="nc" id="L5474">		}</span>
		else
		{

<span class="nc" id="L5478">			type = aType;</span>
<span class="nc" id="L5479">			typeIndex = -1;</span>
		}

<span class="nc bnc" id="L5482" title="All 2 branches missed.">		contents.stream().filter(eq -&gt; !eq.isType(type)).forEach(contents::remove);</span>

<span class="nc bnc" id="L5484" title="All 2 branches missed.">		if (typeIndex &lt; contents.size())</span>
		{
<span class="nc bnc" id="L5486" title="All 2 branches missed.">			if (&quot;SPROP&quot;.equals(aSubTag))</span>
			{
<span class="nc" id="L5488">				return contents.get(typeIndex).getRawSpecialProperties();</span>
			}
<span class="nc" id="L5490">			return contents.get(typeIndex).getName();</span>
		}
<span class="nc" id="L5492">		return &quot; &quot;;</span>
	}

	/**
	 * Gets the containerContentsString attribute of the Equipment object
	 * 
	 * @return The containerContentsString value
	 */
	public String getContainerContentsString()
	{
<span class="nc bnc" id="L5502" title="All 2 branches missed.">		if (containerContentsString == null)</span>
		{
<span class="nc" id="L5504">			updateContainerContentsString(null);</span>
		}
<span class="nc" id="L5506">		return containerContentsString;</span>
	}

	/**
	 * Convenience method. &lt;p&gt; &lt;br&gt;
	 * author: Thomas Behr 27-03-02
	 * 
	 * @return a list with all Equipment objects this container holds; if this
	 *         instance is no container, the list will be empty.
	 */
	public Collection&lt;Equipment&gt; getContents()
	{

<span class="nc" id="L5519">		return IntStream.range(0, getContainedEquipmentCount())</span>
<span class="nc" id="L5520">			.mapToObj(this::getContainedEquipment).collect(Collectors.toList());</span>
	}

	// ---------------------------
	// Container Definition methods
	// ---------------------------

	/**
	 * Gets the containerCapacityString attribute of the Equipment object
	 * 
	 * @return The containerCapacityString value
	 */
	public String getContainerCapacityString()
	{
<span class="nc bnc" id="L5534" title="All 2 branches missed.">		if (containerCapacityString == null)</span>
		{
<span class="nc" id="L5536">			updateContainerCapacityString();</span>
		}
<span class="nc" id="L5538">		return containerCapacityString;</span>
	}

<span class="fc" id="L5541">	private List&lt;EquipmentHead&gt; heads = new ArrayList&lt;&gt;();</span>

	public EquipmentHead getEquipmentHead(int index)
	{
<span class="pc bpc" id="L5545" title="1 of 2 branches missed.">		if (index &lt;= 0)</span>
		{
<span class="nc" id="L5547">			throw new IndexOutOfBoundsException(Integer.toString(index));</span>
		}

<span class="fc" id="L5550">		int headsIndex = index - 1;</span>
<span class="fc" id="L5551">		int currentSize = heads.size();</span>

		EquipmentHead head;
<span class="fc bfc" id="L5554" title="All 2 branches covered.">		if (headsIndex &gt;= currentSize)</span>
		{
<span class="fc bfc" id="L5556" title="All 2 branches covered.">			for (int i = 0; i &lt; headsIndex - currentSize; i++)</span>
			{
<span class="fc" id="L5558">				heads.add(null);</span>
			}
<span class="fc" id="L5560">			head = new EquipmentHead(this, index);</span>
<span class="fc" id="L5561">			heads.add(head);</span>
		}
		else
		{
<span class="fc" id="L5565">			head = heads.get(headsIndex);</span>
<span class="fc bfc" id="L5566" title="All 2 branches covered.">			if (head == null)</span>
			{
<span class="fc" id="L5568">				head = new EquipmentHead(this, index);</span>
<span class="fc" id="L5569">				heads.set(headsIndex, head);</span>
			}
		}
<span class="fc" id="L5572">		return head;</span>
	}

	public EquipmentHead getEquipmentHeadReference(int index)
	{
<span class="pc bpc" id="L5577" title="1 of 2 branches missed.">		if (index &lt;= 0)</span>
		{
<span class="nc" id="L5579">			throw new IndexOutOfBoundsException(Integer.toString(index));</span>
		}
<span class="fc bfc" id="L5581" title="All 2 branches covered.">		else if (index &lt;= heads.size())</span>
		{
<span class="fc" id="L5583">			return heads.get(index - 1);</span>
		}
<span class="fc" id="L5585">		return null;</span>
	}

	public List&lt;EquipmentHead&gt; getEquipmentHeads()
	{
<span class="nc" id="L5590">		return new ArrayList&lt;&gt;(heads);</span>
	}

	/**
	 * Reduce/increase damage for modified size as per DMG p.162
	 *
	 * @param aDamage The base damage
	 * @param newSizeInt The size to adjust for
	 * @return     The adjusted damage
	 */
	private String adjustDamage(final String aDamage, int newSizeInt)
	{
<span class="nc bnc" id="L5602" title="All 2 branches missed.">		if (aDamage == null)</span>
		{
<span class="nc" id="L5604">			return null;</span>
		}
<span class="nc bnc" id="L5606" title="All 4 branches missed.">		if (!&quot;special&quot;.equalsIgnoreCase(aDamage) &amp;&amp; !&quot;-&quot;.equals(aDamage))</span>
		{
<span class="nc" id="L5608">			return Globals.adjustDamage(aDamage, newSizeInt - sizeInt());</span>
		}

<span class="nc" id="L5611">		return aDamage;</span>
	}

	/**
	 * Gets the damageAdjustedForSize attribute of the Equipment object
	 *
	 * @param newSizeInt
	 *           The size to adjust for
	 * @param bPrimary
	 *           If true get the damage for the primary head, otherwise
	 *           get the damage for the secondary head
	 * @return     The damageAdjustedForSize value
	 */
	private String getDamageAdjustedForSize(int newSizeInt, final boolean bPrimary)
	{
<span class="nc bnc" id="L5626" title="All 2 branches missed.">		int headnum = bPrimary ? 1 : 2;</span>
<span class="nc" id="L5627">		EquipmentHead head = getEquipmentHeadReference(headnum);</span>
<span class="nc bnc" id="L5628" title="All 2 branches missed.">		if (head == null)</span>
		{
<span class="nc" id="L5630">			return null;</span>
		}
<span class="nc" id="L5632">		String dam = head.get(StringKey.DAMAGE);</span>
<span class="nc bnc" id="L5633" title="All 6 branches missed.">		if (!isWeapon() || (!bPrimary &amp;&amp; !isDouble()))</span>
		{
<span class="nc" id="L5635">			return dam;</span>
		}
<span class="nc bnc" id="L5637" title="All 2 branches missed.">		if (dam == null)</span>
		{
<span class="nc" id="L5639">			dam = getWeaponInfo(&quot;DAMAGE&quot;, bPrimary);</span>
		}
<span class="nc" id="L5641">		return adjustDamage(dam, newSizeInt);</span>
	}

	public String getWeaponInfo(final String infoType, final boolean bPrimary)
	{
<span class="nc" id="L5646">		final String it = infoType + &quot;|&quot;;</span>
<span class="nc" id="L5647">		final EquipmentModifier eqMod = getEqModifierKeyed(Constants.INTERNAL_EQMOD_WEAPON, bPrimary);</span>

<span class="nc bnc" id="L5649" title="All 2 branches missed.">		if (eqMod != null)</span>
		{
<span class="nc" id="L5651">			return getAssociationList(eqMod).stream().filter(aString -&gt; aString.startsWith(it)).findFirst()</span>
<span class="nc" id="L5652">				.map(aString -&gt; aString.substring(it.length())).orElse(&quot;&quot;);</span>
		}

<span class="nc" id="L5655">		return &quot;&quot;;</span>
	}

	public ShieldProf getShieldProf()
	{
<span class="nc bnc" id="L5660" title="All 2 branches missed.">		if (isShield())</span>
		{
<span class="nc" id="L5662">			CDOMSingleRef&lt;ShieldProf&gt; ref = get(ObjectKey.SHIELD_PROF);</span>
<span class="nc bnc" id="L5663" title="All 2 branches missed.">			if (ref == null)</span>
			{
<span class="nc" id="L5665">				ShieldProf sp = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L5666">					.silentlyGetConstructedCDOMObject(ShieldProf.class, getKeyName());</span>
<span class="nc bnc" id="L5667" title="All 2 branches missed.">				if (sp == null)</span>
				{
<span class="nc" id="L5669">					return Globals.getContext().getReferenceContext().constructCDOMObject(ShieldProf.class,</span>
<span class="nc" id="L5670">						getKeyName());</span>
				}
				else
				{
<span class="nc" id="L5674">					return sp;</span>
				}
			}
			else
			{
<span class="nc" id="L5679">				return ref.get();</span>
			}
		}
<span class="nc" id="L5682">		return null;</span>
	}

	public ArmorProf getArmorProf()
	{
<span class="nc bnc" id="L5687" title="All 2 branches missed.">		if (isArmor())</span>
		{
<span class="nc" id="L5689">			CDOMSingleRef&lt;ArmorProf&gt; ref = get(ObjectKey.ARMOR_PROF);</span>
<span class="nc bnc" id="L5690" title="All 2 branches missed.">			if (ref == null)</span>
			{
<span class="nc" id="L5692">				ArmorProf ap = Globals.getContext().getReferenceContext()</span>
<span class="nc" id="L5693">					.silentlyGetConstructedCDOMObject(ArmorProf.class, getKeyName());</span>
<span class="nc bnc" id="L5694" title="All 2 branches missed.">				if (ap == null)</span>
				{
<span class="nc" id="L5696">					return Globals.getContext().getReferenceContext().constructCDOMObject(ArmorProf.class,</span>
<span class="nc" id="L5697">						getKeyName());</span>
				}
				else
				{
<span class="nc" id="L5701">					return ap;</span>
				}
			}
			else
			{
<span class="nc" id="L5706">				return ref.get();</span>
			}
		}
<span class="nc" id="L5709">		return null;</span>
	}

	public void addAssociation(CDOMObject obj, String o)
	{
<span class="nc" id="L5714">		assocSupt.addAssoc(obj, AssociationListKey.CHOICES, new FixedStringList(o));</span>
<span class="nc" id="L5715">	}</span>

	public boolean containsAssociated(CDOMObject obj, String o)
	{
<span class="nc" id="L5719">		List&lt;FixedStringList&gt; list = assocSupt.getAssocList(obj, AssociationListKey.CHOICES);</span>
<span class="nc bnc" id="L5720" title="All 2 branches missed.">		if (list != null)</span>
		{
<span class="nc" id="L5722">			return list.stream()</span>
<span class="nc bnc" id="L5723" title="All 2 branches missed.">				.anyMatch(fsl -&gt; FixedStringList.CASE_INSENSITIVE_ORDER.compare(fsl, new FixedStringList(o)) == 0);</span>
		}
<span class="nc" id="L5725">		return false;</span>
	}

	private int getSelectCorrectedAssociationCount(CDOMObject obj)
	{
<span class="nc" id="L5730">		Formula f = obj.getSafe(FormulaKey.SELECT);</span>

		//TODO Null here is probably a problem for the PC :/
<span class="nc" id="L5733">		int select = f.resolve(this, true, null, &quot;&quot;).intValue();</span>
<span class="nc" id="L5734">		return assocSupt.getAssocCount(obj, AssociationListKey.CHOICES) / select;</span>
	}

	public List&lt;String&gt; getAssociationList(CDOMObject obj)
	{
<span class="nc" id="L5739">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L5740">		List&lt;FixedStringList&gt; assocList = assocSupt.getAssocList(obj, AssociationListKey.CHOICES);</span>
<span class="nc bnc" id="L5741" title="All 2 branches missed.">		if (assocList != null)</span>
		{
<span class="nc" id="L5743">			assocList.stream().map(ac -&gt; ac.get(0)).forEach(choiceStr -&gt; {</span>
<span class="nc bnc" id="L5744" title="All 2 branches missed.">				if (Constants.EMPTY_STRING.equals(choiceStr))</span>
				{
<span class="nc" id="L5746">					list.add(null);</span>
				}
				else
				{
<span class="nc" id="L5750">					list.add(choiceStr);</span>
				}
<span class="nc" id="L5752">			});</span>
		}
<span class="nc" id="L5754">		return list;</span>
	}

	public boolean hasAssociations(Object obj)
	{
<span class="nc" id="L5759">		return assocSupt.hasAssocs(obj, AssociationListKey.CHOICES);</span>
	}

	public List&lt;String&gt; removeAllAssociations(CDOMObject obj)
	{
<span class="nc" id="L5764">		List&lt;String&gt; list = getAssociationList(obj);</span>
<span class="nc" id="L5765">		assocSupt.removeAllAssocs(obj, AssociationListKey.CHOICES);</span>
<span class="nc" id="L5766">		return list;</span>
	}

	private void removeAssociation(CDOMObject obj, String o)
	{
<span class="nc" id="L5771">		assocSupt.removeAssoc(obj, AssociationListKey.CHOICES, new FixedStringList(o));</span>
<span class="nc" id="L5772">	}</span>

	public String getFirstAssociation(CDOMObject obj)
	{
<span class="nc" id="L5776">		return assocSupt.getAssocList(obj, AssociationListKey.CHOICES).get(0).get(0);</span>
	}

	/**
	 * Get the map of bonuses for this object
	 * @return bonusMap
	 */
	public Map&lt;String, String&gt; getBonusMap()
	{
<span class="nc bnc" id="L5785" title="All 2 branches missed.">		if (bonusMap == null)</span>
		{
<span class="nc" id="L5787">			bonusMap = new HashMap&lt;&gt;();</span>
		}

<span class="nc" id="L5790">		return bonusMap;</span>
	}

	/**
	 * Put the key/value pair into the bonus map
	 * 
	 * @param aKey The Key to store the bonus under
	 * @param aVal The value of the Bonus
	 */
	private void putBonusMap(final String aKey, final String aVal)
	{
<span class="nc" id="L5801">		getBonusMap().put(aKey, aVal);</span>
<span class="nc" id="L5802">	}</span>

	/**
	 * @param bonus  a Number (such as 2)
	 * @param aType  &quot;COMBAT.AC.Dodge&quot; or &quot;COMBAT.AC.Dodge.STACK&quot;
	 */
	public void setBonusStackFor(final double bonus, String aType)
	{
<span class="nc bnc" id="L5810" title="All 2 branches missed.">		String bType = (aType != null) ? aType.toUpperCase() : null;</span>

		// Default to non-stacking bonuses
<span class="nc" id="L5813">		int index = -1;</span>

		// e.g. &quot;COMBAT.AC.DODGE&quot;
<span class="nc bnc" id="L5816" title="All 2 branches missed.">		if (aType != null)</span>
		{
<span class="nc" id="L5818">			final StringTokenizer aTok = new StringTokenizer(bType, &quot;.&quot;);</span>
<span class="nc bnc" id="L5819" title="All 2 branches missed.">			if (aTok.countTokens() &gt;= 2)</span>
			{

				// we need to get the 3rd token to see
				// if it should .STACK or .REPLACE
<span class="nc" id="L5824">				aTok.nextToken(); // Discard token</span>
<span class="nc" id="L5825">				String aString = aTok.nextToken();</span>
<span class="nc" id="L5826">				String nextTok = null;</span>

				// if the 3rd token is &quot;BASE&quot; we have something like
				// CHECKS.BASE.Fortitude
				// Type: .DODGE
<span class="nc bnc" id="L5831" title="All 2 branches missed.">				if (&quot;BASE&quot;.equals(aString))</span>
				{
<span class="nc bnc" id="L5833" title="All 2 branches missed.">					if (aTok.hasMoreTokens())</span>
					{
						// discard next token (Fortitude)
<span class="nc" id="L5836">						aTok.nextToken();</span>
					}

				}
<span class="nc bnc" id="L5840" title="All 2 branches missed.">				if (aTok.hasMoreTokens())</span>
				{
					// check for a TYPE
<span class="nc" id="L5843">					nextTok = aTok.nextToken();</span>
				}

<span class="nc bnc" id="L5846" title="All 2 branches missed.">				if (nextTok != null)</span>
				{
<span class="nc" id="L5848">					index = SettingsHandler.getGameAsProperty().get().getUnmodifiableBonusStackList().indexOf(nextTok); // e.g.</span>
					// Dodge
				}

				// un-named (or un-TYPE'd) bonus should stack
<span class="nc bnc" id="L5853" title="All 4 branches missed.">				if ((nextTok == null) || &quot;NULL&quot;.equals(nextTok))</span>
				{
<span class="nc" id="L5855">					index = 1;</span>
				}
			}
		}
		// .STACK means stack
		// .REPLACE stacks with other .REPLACE bonuses
<span class="nc bnc" id="L5861" title="All 6 branches missed.">		if ((bType != null) &amp;&amp; (bType.endsWith(&quot;.STACK&quot;) || bType.endsWith(&quot;.REPLACE&quot;)))</span>
		{
<span class="nc" id="L5863">			index = 1;</span>
		}

		// If it's a negative bonus, it always needs to be added
<span class="nc bnc" id="L5867" title="All 2 branches missed.">		if (bonus &lt; 0)</span>
		{
<span class="nc" id="L5869">			index = 1;</span>
		}

<span class="nc bnc" id="L5872" title="All 2 branches missed.">		if (index == -1) // a non-stacking bonus</span>
		{
<span class="nc" id="L5874">			final String aVal = getBonusMap().get(bType);</span>

<span class="nc bnc" id="L5876" title="All 2 branches missed.">			if (aVal == null)</span>
			{
<span class="nc" id="L5878">				putBonusMap(bType, String.valueOf(bonus));</span>
			}
			else
			{
<span class="nc" id="L5882">				putBonusMap(bType, String.valueOf(Math.max(bonus, Float.parseFloat(aVal))));</span>
			}
<span class="nc" id="L5884">		}</span>
		else
		// a stacking bonus
		{
<span class="nc bnc" id="L5888" title="All 2 branches missed.">			String type = bType == null ? &quot;&quot;</span>
<span class="nc bnc" id="L5889" title="All 2 branches missed.">				: bType.endsWith(&quot;.REPLACE.STACK&quot;) ? bType.substring(0, bType.length() - 6) : bType;</span>

<span class="nc" id="L5891">			final String aVal = getBonusMap().get(type);</span>

<span class="nc bnc" id="L5893" title="All 2 branches missed.">			if (aVal == null)</span>
			{
<span class="nc" id="L5895">				putBonusMap(type, String.valueOf(bonus));</span>
			}
			else
			{
<span class="nc" id="L5899">				putBonusMap(type, String.valueOf(bonus + Float.parseFloat(aVal)));</span>
			}
		}
<span class="nc" id="L5902">	}</span>

	private void dumpTypeCache()
	{
<span class="fc" id="L5906">		usePrimaryCache = false;</span>
<span class="fc" id="L5907">		useSecondaryCache = false;</span>
<span class="fc" id="L5908">	}</span>

	public void addType(Type newType)
	{
<span class="fc" id="L5912">		addToListFor(ListKey.TYPE, newType);</span>
<span class="fc" id="L5913">		dumpTypeCache();</span>
<span class="fc" id="L5914">	}</span>

	public void removeType(Type t)
	{
<span class="nc" id="L5918">		boolean moreToRemove = true;</span>
<span class="nc bnc" id="L5919" title="All 2 branches missed.">		while (moreToRemove)</span>
		{
<span class="nc" id="L5921">			moreToRemove = removeFromListFor(ListKey.TYPE, t);</span>
		}
<span class="nc" id="L5923">		dumpTypeCache();</span>
<span class="nc" id="L5924">	}</span>

	/**
	 * Add a Weapon to an Equipment Location.
	 * @param num how many pieces to add
	 * @param eLoc the Location to add the weapon to
	 * @param aPC the PC to quip the weapon on
	 */
	public void addWeaponToLocation(Float num, EquipmentLocation eLoc, PlayerCharacter aPC)
	{
<span class="nc bnc" id="L5934" title="All 2 branches missed.">		float numEquipped = (eLoc == EquipmentLocation.EQUIPPED_TWO_HANDS) ? 2.0f : num;</span>
<span class="nc" id="L5935">		setNumberEquipped((int) numEquipped);</span>

<span class="nc" id="L5937">		setLocation(eLoc);</span>

<span class="nc bnc" id="L5939" title="All 2 branches missed.">		if (eLoc != EquipmentLocation.EQUIPPED_NEITHER)</span>
		{
<span class="nc" id="L5941">			setQty(num);</span>
<span class="nc" id="L5942">			setNumberCarried(num);</span>
<span class="nc" id="L5943">			setIsEquipped(true, aPC);</span>
		}
<span class="nc" id="L5945">	}</span>

	/**
	 * Add a piece of general equipment to an Equipment Location.
	 * @param num how many pieces to add
	 * @param eLoc the Location to add the equipment to
	 * @param equip whether to equip the item
	 * @param aPC the PC to quip the weapon on
	 */
	public void addEquipmentToLocation(Float num, EquipmentLocation eLoc, boolean equip, PlayerCharacter aPC)
	{
<span class="nc" id="L5956">		setLocation(eLoc);</span>
<span class="nc" id="L5957">		setQty(num);</span>
<span class="nc" id="L5958">		setIsEquipped(equip, aPC);</span>

<span class="nc bnc" id="L5960" title="All 2 branches missed.">		Float numCarried = (eLoc == EquipmentLocation.NOT_CARRIED) ? 0.0f : num;</span>

<span class="nc" id="L5962">		setNumberCarried(numCarried);</span>
<span class="nc" id="L5963">	}</span>

	/**
	 * The Class {@code EquipmentHeadCostSummary} carries the multi
	 * valued response back when calculating the cost of a head.  
	 */
<span class="nc" id="L5969">	private static class EquipmentHeadCostSummary</span>
	{
<span class="nc" id="L5971">		private BigDecimal postSizeCost = BigDecimal.ZERO;</span>
<span class="nc" id="L5972">		private BigDecimal nonDoubleCost = BigDecimal.ZERO;</span>
<span class="nc" id="L5973">		private int headPlus = 0;</span>
	}

	/**
	 * Get the list of temporary bonuses for this list
	 * @return the list of temporary bonuses for this list
	 */
	private List&lt;BonusObj&gt; getTempBonusList()
	{
<span class="nc" id="L5982">		return getSafeListFor(ListKey.TEMP_BONUS);</span>
	}

	/**
	 * Add to the list of temporary bonuses
	 * @param aBonus
	 */
	public void addTempBonus(final BonusObj aBonus)
	{
<span class="nc" id="L5991">		addToListFor(ListKey.TEMP_BONUS, aBonus);</span>
<span class="nc" id="L5992">	}</span>

	/**
	 * Remove from the list of temporary bonuses
	 * @param aBonus
	 */
	public void removeTempBonus(final BonusObj aBonus)
	{
<span class="nc" id="L6000">		removeFromListFor(ListKey.TEMP_BONUS, aBonus);</span>
<span class="nc" id="L6001">	}</span>

	/**
	 * Reset (Clear) the temporary bonus list
	 */
	public void resetTempBonusList()
	{
<span class="nc" id="L6008">		removeListFor(ListKey.TEMP_BONUS);</span>
<span class="nc" id="L6009">	}</span>

	public boolean altersAC(PlayerCharacter pc)
	{
<span class="nc" id="L6013">		String alterAC = pc.getControl(CControl.ALTERSAC);</span>
<span class="nc bnc" id="L6014" title="All 2 branches missed.">		if (alterAC != null)</span>
		{
<span class="nc" id="L6016">			Object o = pc.getLocal(this, alterAC);</span>
<span class="nc" id="L6017">			return (Boolean) o;</span>
		}

<span class="nc" id="L6020">		return getRawBonusList(pc).stream().anyMatch(bonus -&gt; bonus.getBonusInfo().equalsIgnoreCase(&quot;AC&quot;));</span>
	}

	@Override
	public String[] getTypes()
	{
<span class="nc" id="L6026">		String type = getType();</span>
<span class="nc" id="L6027">		return type.split(&quot;\\.&quot;);</span>
	}

	@Override
	public List&lt;String&gt; getTypesForDisplay()
	{
<span class="nc" id="L6033">		List&lt;Type&gt; trueTypeList = getTrueTypeList(true);</span>
<span class="nc" id="L6034">		List&lt;String&gt; result = new ArrayList&lt;&gt;(trueTypeList.size());</span>
<span class="nc" id="L6035">		trueTypeList.stream().map(Type::toString).forEach(result::add);</span>
<span class="nc" id="L6036">		return result;</span>
	}

	/**
	 * Retrieve the icon for this equipment item. This may be directly set for 
	 * the item, or it may be for one of the item's types. The types are 
	 * checked from right to left.
	 *  
	 * @return The icon for this equipment item, or null if none
	 */
	@Override
	public File getIcon()
	{
		// Check for icon on this specific item
<span class="nc" id="L6050">		URI uri = this.get(ObjectKey.ICON_URI);</span>
<span class="nc bnc" id="L6051" title="All 2 branches missed.">		if (uri != null)</span>
		{
<span class="nc" id="L6053">			return new File(uri);</span>
		}

		// If not defined, then try the types 
<span class="nc" id="L6057">		final GameMode gameMode = SettingsHandler.getGameAsProperty().get();</span>
<span class="nc" id="L6058">		List&lt;String&gt; typeList = typeList(true);</span>
<span class="nc" id="L6059">		String iconPath = null;</span>
<span class="nc" id="L6060">		int iconPriority = 0;</span>
<span class="nc bnc" id="L6061" title="All 2 branches missed.">		for (String type : typeList)</span>
		{
<span class="nc" id="L6063">			String path = gameMode.getEquipTypeIcon(type);</span>
<span class="nc bnc" id="L6064" title="All 2 branches missed.">			if (path != null)</span>
			{
<span class="nc" id="L6066">				int priority = gameMode.getEquipTypeIconPriority(type);</span>
				// Later types will win priority ties
<span class="nc bnc" id="L6068" title="All 4 branches missed.">				if (iconPath == null || priority &gt;= iconPriority)</span>
				{
<span class="nc" id="L6070">					iconPath = path;</span>
<span class="nc" id="L6071">					iconPriority = priority;</span>
				}
			}
<span class="nc" id="L6074">		}</span>
<span class="nc bnc" id="L6075" title="All 2 branches missed.">		if (iconPath != null)</span>
		{
<span class="nc" id="L6077">			return new File(iconPath);</span>
		}

		// A default fallback
<span class="nc" id="L6081">		String path = gameMode.getEquipTypeIcon(Constants.DEFAULT);</span>
<span class="nc bnc" id="L6082" title="All 2 branches missed.">		if (path != null)</span>
		{
<span class="nc" id="L6084">			return new File(path);</span>
		}

		// No icon can be found
<span class="nc" id="L6088">		return null;</span>
	}

	@Override
	public Optional&lt;String&gt; getLocalScopeName()
	{
<span class="nc" id="L6094">		return Optional.of(&quot;PC.EQUIPMENT&quot;);</span>
	}

	public Object getLocalVariable(CharID id, String varName)
	{
<span class="nc" id="L6099">		ResultFacet resultFacet = FacetLibrary.getFacet(ResultFacet.class);</span>
<span class="nc" id="L6100">		return resultFacet.getLocalVariable(id, this, varName);</span>
	}

	@Override
	public CDOMObject getLocalChild(String childType, String childName)
	{
<span class="nc bnc" id="L6106" title="All 2 branches missed.">		if (&quot;EQUIPMENT.PART&quot;.equals(childType))</span>
		{
<span class="nc" id="L6108">			return getEquipmentHead(Integer.parseInt(childName));</span>
		}
<span class="nc" id="L6110">		return null;</span>
	}

	@Override
	public List&lt;String&gt; getChildTypes()
	{
<span class="nc" id="L6116">		return Collections.singletonList(&quot;EQUIPMENT.PART&quot;);</span>
	}

	@Override
	public List&lt;PCGenScoped&gt; getChildren(String childType)
	{
<span class="nc bnc" id="L6122" title="All 2 branches missed.">		if (&quot;EQUIPMENT.PART&quot;.equals(childType))</span>
		{
<span class="nc" id="L6124">			return new ArrayList&lt;&gt;(heads);</span>
		}
<span class="nc" id="L6126">		return null;</span>
	}

	public boolean isType(Type type, boolean bPrimary)
	{
<span class="nc" id="L6131">		return isType(type.toString(), bPrimary);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>