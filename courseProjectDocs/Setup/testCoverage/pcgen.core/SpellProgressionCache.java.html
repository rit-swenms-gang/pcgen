<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpellProgressionCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">SpellProgressionCache.java</span></div><h1>SpellProgressionCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2006 (C) Tom Parker &lt;thpr@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Created: November 8, 2006
 *
 */
package pcgen.core;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.TreeMap;

import pcgen.base.formula.Formula;

/**
 * SpellProgressionInfo contains information about Spell Progression in support
 * of a PCClass.
 * 
 */
<span class="nc" id="L35">public class SpellProgressionCache implements Cloneable</span>
{

	/*
	 * FUTURETYPESAFETY Currently can't do better than String in knownMap,
	 * castMap and specialtyKnownMap, because each one of these can be a
	 * formula, or some special gunk for Psionicists (can we clean up the +d??)
	 */

	/**
	 * This is a Progression of KNOWN spells.
	 */
<span class="nc" id="L47">	private Progression knownProgression = null;</span>

	/**
	 * This is a Progression KNOWN spells added by a specialty.
	 */
<span class="nc" id="L52">	private Progression specialtyKnownProgression = null;</span>

	/**
	 * This is a Progression of CAST spells.
	 */
<span class="nc" id="L57">	private Progression castProgression = null;</span>

	/**
	 * Sets the Known spells for the given class level for this
	 * SpellProgression. The given character level must be greater than or equal
	 * to one.
	 * 
	 * Note that this is a SET (not an ADD) and will therefore OVERWRITE a KNOWN
	 * spell progression for the given class level if one is already present
	 * within this SpellProgression.
	 * 
	 * @param iLevel
	 *            The class level for which the given known spell progression
	 *            applies.
	 * @param aList
	 *            The known spell progression for the given class level.
	 */
	public void setKnown(int iLevel, List&lt;Formula&gt; aList)
	{
<span class="nc bnc" id="L76" title="All 2 branches missed.">		if (knownProgression == null)</span>
		{
<span class="nc" id="L78">			knownProgression = new Progression();</span>
		}
<span class="nc" id="L80">		knownProgression.setProgression(iLevel, aList);</span>
<span class="nc" id="L81">	}</span>

	/**
	 * Returns true if this SpellProgression contains a KNOWN spell progression.
	 * (this is not required, e.g. OGL Wizards do not have a KNOWN spell
	 * progression, rather they are limited by what spells are in their
	 * spellbook(s))
	 * 
	 * @return True if this SpellProgression contains a known spell progression;
	 *         false otherwise.
	 */
	public boolean hasKnownProgression()
	{
<span class="nc bnc" id="L94" title="All 4 branches missed.">		return knownProgression != null &amp;&amp; knownProgression.hasProgression();</span>
	}

	/**
	 * Returns the known spell progression for the given class level. If this
	 * SpellProgression does not contain a KNOWN spell progression or if the
	 * given class level is not high enough to have known spells, this method
	 * returns null.
	 * 
	 * This method is value-semantic. Ownership of the returned List is
	 * transferred to the calling object (The returned list can be modified
	 * without impacting the internal contents of this SpellProgression)
	 * 
	 * @param aLevel
	 *            The class level for which the known spell progression should
	 *            be returned.
	 * @return The known spell progression for the given class level, or null if
	 *         there is no known spell progression for the given class level.
	 */
	public List&lt;Formula&gt; getKnownForLevel(int aLevel)
	{
<span class="nc bnc" id="L115" title="All 2 branches missed.">		return knownProgression == null ? null : knownProgression.getProgressionForLevel(aLevel);</span>
	}

	/**
	 * Returns the highest possible known spell level in this SpellProgression.
	 * 
	 * Note that this is a theoretical highest level, and based on the abilities
	 * of a PlayerCharacter, the highest known spell level may not be available
	 * to that PlayerCharacter.
	 * 
	 * There are at least two known situations where the theoretical known spell
	 * level is higher than what a specific PlayerCharacter could actually know:
	 * (1) When a Stat limits the level of spells that a given PlayerCharacter
	 * can learn (2) When a Class grants 0 known spells, but some
	 * PlayerCharacters could have a Stat that provides bonus spells [this
	 * method WILL return a spell level where a Class grants 0 spells, since
	 * this is a theoretical limit test.]
	 * 
	 * @return The highest possible known spell level.
	 */
	public int getHighestKnownSpellLevel()
	{
<span class="nc bnc" id="L137" title="All 2 branches missed.">		return knownProgression == null ? 0 : knownProgression.getHighestSpellLevel();</span>
	}

	/**
	 * Sets the KNOWN SPECIALTY spells for the given class level for this
	 * SpellProgression. The given character level must be greater than or equal
	 * to one.
	 * 
	 * Note that this is a SET (not an ADD) and will therefore OVERWRITE a KNOWN
	 * SPECIALTY spell progression for the given class level if one is already
	 * present within this SpellProgression.
	 * 
	 * @param aLevel
	 *            The class level for which the given known specialty spell
	 *            progression applies.
	 * @param aList
	 *            The known specialty spell progression for the given class
	 *            level.
	 */
	public void setSpecialtyKnown(int aLevel, List&lt;Formula&gt; aList)
	{
<span class="nc bnc" id="L158" title="All 2 branches missed.">		if (specialtyKnownProgression == null)</span>
		{
<span class="nc" id="L160">			specialtyKnownProgression = new Progression();</span>
		}
<span class="nc" id="L162">		specialtyKnownProgression.setProgression(aLevel, aList);</span>
<span class="nc" id="L163">	}</span>

	/**
	 * Returns true if this SpellProgression contains KNOWN SPECIALTY spell
	 * progressions. (this is not required, e.g. most 3.0SRD classes do not have
	 * a KNOWN SPECIALTY list)
	 * 
	 * @return True if this SpellProgression contains a known specialty spell
	 *         progression; false otherwise.
	 */
	public boolean hasSpecialtyKnownProgression()
	{
<span class="nc bnc" id="L175" title="All 4 branches missed.">		return specialtyKnownProgression != null &amp;&amp; specialtyKnownProgression.hasProgression();</span>
	}

	/**
	 * Returns the known specialty spell progression for the given class level.
	 * If this SpellProgression does not contain a KNOWN SPECIALTY spell
	 * progression or if the given class level is not high enough to have
	 * entered the known specialty spell progression, this method returns null.
	 * 
	 * This method is value-semantic. Ownership of the returned List is
	 * transferred to the calling object (The returned list can be modified
	 * without impacting the internal contents of this SpellProgression)
	 * 
	 * @param aLevel
	 *            The class level for which the known specialty spell
	 *            progression should be returned.
	 * @return The known specialty spell progression for the given class level,
	 *         or null if there is no known specialty spell progression for the
	 *         given class level.
	 */
	public List&lt;Formula&gt; getSpecialtyKnownForLevel(int aLevel)
	{
<span class="nc bnc" id="L197" title="All 2 branches missed.">		return specialtyKnownProgression == null ? null : specialtyKnownProgression.getProgressionForLevel(aLevel);</span>
	}

	/**
	 * Sets the CAST spells for the given class level for this SpellProgression.
	 * The given character level must be greater than or equal to one.
	 * 
	 * Note that this is a SET (not an ADD) and will therefore OVERWRITE a CAST
	 * spell progression for the given class level if one is already present
	 * within this SpellProgression.
	 * 
	 * @param aLevel
	 *            The class level for which the given CAST spell progression
	 *            applies.
	 * @param aList
	 *            The CAST spell progression for the given class level.
	 * @return The previously set CAST spell progression for the given class
	 *         level; null if no CAST spell progression was previously set.
	 */
	public List&lt;Formula&gt; setCast(int aLevel, List&lt;Formula&gt; aList)
	{
<span class="nc bnc" id="L218" title="All 2 branches missed.">		if (castProgression == null)</span>
		{
<span class="nc" id="L220">			castProgression = new Progression();</span>
		}
<span class="nc" id="L222">		return castProgression.setProgression(aLevel, aList);</span>
	}

	/**
	 * Returns true if this SpellProgression contains CAST spell progressions.
	 * (this is not required, but would be a bit strange to be empty)
	 * 
	 * @return True if this SpellProgression contains a CAST spell progression;
	 *         false otherwise.
	 */
	public boolean hasCastProgression()
	{
<span class="nc bnc" id="L234" title="All 4 branches missed.">		return castProgression != null &amp;&amp; castProgression.hasProgression();</span>
	}

	/**
	 * Returns the CAST spell progression for the given class level. If this
	 * SpellProgression does not contain a CAST spell progression or if the
	 * given class level is not high enough to have CAST spells, this method
	 * returns null.
	 * 
	 * This method is value-semantic. Ownership of the returned List is
	 * transferred to the calling object (The returned list can be modified
	 * without impacting the internal contents of this SpellProgression)
	 * 
	 * @param aLevel
	 *            The class level for which the CAST spell progression should be
	 *            returned.
	 * @return The CAST spell progression for the given class level, or null if
	 *         there is no CAST spell progression for the given class level.
	 */
	public List&lt;Formula&gt; getCastForLevel(int aLevel)
	{
<span class="nc bnc" id="L255" title="All 2 branches missed.">		return castProgression == null ? null : castProgression.getProgressionForLevel(aLevel);</span>
	}

	/**
	 * Returns the highest possible CAST spell level in this SpellProgression.
	 * 
	 * Note that this is a theoretical highest level, and based on the abilities
	 * of a PlayerCharacter, the highest CAST spell level may not be available
	 * to that PlayerCharacter.
	 * 
	 * There are at least two known situations where the theoretical CAST spell
	 * level is higher than what a specific PlayerCharacter could actually know:
	 * (1) When a Stat limits the level of spells that a given PlayerCharacter
	 * can learn (2) When a Class grants 0 CAST spells, but some
	 * PlayerCharacters could have a Stat that provides bonus spells [this
	 * method WILL return a spell level where a Class grants 0 spells, since
	 * this is a theoretical limit test.]
	 * 
	 * @return The highest possible CAST spell level.
	 */
	public int getHighestCastSpellLevel()
	{
<span class="nc bnc" id="L277" title="All 2 branches missed.">		return castProgression == null ? 0 : castProgression.getHighestSpellLevel();</span>
	}

	/**
	 * Returns the minimum class level required to acquire a spell of the given
	 * spell level (and potential application of bonuses).
	 * 
	 * There are two situations that can also be distinguished:
	 * 
	 * If allowBonus is true, then this will return a class level where the CAST
	 * or KNOWN spell count is equal to zero (since it assumes that bonuses
	 * could provide that spell level). This DOES NOT return a class level where
	 * a spell count is &quot;-&quot; (or spells are not available at all).
	 * 
	 * If allowBonus is false, this will return a class level where the
	 * CAST or KNOWN spell count is greater than zero (since no bonuses would be
	 * applied to make the spell count a non-zero value)
	 * 
	 * *WARNING* This method is KNOWN to be broken if this SpellProgressionInfo
	 * contains a spell formula. Analysis must be done in context to the formula
	 * in that case.
	 * 
	 * @param spellLevel
	 *            The spell level for which the minimum required class level
	 *            will be returned
	 * @param allowBonus
	 *            true if the class level is allowed to have a &quot;0&quot; CAST or KNOWN
	 *            spell count.
	 * @return The minimum class level required to acquire a spell of the given
	 *         spell level (and potential application of bonuses)
	 */
	public int getMinLevelForSpellLevel(int spellLevel, boolean allowBonus)
	{
<span class="nc bnc" id="L310" title="All 2 branches missed.">		if (castProgression != null)</span>
		{
<span class="nc" id="L312">			int lvl = castProgression.getMinLevelForSpellLevel(spellLevel, allowBonus);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (lvl != -1)</span>
			{
<span class="nc" id="L315">				return lvl;</span>
			}
		}
		/*
		 * CONSIDER Should the castMap really dominate the knownMap like this??? -
		 * I know that it probably returns the intended result, but it needs to
		 * be explained better in the comments. - thpr 11/9/06
		 */
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (knownProgression != null)</span>
		{
<span class="nc" id="L325">			int lvl = knownProgression.getMinLevelForSpellLevel(spellLevel, allowBonus);</span>
<span class="nc" id="L326">            return lvl;</span>
		}

<span class="nc" id="L329">		return -1;</span>
	}

	/**
	 * Returns the theoretical maximum spell level for the given class level.
	 * 
	 * Note that this is a theoretical highest level, and based on the abilities
	 * of a PlayerCharacter, the highest spell level may not be available to
	 * that PlayerCharacter.
	 * 
	 * This theoretical test WILL return a spell level where the class grants 0
	 * known or cast spells, as bonuses acquired from Stats can provide use of
	 * that spell level.
	 * 
	 * @param classLevel
	 *            The class level for which the theoretical maximum spell level
	 *            should be returned.
	 * @return The theoretical maximum spell level for the given class level; -1
	 *         if this SpellProgressionInfo does not contain any KNOWN or CAST
	 *         spell progressions for the given class level.
	 */
	public int getMaxSpellLevelForClassLevel(int classLevel)
	{
		/*
		 * Delegation to get*ForLevel is required because it is possible that
		 * the given class level itself does not have a CAST or KNOWN
		 * progression, but that a lower level does. Those methods account for
		 * that situation.
		 */
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (castProgression != null)</span>
		{
<span class="nc" id="L360">			List&lt;Formula&gt; knownList = castProgression.getProgressionForLevel(classLevel);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">			if (knownList != null)</span>
			{
<span class="nc" id="L363">				return knownList.size() - 1;</span>
			}
		}
<span class="nc bnc" id="L366" title="All 2 branches missed.">		if (knownProgression != null)</span>
		{
<span class="nc" id="L368">			List&lt;Formula&gt; knownList = knownProgression.getProgressionForLevel(classLevel);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">			if (knownList != null)</span>
			{
<span class="nc" id="L371">				return knownList.size() - 1;</span>
			}
		}
<span class="nc" id="L374">		return -1;</span>
	}

	/**
	 * Clones this SpellProgressionInfo object. A semi-deep (or semi-shallow,
	 * depending on one's point of view) clone is performed, under the
	 * assumption that the cloned object should be allowed to have any of the
	 * SpellProgressionInfo.set* method called without allowing either the
	 * original or the cloned SpellProgressionInfo object to accidentally modify
	 * the other.
	 * 
	 * There is the assumption, however, that the Lists contained within the
	 * SpellProgressionInfo object are never modified, and violation of that
	 * semantic rule either within SpellProgressionInfo or by other objects
	 * which call the reference-semantic methods of SpellProgressionInfo can
	 * render this clone insufficient.
	 * 
	 * @return A semi-shallow Clone of this SpellProgressionInfo object.
	 * @throws CloneNotSupportedException
	 */
	@Override
	public SpellProgressionCache clone() throws CloneNotSupportedException
	{
<span class="nc" id="L397">		SpellProgressionCache spi = (SpellProgressionCache) super.clone();</span>
		/*
		 * Each of knownMap, specialtyKnownMap, and castMap need one level deep
		 * clones. Since the Lists that are stored are never individually
		 * modified in SpellProgressionInfo (they are always overwritten by a
		 * new set*) there is no need to do a full depth clone. However, the one
		 * level deep clone is required in case there is a PCClass.COPY or
		 * something that then mods a KNOWN or CAST.
		 */
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if (knownProgression != null)</span>
		{
<span class="nc" id="L408">			spi.knownProgression = knownProgression.clone();</span>
		}
<span class="nc bnc" id="L410" title="All 2 branches missed.">		if (specialtyKnownProgression != null)</span>
		{
<span class="nc" id="L412">			spi.specialtyKnownProgression = specialtyKnownProgression.clone();</span>
		}
<span class="nc bnc" id="L414" title="All 2 branches missed.">		if (castProgression != null)</span>
		{
<span class="nc" id="L416">			spi.castProgression = castProgression.clone();</span>
		}
<span class="nc" id="L418">		return spi;</span>
	}

	/*
	 * CONSIDER Do I want an &quot;isValid&quot; method to check that spell type is
	 * defined, et al?? - ensure consistency? - thpr 11/9/06
	 */

	/**
	 * Stores an individual Progression within this SpellProgressionInfo. Broken
	 * out as a separate class in order to maintain consistent behavior and
	 * avoid a ton of redundant code within SpellProgressionInfo.
	 */
<span class="nc" id="L431">	private static class Progression implements Cloneable</span>
	{
		/**
		 * This is a Map of spells. The Integer key is the Class level, the
		 * value is a List of constants or Formula for each SpellLevel.
		 * 
		 * The progressionMap must not contain any null values.
		 */
<span class="nc" id="L439">		private TreeMap&lt;Integer, List&lt;Formula&gt;&gt; progressionMap = null;</span>

		/**
		 * Sets the spells for the given class level for this Progression. The
		 * given character level must be greater than or equal to one.
		 * 
		 * Note that this is a SET (not an ADD) and will therefore OVERWRITE a
		 * spell progression for the given class level if one is already present
		 * within this Progression.
		 * 
		 * @param iLevel
		 *            The class level for which the given spell progression
		 *            applies.
		 * @param aList
		 *            The spell progression for the given class level.
		 * @return The previously set spell progression for the given class
		 *         level; null if no spell progression was previously set.
		 */
		private List&lt;Formula&gt; setProgression(int iLevel, List&lt;Formula&gt; aList)
		{
<span class="nc bnc" id="L459" title="All 2 branches missed.">			if (iLevel &lt; 1)</span>
			{
<span class="nc" id="L461">				throw new IllegalArgumentException(&quot;Level must be &gt;= 1 in spell progression&quot;);</span>
			}
<span class="nc bnc" id="L463" title="All 2 branches missed.">			if (aList == null)</span>
			{
<span class="nc" id="L465">				throw new IllegalArgumentException(&quot;Cannot add null spell progression list to level &quot; + iLevel);</span>
			}
<span class="nc bnc" id="L467" title="All 2 branches missed.">			if (aList.isEmpty())</span>
			{
<span class="nc" id="L469">				throw new IllegalArgumentException(&quot;Cannot add empty spell progression list to level &quot; + iLevel);</span>
			}
<span class="nc bnc" id="L471" title="All 2 branches missed.">			if (aList.contains(null))</span>
			{
<span class="nc" id="L473">				throw new IllegalArgumentException(</span>
					&quot;Cannot have null value in spell progrssion list in level &quot; + iLevel);
			}
<span class="nc bnc" id="L476" title="All 2 branches missed.">			if (progressionMap == null)</span>
			{
<span class="nc" id="L478">				progressionMap = new TreeMap&lt;&gt;();</span>
			}
<span class="nc" id="L480">			return progressionMap.put(iLevel, new ArrayList&lt;&gt;(aList));</span>
		}

		private int getMinLevelForSpellLevel(int spellLevel, boolean allowBonus)
		{
<span class="nc bnc" id="L485" title="All 2 branches missed.">			for (Entry&lt;Integer, List&lt;Formula&gt;&gt; me : progressionMap.entrySet())</span>
			{
<span class="nc" id="L487">				List&lt;Formula&gt; progressionList = me.getValue();</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">				for (int lvl = spellLevel; lvl &lt; progressionList.size(); lvl++)</span>
				{
					/*
					 * This for loop is to protect against a (admittedly
					 * strange) class that grants N + 1 level spells, but not N
					 * and N is the spellLevel parameter to this method.
					 */
					/*
					 * FIXME This will break if there are spell formulae - thpr
					 * 11/9/06
					 */
<span class="nc bnc" id="L499" title="All 4 branches missed.">					if (allowBonus || Integer.parseInt(progressionList.get(lvl).toString()) != 0)</span>
					{
<span class="nc" id="L501">						return me.getKey();</span>
					}
				}
<span class="nc" id="L504">			}</span>
<span class="nc" id="L505">			return -1;</span>
		}

		/**
		 * Returns true if this Progression contains a spell progression.
		 * 
		 * @return True if this Progression contains a spell progression; false
		 *         otherwise.
		 */
		private boolean hasProgression()
		{
<span class="nc bnc" id="L516" title="All 2 branches missed.">			return progressionMap != null;</span>
		}

		/**
		 * Returns the spell progression for the given class level. If this
		 * Progression does not contain a spell progression or if the given
		 * class level is not high enough to have spells, this method returns
		 * null.
		 * 
		 * This method is value-semantic. Ownership of the returned List is
		 * transferred to the calling object (The returned list can be modified
		 * without impacting the internal contents of this Progression)
		 * 
		 * @param classLevel
		 *            The class level for which the spell progression should be
		 *            returned.
		 * @return The spell progression for the given class level, or null if
		 *         there is no spell progression for the given class level.
		 */
		private List&lt;Formula&gt; getProgressionForLevel(int classLevel)
		{
<span class="nc" id="L537">			List&lt;Formula&gt; spellProgression = null;</span>
<span class="nc" id="L538">			boolean found = false;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">			if (progressionMap != null)</span>
			{
<span class="nc" id="L541">				Integer key = classLevel;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">				if (!progressionMap.containsKey(key))</span>
				{
					//No spellcasting at level key, check previous levels
<span class="nc bnc" id="L545" title="All 2 branches missed.">					if (progressionMap.firstKey() &lt; classLevel)</span>
					{
<span class="nc" id="L547">						key = progressionMap.headMap(key).lastKey();</span>
<span class="nc" id="L548">						found = true;</span>
					}
				}
				else
				{
<span class="nc" id="L553">					found = true;</span>
				}
<span class="nc bnc" id="L555" title="All 2 branches missed.">				if (found)</span>
				{
<span class="nc" id="L557">					List&lt;Formula&gt; list = progressionMap.get(key);</span>
<span class="nc" id="L558">					spellProgression = new ArrayList&lt;&gt;(list);</span>
				}
			}
<span class="nc" id="L561">			return spellProgression;</span>

		}

		/**
		 * Returns the highest possible spell level in this Progression.
		 * 
		 * Note that this is a theoretical highest level, and based on the
		 * abilities of a PlayerCharacter, the highest spell level may not be
		 * available to that PlayerCharacter.
		 * 
		 * There are at least two known situations where the theoretical spell
		 * level is higher than what a specific PlayerCharacter could actually
		 * know: (1) When a Stat limits the level of spells that a given
		 * PlayerCharacter can learn (2) When a Class grants 0 known spells, but
		 * some PlayerCharacters could have a Stat that provides bonus spells
		 * [this method WILL return a spell level where a Class grants 0 spells,
		 * since this is a theoretical limit test.]
		 * 
		 * @return The highest possible spell level in this Progression.
		 */
		private int getHighestSpellLevel()
		{
<span class="nc bnc" id="L584" title="All 2 branches missed.">			if (progressionMap != null)</span>
			{
<span class="nc" id="L586">				int highest = -1;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">				for (List&lt;Formula&gt; list : progressionMap.values())</span>
				{
<span class="nc" id="L589">					highest = Math.max(highest, list.size() - 1);</span>
<span class="nc" id="L590">				}</span>
<span class="nc" id="L591">				return highest;</span>
			}
<span class="nc" id="L593">			return -1;</span>
		}

		/**
		 * Clones this Progression object. A semi-deep (or semi-shallow,
		 * depending on one's point of view) clone is performed, under the
		 * assumption that the cloned object should be allowed to have the
		 * Progression.set* method called without allowing either the original
		 * or the cloned Progression object to accidentally modify the other.
		 * 
		 * There is the assumption, however, that the Lists contained within the
		 * Progression object are never modified, and violation of that semantic
		 * rule either within Progression or by other objects which call the
		 * reference-semantic methods of Progression can render this clone
		 * insufficient.
		 * 
		 * @return A semi-shallow Clone of this Progression object.
		 * @throws CloneNotSupportedException
		 */
		@Override
		public Progression clone() throws CloneNotSupportedException
		{
<span class="nc" id="L615">			Progression p = (Progression) super.clone();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">			if (progressionMap != null)</span>
			{
<span class="nc" id="L618">				p.progressionMap = new TreeMap&lt;&gt;(progressionMap);</span>
			}
<span class="nc" id="L620">			return p;</span>
		}
	}

	public boolean isEmpty()
	{
<span class="nc bnc" id="L626" title="All 6 branches missed.">		return knownProgression == null &amp;&amp; castProgression == null &amp;&amp; specialtyKnownProgression == null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>