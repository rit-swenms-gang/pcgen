<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbilityCategory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.core</a> &gt; <span class="el_source">AbilityCategory.java</span></div><h1>AbilityCategory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2010 Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * Copyright 2006 (C) Aaron Divinsky &lt;boomer70@yahoo.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package pcgen.core;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import pcgen.base.formula.Formula;
import pcgen.cdom.base.BasicClassIdentity;
import pcgen.cdom.base.Category;
import pcgen.cdom.base.ChooseInformation;
import pcgen.cdom.base.ClassIdentity;
import pcgen.cdom.base.FormulaFactory;
import pcgen.cdom.base.Loadable;
import pcgen.cdom.enumeration.DisplayLocation;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.Type;
import pcgen.cdom.reference.CDOMAllRef;
import pcgen.cdom.reference.CDOMDirectSingleRef;
import pcgen.cdom.reference.CDOMGroupRef;
import pcgen.cdom.reference.CDOMSimpleSingleRef;
import pcgen.cdom.reference.CDOMSingleRef;
import pcgen.cdom.reference.CDOMTypeRef;
import pcgen.cdom.reference.ManufacturableFactory;
import pcgen.cdom.reference.ReferenceManufacturer;
import pcgen.cdom.reference.UnconstructedValidator;
import pcgen.core.utils.LastGroupSeparator.GroupingMismatchException;
import pcgen.system.LanguageBundle;
import pcgen.util.Logging;
import pcgen.util.enumeration.View;
import pcgen.util.enumeration.Visibility;

/**
 * This class stores and manages information about Ability categories.
 * 
 * &lt;p&gt;This is a higher level abstraction than the category specified by the 
 * ability object itself.  The low-level AbilityCategory defaults to the same
 * as this category key but this can be changed.  For example to specify an
 * &lt;tt&gt;AbilityCategory&lt;/tt&gt; &amp;quot;Fighter Bonus Feats&amp;quot; you could specify
 * the AbilityCategory was &amp;quot;FEAT&amp;quot; and set the ability type to
 * &amp;quot;Fighter&amp;quot;. 
 * 
 * 
 */
public class AbilityCategory
		implements Category&lt;Ability&gt;, Loadable, ManufacturableFactory&lt;Ability&gt;
{
<span class="fc" id="L72">	private static final ClassIdentity&lt;AbilityCategory&gt; IDENTITY =</span>
<span class="fc" id="L73">			BasicClassIdentity.getIdentity(AbilityCategory.class);</span>

	private URI sourceURI;

	private String keyName;
	private String displayName;
	private String pluralName;

	private CDOMSingleRef&lt;AbilityCategory&gt; parentCategory;
<span class="fc" id="L82">	private Set&lt;CDOMSingleRef&lt;Ability&gt;&gt; containedAbilities = null;</span>
	private DisplayLocation displayLocation;
<span class="fc" id="L84">	private boolean isAllAbilityTypes = false;</span>
<span class="fc" id="L85">	private Set&lt;Type&gt; types = null;</span>
<span class="fc" id="L86">	private Formula poolFormula = FormulaFactory.ZERO;</span>

<span class="fc" id="L88">	private Visibility visibility = Visibility.DEFAULT;</span>
<span class="fc" id="L89">	private boolean isEditable = true;</span>
<span class="fc" id="L90">	private boolean isPoolModifiable = true;</span>
<span class="fc" id="L91">	private boolean isPoolFractional = false;</span>
<span class="fc" id="L92">	private boolean isInternal = false;</span>

	/** A constant used to refer to the &amp;quot;Feat&amp;quot; category. */
<span class="fc" id="L95">	public static final AbilityCategory FEAT = new AbilityCategory(&quot;FEAT&quot;, &quot;in_feat&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L96">	public static final AbilityCategory LANGBONUS = new AbilityCategory(&quot;*LANGBONUS&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L97">	public static final AbilityCategory ANY = new AbilityCategory(&quot;ANY&quot;); //$NON-NLS-1$</span>

	static
	{
<span class="fc" id="L101">		FEAT.pluralName = LanguageBundle.getString(&quot;in_feats&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L102">		FEAT.displayLocation = DisplayLocation.getConstant(LanguageBundle.getString(&quot;in_feats&quot;)); //$NON-NLS-1$</span>
<span class="fc" id="L103">		FEAT.setInternal(true);</span>
<span class="fc" id="L104">		LANGBONUS.setPoolFormula(FormulaFactory.getFormulaFor(&quot;BONUSLANG&quot;));</span>
<span class="fc" id="L105">		LANGBONUS.setInternal(true);</span>
<span class="fc" id="L106">	}</span>

	/**
	 * Constructs a new &lt;tt&gt;AbilityCategory&lt;/tt&gt; with the specified key.
	 * 
	 * &lt;p&gt;This method sets the display and plural names to the same value as
	 * the key name.
	 */
	public AbilityCategory()
<span class="fc" id="L115">	{</span>
		//For fooling other things
<span class="fc" id="L117">		keyName = &quot;&quot;;</span>
		//Self until proven otherwise
<span class="fc" id="L119">		parentCategory = CDOMDirectSingleRef.getRef(this);</span>
<span class="fc" id="L120">	}</span>

	/**
	 * Update this ability category using the values from the supplied 
	 * ability category. 
	 * @param srcCat The category to be copied.
	 */
	public void copyFields(AbilityCategory srcCat)
	{
<span class="nc" id="L129">		sourceURI = srcCat.sourceURI;</span>
<span class="nc" id="L130">		keyName = srcCat.keyName;</span>
<span class="nc" id="L131">		displayName = srcCat.displayName;</span>
<span class="nc" id="L132">		pluralName = srcCat.pluralName;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		if (srcCat.getParentCategory() == srcCat)</span>
		{
<span class="nc" id="L135">			parentCategory = CDOMDirectSingleRef.getRef(this);</span>
		}
		else
		{
<span class="nc" id="L139">			parentCategory = srcCat.parentCategory;</span>
		}
<span class="nc" id="L141">		displayLocation = srcCat.displayLocation;</span>
<span class="nc" id="L142">		isAllAbilityTypes = srcCat.isAllAbilityTypes;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">		types = (srcCat.types == null) ? null : new HashSet&lt;&gt;(srcCat.types);</span>
<span class="nc" id="L144">		poolFormula = srcCat.poolFormula;</span>
<span class="nc" id="L145">		visibility = srcCat.visibility;</span>
<span class="nc" id="L146">		isEditable = srcCat.isEditable;</span>
<span class="nc" id="L147">		isPoolModifiable = srcCat.isPoolModifiable;</span>
<span class="nc" id="L148">		isPoolFractional = srcCat.isPoolFractional;</span>
<span class="nc" id="L149">		isInternal = srcCat.isInternal;</span>
<span class="nc" id="L150">	}</span>

	/**
	 * Constructor takes a key name and display name for the category.
	 * 
	 * @param aKeyName The name to use to reference this category.
	 * @param aDisplayName The resource key to use for the display name
	 */
	public AbilityCategory(final String aKeyName, final String aDisplayName)
<span class="fc" id="L159">	{</span>
<span class="fc" id="L160">		keyName = aKeyName;</span>
<span class="fc" id="L161">		setName(aDisplayName);</span>
<span class="fc" id="L162">		setPluralName(aDisplayName);</span>

<span class="fc" id="L164">		parentCategory = CDOMDirectSingleRef.getRef(this);</span>
<span class="fc" id="L165">		displayLocation = DisplayLocation.getConstant(aDisplayName);</span>
<span class="fc" id="L166">	}</span>

	/**
	 * Constructor takes a name for the category.
	 * 
	 * @param aKeyName The name to use to reference this category.
	 */
	public AbilityCategory(String aKeyName)
	{
<span class="fc" id="L175">		this(aKeyName, aKeyName);</span>
<span class="fc" id="L176">	}</span>

	/**
	 * Sets the parent AbilityCategory this category is part of.
	 * 
	 * @param category A Reference to an AbilityCategory.
	 */
	public void setAbilityCategory(CDOMSingleRef&lt;AbilityCategory&gt; category)
	{
		/*
		 * Note: This makes an assumption that keyName will not change. We
		 * should not enable a KEY token for AbilityCategory
		 */
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">		if (isInternal)</span>
		{
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if (!category.getLSTformat(false).equals(this.getKeyName()))</span>
			{
<span class="nc" id="L193">				throw new IllegalArgumentException(&quot;Cannot set CATEGORY on an internal AbilityCategory&quot;);</span>
			}
		}
		else
		{
<span class="fc" id="L198">			parentCategory = category;</span>
		}
<span class="fc" id="L200">	}</span>

	/**
	 * Gets the parent AbilityCategory this category is part of.
	 * 
	 * @return A reference to the AbilityCategory.
	 */
	public CDOMSingleRef&lt;AbilityCategory&gt; getAbilityCatRef()
	{
<span class="nc" id="L209">		return parentCategory;</span>
	}

	/**
	 * Adds a new type to the list of types included in this category.
	 * 
	 * @param type A type string.
	 */
	public void addAbilityType(final Type type)
	{
<span class="nc bnc" id="L219" title="All 2 branches missed.">		if (types == null)</span>
		{
<span class="nc" id="L221">			types = new TreeSet&lt;&gt;();</span>
		}
<span class="nc" id="L223">		types.add(type);</span>
<span class="nc" id="L224">	}</span>

	/**
	 * Gets the &lt;tt&gt;Set&lt;/tt&gt; of all the ability types to be included in this
	 * category.
	 * 
	 * @return An unmodifiable &lt;tt&gt;Set&lt;/tt&gt; of type strings.
	 */
	public Set&lt;Type&gt; getTypes()
	{
<span class="nc bnc" id="L234" title="All 2 branches missed.">		if (types == null)</span>
		{
<span class="nc" id="L236">			return Collections.emptySet();</span>
		}
<span class="nc" id="L238">		return Collections.unmodifiableSet(types);</span>
	}

	/**
	 * Should all ability types be included in this category?
	 * @return true if all types should be included, 
	 *         false if only those listed should be.
	 */
	public boolean isAllAbilityTypes()
	{
<span class="nc" id="L248">		return isAllAbilityTypes;</span>
	}

	/**
	 * Configure whether all ability types be included in this category?
	 * @param allAbilityTypes true if all types should be included, 
	 *         false if only those listed should be.
	 */
	public void setAllAbilityTypes(boolean allAbilityTypes)
	{
<span class="nc" id="L258">		this.isAllAbilityTypes = allAbilityTypes;</span>
<span class="nc" id="L259">	}</span>

	/**
	 * @param key the Ability Key to add to the set
	 */
	public void addAbilityKey(CDOMSingleRef&lt;Ability&gt; key)
	{
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (containedAbilities == null)</span>
		{
<span class="nc" id="L268">			containedAbilities = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L270">		containedAbilities.add(key);</span>
<span class="nc" id="L271">	}</span>

	/**
	 * Gets the formula to use for calculating the base pool size for this
	 * category of ability.
	 * 
	 * @return A formula
	 */
	public Formula getPoolFormula()
	{
<span class="nc" id="L281">		return poolFormula;</span>
	}

	/**
	 * Sets the formula to use to calculate the base pool size for this category
	 * of ability.
	 * 
	 * @param formula A valid formula or variable.
	 */
	public void setPoolFormula(Formula formula)
	{
<span class="fc" id="L292">		poolFormula = formula;</span>
<span class="fc" id="L293">	}</span>

	/**
	 * Sets the internationalized plural name for this category.
	 * 
	 * @param aName A plural name.
	 */
	public void setPluralName(final String aName)
	{
<span class="fc" id="L302">		pluralName = aName;</span>
<span class="fc" id="L303">	}</span>

	/**
	 * Returns an internationalized plural version of the category name.
	 * 
	 * @return The pluralized name
	 */
	public String getPluralName()
	{
<span class="nc" id="L312">		String name = pluralName;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">		if (name == null)</span>
		{
<span class="nc" id="L315">			name = displayName;</span>
		}
<span class="nc bnc" id="L317" title="All 2 branches missed.">		if (name.startsWith(&quot;in_&quot;))</span>
		{
<span class="nc" id="L319">			return LanguageBundle.getString(name);</span>
		}
		else
		{
<span class="nc" id="L323">			return name;</span>
		}
	}

	public String getRawPluralName()
	{
<span class="nc" id="L329">		return pluralName;</span>
	}

	/**
	 * Returns the location on which the AbilityCategory should be displayed.
	 * 
	 * @return The display location.
	 */
	public DisplayLocation getDisplayLocation()
	{
<span class="nc bnc" id="L339" title="All 2 branches missed.">		if (displayLocation == null)</span>
		{
<span class="nc" id="L341">			displayLocation = DisplayLocation.getConstant(getPluralName());</span>
		}
<span class="nc" id="L343">		return displayLocation;</span>
	}

	/**
	 * Sets the location where the AbilityCategory should be displayed.
	 * 
	 * @param location
	 *            The new displayLocation
	 */
	public void setDisplayLocation(DisplayLocation location)
	{
<span class="nc" id="L354">		displayLocation = location;</span>
<span class="nc" id="L355">	}</span>

	/**
	 * Sets if abilities of this category should be displayed in the UI.
	 * 
	 * @param visible the visibility for abilities, i.e. hidden, visible, etc. 
	 */
	public void setVisible(Visibility visible)
	{
<span class="nc" id="L364">		visibility = visible;</span>
<span class="nc" id="L365">	}</span>

	/**
	 * Checks if this category of ability should be displayed in the UI.
	 * 
	 * @return &lt;tt&gt;true&lt;/tt&gt; if these abilities should be displayed.
	 */
	public boolean isVisibleTo(View v)
	{
<span class="nc" id="L374">		return isVisibleTo(null, v);</span>
	}

	/**
	 * Checks if this category of ability should be displayed in the 
	 * UI for this PC.
	 * 
	 * @param pc The character to be tested.
	 * @return &lt;tt&gt;true&lt;/tt&gt; if these abilities should be displayed.
	 */
	public boolean isVisibleTo(PlayerCharacter pc, View v)
	{
<span class="nc bnc" id="L386" title="All 2 branches missed.">		if (visibility.equals(Visibility.QUALIFY))</span>
		{
			/*
			 * Note that hasAbilityVisibleTo is apparently not how data is
			 * designed - the problem (in my opinion) being that either an
			 * undocumented design change was made or a bug was being taken
			 * advantage of and the data is now dependent upon that bug. This
			 * reintroduces a wider behavior, but - again in my opinion -
			 * decreases clarity over the definition of QUALIFIED and whether
			 * the actual behavior aligns with the dictionary definition of the
			 * word. - thpr Apr 5 '14
			 */
<span class="nc bnc" id="L398" title="All 6 branches missed.">			return (pc == null) || (pc.getTotalAbilityPool(this).floatValue() != 0.0) || pc.hasAbilityInPool(this);</span>
			//|| pc.hasAbilityVisibleTo(this, v);
		}
<span class="nc" id="L401">		return visibility.isVisibleTo(v);</span>
	}

	/**
	 * Sets if abilities in this category should be user-editable
	 * 
	 * @param yesNo &lt;tt&gt;true&lt;/tt&gt; if the user should be able to add and remove
	 * abilities of this category.
	 */
	public void setEditable(final boolean yesNo)
	{
<span class="nc" id="L412">		isEditable = yesNo;</span>
<span class="nc" id="L413">	}</span>

	/**
	 * Checks if this category of abilities is user-editable.
	 * 
	 * @return &lt;tt&gt;true&lt;/tt&gt; if these abilities are editable.
	 */
	public boolean isEditable()
	{
<span class="nc" id="L422">		return isEditable;</span>
	}

	/**
	 * Sets the flag to allow/disallow user editing of the pool.
	 * 
	 * @param yesNo Set to &lt;tt&gt;true&lt;/tt&gt; to allow user editing.
	 */
	public void setModPool(final boolean yesNo)
	{
<span class="nc" id="L432">		isPoolModifiable = yesNo;</span>
<span class="nc" id="L433">	}</span>

	/**
	 * Checks if this category allows user editing of the pool.
	 * 
	 * @return &lt;tt&gt;true&lt;/tt&gt; to allow user editing.
	 */
	public boolean allowPoolMod()
	{
<span class="nc" id="L442">		return isPoolModifiable;</span>
	}

	/**
	 * Sets if the pool can use fractional amounts.
	 * 
	 * @param yesNo &lt;tt&gt;true&lt;/tt&gt; to allow fractions.
	 */
	public void setAllowFractionalPool(final boolean yesNo)
	{
<span class="nc" id="L452">		isPoolFractional = yesNo;</span>
<span class="nc" id="L453">	}</span>

	/**
	 * Checks if the pool should use whole numbers only.
	 * 
	 * @return &lt;tt&gt;true&lt;/tt&gt; if fractional pool amounts are valid.
	 */
	public boolean allowFractionalPool()
	{
<span class="nc" id="L462">		return isPoolFractional;</span>
	}

	// -------------------------------------------
	// KeyedObject Support
	// -------------------------------------------
	@Override
	public String getDisplayName()
	{
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (displayName.startsWith(&quot;in_&quot;))</span>
		{
<span class="nc" id="L473">			return LanguageBundle.getString(displayName);</span>
		}
		else
		{
<span class="nc" id="L477">			return displayName;</span>
		}
	}

	public String getRawDisplayName()
	{
<span class="nc" id="L483">		return displayName;</span>
	}

	@Override
	public String getKeyName()
	{
<span class="fc" id="L489">		return keyName;</span>
	}

	@Override
	public void setName(final String aName)
	{
<span class="fc bfc" id="L495" title="All 2 branches covered.">		if (&quot;&quot;.equals(keyName))</span>
		{
<span class="fc" id="L497">			keyName = aName;</span>
		}
<span class="fc" id="L499">		displayName = aName;</span>
<span class="fc" id="L500">	}</span>

	@Override
	public String toString()
	{
<span class="nc" id="L505">		return getDisplayName();</span>
	}

	@Override
	public int hashCode()
	{
<span class="fc" id="L511">		final int prime = 31;</span>
<span class="fc" id="L512">		int result = 1;</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">		result = (prime * result) + ((keyName == null) ? 0 : keyName.hashCode());</span>
<span class="fc" id="L514">		return result;</span>
	}

	@Override
	public boolean equals(Object obj)
	{
<span class="fc bfc" id="L520" title="All 2 branches covered.">		if (this == obj)</span>
		{
<span class="fc" id="L522">			return true;</span>
		}
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">		if (obj == null)</span>
		{
<span class="nc" id="L526">			return false;</span>
		}
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">		if (getClass() != obj.getClass())</span>
		{
<span class="nc" id="L530">			return false;</span>
		}
<span class="fc" id="L532">		final AbilityCategory other = (AbilityCategory) obj;</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">		if (keyName == null)</span>
		{
<span class="nc bnc" id="L535" title="All 2 branches missed.">			return other.keyName == null;</span>
		}
		else
		{
<span class="fc" id="L539">			return keyName.equals(other.keyName);</span>
		}
	}

	@Override
	public Category&lt;Ability&gt; getParentCategory()
	{
<span class="fc" id="L546">		return parentCategory.get();</span>
	}

	/**
	 * Return the collection of references for abilities that will be directly
	 * included in the category.
	 * 
	 * @return the collection of references
	 */
	public Collection&lt;CDOMSingleRef&lt;Ability&gt;&gt; getAbilityRefs()
	{
<span class="nc bnc" id="L557" title="All 2 branches missed.">		if (containedAbilities == null)</span>
		{
<span class="nc" id="L559">			return Collections.emptySet();</span>
		}
<span class="nc" id="L561">		return Collections.unmodifiableCollection(containedAbilities);</span>
	}

	public boolean hasDirectReferences()
	{
<span class="nc bnc" id="L566" title="All 4 branches missed.">		return (containedAbilities != null) &amp;&amp; !containedAbilities.isEmpty();</span>
	}

	public Visibility getVisibility()
	{
<span class="nc" id="L571">		return visibility;</span>
	}

	@Override
	public URI getSourceURI()
	{
<span class="nc" id="L577">		return sourceURI;</span>
	}

	@Override
	public void setSourceURI(URI source)
	{
<span class="fc" id="L583">		sourceURI = source;</span>
<span class="fc" id="L584">	}</span>

	public void setInternal(boolean internal)
	{
<span class="fc" id="L588">		isInternal = internal;</span>
<span class="fc" id="L589">	}</span>

	@Override
	public boolean isInternal()
	{
<span class="fc" id="L594">		return isInternal;</span>
	}

	@Override
	public boolean isType(String type)
	{
<span class="nc" id="L600">		return false;</span>
	}

	@Override
	public CDOMGroupRef&lt;Ability&gt; getAllReference()
	{
<span class="fc" id="L606">		return new CDOMAllRef&lt;&gt;(this);</span>
	}

	@Override
	public CDOMGroupRef&lt;Ability&gt; getTypeReference(String... types)
	{
<span class="fc" id="L612">		return new CDOMTypeRef&lt;&gt;(this, types);</span>
	}

	@Override
	public CDOMSingleRef&lt;Ability&gt; getReference(String ident)
	{
<span class="fc" id="L618">		return new CDOMSimpleSingleRef&lt;&gt;(this, ident);</span>
	}

	@Override
	public Ability newInstance()
	{
<span class="fc" id="L624">		Ability a = new Ability();</span>
<span class="fc" id="L625">		a.setCDOMCategory(this);</span>
<span class="fc" id="L626">		return a;</span>
	}

	@Override
	public boolean isMember(Ability item)
	{
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">		if (item == null)</span>
		{
<span class="nc" id="L634">			return false;</span>
		}
<span class="fc" id="L636">		Category&lt;Ability&gt; itemCategory = item.getCDOMCategory();</span>
<span class="pc bpc" id="L637" title="3 of 4 branches missed.">		return this.equals(itemCategory) || getParentCategory().equals(itemCategory);</span>
	}

	@Override
	public Class&lt;Ability&gt; getReferenceClass()
	{
<span class="fc" id="L643">		return Ability.class;</span>
	}

	@Override
	public String getReferenceDescription()
	{
<span class="fc" id="L649">		return &quot;Ability Category &quot; + this.getKeyName();</span>
	}

	@Override
	public boolean resolve(ReferenceManufacturer&lt;Ability&gt; rm, String name, CDOMSingleRef&lt;Ability&gt; reference,
		UnconstructedValidator validator)
	{
<span class="pc bpc" id="L656" title="3 of 4 branches missed.">		if ((containedAbilities != null) &amp;&amp; (containedAbilities.contains(reference)))</span>
		{
<span class="nc" id="L658">			return true;</span>
		}
<span class="fc" id="L660">		return doResolve(rm, name, reference, validator);</span>
	}

	private boolean doResolve(ReferenceManufacturer&lt;Ability&gt; rm, String name, CDOMSingleRef&lt;Ability&gt; reference,
		UnconstructedValidator validator)
	{
<span class="fc" id="L666">		boolean returnGood = true;</span>
<span class="fc" id="L667">		Ability activeObj = rm.getObject(name);</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">		if (activeObj == null)</span>
		{
<span class="fc" id="L670">			List&lt;String&gt; choices = new ArrayList&lt;&gt;();</span>
			try
			{
<span class="fc" id="L673">				String reduced = AbilityUtilities.getUndecoratedName(name, choices);</span>
<span class="fc" id="L674">				activeObj = rm.getObject(reduced);</span>
			}
<span class="nc" id="L676">			catch (GroupingMismatchException e)</span>
			{
<span class="nc" id="L678">				Logging.log(Logging.LST_ERROR, e.getMessage());</span>
<span class="fc" id="L679">			}</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">			if (activeObj == null)</span>
			{
				// Really not constructed...
				// Wasn't constructed!
<span class="pc bpc" id="L684" title="2 of 4 branches missed.">				if ((name.charAt(0) != '*') &amp;&amp; !report(validator, name))</span>
				{
<span class="fc" id="L686">					Logging.errorPrint(&quot;Unconstructed Reference: &quot; + getReferenceDescription() + &quot; &quot; + name);</span>
<span class="fc" id="L687">					rm.fireUnconstuctedEvent(reference);</span>
<span class="fc" id="L688">					returnGood = false;</span>
				}
<span class="fc" id="L690">				activeObj = rm.buildObject(name);</span>
			}
			else
			{
				// Successful on reduced
<span class="fc" id="L695">				reference.addResolution(activeObj);</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">				if (choices.size() == 1)</span>
				{
<span class="fc" id="L698">					reference.setChoice(choices.get(0));</span>
				}
<span class="nc bnc" id="L700" title="All 2 branches missed.">				else if (choices.size() &gt; 1)</span>
				{
<span class="nc" id="L702">					Logging.errorPrint(&quot;Invalid use of multiple items &quot; + &quot;in parenthesis (comma prohibited) in &quot;</span>
<span class="nc" id="L703">						+ activeObj + &quot; &quot; + choices.toString());</span>
<span class="nc" id="L704">					returnGood = false;</span>
				}
			}
<span class="fc" id="L707">		}</span>
		else
		{
<span class="fc" id="L710">			reference.addResolution(activeObj);</span>
<span class="pc bpc" id="L711" title="1 of 4 branches missed.">			if (reference.requiresTarget() &amp;&amp; activeObj.getSafe(ObjectKey.MULTIPLE_ALLOWED))</span>
			{
<span class="nc" id="L713">				ChooseInformation&lt;?&gt; ci = activeObj.get(ObjectKey.CHOOSE_INFO);</span>
				// Is MULT:YES.... and not CHOOSE:NOCHOICE
				// Null check (unfortunately) required to protect vs. bad data
				// No error message though, that is caught by MULT token
<span class="nc bnc" id="L717" title="All 4 branches missed.">				if ((ci != null) &amp;&amp; !&quot;No Choice&quot;.equals(ci.getName()))</span>
				{
<span class="nc" id="L719">					Logging.errorPrint(</span>
						&quot;Invalid use of MULT:YES Ability &quot; + activeObj + &quot; where a target [parens] is required&quot;);
<span class="nc" id="L721">					Logging.errorPrint(&quot;PLEASE TAKE NOTE: &quot; + &quot;If usage locations are reported, &quot;</span>
						+ &quot;not all usages are necessary illegal &quot; + &quot;(at least one is)&quot;);
<span class="nc" id="L723">					rm.fireUnconstuctedEvent(reference);</span>
<span class="nc" id="L724">					returnGood = false;</span>
				}
			}
		}
<span class="fc" id="L728">		return returnGood;</span>
	}

	private boolean report(UnconstructedValidator validator, String key)
	{
<span class="pc bpc" id="L733" title="3 of 4 branches missed.">		return (validator != null) &amp;&amp; validator.allowUnconstructed(getReferenceIdentity(), key);</span>
	}

	@Override
	public boolean populate(ReferenceManufacturer&lt;Ability&gt; parentCrm, ReferenceManufacturer&lt;Ability&gt; rm,
		UnconstructedValidator validator)
	{
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">		if (parentCrm == null)</span>
		{
<span class="fc" id="L742">			return true;</span>
		}
<span class="nc" id="L744">		Collection&lt;Ability&gt; allObjects = parentCrm.getAllObjects();</span>
		// Don't add things twice or we'll get dupe messages :)
<span class="nc" id="L746">		Set&lt;Ability&gt; added = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());</span>
		/*
		 * Pull in all the base objects... note this skips containsDirectly
		 * because items haven't been resolved
		 */
<span class="nc bnc" id="L751" title="All 2 branches missed.">		for (final Ability ability : allObjects)</span>
		{
<span class="nc" id="L753">			boolean use = isAllAbilityTypes;</span>
<span class="nc bnc" id="L754" title="All 4 branches missed.">			if (!use &amp;&amp; (types != null))</span>
			{
<span class="nc bnc" id="L756" title="All 2 branches missed.">				for (Type type : types)</span>
				{
<span class="nc bnc" id="L758" title="All 2 branches missed.">					if (ability.isType(type.toString()))</span>
					{
<span class="nc" id="L760">						use = true;</span>
<span class="nc" id="L761">						break;</span>
					}
<span class="nc" id="L763">				}</span>
			}
<span class="nc bnc" id="L765" title="All 2 branches missed.">			if (use)</span>
			{
<span class="nc" id="L767">				added.add(ability);</span>
<span class="nc" id="L768">				rm.addObject(ability, ability.getKeyName());</span>
			}
<span class="nc" id="L770">		}</span>
<span class="nc" id="L771">		boolean returnGood = true;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">		if (containedAbilities != null)</span>
		{
<span class="nc bnc" id="L774" title="All 2 branches missed.">			for (CDOMSingleRef&lt;Ability&gt; ref : containedAbilities)</span>
			{
<span class="nc" id="L776">				boolean res = doResolve(parentCrm, ref.getLSTformat(false), ref, validator);</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">				if (res)</span>
				{
<span class="nc" id="L779">					Ability ability = ref.get();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">					if (added.add(ability))</span>
					{
<span class="nc" id="L782">						rm.addObject(ability, ability.getKeyName());</span>
					}
				}
<span class="nc" id="L785">				returnGood &amp;= res;</span>
<span class="nc" id="L786">			}</span>
		}
<span class="nc" id="L788">		return returnGood;</span>
	}

	@Override
	public ManufacturableFactory&lt;Ability&gt; getParent()
	{
<span class="fc" id="L794">		AbilityCategory parent = parentCategory.get();</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">		if (this.equals(parent))</span>
		{
<span class="fc" id="L797">			return null;</span>
		}
<span class="nc" id="L799">		return parent;</span>
	}

	@Override
	public String getName()
	{
<span class="nc" id="L805">		return getDisplayName();</span>
	}

	public String getType()
	{
<span class="nc" id="L810">		return String.valueOf(getDisplayLocation());</span>
	}

	@Override
	public ClassIdentity&lt;Ability&gt; getReferenceIdentity()
	{
<span class="fc" id="L816">		return this;</span>
	}

	@Override
	public ClassIdentity&lt;? extends Loadable&gt; getClassIdentity()
	{
<span class="fc" id="L822">		return IDENTITY;</span>
	}

	@Override
	public String getPersistentFormat()
	{
<span class="fc" id="L828">		return &quot;ABILITY=&quot; + getKeyName();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>