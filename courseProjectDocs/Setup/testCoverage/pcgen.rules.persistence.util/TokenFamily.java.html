<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenFamily.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.rules.persistence.util</a> &gt; <span class="el_source">TokenFamily.java</span></div><h1>TokenFamily.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 (C) Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.rules.persistence.util;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;

import pcgen.base.lang.CaseInsensitiveString;
import pcgen.base.lang.UnreachableError;
import pcgen.base.util.CaseInsensitiveMap;
import pcgen.base.util.DoubleKeyMap;
import pcgen.base.util.TripleKeyMap;
import pcgen.cdom.base.GroupDefinition;
import pcgen.cdom.base.Loadable;
import pcgen.persistence.lst.prereq.PrerequisiteParserInterface;
import pcgen.rules.persistence.token.CDOMSecondaryToken;
import pcgen.rules.persistence.token.CDOMSubToken;
import pcgen.rules.persistence.token.CDOMToken;
import pcgen.rules.persistence.token.DeferredToken;
import pcgen.util.Logging;

/**
 * A TokenFamily represents a set of tokens applicable to a specific Revision of
 * PCGen. This class also acts as the overall library of TokenFamily objects.
 */
public final class TokenFamily implements Comparable&lt;TokenFamily&gt;
{

	/**
	 * The TokenFamily for the current version of PCGen (the one being run)
	 */
<span class="fc" id="L56">	public static final TokenFamily CURRENT = new TokenFamily(new Revision(Integer.MAX_VALUE, 0, 0));</span>

	/**
	 * The TokenFamily for Revision 5.14 of PCGen. This version has specific
	 * compatibility around things like using PCClass tokens on PCClassLevel
	 * lines, so this revision requires some hardcoding (vs other Revisions that
	 * are dynamically generated by compatibility tokens)
	 */
<span class="fc" id="L64">	public static final TokenFamily REV514 = new TokenFamily(new Revision(5, 14, Integer.MIN_VALUE));</span>

	/**
	 * The Library of TokenFamily objects available for use
	 */
	private static SortedMap&lt;Revision, TokenFamily&gt; typeMap;

	/**
	 * The Revision of PCGen for which this TokenFamily is used or is providing
	 * compatibility
	 */
	private final Revision rev;

	/**
	 * The CDOMTokens available in this TokenFamily. This is stored by the class
	 * where the token can be used and the token name.
	 */
<span class="fc" id="L81">	private final DoubleKeyMap&lt;Class&lt;?&gt;, String, CDOMToken&lt;?&gt;&gt; tokenMap = new DoubleKeyMap&lt;&gt;();</span>

	/**
	 * The CDOMSecondaryTokens available in this TokenFamily. This is stored by
	 * the class where the token can be used, the &quot;primary/parent&quot; token name
	 * and the subtoken name.
	 */
<span class="fc" id="L88">	private final TripleKeyMap&lt;Class&lt;?&gt;, String, String, CDOMSecondaryToken&lt;?&gt;&gt; subTokenMap =</span>
			new TripleKeyMap&lt;&gt;(HashMap.class, CaseInsensitiveMap.class, CaseInsensitiveMap.class);

	/**
	 * The PRExxx tokens available in this TokenFamily. This is stored by the
	 * token name.
	 */
<span class="fc" id="L95">	private final Map&lt;CaseInsensitiveString, PrerequisiteParserInterface&gt; preTokenMap = new HashMap&lt;&gt;();</span>

	/**
	 * The DeferredTokens defined for this TokenFamily. This set of tokens will
	 * be run after the initial pass of the data load is complete
	 */
<span class="fc" id="L101">	private final List&lt;DeferredToken&lt;? extends Loadable&gt;&gt; deferredTokenList = new ArrayList&lt;&gt;();</span>

	/**
	 * The Group Definitions available for this TokenFamily. These are FACT and
	 * FACTSET items. These are stored by the Class in which they are usable and
	 * the Token name.
	 */
<span class="fc" id="L108">	private final DoubleKeyMap&lt;Class&lt;?&gt;, String, GroupDefinition&lt;?&gt;&gt; groupDefinitionMap =</span>
			new DoubleKeyMap&lt;&gt;(HashMap.class, CaseInsensitiveMap.class);

	/**
	 * Constructs a new TokenFamily for the given Revision.
	 * 
	 * @param r The Revision of PCGen covered by this TokenFamily
	 */
	public TokenFamily(Revision r)
<span class="fc" id="L117">	{</span>
<span class="fc" id="L118">		rev = r;</span>
<span class="fc" id="L119">	}</span>

	/**
	 * Adds a new Token to this TokenLibrary.
	 * 
	 * @param tok
	 *            The CDOMToken to be added to this TokenLibrary
	 * 
	 * @return The previous CDOMToken stored in this TokenLibrary for the same
	 *         Token Class and Token Name; null if no CDOMToken had previously
	 *         been stored for that combination
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; CDOMToken&lt;T&gt; putToken(CDOMToken&lt;T&gt; tok)
	{
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">		if (tok.getTokenClass() == null)</span>
		{
<span class="nc" id="L136">			Logging.errorPrint(&quot;Cannot load token &quot; + tok.getClass().getSimpleName() + &quot; with no token class&quot;);</span>
		}
<span class="fc" id="L138">		return (CDOMToken&lt;T&gt;) tokenMap.put(tok.getTokenClass(), tok.getTokenName(), tok);</span>
	}

	/**
	 * Returns the CDOMToken for the given Class and with the given token name.
	 * 
	 * @param cl
	 *            The Class for which a token should be retrieved
	 * @param name
	 *            The name of the token to be retrieved
	 * @return the CDOMToken for the given Class and with the given token name
	 */
	public CDOMToken&lt;?&gt; getToken(Class&lt;?&gt; cl, String name)
	{
<span class="fc" id="L152">		return tokenMap.get(cl, name);</span>
	}

	/**
	 * Returns all the tokens in this TokenLibrary for the given Class.
	 * 
	 * @param cl
	 *            The Class for which the tokens in this library should be
	 *            returned
	 * 
	 * @return A set of the tokens in this TokenLibrary for the given Class
	 */
	public Set&lt;CDOMToken&lt;?&gt;&gt; getTokens(Class&lt;?&gt; cl)
	{
<span class="fc" id="L166">		return tokenMap.values(cl);</span>
	}

	/**
	 * Adds a new SubToken to this TokenLibrary.
	 * 
	 * @param tok
	 *            The CDOMSecondaryToken to be added to this TokenLibrary
	 * 
	 * @return The previous CDOMSecondaryToken stored in this TokenLibrary for
	 *         the same Token Class, Parent Token, and Token Name; null if no
	 *         CDOMSecondaryToken had previously been stored for that
	 *         combination
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;U, T extends CDOMSecondaryToken&lt;U&gt;&gt; CDOMSecondaryToken&lt;U&gt; putSubToken(T tok)
	{
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (tok.getTokenClass() == null)</span>
		{
<span class="nc" id="L185">			Logging.errorPrint(&quot;Cannot load token &quot; + tok.getClass().getSimpleName() + &quot; with no token class&quot;);</span>
		}
<span class="fc" id="L187">		return (CDOMSecondaryToken&lt;U&gt;) subTokenMap.put(tok.getTokenClass(), tok.getParentToken(), tok.getTokenName(),</span>
			tok);
	}

	/**
	 * Returns the CDOMSubToken for the given Class and parent token, and with
	 * the given token name.
	 * 
	 * @param cl
	 *            The Class for which a token should be retrieved
	 * @param token
	 *            The name of the parent token for the CDOMSubToken to be
	 *            returned
	 * @param key
	 *            The name of the sub token to be retrieved
	 * @return the CDOMSubToken for the given Class and parent token, and with
	 *         the given token name
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; CDOMSubToken&lt;? super T&gt; getSubToken(Class&lt;? extends T&gt; cl, String token, String key)
	{
<span class="fc" id="L208">		return (CDOMSubToken&lt;? super T&gt;) subTokenMap.get(cl, token, key);</span>
	}

	/**
	 * Returns all the tokens in this TokenLibrary for the given Class and
	 * parent token name.
	 * 
	 * @param cl
	 *            The Class for which the tokens in this library should be
	 *            returned
	 * @param token
	 *            The name of the parent token for the CDOMSubTokens to be
	 *            returned
	 * 
	 * @return A Set of the subtokens in this TokenLibrary for the given Class
	 *         and parent token name
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; Set&lt;CDOMSecondaryToken&lt;? super T&gt;&gt; getSubTokens(Class&lt;? super T&gt; cl, String token)
	{
<span class="fc" id="L228">		return (Set) subTokenMap.values(cl, token);</span>
	}

	/**
	 * Adds a Prerequisite Parser Token to this TokenLibrary.
	 * 
	 * @param token
	 *            The Prerequisite Parser Token to be added to this TokenLibrary
	 */
	public void putPrerequisiteToken(PrerequisiteParserInterface token)
	{
<span class="fc bfc" id="L239" title="All 2 branches covered.">		for (String s : token.kindsHandled())</span>
		{
<span class="fc" id="L241">			preTokenMap.put(new CaseInsensitiveString(s), token);</span>
		}
<span class="fc" id="L243">	}</span>

	/**
	 * Returns the Prerequisite Parser Token for the given Prerequisite token
	 * name.
	 * 
	 * @param key
	 *            The Prerequisite token name for which the Prerequisite Parser
	 *            Token should be returned
	 * @return The Prerequisite Parser Token for the given Prerequisite token
	 *         name
	 */
	public PrerequisiteParserInterface getPrerequisiteToken(String key)
	{
<span class="nc" id="L257">		return preTokenMap.get(new CaseInsensitiveString(key));</span>
	}

	/**
	 * Constructs a new TokenFamily with the given primary, secondary and
	 * tertiary values as the Sequence characteristics
	 * 
	 * @return The new TokenFamily built with the given primary, secondary and
	 *         tertiary values
	 */
	public static TokenFamily getConstant(int primary, int secondary, int tertiary)
	{
<span class="fc bfc" id="L269" title="All 2 branches covered.">		if (typeMap == null)</span>
		{
<span class="fc" id="L271">			buildMap();</span>
		}
<span class="fc" id="L273">		Revision r = new Revision(primary, secondary, tertiary);</span>
<span class="fc" id="L274">		TokenFamily o = typeMap.get(r);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">		if (o == null)</span>
		{
<span class="fc" id="L277">			o = new TokenFamily(r);</span>
<span class="fc" id="L278">			typeMap.put(r, o);</span>
		}
<span class="fc" id="L280">		return o;</span>
	}

	/**
	 * Actually build the set of Constants, using any &quot;public static final&quot;
	 * constants within the child (extending) class as initial values in the
	 * Constant pool.
	 */
	private static void buildMap()
	{
<span class="fc" id="L290">		typeMap = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L291">		Class&lt;TokenFamily&gt; cl = TokenFamily.class;</span>
<span class="fc" id="L292">		Field[] fields = cl.getDeclaredFields();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">		for (Field field : fields)</span>
		{
<span class="fc" id="L295">			int mod = field.getModifiers();</span>

<span class="pc bpc" id="L297" title="1 of 6 branches missed.">			if (Modifier.isStatic(mod) &amp;&amp; Modifier.isFinal(mod) &amp;&amp; Modifier.isPublic(mod))</span>
			{
				try
				{
<span class="fc" id="L301">					Object o = field.get(null);</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">					if (cl.equals(o.getClass()))</span>
					{
<span class="fc" id="L304">						TokenFamily tObj = cl.cast(o);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">						if (typeMap.containsKey(tObj.rev))</span>
						{
<span class="nc" id="L307">							throw new UnreachableError(&quot;Attempt to redefine constant value &quot; + tObj.rev + &quot; to &quot;</span>
<span class="nc" id="L308">									+ field.getName() + &quot;, value was &quot; + typeMap.get(tObj.rev));</span>
						}
<span class="fc" id="L310">						typeMap.put(tObj.rev, tObj);</span>
					}
				}
<span class="nc" id="L313">				catch (IllegalArgumentException | IllegalAccessException e)</span>
				{
<span class="nc" id="L315">					throw new UnreachableError(&quot;Attempt to fetch field failed: &quot;, e);</span>
<span class="fc" id="L316">				}</span>
			}
		}
<span class="fc" id="L319">	}</span>

	/**
	 * Clears all of the Constants defined by this class. Note that this does
	 * not remove any Constants declared in the Constant class (as those are
	 * considered 'permanent' members of the Sequenced Constant collection.
	 * 
	 * Note that this *will not* reset the ordinal count, because that is a
	 * dangerous operation. As there could be outstanding references to
	 * constants that would be removed from the Constant pool, no reuse of
	 * ordinals is driven by this method. As a result, calling this method may
	 * result in a Constant Pool which does not have sequentially numbered
	 * ordinal values.
	 */
	public static void clearConstants()
	{
<span class="nc" id="L335">		buildMap();</span>
<span class="nc" id="L336">	}</span>

	/**
	 * Returns a Collection of all of the Constants for this class. The returned
	 * Collection is unmodifiable.
	 * 
	 * @return an unmodifiable Collection of all of the Constants for this class
	 */
	public static Collection&lt;TokenFamily&gt; getAllConstants()
	{
<span class="nc" id="L346">		return Collections.unmodifiableCollection(typeMap.values());</span>
	}

	@Override
	public int compareTo(TokenFamily tf)
	{
<span class="fc" id="L352">		return rev.compareTo(tf.rev);</span>
	}

	/*
	 * Note there is no reason to do .hashCode or .equals because this is Type
	 * Safe (meaning it can only build one object per Revision)
	 */

	@Override
	public String toString()
	{
<span class="nc" id="L363">		return &quot;Token Family: &quot; + rev.toString();</span>
	}

	@Override
	public boolean equals(Object obj)
	{
<span class="pc bpc" id="L369" title="2 of 6 branches missed.">		return obj == this || obj instanceof TokenFamily &amp;&amp; compareTo((TokenFamily) obj) == 0;</span>
	}

	@Override
	public int hashCode()
	{
<span class="nc" id="L375">		return rev.hashCode();</span>
	}

	public void clearTokens()
	{
<span class="fc" id="L380">		tokenMap.clear();</span>
<span class="fc" id="L381">		subTokenMap.clear();</span>
<span class="fc" id="L382">		deferredTokenList.clear();</span>
<span class="fc" id="L383">		preTokenMap.clear();</span>
<span class="fc" id="L384">	}</span>

	/**
	 * Returns all the DeferredTokens in this TokenLibrary.
	 * 
	 * @return A List of the DeferredToken in this TokenLibrary
	 */
	public List&lt;DeferredToken&lt;? extends Loadable&gt;&gt; getDeferredTokens()
	{
<span class="fc" id="L393">		return new ArrayList&lt;&gt;(deferredTokenList);</span>
	}

	/**
	 * Adds a new DeferredToken to this TokenLibrary.
	 * 
	 * @param newToken
	 *            The DeferredToken to be added to this TokenLibrary
	 */
	public void addDeferredToken(DeferredToken&lt;?&gt; newToken)
	{
<span class="fc" id="L404">		deferredTokenList.add(newToken);</span>
<span class="fc" id="L405">	}</span>

	/**
	 * Adds a new GroupDefinition to this TokenFamily. A GroupDefinition can
	 * produce an ObjectContainer (grouping of objects) based on an underlying
	 * set of requirements (typically defined in the Data Control file).
	 * 
	 * @param def
	 *            The GroupDefinition to be added to this TokenFamily.
	 */
	public void addGroupDefinition(GroupDefinition&lt;?&gt; def)
	{
<span class="fc" id="L417">		GroupDefinition&lt;?&gt; existingDef = groupDefinitionMap.put(def.getReferenceClass(), def.getPrimitiveName(), def);</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">		if (existingDef != null)</span>
		{
<span class="nc" id="L420">			Logging.errorPrint(&quot;Duplicate Group Definition in &quot; + def.getReferenceClass().getSimpleName() + &quot;: &quot;</span>
<span class="nc" id="L421">				+ def.getPrimitiveName() + &quot;. Classes were &quot; + existingDef.getClass().getName() + &quot; and &quot;</span>
<span class="nc" id="L422">				+ def.getClass().getName());</span>
		}
<span class="fc" id="L424">	}</span>

	/**
	 * Returns the GroupDefinition for the given Class, and with the given group
	 * name.
	 * 
	 * @param cl
	 *            The Class for which a token should be retrieved
	 * @param name
	 *            The name of the GroupDefinition to be retrieved
	 * @return the GroupDefinition for the given Class, and with the given group
	 *         name
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; GroupDefinition&lt;T&gt; getGroup(Class&lt;T&gt; cl, String name)
	{
<span class="fc" id="L440">		return (GroupDefinition&lt;T&gt;) groupDefinitionMap.get(cl, name);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>