<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractReferenceManufacturer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.cdom.reference</a> &gt; <span class="el_source">AbstractReferenceManufacturer.java</span></div><h1>AbstractReferenceManufacturer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007, 2008 (C) Tom Parker &lt;thpr@users.sourceforge.net&gt;
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package pcgen.cdom.reference;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.TreeMap;

import javax.swing.event.EventListenerList;

import pcgen.base.lang.CaseInsensitiveString;
import pcgen.base.util.BasicIndirect;
import pcgen.base.util.FixedStringList;
import pcgen.base.util.FormatManager;
import pcgen.base.util.HashMapToInstanceList;
import pcgen.base.util.Indirect;
import pcgen.base.util.KeyMap;
import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.base.CDOMReference;
import pcgen.cdom.base.ClassIdentity;
import pcgen.cdom.base.Loadable;
import pcgen.cdom.content.RollMethod;
import pcgen.cdom.inst.Dynamic;
import pcgen.util.Logging;
import pcgen.util.StringPClassUtil;

/**
 * An AbstractReferenceManufacturer is a concrete, but abstract object capable
 * of creating CDOMReferences of a given &quot;form&quot;. That &quot;form&quot; includes a specific
 * Class of Loadable, or a specific Class/Category for Categorized Loadable
 * (this class does not make distinction between the Class and Class/Categorized
 * cases)
 * 
 * The Class is designed to share significant common code between
 * implementations of the ReferenceManufacturer interface.
 * 
 * @param &lt;T&gt;
 *            The Class of object this AbstractReferenceManufacturer can
 *            manufacture
 */
public abstract class AbstractReferenceManufacturer&lt;T extends Loadable&gt; implements ReferenceManufacturer&lt;T&gt;
{

<span class="fc" id="L67">	private boolean isResolved = false;</span>

	private final ManufacturableFactory&lt;T&gt; factory;

	/**
	 * The &quot;ALL&quot; reference, if it is ever referenced. This ensures that only one
	 * &quot;ALL&quot; reference is ever built (and allows it to be reused if the
	 * reference is requested a second time). This also stores the reference so
	 * that it can be appropriately resolved when resolveReferences() is called.
	 */
	private CDOMGroupRef&lt;T&gt; allRef;

	/**
	 * Storage for &quot;TYPE&quot; references. This ensures that only one &quot;TYPE&quot;
	 * reference is ever built for any combination of Types. (and allows those
	 * references to be reused if a combination of types reference is requested
	 * a second time). This also stores the reference so that it can be
	 * appropriately resolved when resolveReferences() is called.
	 * 
	 * It is expected that the String array used as a key to this map conforms
	 * to the following rules: (1) The array does not contain null values (2)
	 * The array does not contain redundant values (3) The array is sorted in
	 * alphabetical order, as defined by the natural ordering of String (for
	 * simplicity [and due to lack of user presentation of this value] this sort
	 * does not correct for internationalization)
	 */
<span class="fc" id="L93">	private final Map&lt;FixedStringList, WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt;&gt; typeReferences =</span>
			new TreeMap&lt;&gt;(FixedStringList.CASE_INSENSITIVE_ORDER);

	/**
	 * Storage for individual references. This ensures that only one reference
	 * is ever built for any identifier. (and allows those references to be
	 * reused if a reference to an identifier is requested a second time). This
	 * also stores the reference so that it can be appropriately resolved when
	 * resolveReferences() is called.
	 */
<span class="fc" id="L103">	private final Map&lt;String, WeakReference&lt;CDOMSingleRef&lt;T&gt;&gt;&gt; referenced =</span>
			new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);

	/**
	 * Stores the active objects for this AbstractReferenceManufacturer. These
	 * are objects that have been constructed or imported into the
	 * AbstractReferenceManufacturer.
	 */
<span class="fc" id="L111">	private final KeyMap&lt;T&gt; active = new KeyMap&lt;&gt;();</span>

	/**
	 * Stores derivative objects (Those that are NOT created by this
	 * AbstractReferenceManufacturer and are NOT inserted into this
	 * AbstractReferenceManufacturer. However, these objects exist elsewhere,
	 * and need to be processed under certain conditions. The getAllObjects()
	 * method should NOT add this list to the items returned.
	 */
<span class="fc" id="L120">	private final List&lt;T&gt; derivatives = new ArrayList&lt;&gt;();</span>

	/**
	 * Stores the duplicate objects for identifiers in this
	 * AbstractReferenceManufacturer. Identifiers will only be stored in this
	 * Map if an identical identifier already exists in the active map. Also, if
	 * the gating object in the active map is removed, then the first
	 * &quot;duplicate&quot; in this MapToList should be removed and moved to the &quot;active&quot;
	 * map. This map should never contain an identifier which is not in the
	 * active map.
	 * 
	 * Due to extremely weak .equals() rules in many PObjects, this Map MUST be
	 * a HashMapToInstanceList. In the future, it may be exchanged for a
	 * TreeMapToList that leverages String.CASE_INSENSITIVE_ORDER; however, the
	 * instance behavior may be too important to make that swap without
	 * developing a MapToList that is backed by a TreeMap and also an
	 * &quot;InstanceList&quot;
	 */
<span class="fc" id="L138">	private final HashMapToInstanceList&lt;CaseInsensitiveString, T&gt; duplicates = new HashMapToInstanceList&lt;&gt;();</span>

	/**
	 * Contains a list of deferred objects. Identifiers for objects for which
	 * construction was deferred were inserted into the
	 * AbstractReferenceManufacturer using constructIfNecessary(String). Objects
	 * will be constructed when buildDeferredReferences() is called, if and only
	 * if no object with the matching identifier has been constructed or
	 * imported into this AbstractReferenceManufacturer.
	 */
<span class="fc" id="L148">	private final List&lt;String&gt; deferred = new ArrayList&lt;&gt;();</span>

	/**
	 * Contains a list of manufactured objects (those that are built implicitly
	 * by tokens like NATURALATTACKS). These can be &quot;displaced&quot; by object which
	 * are later built explicitly in a WeaponProf LST file, for example.
	 */
<span class="fc" id="L155">	private final List&lt;WeakReference&lt;T&gt;&gt; manufactured = new ArrayList&lt;&gt;();</span>

	/**
	 * The EventListenerList which contains the listeners to this
	 * AbstractReferenceManufacturer.
	 */
<span class="fc" id="L161">	private final EventListenerList listenerList = new EventListenerList();</span>

	/**
	 * Constructs a new AbstractReferenceManufacturer for the given Class.
	 * 
	 * @param fac
	 *            The ManufacturableFactory this AbstractReferenceManufacturer
	 *            will use to construct and reference objects
	 * @throws IllegalArgumentException
	 *             if the given Class is null or the given Class does not have a
	 *             public, zero argument constructor
	 * 
	 */
	public AbstractReferenceManufacturer(ManufacturableFactory&lt;T&gt; fac)
<span class="fc" id="L175">	{</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">		if (fac == null)</span>
		{
<span class="nc" id="L178">			throw new IllegalArgumentException(&quot;Factory for &quot; + getClass().getName() + &quot; cannot be null&quot;);</span>
		}
<span class="fc" id="L180">		factory = fac;</span>
<span class="fc" id="L181">	}</span>

	/**
	 * Gets a reference to the Class or Class/Context provided by this
	 * AbstractReferenceManufacturer. The reference will be a reference to the
	 * objects identified by the given types.
	 * 
	 * @param types
	 *            An array of the types of objects to which the returned
	 *            CDOMReference will refer.
	 * @return A CDOMGroupRef which is intended to contain objects of a given
	 *         Type for the Class or Class/Context this
	 *         AbstractReferenceManufacturer represents.
	 * @throws IllegalArgumentException
	 *             if any of the given Strings is null, empty (length is zero),
	 *             or contains a period (.), equals (=), comma (,) or pipe (|)
	 */
	@Override
	public CDOMGroupRef&lt;T&gt; getTypeReference(String... types)
	{
<span class="fc bfc" id="L201" title="All 2 branches covered.">		for (String type : types)</span>
		{
<span class="pc bpc" id="L203" title="2 of 4 branches missed.">			if (type == null || type.isEmpty())</span>
			{
<span class="nc" id="L205">				throw new IllegalArgumentException(</span>
					&quot;Attempt to acquire empty Type (the type String contains a null or empty element)&quot;);
			}
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">			if (type.indexOf('.') != -1)</span>
			{
<span class="nc" id="L210">				throw new IllegalArgumentException(&quot;Cannot build Reference with type containing a period: &quot; + type);</span>
			}
<span class="fc bfc" id="L212" title="All 2 branches covered.">			if (type.indexOf('=') != -1)</span>
			{
<span class="fc" id="L214">				throw new IllegalArgumentException(&quot;Cannot build Reference with type containing an equals: &quot; + type);</span>
			}
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">			if (type.indexOf(',') != -1)</span>
			{
<span class="nc" id="L218">				throw new IllegalArgumentException(&quot;Cannot build Reference with type containing a comma: &quot; + type);</span>
			}
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">			if (type.indexOf('|') != -1)</span>
			{
<span class="nc" id="L222">				throw new IllegalArgumentException(&quot;Cannot build Reference with type containing a pipe: &quot; + type);</span>
			}
		}
<span class="fc" id="L225">		Arrays.sort(types);</span>
<span class="fc" id="L226">		FixedStringList typeList = new FixedStringList(types);</span>
<span class="fc" id="L227">		WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt; ref = typeReferences.get(typeList);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">		if (ref != null)</span>
		{
<span class="fc" id="L230">			CDOMGroupRef&lt;T&gt; trt = ref.get();</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">			if (trt != null)</span>
			{
<span class="fc" id="L233">				return trt;</span>
			}
		}
		// Didn't find the appropriate key, create new
<span class="fc" id="L237">		CDOMGroupRef&lt;T&gt; cgr = factory.getTypeReference(types);</span>
<span class="fc" id="L238">		typeReferences.put(typeList, new WeakReference&lt;&gt;(cgr));</span>
<span class="fc" id="L239">		return cgr;</span>
	}

	/**
	 * Returns a CDOMGroupRef for the given Class or Class/Context provided by
	 * this AbstractReferenceManufacturer.
	 * 
	 * @return A CDOMGroupRef which is intended to contain all the objects of
	 *         the Class or Class/Context this AbstractReferenceManufacturer
	 *         represents.
	 */
	@Override
	public CDOMGroupRef&lt;T&gt; getAllReference()
	{
<span class="fc bfc" id="L253" title="All 2 branches covered.">		if (allRef == null)</span>
		{
<span class="fc" id="L255">			allRef = factory.getAllReference();</span>
		}
<span class="fc" id="L257">		return allRef;</span>
	}

	/**
	 * The class of object this AbstractReferenceManufacturer represents.
	 * 
	 * @return The class of object this AbstractReferenceManufacturer
	 *         represents.
	 */
	@Override
	public Class&lt;T&gt; getReferenceClass()
	{
<span class="fc" id="L269">		return factory.getReferenceClass();</span>
	}

	/**
	 * Resolves the references that have been requested from this
	 * AbstractReferenceManufacturer, using the objects contained within this
	 * AbstractReferenceManufacturer.
	 * 
	 * This method guarantees that all references are resolved.
	 * 
	 * Note: Implementations of AbstractReferenceManufacturer may place limits
	 * on the number of times resolveReferences() can be called. The reason for
	 * this is that some references may only be resolved once, and the
	 * AbstractReferenceManufacturer is not required to maintain a list of
	 * references that have been resolved and those which have not been
	 * resolved.
	 */
	@Override
	public boolean resolveReferences(UnconstructedValidator validator)
	{
<span class="fc" id="L289">		boolean resolutionSuccessful = resolvePrimitiveReferences(validator);</span>
<span class="fc" id="L290">		resolutionSuccessful &amp;= resolveGroupReferences();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">		for (WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt; ref : typeReferences.values())</span>
		{
<span class="fc" id="L293">			CDOMGroupRef&lt;T&gt; trt = ref.get();</span>
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">			if (trt != null &amp;&amp; trt.getObjectCount() == 0)</span>
			{
<span class="fc" id="L296">				Logging.errorPrint(&quot;Error: No &quot; + factory.getReferenceDescription() + &quot; objects of &quot;</span>
<span class="fc" id="L297">					+ trt.getLSTformat(false) + &quot; were loaded but were referred to in the data&quot;);</span>
<span class="fc" id="L298">				fireUnconstuctedEvent(trt);</span>
<span class="fc" id="L299">				resolutionSuccessful = false;</span>
			}
<span class="fc" id="L301">		}</span>
<span class="fc" id="L302">		isResolved = true;</span>
<span class="fc" id="L303">		return resolutionSuccessful;</span>
	}

	private boolean resolvePrimitiveReferences(UnconstructedValidator validator)
	{
<span class="fc" id="L308">		boolean resolutionSuccessful = true;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">		for (Entry&lt;String, WeakReference&lt;CDOMSingleRef&lt;T&gt;&gt;&gt; me1 : referenced.entrySet())</span>
		{
<span class="fc" id="L311">			CDOMSingleRef&lt;T&gt; value = me1.getValue().get();</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">			if (value != null)</span>
			{
<span class="fc" id="L314">				resolutionSuccessful &amp;= factory.resolve(this, me1.getKey(), value, validator);</span>
			}
<span class="fc" id="L316">		}</span>
<span class="fc" id="L317">		return resolutionSuccessful;</span>
	}

	private boolean resolveGroupReferences()
	{
<span class="fc bfc" id="L322" title="All 2 branches covered.">		for (T obj : getAllObjects())</span>
		{
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (allRef != null)</span>
			{
<span class="fc" id="L326">				allRef.addResolution(obj);</span>
			}
<span class="fc bfc" id="L328" title="All 2 branches covered.">			for (Map.Entry&lt;FixedStringList, WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt;&gt; me : typeReferences.entrySet())</span>
			{
<span class="fc" id="L330">				CDOMGroupRef&lt;T&gt; trt = me.getValue().get();</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">				if (trt != null)</span>
				{
<span class="fc" id="L333">					boolean typeOkay = true;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">					for (String type : me.getKey())</span>
					{
<span class="fc bfc" id="L336" title="All 2 branches covered.">						if (!obj.isType(type))</span>
						{
<span class="fc" id="L338">							typeOkay = false;</span>
<span class="fc" id="L339">							break;</span>
						}
<span class="fc" id="L341">					}</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">					if (typeOkay)</span>
					{
<span class="fc" id="L344">						trt.addResolution(obj);</span>
					}
				}
<span class="fc" id="L347">			}</span>
<span class="fc" id="L348">		}</span>
<span class="fc bfc" id="L349" title="All 4 branches covered.">		if (allRef != null &amp;&amp; allRef.getObjectCount() == 0)</span>
		{
<span class="fc" id="L351">			Logging.errorPrint(&quot;Error: No &quot; + factory.getReferenceDescription()</span>
				+ &quot; objects were loaded but were referred to in the data&quot;);
<span class="fc" id="L353">			fireUnconstuctedEvent(allRef);</span>
<span class="fc" id="L354">			return false;</span>
		}
<span class="fc" id="L356">		return true;</span>
	}

	/**
	 * Adds an object to the contents of this AbstractReferenceManufacturer.
	 * This is used in conditions where this AbstractReferenceManufacturer was
	 * not used to construct the object.
	 * 
	 * Implementation Note: There are various situations where this &quot;external
	 * construction&quot; may happen - the primary one being loading of &quot;game mode&quot;
	 * information like CDOMStat objects.
	 * 
	 * @param item
	 *            The object to be imported into this
	 *            AbstractReferenceManufacturer
	 * @param key
	 *            The identifier of the object to be imported into this
	 *            AbstractReferenceManufacturer
	 * @throws IllegalArgumentException
	 *             if the given object is not of the Class that this
	 *             AbstractReferenceManufacturer constructs and references
	 */
	@Override
	public void addObject(T item, String key)
	{
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (!factory.isMember(item))</span>
		{
<span class="nc" id="L383">			throw new IllegalArgumentException(</span>
<span class="nc" id="L384">				&quot;Attempted to register a &quot; + item.getClass().getName() + &quot; in &quot; + factory.getReferenceDescription());</span>
		}
<span class="fc" id="L386">		T current = active.get(key);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">		if (current == null)</span>
		{
<span class="fc" id="L389">			active.put(key, item);</span>
		}
		else
		{
<span class="fc" id="L393">			duplicates.addToListFor(new CaseInsensitiveString(key), item);</span>
		}
<span class="fc" id="L395">	}</span>

	/**
	 * Gets the object represented by the given identifier. Will return null if
	 * an object with the given identifier is not present in this
	 * AbstractReferenceManufacturer. Does not make any test to check if the
	 * given identifier has multiple matching objects.
	 * 
	 * Note that this is testing *object* presence. This will not return an
	 * object if a reference for the given identifier has been requested; it
	 * will only return true if an object with the given identifier has actually
	 * been constructed by or imported into this AbstractReferenceManufacturer.
	 * 
	 * @param key
	 *            identifier of the object to be returned
	 * @return The object stored in this AbstractReferenceManufacturer with the
	 *         given identifier, or null if this AbstractReferenceManufacturer
	 *         does not contain an object with the given identifier.
	 */
	@Override
	public T getActiveObject(String key)
	{
<span class="fc" id="L417">		return active.get(key);</span>
	}

	/**
	 * Gets the object represented by the given identifier. Will return null if
	 * an object with the given identifier is not present in this
	 * AbstractReferenceManufacturer.
	 * 
	 * Note that this is testing *object* presence. This will not return an
	 * object if a reference for the given identifier has been requested; it
	 * will only return true if an object with the given identifier has actually
	 * been constructed by or imported into this AbstractReferenceManufacturer.
	 * 
	 * @param key
	 *            identifier of the object to be returned
	 * @return The object stored in this AbstractReferenceManufacturer with the
	 *         given identifier, or null if this AbstractReferenceManufacturer
	 *         does not contain an object with the given identifier.
	 */
	@Override
	public T getObject(String key)
	{
<span class="fc" id="L439">		T po = active.get(key);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">		if (po != null)</span>
		{
<span class="fc" id="L442">			List&lt;T&gt; list = duplicates.getListFor(new CaseInsensitiveString(key));</span>
<span class="pc bpc" id="L443" title="3 of 4 branches missed.">			if ((list != null) &amp;&amp; !list.isEmpty())</span>
			{
<span class="nc" id="L445">				Logging.errorPrint(</span>
<span class="nc" id="L446">					&quot;Reference to Constructed &quot; + factory.getReferenceDescription() + &quot; &quot; + key + &quot; is ambiguous&quot;);</span>
<span class="nc" id="L447">				StringBuilder sb = new StringBuilder(1000);</span>
<span class="nc" id="L448">				sb.append(&quot;Locations: &quot;);</span>
<span class="nc" id="L449">				sb.append(po.getSourceURI());</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">				for (T dupe : list)</span>
				{
<span class="nc" id="L452">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L453">					sb.append(dupe.getSourceURI());</span>
<span class="nc" id="L454">				}</span>
<span class="nc" id="L455">				Logging.errorPrint(sb.toString());</span>
			}
<span class="fc" id="L457">			return po;</span>
		}
<span class="fc" id="L459">		return null;</span>
	}

	/**
	 * Constructs a new Loadable of the Class or Class/Category represented by
	 * this AbstractReferenceManufacturer. This also adds the object to the list
	 * of constructed objects within this AbstractReferenceManufacturer.
	 * 
	 * Implementation Note: At this point, the &quot;key&quot; provided is likely to be
	 * the &quot;display name&quot; of an object, not the actual &quot;KEY&quot;. This is due to the
	 * need to construct an object at the time it is first encountered, which is
	 * probably not the time at which the KEY is known (the intent is not to do
	 * &quot;lookahead&quot;, as it fails under .MOD conditions anyway). In order to
	 * &quot;rename&quot; an object once a KEY is encountered, see renameObject(String, T)
	 * 
	 * @param key
	 *            The identifier of the Loadable to be constructed
	 * @return The new Loadable of the Class or Class/Category represented by
	 *         this AbstractReferenceManufacturer
	 * @throws IllegalArgumentException
	 *             if the given identifier is null or empty (length is zero)
	 */
	@Override
	public T constructObject(String key)
	{
<span class="fc" id="L484">		T obj = buildObject(key);</span>
<span class="fc" id="L485">		addObject(obj, key);</span>
<span class="fc" id="L486">		return obj;</span>
	}

	/**
	 * Constructs a new Loadable of the Class or Class/Category represented by
	 * this AbstractReferenceManufacturer
	 * 
	 * This should remain protected (vs. public) as it is for &quot;internal use
	 * only&quot;; it serves as a convenience method to wrap the .newInstance call
	 * and the possible Exceptions. Other classes should use
	 * constructObject(String)
	 * 
	 * @param key
	 *            The identifier of the Loadable to be constructed
	 * @return The new Loadable of the Class or Class/Category represented by
	 *         this AbstractReferenceManufacturer
	 * @throws IllegalArgumentException
	 *             if the given identifier is null or empty (length is zero)
	 */
	@Override
	public T buildObject(String key)
	{
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">		if (key == null || key.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L510">			throw new IllegalArgumentException(&quot;Cannot build empty name&quot;);</span>
		}
<span class="fc" id="L512">		T obj = factory.newInstance();</span>
<span class="fc" id="L513">		obj.setName(key);</span>
<span class="fc" id="L514">		return obj;</span>
	}

	/**
	 * Changes the identifier for a given object, as stored in this
	 * AbstractReferenceManufacturer.
	 * 
	 * @param key
	 *            The new identifier to be used for the given object
	 * @param item
	 *            The object for which the identifier in this
	 *            AbstractReferenceManufacturer should be changed
	 */
	@Override
	public void renameObject(String key, T item)
	{
<span class="fc" id="L530">		String oldKey = item.getKeyName();</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">		if (oldKey.equalsIgnoreCase(key))</span>
		{
<span class="nc bnc" id="L533" title="All 2 branches missed.">			if (Logging.isDebugMode())</span>
			{
<span class="nc" id="L535">				Logging.debugPrint(&quot;Worthless Key change encountered: &quot; + item.getDisplayName() + &quot; &quot; + oldKey);</span>
<span class="nc" id="L536">				Logging.reportSource(Logging.DEBUG, item.getSourceURI());</span>
			}
		}
<span class="fc" id="L539">		forgetObject(item);</span>
<span class="fc" id="L540">		addObject(item, key);</span>
<span class="fc" id="L541">	}</span>

	/**
	 * Remove the given object from this AbstractReferenceManufacturer. Returns
	 * true if the object was removed from this AbstractReferenceManufacturer;
	 * false otherwise.
	 * 
	 * @param item
	 *            The object to be removed from this
	 *            AbstractReferenceManufacturer.
	 * @return true if the object was removed from this
	 *         AbstractReferenceManufacturer; false otherwise.
	 */
	@Override
	public boolean forgetObject(T item)
	{
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">		if (!factory.isMember(item))</span>
		{
<span class="nc" id="L559">			throw new IllegalArgumentException(</span>
				&quot;Object to be forgotten does not match Class &quot; + &quot;of this AbstractReferenceManufacturer&quot;);
		}
<span class="fc" id="L562">		String key = active.getKeyFor(item);</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">		if (key == null)</span>
		{
			/*
			 * TODO This is a bug - the key name is not necessarily loaded into
			 * the object, it may have been consumed by the object context... :P
			 */
<span class="nc" id="L569">			CaseInsensitiveString ocik = new CaseInsensitiveString(item.getKeyName());</span>
<span class="nc" id="L570">			duplicates.removeFromListFor(ocik, item);</span>
<span class="nc" id="L571">		}</span>
		else
		{
<span class="fc" id="L574">			CaseInsensitiveString ocik = new CaseInsensitiveString(key);</span>
<span class="fc" id="L575">			List&lt;T&gt; list = duplicates.getListFor(ocik);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">			if (list == null)</span>
			{
				// No replacement
<span class="fc" id="L579">				active.remove(key);</span>
			}
			else
			{
<span class="fc" id="L583">				T newActive = duplicates.getElementInList(ocik, 0);</span>
<span class="fc" id="L584">				duplicates.removeFromListFor(ocik, newActive);</span>
<span class="fc" id="L585">				active.put(key, newActive);</span>
			}
		}
<span class="fc" id="L588">		return true;</span>
	}

	/**
	 * Returns true if this AbstractReferenceManufacturer contains an object of
	 * the Class or Class/Category represented by this
	 * AbstractReferenceManufacturer.
	 * 
	 * Note that this is testing *object* presence. This will not return true if
	 * a reference for the given identifier has been requested; it will only
	 * return true if an object with the given identifier has actually been
	 * constructed by or imported into this AbstractReferenceManufacturer.
	 * 
	 * @param key
	 *            The identifier of the object to be checked if it is present in
	 *            this AbstractReferenceManufacturer.
	 * @return true if this AbstractReferenceManufacturer contains an object of
	 *         the Class or Class/Category represented by this
	 *         AbstractReferenceManufacturer; false otherwise.
	 */
	@Override
	public boolean containsObjectKeyed(String key)
	{
<span class="nc" id="L611">		return active.containsKey(key);</span>
	}

	/**
	 * Gets a reference to the Class or Class/Context provided by this
	 * AbstractReferenceManufacturer. The reference will be a reference to the
	 * object identified by the given key.
	 * 
	 * @param key
	 *            The key used to identify the object to which the returned
	 *            CDOMReference will refer.
	 * @return A CDOMReference that refers to the object identified by the given
	 *         key
	 * @throws IllegalArgumentException
	 *             if the given key is null or empty
	 */
	@Override
	public CDOMSingleRef&lt;T&gt; getReference(String key)
	{
		/*
		 * TODO This is incorrect, but a hack for now :)
		 * 
		 * Mainly this throws around IllegalArgumentException in order to catch
		 * bad parsing issues (design flaws in the code). Not sure if we want to
		 * continue that long term? Once tokens are truly tested this may not be
		 * necessary or desirable.
		 */
<span class="fc" id="L638">		Objects.requireNonNull(key, &quot;Cannot request a reference to null identifier&quot;);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">		if (key.isEmpty())</span>
		{
<span class="fc" id="L641">			throw new IllegalArgumentException(&quot;Cannot request a reference to an empty identifier&quot;);</span>
		}
		/*
		 * Items thrown below this point are for protection from coding errors
		 * in LST files, not part of the public interface of this method
		 */
		try
		{
<span class="fc" id="L649">			Integer.parseInt(key);</span>
<span class="fc" id="L650">			throw new IllegalArgumentException(&quot;A number cannot be a valid single item: &quot; + key);</span>
		}
<span class="fc" id="L652">		catch (NumberFormatException nfe)</span>
		{
			// ok
		}
<span class="fc bfc" id="L656" title="All 2 branches covered.">		if (key.contains(&quot;=&quot;))</span>
		{
<span class="fc" id="L658">			throw new IllegalArgumentException(&quot;= cannot be a in valid single item (perhaps something like TYPE= &quot;</span>
				+ &quot;is not supported in this token?): &quot; + key);
		}
<span class="fc bfc" id="L661" title="All 2 branches covered.">		if (key.equalsIgnoreCase(&quot;ANY&quot;))</span>
		{
<span class="fc" id="L663">			throw new IllegalArgumentException(&quot;Any cannot be a valid single item (not supported in this token?)&quot;);</span>
		}
<span class="fc bfc" id="L665" title="All 2 branches covered.">		if (key.equalsIgnoreCase(&quot;ALL&quot;))</span>
		{
<span class="fc" id="L667">			throw new IllegalArgumentException(&quot;All cannot be a valid single item (not supported in this token?)&quot;);</span>
		}
<span class="fc bfc" id="L669" title="All 2 branches covered.">		if (key.contains(&quot;:&quot;))</span>
		{
<span class="fc" id="L671">			throw new IllegalArgumentException(&quot;: cannot exist in a valid single item (did you try to use a &quot;</span>
				+ &quot;PRE where it is not supported?) &quot; + key);
		}
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">		if (key.equalsIgnoreCase(&quot;%LIST&quot;))</span>
		{
<span class="nc" id="L676">			throw new IllegalArgumentException(&quot;%LIST cannot be a valid single item (not supported in this token?)&quot;);</span>
		}

<span class="fc" id="L679">		WeakReference&lt;CDOMSingleRef&lt;T&gt;&gt; wr = referenced.get(key);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">		if (wr != null)</span>
		{
<span class="fc" id="L682">			CDOMSingleRef&lt;T&gt; ref = wr.get();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">			if (ref != null)</span>
			{
<span class="fc" id="L685">				return ref;</span>
			}
		}
		CDOMSingleRef&lt;T&gt; ref;
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">		if (isResolved)</span>
		{
<span class="nc" id="L691">			T current = active.get(key);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">			if (current == null)</span>
			{
<span class="nc" id="L694">				throw new IllegalArgumentException(</span>
					key + &quot; is not valid post-resolution &quot; + &quot;because it was never constructed&quot;);
			}
<span class="nc" id="L697">			ref = CDOMDirectSingleRef.getRef(current);</span>
<span class="nc" id="L698">		}</span>
		else
		{
<span class="fc" id="L701">			CDOMSingleRef&lt;T&gt; lr = factory.getReference(key);</span>
<span class="fc" id="L702">			referenced.put(key, new WeakReference&lt;&gt;(lr));</span>
<span class="fc" id="L703">			ref = lr;</span>
		}
<span class="fc" id="L705">		return ref;</span>
	}

	/**
	 * Returns true if this AbstractReferenceManufacturer is &quot;valid&quot;. A &quot;valid&quot;
	 * AbstractReferenceManufacturer is one where all of the following are true:
	 * 
	 * (1) Any object stored in the AbstractReferenceManufacturer reports that
	 * it's KEY (as defined by Loadable.getKeyName()) matches the identifier
	 * used to store the object in the AbstractReferenceManufacturer.
	 * 
	 * (2) All objects stored in the ReferenceManufacturer have valid names
	 * (do not use illegal characters in the names)
	 * 
	 * (3) No two objects in the AbstractReferenceManufacturer have a matching
	 * identifier.
	 * 
	 * @param validator
	 *            UnconstructedValidator which can suppress unconstructed
	 *            reference warnings
	 * 
	 * @return true if the AbstractReferenceManufacturer is &quot;valid&quot;; false
	 *         otherwise.
	 */
	@Override
	public boolean validate(UnconstructedValidator validator)
	{
<span class="fc" id="L732">		boolean returnGood = true;</span>
<span class="pc bpc" id="L733" title="3 of 4 branches missed.">		if (validator == null || !validator.allowDuplicates(getReferenceClass()))</span>
		{
<span class="fc" id="L735">			returnGood = validateDuplicates();</span>
		}
<span class="fc" id="L737">		returnGood &amp;= validateNames();</span>
<span class="fc" id="L738">		returnGood &amp;= validateActive();</span>
<span class="fc" id="L739">		return returnGood;</span>
	}

	private boolean validateNames()
	{
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">		if (!Logging.isLoggable(Logging.LST_WARNING))</span>
		{
<span class="nc" id="L746">			return true;</span>
		}
<span class="fc bfc" id="L748" title="All 2 branches covered.">		for (String key : active.keySet())</span>
		{
<span class="fc" id="L750">			T value = active.get(key);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">			if (value.isInternal())</span>
			{
<span class="fc" id="L753">				continue;</span>
			}
			/*
			 * http://wiki.pcgen.org/index.php?title=Data_LST_Standards
			 * 
			 * Characters which should never be used in object names are Commas
			 * (,), Pipes (|), Backslashes (\), Colons (:), Semicolons (;),
			 * Periods (.), Brackets ([]), Percent (%), Asterisk (*) and Equals
			 * (=).
			 */
<span class="pc bpc" id="L763" title="3 of 4 branches missed.">			if (key.indexOf(',') != -1 &amp;&amp; factory.getReferenceClass() != RollMethod.class)</span>
			{
<span class="nc" id="L765">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a comma &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">			if (key.indexOf('|') != -1)</span>
			{
<span class="nc" id="L770">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a pipe &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">			if (key.indexOf('\\') != -1)</span>
			{
<span class="nc" id="L775">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a backslash &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">			if (key.indexOf(':') != -1)</span>
			{
<span class="nc" id="L780">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a colon &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">			if (key.indexOf(';') != -1)</span>
			{
<span class="nc" id="L785">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a semicolon &quot; + &quot;(prohibited character in a key)&quot;);
			}
			// if (key.indexOf('.') != -1)
			// {
			// Logging.log(Logging.LST_WARNING, &quot;Found &quot;
			// + getReferenceDescription() + &quot; with KEY: &quot; + key
			// + &quot; which contains a period &quot;
			// + &quot;(prohibited character in a key)&quot;);
			// }
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">			if (key.indexOf('%') != -1)</span>
			{
<span class="nc" id="L797">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a percent sign &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">			if (key.indexOf('*') != -1)</span>
			{
<span class="nc" id="L802">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains an asterisk &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">			if (key.indexOf('=') != -1)</span>
			{
<span class="nc" id="L807">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains an equals sign &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="pc bpc" id="L810" title="2 of 4 branches missed.">			if ((key.indexOf('[') != -1) || (key.indexOf(']') != -1))</span>
			{
<span class="nc" id="L812">				Logging.log(Logging.LST_WARNING, &quot;Found &quot; + factory.getReferenceDescription() + &quot; with KEY: &quot; + key</span>
					+ &quot; which contains a bracket  &quot; + &quot;(prohibited character in a key)&quot;);
			}
<span class="fc" id="L815">		}</span>
<span class="fc" id="L816">		return true;</span>
	}

	private boolean validateActive()
	{
<span class="fc" id="L821">		boolean returnGood = true;</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">		for (Object second : active.keySet())</span>
		{
<span class="fc" id="L824">			T activeObj = active.get(second);</span>
<span class="fc" id="L825">			String keyName = activeObj.getKeyName();</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">			if (keyName == null)</span>
			{
<span class="nc" id="L828">				Logging.errorPrint(activeObj.getClass() + &quot; &quot; + activeObj.getDisplayName() + &quot; has a null KeyName&quot;);</span>
			}
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">			else if (!keyName.equalsIgnoreCase(second.toString()))</span>
			{
<span class="nc" id="L832">				Logging.errorPrint(getReferenceDescription() + &quot; Magical Key Change: &quot; + second + &quot; to &quot; + keyName);</span>
<span class="nc" id="L833">				returnGood = false;</span>
			}
<span class="fc" id="L835">		}</span>
<span class="fc" id="L836">		return returnGood;</span>
	}

	private boolean validateDuplicates()
	{
<span class="fc" id="L841">		boolean returnGood = true;</span>
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">		for (CaseInsensitiveString second : duplicates.getKeySet())</span>
		{
<span class="nc" id="L844">			List&lt;T&gt; list = duplicates.getListFor(second);</span>
<span class="nc" id="L845">			T good = active.get(second.toString());</span>
			/*
			 * CONSIDER Should get CDOMObject reference out of here :(
			 */
<span class="nc bnc" id="L849" title="All 2 branches missed.">			if (good instanceof CDOMObject cdo)</span>
			{
<span class="nc bnc" id="L851" title="All 2 branches missed.">				for (T dupe : list)</span>
                {
<span class="nc bnc" id="L853" title="All 2 branches missed.">                    if (cdo.isCDOMEqual((CDOMObject) dupe))</span>
                    {
<span class="nc bnc" id="L855" title="All 2 branches missed.">                        for (Iterator&lt;WeakReference&lt;T&gt;&gt; it = manufactured.iterator();it.hasNext();)</span>
                        {
<span class="nc" id="L857">                            WeakReference&lt;T&gt; wr = it.next();</span>
<span class="nc" id="L858">                            T mfg = wr.get();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                            if (mfg == null)</span>
                            {
<span class="nc" id="L861">                                it.remove();</span>
                            }
                            // Yes this is instance equality, not .equals
<span class="nc bnc" id="L864" title="All 2 branches missed.">                            else if (mfg == good)</span>
                            {
<span class="nc" id="L866">                                forgetObject(good);</span>
<span class="nc" id="L867">                                break;</span>
                            }
<span class="nc" id="L869">                        }</span>
                    }
<span class="nc" id="L871">                }</span>
			}
<span class="nc bnc" id="L873" title="All 2 branches missed.">			if (duplicates.containsListFor(second))</span>
			{
<span class="nc" id="L875">				Logging.errorPrint(&quot;More than one &quot; + factory.getReferenceDescription() + &quot; with key/name &quot;</span>
<span class="nc" id="L876">					+ good.getKeyName() + &quot; was built&quot;);</span>
<span class="nc" id="L877">				List&lt;T&gt; dupes = duplicates.getListFor(second);</span>
<span class="nc" id="L878">				StringBuilder sb = new StringBuilder(1000);</span>
<span class="nc" id="L879">				sb.append(&quot;Sources: &quot;);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">				sb.append(good.isInternal() ? &quot;&lt;internal&gt;&quot; : good.getSourceURI());</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">				for (T dupe : dupes)</span>
				{
<span class="nc bnc" id="L883" title="All 2 branches missed.">					sb.append(&quot;, &quot;).append(dupe.isInternal() ? &quot;&lt;internal&gt;&quot; : dupe.getSourceURI());</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">					if (!dupe.getKeyName().equals(good.getKeyName()))</span>
					{
<span class="nc" id="L886">						Logging.errorPrint(&quot;Key case differed for &quot; + dupe.getKeyName());</span>
					}
<span class="nc" id="L888">				}</span>
<span class="nc" id="L889">				Logging.errorPrint(sb.toString());</span>
<span class="nc" id="L890">				returnGood = false;</span>
			}
<span class="nc" id="L892">		}</span>
<span class="fc" id="L893">		return returnGood;</span>
	}

	/**
	 * Instructs the AbstractReferenceManufacturer that the object with the
	 * given identifer should be constructed automatically if it is necessary
	 * when buildDeferredObjects() is called. The object will be constructed
	 * only if no object with the matching identifier has been constructed or
	 * imported into this AbstractReferenceManufacturer.
	 * 
	 * Implementation Note: This is generally used for backwards compatibility
	 * to previous versions of PCGen or to items that are built automatically
	 * (such as Weapon Proficiencies for Natural Attacks)
	 * 
	 * @param key
	 *            The identifier of the Loadable to be built (if otherwise not
	 *            constructed or imported into this
	 *            AbstractReferenceManufacturer) when buildDeferredObjects() is
	 *            called.
	 */
	@Override
	public void constructIfNecessary(String key)
	{
		/*
		 * TODO FIXME Need to ensure that items that are built here are tagged
		 * as manufactured, so that they are not written out to LST files
		 */
<span class="fc" id="L920">		deferred.add(key);</span>
<span class="fc" id="L921">	}</span>

	/**
	 * Returns a Collection of all of the objects contained in this
	 * AbstractReferenceManufacturer, sorted by their Key Name. This will not
	 * return null, it will return an empty list if no objects have been
	 * constructed by or imported into this AbstractReferenceManufacturer.
	 * 
	 * @return A sorted Collection of all of the objects contained in this
	 *         AbstractReferenceManufacturer
	 */
	@Override
	public Collection&lt;T&gt; getAllObjects()
	{
<span class="fc" id="L935">		return active.keySortedValues();</span>
	}

	/**
	 * Builds any objects whose construction was deferred. Identifiers for
	 * objects for which construction was deferred were inserted into the
	 * AbstractReferenceManufacturer using constructIfNecessary(String). Objects
	 * will be constructed only if no object with the matching identifier has
	 * been constructed or imported into this AbstractReferenceManufacturer.
	 * 
	 * Construction or import into the AbstractReferenceManufacturer could occur
	 * at any time before buildDeferredObjects() is called, either before or
	 * after constructIfNecessary(String) was called with the relevant
	 * identifier. However, construction or import of an object with an
	 * identical identifier after buildDeferredObjects() is called will result
	 * in a duplicate object being formed. AbstractReferenceManufacturer is not
	 * responsible for deleting automatically built objects under those
	 * conditions.
	 */
	@Override
	public void buildDeferredObjects()
	{
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">		for (String cis : deferred)</span>
		{
<span class="nc bnc" id="L959" title="All 2 branches missed.">			if (!active.containsKey(cis))</span>
			{
<span class="nc" id="L961">				constructObject(cis);</span>
			}
<span class="nc" id="L963">		}</span>
<span class="fc" id="L964">	}</span>

	/**
	 * Returns a Collection of the &quot;TYPE&quot; references for this
	 * AbstractReferenceManufacturer.
	 * 
	 * This method is value-semantic in that ownership of the returned
	 * Collection is transferred to the class calling this method. Modification
	 * of the returned Collection will not modify the &quot;TYPE&quot; references for this
	 * AbstractReferenceManufacturer and modification of the &quot;TYPE&quot; references
	 * for this AbstractReferenceManufacturer through subsequent calls of
	 * getTypeReference(String...) will not modify the returned Collection.
	 * 
	 * This method will not return null, even if getTypeReference(String...)
	 * method was never called.
	 * 
	 * @return A Collection of the &quot;TYPE&quot; references for this
	 *         AbstractReferenceManufacturer.
	 */
	protected Collection&lt;CDOMGroupRef&lt;T&gt;&gt; getTypeReferences()
	{
<span class="fc" id="L985">		List&lt;CDOMGroupRef&lt;T&gt;&gt; list = new ArrayList&lt;&gt;(typeReferences.size());</span>
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">		for (Iterator&lt;WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt;&gt; it = typeReferences.values().iterator(); it.hasNext();)</span>
		{
<span class="nc" id="L988">			WeakReference&lt;CDOMGroupRef&lt;T&gt;&gt; wr = it.next();</span>
<span class="nc" id="L989">			CDOMGroupRef&lt;T&gt; trt = wr.get();</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">			if (trt == null)</span>
			{
<span class="nc" id="L992">				it.remove();</span>
			}
			else
			{
<span class="nc" id="L996">				list.add(trt);</span>
			}
<span class="nc" id="L998">		}</span>
<span class="fc" id="L999">		return list;</span>
	}

	/**
	 * Returns a Collection of the primitive references for this
	 * AbstractReferenceManufacturer.
	 * 
	 * This method is value-semantic in that ownership of the returned
	 * Collection is transferred to the class calling this method. Modification
	 * of the returned Collection will not modify the primitive references for
	 * this AbstractReferenceManufacturer and modification of the primitive
	 * references for this AbstractReferenceManufacturer through subsequent
	 * calls of getReference(String) will not modify the returned Collection.
	 * 
	 * This method will not return null, even if getReference(String) method was
	 * never called.
	 * 
	 * @return A Collection of the primitive references for this
	 *         AbstractReferenceManufacturer.
	 */
	@Override
	public Collection&lt;CDOMSingleRef&lt;T&gt;&gt; getReferenced()
	{
<span class="fc" id="L1022">		List&lt;CDOMSingleRef&lt;T&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">		for (WeakReference&lt;CDOMSingleRef&lt;T&gt;&gt; wr : referenced.values())</span>
		{
<span class="nc" id="L1025">			CDOMSingleRef&lt;T&gt; ref = wr.get();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			if (ref != null)</span>
			{
<span class="nc" id="L1028">				list.add(ref);</span>
			}
<span class="nc" id="L1030">		}</span>
<span class="fc" id="L1031">		return list;</span>
	}

	/**
	 * Injects all objects from the given ReferenceManufacturer into this
	 * AbstractReferenceManufacturer. Effectively this is a bulk addObject for
	 * all of the objects contained in the given ReferenceManufacturer.
	 * 
	 * Note that this imports only the objects, and NOT references. This
	 * AbstractReferenceManufacturer does inherit any deferred objects
	 * (triggered through constructIfNecessary) from the given
	 * ReferenceManufacturer.
	 * 
	 * @param arm
	 *            The ReferenceManufacturer from which the objects should be
	 *            imported into this AbstractReferenceManufacturer
	 */
	@Override
	public void injectConstructed(ReferenceManufacturer&lt;T&gt; arm)
	{
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">		for (T value : active.keySortedValues())</span>
		{
<span class="nc" id="L1053">			arm.addObject(value, active.getKeyFor(value));</span>
<span class="nc" id="L1054">		}</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">		for (CaseInsensitiveString cis : duplicates.getKeySet())</span>
		{
<span class="nc bnc" id="L1057" title="All 2 branches missed.">			for (T obj : duplicates.getListFor(cis))</span>
			{
<span class="nc" id="L1059">				arm.addObject(obj, cis.toString());</span>
<span class="nc" id="L1060">			}</span>
<span class="nc" id="L1061">		}</span>
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">		for (String s : deferred)</span>
		{
<span class="nc" id="L1064">			arm.constructIfNecessary(s);</span>
<span class="nc" id="L1065">		}</span>
<span class="fc" id="L1066">	}</span>

	/**
	 * Triggers immediate construction of the object with the given identifier
	 * if it does not exist. This is an alternative to constructIfNecessary that
	 * should be used sparingly (generally direct access like this is higher
	 * risk, but necessary in some cases)
	 * 
	 * Note that use of this method is inherently risky when taken in context to
	 * .MOD and .COPY. Changes to keys may change the object to which an
	 * identifier refers. Therefore, any resolution that should take place at
	 * runtime should use getReference and resolve the reference.
	 * 
	 * The object will be constructed only if no object with the matching
	 * identifier has been constructed or imported into this
	 * ReferenceManufacturer. If the object has already been constructed, then
	 * the previously constructed object is returned.
	 * 
	 * This method is effectively a convenience method that wraps
	 * containsObject, getObject, and constructObject into a single method call
	 * (and avoids the contains-triggered branch)
	 * 
	 * @param key
	 *            The identifier of the Loadable to be built (if otherwise not
	 *            constructed or imported into this
	 *            AbstractReferenceManufacturer), or if an object with that
	 *            identifier already exists, the identifier of the object to be
	 *            returned.
	 * @return The previously existing or new Loadable with the given
	 *         identifier.
	 */
	@Override
	public T constructNowIfNecessary(String key)
	{
<span class="fc" id="L1100">		T obj = active.get(key);</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">		if (obj == null)</span>
		{
<span class="fc" id="L1103">			obj = constructObject(key);</span>
<span class="fc" id="L1104">			manufactured.add(new WeakReference&lt;&gt;(obj));</span>
		}
<span class="fc" id="L1106">		return obj;</span>
	}

	/**
	 * Adds an UnconstructedListener to this AbstractReferenceManufacturer, that
	 * will receive UnconstructedEvents if the validate method of this
	 * AbstractReferenceManufacturer is called and the UnconstructedValidator
	 * given to the validate method does not report that the unconstructed
	 * reference is permitted.
	 * 
	 * @param listener
	 *            The UnconstructedListener to be registered with this
	 *            AbstractReferenceManufacturer
	 */
	@Override
	public void addUnconstructedListener(UnconstructedListener listener)
	{
<span class="fc" id="L1123">		listenerList.add(UnconstructedListener.class, listener);</span>
<span class="fc" id="L1124">	}</span>

	/**
	 * Returns an array of UnconstructedListeners that are registered with this
	 * AbstractReferenceManufacturer.
	 * 
	 * @return An array of UnconstructedListeners that are registered with this
	 *         AbstractReferenceManufacturer.
	 */
	@Override
	public synchronized UnconstructedListener[] getUnconstructedListeners()
	{
<span class="nc" id="L1136">		return listenerList.getListeners(UnconstructedListener.class);</span>
	}

	/**
	 * Removes an UnconstructedListener from this AbstractReferenceManufacturer,
	 * so that it will no longer receive UnconstructedEvents from this
	 * AbstractReferenceManufacturer
	 * 
	 * @param listener
	 *            The UnconstructedListener to be removed from registration with
	 *            this AbstractReferenceManufacturer
	 */
	@Override
	public void removeUnconstructedListener(UnconstructedListener listener)
	{
<span class="nc" id="L1151">		listenerList.remove(UnconstructedListener.class, listener);</span>
<span class="nc" id="L1152">	}</span>

	/**
	 * Fires a new UnconstructedEvent for the given CDOMReference to any
	 * UnconstructedListener objects registered with this
	 * AbstractReferenceManufacturer
	 * 
	 * @param ref
	 *            The CDOMReference to which the UnconstructedEvent should
	 *            refer.
	 */
	@Override
	public void fireUnconstuctedEvent(CDOMReference&lt;?&gt; ref)
	{
<span class="fc" id="L1166">		Object[] listeners = listenerList.getListenerList();</span>
		/*
		 * This list is decremented from the end of the list to the beginning in
		 * order to maintain consistent operation with how Java AWT and Swing
		 * listeners are notified of Events (they are in reverse order to how
		 * they were added to the Event-owning object).
		 */
<span class="fc" id="L1173">		UnconstructedEvent uEvent = null;</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">		for (int i = listeners.length - 2; i &gt;= 0; i -= 2)</span>
		{
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">			if (listeners[i] == UnconstructedListener.class)</span>
			{
				// Lazily create event
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">				if (uEvent == null)</span>
				{
<span class="fc" id="L1181">					uEvent = new UnconstructedEvent(this, ref); // NOPMD</span>
				}
<span class="fc" id="L1183">				((UnconstructedListener) listeners[i + 1]).unconstructedReferenceFound(uEvent);</span>
			}
		}
<span class="fc" id="L1186">	}</span>

	/**
	 * Returns the number of objects that are constructed in this
	 * AbstractReferenceManufacturer (These could be natively constructed or
	 * imported objects and does not count duplicates)
	 * 
	 * @return The number of objects that are constructed in this
	 *         AbstractReferenceManufacturer
	 */
	@Override
	public int getConstructedObjectCount()
	{
<span class="fc" id="L1199">		return active.size();</span>
	}

	@Override
	public ManufacturableFactory&lt;T&gt; getFactory()
	{
<span class="fc" id="L1205">		return factory;</span>
	}

	@Override
	public String getReferenceDescription()
	{
<span class="nc" id="L1211">		return factory.getReferenceDescription();</span>
	}

	@Override
	public Collection&lt;CDOMReference&lt;T&gt;&gt; getAllReferences()
	{
<span class="fc" id="L1217">		List&lt;CDOMReference&lt;T&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">		if (allRef != null)</span>
		{
<span class="nc" id="L1220">			list.add(allRef);</span>
		}
<span class="fc" id="L1222">		list.addAll(getTypeReferences());</span>
<span class="fc" id="L1223">		list.addAll(getReferenced());</span>
<span class="fc" id="L1224">		return list;</span>
	}

	@Override
	public void addDerivativeObject(T obj)
	{
<span class="fc" id="L1230">		Objects.requireNonNull(obj, &quot;Derivative Object cannot be null&quot;);</span>
<span class="fc" id="L1231">		derivatives.add(obj);</span>
<span class="fc" id="L1232">	}</span>

	@Override
	public Collection&lt;T&gt; getDerivativeObjects()
	{
<span class="fc" id="L1237">		return new ArrayList&lt;&gt;(derivatives);</span>
	}

	@Override
	public T convert(String key)
	{
<span class="fc" id="L1243">		return getActiveObject(key);</span>
	}

	@Override
	public Indirect&lt;T&gt; convertIndirect(String key)
	{
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">		return isResolved ? new BasicIndirect&lt;&gt;(this, getActiveObject(key)) : getReference(key);</span>
	}

	@Override
	public String getIdentifierType()
	{
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">		if (Dynamic.class.equals(getManagedClass()))</span>
		{
<span class="nc" id="L1257">			return factory.getPersistentFormat();</span>
		}
<span class="fc" id="L1259">		return StringPClassUtil.getStringFor(getManagedClass());</span>
	}

	@Override
	public Class&lt;T&gt; getManagedClass()
	{
<span class="fc" id="L1265">		return factory.getReferenceClass();</span>
	}

	@Override
	public String unconvert(T arg0)
	{
<span class="nc" id="L1271">		return arg0.getKeyName();</span>
	}

	@Override
	public Optional&lt;FormatManager&lt;?&gt;&gt; getComponentManager()
	{
<span class="fc" id="L1277">		return Optional.empty();</span>
	}

	@Override
	public boolean isDirect()
	{
<span class="nc" id="L1283">		return false;</span>
	}

	@Override
	public ClassIdentity&lt;T&gt; getReferenceIdentity()
	{
<span class="fc" id="L1289">		return factory.getReferenceIdentity();</span>
	}

	@Override
	public String getPersistentFormat()
	{
<span class="fc" id="L1295">		return factory.getPersistentFormat();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>