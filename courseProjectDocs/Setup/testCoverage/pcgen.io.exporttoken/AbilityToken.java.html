<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbilityToken.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.io.exporttoken</a> &gt; <span class="el_source">AbilityToken.java</span></div><h1>AbilityToken.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2006 (C) James Dempsey
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *
 */

package pcgen.io.exporttoken;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;

import pcgen.base.lang.StringUtil;
import pcgen.base.lang.UnreachableError;
import pcgen.base.util.GenericMapToList;
import pcgen.base.util.HashMapToList;
import pcgen.base.util.MapToList;
import pcgen.cdom.base.Constants;
import pcgen.cdom.content.CNAbility;
import pcgen.cdom.enumeration.AspectName;
import pcgen.cdom.enumeration.MapKey;
import pcgen.cdom.enumeration.Nature;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.SourceFormat;
import pcgen.cdom.helper.Aspect;
import pcgen.core.Ability;
import pcgen.core.AbilityCategory;
import pcgen.core.BenefitFormatting;
import pcgen.core.Globals;
import pcgen.core.PlayerCharacter;
import pcgen.core.SettingsHandler;
import pcgen.core.analysis.QualifiedName;
import pcgen.io.ExportHandler;
import pcgen.util.Logging;
import pcgen.util.enumeration.View;

/**
 * {@code AbilityToken} handles the output of ability information.
 * 
 * The format is ABILITY.u.v.w.x.y.z where:
 * &lt;ul&gt;
 * &lt;li&gt;u is the AbilityCategory (FEAT, FIGHTER etc, or ALL) - Mandatory&lt;/li&gt;
 * &lt;li&gt;v is the visibility (DEFAULT, ALL, VISIBLE, HIDDEN) - Optional&lt;/li&gt;
 * &lt;li&gt;w is the ability type filtering via strings - Optional&lt;/li&gt;
 * &lt;li&gt;x is the ability's position in the list of abilities, 0-based index -
 * Optional&lt;/li&gt;
 * &lt;li&gt;y is the ability type filtering via AbilityType - default is ALL).&lt;/li&gt;
 * &lt;li&gt;z is what is to be output DESC, TYPE, SOURCE, default is name, or
 * TYPE=&amp;lt;type&amp;gt; - type filter&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 */
<span class="nc" id="L73">public class AbilityToken extends Token</span>
{

	/** Token Name */
	public static final String TOKENNAME = &quot;ABILITY&quot;;

	/** The list of abilities to get the ability from */
<span class="nc" id="L80">	private MapToList&lt;Ability, CNAbility&gt; abilityList = new HashMapToList&lt;&gt;();</span>

	/** The current visibility filtering to apply */
<span class="nc" id="L83">	private View view = View.VISIBLE_EXPORT;</span>

	/** The cached PC */
<span class="nc" id="L86">	private PlayerCharacter cachedPC = null;</span>

	/** The cached PC serial (serial holds whether a PC has been changed) */
<span class="nc" id="L89">	private int cachedPcSerial = 0;</span>

	/** The last token in the list of abilities */
<span class="nc" id="L92">	private String lastToken = null;</span>

	/** The last ability category in the list of abilities */
<span class="nc" id="L95">	private AbilityCategory lastCategory = null;</span>

	/**
	 * Get the TOKENNAME
	 * 
	 * @return TOKENNAME
	 */
	@Override
	public String getTokenName()
	{
<span class="nc" id="L105">		return TOKENNAME;</span>
	}

	@Override
	public String getToken(String tokenSource, PlayerCharacter pc, ExportHandler eh)
	{
		// Skip the ABILITY token itself
<span class="nc" id="L112">		final StringTokenizer aTok = new StringTokenizer(tokenSource, &quot;.&quot;);</span>
<span class="nc" id="L113">		final String tokenString = aTok.nextToken();</span>

		// Get the Ability Category from the Gamemode given the key
<span class="nc" id="L116">		final String categoryString = aTok.nextToken();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		final AbilityCategory aCategory = &quot;ANY&quot;.equals(categoryString) ? AbilityCategory.ANY</span>
<span class="nc" id="L118">			: SettingsHandler.getGameAsProperty().get().getAbilityCategory(categoryString);</span>

		// Get the ABILITY token for the category
<span class="nc" id="L121">		return getTokenForCategory(tokenSource, pc, eh, aTok, tokenString, aCategory);</span>
	}

	/**
	 * Produce the ABILITY token output for a specific ability category.
	 * 
	 * @param tokenSource
	 *            The token being processed.
	 * @param pc
	 *            The character being processed.
	 * @param eh
	 *            The export handler in use for the export.
	 * @param aTok
	 *            The tokenised request, already past the category.
	 * @param tokenString
	 *            The output token requested
	 * @param aCategory
	 *            The ability category being output.
	 * @return The token value.
	 */
	protected String getTokenForCategory(String tokenSource, PlayerCharacter pc, ExportHandler eh,
		final StringTokenizer aTok, final String tokenString, final AbilityCategory aCategory)
	{
<span class="nc bnc" id="L144" title="All 4 branches missed.">		boolean cacheAbilityProcessingData = (cachedPC != pc || !aCategory.equals(lastCategory)</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">			|| cachedPcSerial != pc.getSerial() || !tokenString.equals(lastToken));</span>

		// As this method can effectively be called by an OS FOR token, there 
		// is a performance saving in caching some of the one-off processing data 
<span class="nc bnc" id="L149" title="All 2 branches missed.">		if (cacheAbilityProcessingData)</span>
		{
			// Overridden by subclasses to return the right list.
<span class="nc" id="L152">			abilityList = getAbilityList(pc, aCategory);</span>
<span class="nc" id="L153">			cachedPC = pc;</span>
<span class="nc" id="L154">			lastCategory = aCategory;</span>
<span class="nc" id="L155">			cachedPcSerial = pc.getSerial();</span>
<span class="nc" id="L156">			lastToken = tokenString;</span>
		}

		// Ability Types Filter List
<span class="nc" id="L160">		List&lt;String&gt; types = new ArrayList&lt;&gt;();</span>
		// Negated Ability Types Filter List (excludes from types)
<span class="nc" id="L162">		List&lt;String&gt; negate = new ArrayList&lt;&gt;();</span>
		// Ability Type
<span class="nc" id="L164">		String abilityType = null;</span>
		// Ability Types Filter List
<span class="nc" id="L166">		String key = null;</span>
		// Ability Aspect Filter
<span class="nc" id="L168">		String aspect = null;</span>

		/*
		 * abilityIndex holds the number of the ability we want, is decremented
		 * as we iterate through the list. It is only decremented if the current
		 * ability matches the desired ability
		 */
<span class="nc" id="L175">		int abilityIndex = -1;</span>

		/* 
		 * Grab the next token which will either be be:
		 * visibility (v), type (w) or index (x), stop processing 
		 * once you hit the index token 
		 */
<span class="nc bnc" id="L182" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L184">			final String bString = aTok.nextToken();</span>
			try
			{
				// Get the mandatory ability index
<span class="nc" id="L188">				abilityIndex = Integer.parseInt(bString);</span>
<span class="nc" id="L189">				break;</span>
			}
			// The optional visibility (v) or type (w) has been provided, so deal with those 
<span class="nc" id="L192">			catch (NumberFormatException exc)</span>
			{
<span class="nc bnc" id="L194" title="All 4 branches missed.">				switch (bString)</span>
				{
					case &quot;VISIBLE&quot; -&gt; {
<span class="nc" id="L197">						view = View.VISIBLE_EXPORT;</span>
<span class="nc" id="L198">						continue;</span>
					}
					case &quot;HIDDEN&quot; -&gt; {
<span class="nc" id="L201">						view = View.HIDDEN_EXPORT;</span>
<span class="nc" id="L202">						continue;</span>
					}
					case &quot;ALL&quot; -&gt; {
<span class="nc" id="L205">						view = View.ALL;</span>
<span class="nc" id="L206">						continue;</span>
					}
<span class="nc" id="L208">					default -&gt; abilityType = bString;</span>
				}
			}
<span class="nc" id="L211">		}</span>

		/* 
		 * Grab the next token which will either be be:
		 * TYPE (y) or property (z), stop processing 
		 * once you hit the last token 
		 */
<span class="nc bnc" id="L218" title="All 2 branches missed.">		while (aTok.hasMoreTokens())</span>
		{
<span class="nc" id="L220">			final String typeStr = aTok.nextToken();</span>
<span class="nc" id="L221">			int typeInd = typeStr.indexOf(&quot;TYPE=&quot;);</span>
<span class="nc" id="L222">			int extypeInd = typeStr.indexOf(&quot;EXCLUDETYPE=&quot;);</span>

			// If it's TYPE and it actually has a value attached then process it 
<span class="nc bnc" id="L225" title="All 6 branches missed.">			if (typeInd != -1 &amp;&amp; extypeInd == -1 &amp;&amp; typeStr.length() &gt; 5)</span>
			{
				// It's a type to be excluded from the filter list 
<span class="nc bnc" id="L228" title="All 2 branches missed.">				if (typeStr.startsWith(&quot;!&quot;))</span>
				{
<span class="nc" id="L230">					Logging.deprecationPrint(</span>
						&quot;The use of !TYPE with ABILITY output tokens is deprecated. Please use EXCLUDETYPE.&quot;);
<span class="nc" id="L232">					negate.add(typeStr.substring(typeInd + 5));</span>
				}
				else
				{
<span class="nc" id="L236">					StringTokenizer incTok = new StringTokenizer(typeStr.substring(typeInd + 5), Constants.SEMICOLON);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">					while (incTok.hasMoreTokens())</span>
					{
<span class="nc" id="L239">						types.add(incTok.nextToken());</span>
					}
				}
			}

			// If it's EXCLUDETYPE and it actually has a value attached then process it 
<span class="nc bnc" id="L245" title="All 4 branches missed.">			if (extypeInd != -1 &amp;&amp; typeStr.length() &gt; 12)</span>
			{
				// exclude TYPEs from comma-separated list
<span class="nc" id="L248">				StringTokenizer exTok = new StringTokenizer(typeStr.substring(extypeInd + 12), Constants.SEMICOLON);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				while (exTok.hasMoreTokens())</span>
				{
<span class="nc" id="L251">					negate.add(exTok.nextToken());</span>
				}
			}

<span class="nc" id="L255">			int keyInd = typeStr.indexOf(&quot;KEY=&quot;);</span>
			// If it's KEY and it actually has a value attached then process it 
<span class="nc bnc" id="L257" title="All 4 branches missed.">			if (keyInd != -1 &amp;&amp; typeStr.length() &gt; 4)</span>
			{
<span class="nc" id="L259">				key = typeStr.substring(keyInd + 4);</span>
			}

<span class="nc" id="L262">			int aspectInd = typeStr.indexOf(&quot;ASPECT=&quot;);</span>
			// If it's ASPECT and it actually has a value attached then process it
<span class="nc bnc" id="L264" title="All 4 branches missed.">			if (aspectInd != -1 &amp;&amp; typeStr.length() &gt; 7)</span>
			{
<span class="nc" id="L266">				aspect = typeStr.substring(aspectInd + 7);</span>
			}

<span class="nc" id="L269">		}</span>

		// Ability List
		MapToList&lt;Ability, CNAbility&gt; aList;
		// Build the list of abilities that we should display
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if (key == null)</span>
		{
<span class="nc" id="L276">			aList = AbilityToken.buildAbilityList(types, negate, abilityType, view, aspect, abilityList);</span>
		}
		else
		{
<span class="nc" id="L280">			aList = AbilityToken.buildAbilityList(key, view, abilityList);</span>
		}

		// Build the return string to give to the OutputSheet

<span class="nc" id="L285">		return getRetString(tokenSource, pc, eh, abilityIndex, aList);</span>
	}

	/**
	 * Build up the list of abilities of interest based on the type and visibility selection.
	 * 
	 * @param types
	 *            The list of types which it must match at least one of.
	 * @param negate
	 *            The list of types it must not match any of.
	 * @param abilityType
	 *            The type definition it must match.
	 * @param aspect
	 *            The aspect which it must match.
	 * @return List of abilities based on the type, visibility, and aspect selection.
	 */
	static MapToList&lt;Ability, CNAbility&gt; buildAbilityList(List&lt;String&gt; types, List&lt;String&gt; negate, String abilityType,
		View view, String aspect, MapToList&lt;Ability, CNAbility&gt; listOfAbilities)
	{
<span class="nc" id="L304">		List&lt;Ability&gt; aList = new ArrayList&lt;&gt;(listOfAbilities.getKeySet());</span>

		// Sort the ability list passed in
<span class="nc" id="L307">		Globals.sortPObjectListByName(aList);</span>

		boolean matchTypeDef;
		boolean matchVisibilityDef;
		boolean matchAspectDef;

		// List to build up
<span class="nc" id="L314">		List&lt;Ability&gt; bList = new ArrayList&lt;&gt;();</span>

		// For each ability figure out whether it should be displayed depending
		// on its visibility filtering and its ability type filtering 
<span class="nc bnc" id="L318" title="All 2 branches missed.">		for (Ability aAbility : aList)</span>
		{
<span class="nc" id="L320">			matchTypeDef = abilityMatchesType(abilityType, aAbility, types, negate);</span>
<span class="nc" id="L321">			matchVisibilityDef = abilityVisibleTo(view, aAbility);</span>
<span class="nc" id="L322">			matchAspectDef = abilityMatchesAspect(aspect, aAbility);</span>
<span class="nc bnc" id="L323" title="All 6 branches missed.">			if (matchTypeDef &amp;&amp; matchVisibilityDef &amp;&amp; matchAspectDef)</span>
			{
<span class="nc" id="L325">				bList.add(aAbility);</span>
			}
<span class="nc" id="L327">		}</span>
		try
		{
<span class="nc" id="L330">			MapToList&lt;Ability, CNAbility&gt; mtl = new GenericMapToList&lt;&gt;(LinkedHashMap.class);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">			for (Ability a : bList)</span>
			{
<span class="nc" id="L333">				mtl.addAllToListFor(a, listOfAbilities.getListFor(a));</span>
<span class="nc" id="L334">			}</span>
<span class="nc" id="L335">			return mtl;</span>
		}
<span class="nc" id="L337">		catch (ReflectiveOperationException e)</span>
		{
<span class="nc" id="L339">			throw new UnreachableError(e);</span>
		}
	}

	/**
	 * Build up the list of abilities of interest based on the key and visibility selection.
	 * 
	 * @param key
	 *            The key of the wanted ability.
	 * @return List of abilities based on the type and visibility selection.
	 */
	static MapToList&lt;Ability, CNAbility&gt; buildAbilityList(String key, View view,
		MapToList&lt;Ability, CNAbility&gt; listOfAbilities)
	{
<span class="nc" id="L353">		List&lt;Ability&gt; aList = new ArrayList&lt;&gt;(listOfAbilities.getKeySet());</span>

		// Sort the ability list passed in
<span class="nc" id="L356">		Globals.sortPObjectListByName(aList);</span>

		boolean matchKeyDef;
		boolean matchVisibilityDef;

		// List to build up
<span class="nc" id="L362">		List&lt;Ability&gt; bList = new ArrayList&lt;&gt;();</span>

		// For each ability figure out whether it should be displayed depending
		// on its visibility filtering and its ability type filtering 
<span class="nc bnc" id="L366" title="All 2 branches missed.">		for (Ability aAbility : aList)</span>
		{
<span class="nc" id="L368">			matchKeyDef = aAbility.getKeyName().equalsIgnoreCase(key);</span>
<span class="nc" id="L369">			matchVisibilityDef = abilityVisibleTo(view, aAbility);</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">			if (matchKeyDef &amp;&amp; matchVisibilityDef)</span>
			{
<span class="nc" id="L372">				bList.add(aAbility);</span>
			}
<span class="nc" id="L374">		}</span>
		try
		{
<span class="nc" id="L377">			MapToList&lt;Ability, CNAbility&gt; mtl = new GenericMapToList&lt;&gt;(LinkedHashMap.class);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			for (Ability a : bList)</span>
			{
<span class="nc" id="L380">				mtl.addAllToListFor(a, listOfAbilities.getListFor(a));</span>
<span class="nc" id="L381">			}</span>
<span class="nc" id="L382">			return mtl;</span>
		}
<span class="nc" id="L384">		catch (ReflectiveOperationException e)</span>
		{
<span class="nc" id="L386">			throw new UnreachableError(e);</span>
		}
	}

	/**
	 * Helper method, returns true if the ability has one of the ability types that 
	 * we are matching on.
	 * 
	 * @param abilityType The ability Type to test
	 * @param aAbility The ability
	 * @param types The list of types we're trying to match on
	 * @param negate The exclusion list of types
	 * @return True if it matches one of the types else false
	 */
	static boolean abilityMatchesType(String abilityType, Ability aAbility, List&lt;String&gt; types, List&lt;String&gt; negate)
	{
<span class="nc" id="L402">		boolean matchTypeDef = false;</span>

		// If the ability type is an actual properly registered type or its null
		// then match the type definition
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if (abilityType != null)</span>
		{
<span class="nc bnc" id="L408" title="All 2 branches missed.">			if (aAbility.isType(abilityType))</span>
			{
<span class="nc" id="L410">				matchTypeDef = true;</span>
			}
		}
		else
		{
<span class="nc" id="L415">			matchTypeDef = true;</span>
		}

<span class="nc" id="L418">		boolean istype = false;</span>
<span class="nc" id="L419">		boolean isnttype = true;</span>

		// If the types contains at least one of the types we've asked for
<span class="nc bnc" id="L422" title="All 2 branches missed.">		if (!types.isEmpty())</span>
		{
<span class="nc bnc" id="L424" title="All 2 branches missed.">			for (String typeStr : types)</span>
			{
<span class="nc" id="L426">				istype |= aAbility.isType(typeStr);</span>
<span class="nc" id="L427">			}</span>
		}
		else
		{
<span class="nc" id="L431">			istype = true;</span>
		}

		// It isn't all the types we've said
<span class="nc bnc" id="L435" title="All 2 branches missed.">		for (String typeStr : negate)</span>
		{
<span class="nc bnc" id="L437" title="All 2 branches missed.">			isnttype &amp;= !aAbility.isType(typeStr);</span>
<span class="nc" id="L438">		}</span>

<span class="nc bnc" id="L440" title="All 6 branches missed.">		matchTypeDef = matchTypeDef &amp;&amp; istype &amp;&amp; isnttype;</span>
<span class="nc" id="L441">		return matchTypeDef;</span>
	}

	/**
	 * Helper method, returns true if the ability meets the visibility requirements.
	 * 
	 * @param v         The ability Type to test
	 * @param aAbility  The ability
	 * @return true if it meets the visibility requirements
	 */
	static boolean abilityVisibleTo(View v, Ability aAbility)
	{
<span class="nc" id="L453">		return aAbility.getSafe(ObjectKey.VISIBILITY).isVisibleTo(v);</span>
	}

	/**
	 * Helper method, returns true if the ability has the aspect we are matching on.
	 * 
	 * @param aspect The aspecte we're trying to match on
	 * @param aAbility The ability
	 * @return True if it matches the aspect else false
	 */
	static boolean abilityMatchesAspect(String aspect, Ability aAbility)
	{
<span class="nc bnc" id="L465" title="All 4 branches missed.">		return (aspect == null) || (aAbility.get(MapKey.ASPECT, AspectName.getConstant(aspect)) != null);</span>
	}

	/**
	 * Calculate the token value (return string) for the ability token.
	 * 
	 * @param tokenSource
	 *            The text of the export token.
	 * @param pc
	 *            The character being exported.
	 * @param eh
	 *            The export handler.
	 * @param abilityIndex
	 *            The location of the ability in the list.
	 * @param aMapToList
	 *            The list of abilities to get the ability from.
	 * @return The token value.
	 */
	private String getRetString(String tokenSource, PlayerCharacter pc, ExportHandler eh, int abilityIndex,
		MapToList&lt;Ability, CNAbility&gt; aMapToList)
	{
<span class="nc" id="L486">		String retString = &quot;&quot;;</span>
		Ability aAbility;
<span class="nc" id="L488">		List&lt;Ability&gt; aList = new ArrayList&lt;&gt;(aMapToList.getKeySet());</span>
		// If the ability index given is within a valid range
<span class="nc bnc" id="L490" title="All 4 branches missed.">		if (abilityIndex &gt;= 0 &amp;&amp; abilityIndex &lt; aList.size())</span>
		{
<span class="nc" id="L492">			aAbility = aList.get(abilityIndex);</span>
<span class="nc" id="L493">			List&lt;CNAbility&gt; abilities = aMapToList.getListFor(aAbility);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">			if (abilities.isEmpty())</span>
			{
<span class="nc" id="L496">				return &quot;&quot;;</span>
			}

			// If it is the last item and there's a valid export handler and ??? TODO
			// Then tell the ExportHandler that there is no more processing needed
<span class="nc bnc" id="L501" title="All 6 branches missed.">			if (abilityIndex == aList.size() - 1 &amp;&amp; eh != null &amp;&amp; eh.getExistsOnly())</span>
			{
<span class="nc" id="L503">				eh.setNoMoreItems(true);</span>
			}

<span class="nc bnc" id="L506" title="All 2 branches missed.">			if (tokenSource.endsWith(&quot;.DESC&quot;))</span>
			{
<span class="nc" id="L508">				retString = pc.getDescription(abilities);</span>
			}
<span class="nc bnc" id="L510" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.BENEFIT&quot;))</span>
			{
<span class="nc" id="L512">				retString = BenefitFormatting.getBenefits(pc, abilities);</span>
			}
<span class="nc bnc" id="L514" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.TYPE&quot;))</span>
			{
<span class="nc" id="L516">				retString = aAbility.getType().toUpperCase();</span>
			}
<span class="nc bnc" id="L518" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.ASSOCIATED&quot;))</span>
			{
<span class="nc" id="L520">				List&lt;String&gt; assocs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">				for (CNAbility cna : abilities)</span>
				{
<span class="nc" id="L523">					assocs.addAll(pc.getAssociationExportList(cna));</span>
<span class="nc" id="L524">				}</span>
<span class="nc" id="L525">				Collections.sort(assocs);</span>
<span class="nc" id="L526">				retString = StringUtil.join(assocs, &quot;,&quot;);</span>
<span class="nc" id="L527">			}</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">			else if (tokenSource.contains(&quot;.ASSOCIATED.&quot;))</span>
			{
<span class="nc" id="L530">				final String key = tokenSource.substring(tokenSource.indexOf(&quot;.ASSOCIATED.&quot;) + 12);</span>
<span class="nc" id="L531">				retString = getAssociationString(pc, abilities, key);</span>
<span class="nc" id="L532">			}</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.ASSOCIATEDCOUNT&quot;))</span>
			{
<span class="nc" id="L535">				int count = 0;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">				for (CNAbility cna : abilities)</span>
				{
<span class="nc" id="L538">					count += pc.getDetailedAssociationCount(cna);</span>
<span class="nc" id="L539">				}</span>
<span class="nc" id="L540">				retString = Integer.toString(count);</span>
<span class="nc" id="L541">			}</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.SOURCE&quot;))</span>
			{
<span class="nc" id="L544">				retString = SourceFormat.getFormattedString(aAbility, Globals.getSourceDisplay(), true);</span>
			}
<span class="nc bnc" id="L546" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.SOURCESHORT&quot;))</span>
			{
<span class="nc" id="L548">				retString = SourceFormat.formatShort(aAbility, 8);</span>
			}
<span class="nc bnc" id="L550" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.ASPECT&quot;))</span>
			{
<span class="nc" id="L552">				retString = getAspectString(pc, abilities);</span>
			}
<span class="nc bnc" id="L554" title="All 2 branches missed.">			else if (tokenSource.contains(&quot;.ASPECT.&quot;))</span>
			{
<span class="nc" id="L556">				final String key = tokenSource.substring(tokenSource.indexOf(&quot;.ASPECT.&quot;) + 8);</span>
<span class="nc" id="L557">				retString = getAspectString(pc, abilities, key);</span>
<span class="nc" id="L558">			}</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">			else if (tokenSource.endsWith(&quot;.ASPECTCOUNT&quot;))</span>
			{
<span class="nc" id="L561">				retString = Integer.toString(aAbility.getSafeSizeOfMapFor(MapKey.ASPECT));</span>
			}
<span class="nc bnc" id="L563" title="All 2 branches missed.">			else if (tokenSource.contains(&quot;.HASASPECT.&quot;))</span>
			{
<span class="nc" id="L565">				final String key = tokenSource.substring(tokenSource.indexOf(&quot;.HASASPECT.&quot;) + 11);</span>
<span class="nc" id="L566">				retString = getHasAspectString(pc, aAbility, AspectName.getConstant(key));</span>
<span class="nc" id="L567">			}</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">			else if (tokenSource.contains(&quot;.NAME&quot;))</span>
			{
<span class="nc" id="L570">				retString = aAbility.getDisplayName();</span>
			}
<span class="nc bnc" id="L572" title="All 2 branches missed.">			else if (tokenSource.contains(&quot;.KEY&quot;))</span>
			{
<span class="nc" id="L574">				retString = aAbility.getKeyName();</span>
			}
			else
			{
<span class="nc" id="L578">				retString = QualifiedName.qualifiedName(pc, abilities);</span>
			}
<span class="nc" id="L580">		}</span>
		// If the ability index is not in a valid range then tell the 
		// ExportHandler that there are no more items to process
<span class="nc bnc" id="L583" title="All 4 branches missed.">		else if (eh != null &amp;&amp; eh.getExistsOnly())</span>
		{
<span class="nc" id="L585">			eh.setNoMoreItems(true);</span>
		}

<span class="nc" id="L588">		return retString;</span>
	}

	private String getAssociationString(PlayerCharacter pc, List&lt;CNAbility&gt; abilities, String key)
	{
<span class="nc" id="L593">		int index = Integer.parseInt(key);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">		if (index &lt; 0)</span>
		{
<span class="nc" id="L596">			return Constants.EMPTY_STRING;</span>
		}
<span class="nc" id="L598">		List&lt;String&gt; assocs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">		for (CNAbility cna : abilities)</span>
		{
<span class="nc" id="L601">			assocs.addAll(pc.getAssociationExportList(cna));</span>
<span class="nc" id="L602">		}</span>
<span class="nc" id="L603">		Collections.sort(assocs);</span>
<span class="nc" id="L604">		int count = assocs.size();</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">		if (index &lt; count)</span>
		{
<span class="nc" id="L607">			return assocs.get(index);</span>
		}
		//index was too large
<span class="nc" id="L610">		return Constants.EMPTY_STRING;</span>
	}

	/**
	 * Gets the aspect string.
	 * 
	 * @param pc
	 *            The character being exported.
	 * @param abilities
	 *            The ability
	 * 
	 * @return the aspect string
	 */
	private String getAspectString(PlayerCharacter pc, List&lt;CNAbility&gt; abilities)
	{
<span class="nc bnc" id="L625" title="All 2 branches missed.">		if (abilities.isEmpty())</span>
		{
<span class="nc" id="L627">			return &quot;&quot;;</span>
		}
<span class="nc" id="L629">		Ability sampleAbilityObject = abilities.get(0).getAbility();</span>
<span class="nc" id="L630">		Set&lt;AspectName&gt; aspectKeys = sampleAbilityObject.getKeysFor(MapKey.ASPECT);</span>
<span class="nc" id="L631">		SortedSet&lt;AspectName&gt; sortedKeys = new TreeSet&lt;&gt;(aspectKeys);</span>
<span class="nc" id="L632">		StringBuilder buff = new StringBuilder();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">		for (AspectName key : sortedKeys)</span>
		{
<span class="nc bnc" id="L635" title="All 2 branches missed.">			if (buff.length() &gt; 0)</span>
			{
<span class="nc" id="L637">				buff.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L639">			buff.append(Aspect.printAspect(pc, key, abilities));</span>
<span class="nc" id="L640">		}</span>
<span class="nc" id="L641">		return buff.toString();</span>
	}

	/**
	 * Gets the aspect string for an aspect identified by position or name.
	 * 
	 * @param pc
	 *            The character being exported.
	 * @param abilities
	 *            The ability being queried.
	 * @param key
	 *            The key (number or name) of the aspect to retrieve
	 * 
	 * @return the aspect string
	 */
	private String getAspectString(PlayerCharacter pc, List&lt;CNAbility&gt; abilities, String key)
	{
<span class="nc bnc" id="L658" title="All 2 branches missed.">		if (key == null)</span>
		{
<span class="nc" id="L660">			return &quot;&quot;;</span>
		}
<span class="nc bnc" id="L662" title="All 2 branches missed.">		if (abilities.isEmpty())</span>
		{
<span class="nc" id="L664">			return &quot;&quot;;</span>
		}
<span class="nc" id="L666">		Ability sampleAbilityObject = abilities.get(0).getAbility();</span>

		try
		{
<span class="nc" id="L670">			int index = Integer.parseInt(key);</span>
<span class="nc bnc" id="L671" title="All 4 branches missed.">			if ((index &gt;= 0) &amp;&amp; (index &lt; sampleAbilityObject.getSafeSizeOfMapFor(MapKey.ASPECT)))</span>
			{
<span class="nc" id="L673">				Set&lt;AspectName&gt; aspectKeys = sampleAbilityObject.getKeysFor(MapKey.ASPECT);</span>
<span class="nc" id="L674">				List&lt;AspectName&gt; sortedKeys = new ArrayList&lt;&gt;(aspectKeys);</span>
<span class="nc" id="L675">				Collections.sort(sortedKeys);</span>
<span class="nc" id="L676">				AspectName aspectName = sortedKeys.get(index);</span>
<span class="nc" id="L677">				return Aspect.printAspect(pc, aspectName, abilities);</span>
			}
			else
			{
<span class="nc" id="L681">				return &quot;&quot;;</span>
			}
		}
<span class="nc" id="L684">		catch (NumberFormatException e)</span>
		{
			// Ignore exception - expect this as we can get a String at this point
<span class="nc" id="L687">			AspectName aspectName = AspectName.getConstant(key);</span>
<span class="nc" id="L688">			return Aspect.printAspectValue(pc, aspectName, abilities);</span>
		}
	}

	/**
	 * Gets the boolean (Y/N) string for the presence of the named aspect.
	 * 
	 * @param ability
	 *            The ability being queried.
	 * @param key
	 *            The key (name only) of the aspect to check
	 * 
	 * @return Y if the aspect is present, N if not.
	 */
	private String getHasAspectString(PlayerCharacter pc, Ability ability, AspectName key)
	{
<span class="nc" id="L704">		List&lt;Aspect&gt; aspects = ability.get(MapKey.ASPECT, key);</span>
<span class="nc" id="L705">		Aspect aspect = Aspect.lastPassingAspect(aspects, pc, ability);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (aspect == null)</span>
		{
<span class="nc" id="L708">			return &quot;N&quot;;</span>
		}
<span class="nc" id="L710">		return &quot;Y&quot;;</span>
	}

	/**
	 * Returns the correct list of abilities for the character. This method is
	 * overridden in subclasses if they need to change the list of abilities
	 * looked at.
	 * 
	 * @param pc
	 *            The character who's abilities we are retrieving.
	 * @param aCategory
	 *            The category of ability being reported.
	 * @return List of abilities.
	 */
	protected MapToList&lt;Ability, CNAbility&gt; getAbilityList(PlayerCharacter pc, final AbilityCategory aCategory)
	{
<span class="nc" id="L726">		final MapToList&lt;Ability, CNAbility&gt; listOfAbilities = new HashMapToList&lt;&gt;();</span>
<span class="nc" id="L727">		Collection&lt;AbilityCategory&gt; allCats = SettingsHandler.getGameAsProperty().get().getAllAbilityCategories();</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">		for (AbilityCategory aCat : allCats)</span>
		{
<span class="nc bnc" id="L730" title="All 4 branches missed.">			if (AbilityCategory.ANY.equals(aCategory) || aCat.getParentCategory().equals(aCategory))</span>
			{
<span class="nc bnc" id="L732" title="All 2 branches missed.">				for (CNAbility cna : pc.getPoolAbilities(aCat, Nature.NORMAL))</span>
				{
<span class="nc" id="L734">					listOfAbilities.addToListFor(cna.getAbility(), cna);</span>
<span class="nc" id="L735">				}</span>
			}
<span class="nc" id="L737">		}</span>
<span class="nc" id="L738">		return listOfAbilities;</span>
	}

	/**
	 * @param v the view to set
	 */
	protected void setView(View v)
	{
<span class="nc" id="L746">		this.view = v;</span>
<span class="nc" id="L747">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>