<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PCClassLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.persistence.lst</a> &gt; <span class="el_source">PCClassLoader.java</span></div><h1>PCClassLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2001 (C) Bryan McRoberts &lt;merton_monk@yahoo.com&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *
 */
package pcgen.persistence.lst;

import java.util.Collection;
import java.util.List;
import java.util.StringTokenizer;

import pcgen.cdom.enumeration.IntegerKey;
import pcgen.cdom.enumeration.ListKey;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.inst.PCClassLevel;
import pcgen.core.PCClass;
import pcgen.core.SubClass;
import pcgen.core.SubstitutionClass;
import pcgen.core.analysis.PCClassKeyChange;
import pcgen.persistence.PersistenceLayerException;
import pcgen.persistence.SystemLoader;
import pcgen.persistence.lst.utils.DeferredLine;
import pcgen.rules.context.LoadContext;
import pcgen.util.Logging;

<span class="nc" id="L40">public final class PCClassLoader extends LstObjectFileLoader&lt;PCClass&gt;</span>
{
	@Override
	public PCClass parseLine(LoadContext context, PCClass target, String lstLine, SourceEntry source)
	{
<span class="nc bnc" id="L45" title="All 4 branches missed.">		if (lstLine.startsWith(&quot;SUBCLASS:&quot;) || lstLine.startsWith(&quot;SUBCLASSLEVEL:&quot;))</span>
		{
<span class="nc bnc" id="L47" title="All 2 branches missed.">			if (target == null)</span>
			{
<span class="nc" id="L49">				Logging.errorPrint(&quot;Ignoring line: &quot; + lstLine + &quot; as SUBCLASS* type line appeared before CLASS: line&quot;);</span>
<span class="nc" id="L50">				return null;</span>
			}
			SubClass subClass;

<span class="nc bnc" id="L54" title="All 2 branches missed.">			if (lstLine.startsWith(&quot;SUBCLASS:&quot;))</span>
			{
<span class="nc" id="L56">				int tabLoc = lstLine.indexOf('\t');</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">				if (tabLoc == -1)</span>
				{
<span class="nc" id="L59">					Logging.errorPrint(&quot;Expected SUBCLASS to have &quot; + &quot;additional Tags in &quot; + source.getURI()</span>
						+ &quot; (e.g. COST is a required Tag in a SUBCLASS)&quot;);
				}
<span class="nc" id="L62">				final String n = lstLine.substring(9, tabLoc);</span>
<span class="nc" id="L63">				String restOfLine = lstLine.substring(tabLoc);</span>
<span class="nc" id="L64">				subClass = target.getSubClassKeyed(n);</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">				if (subClass == null)</span>
				{
<span class="nc" id="L68">					subClass = new SubClass();</span>
<span class="nc" id="L69">					subClass.setName(n);</span>
<span class="nc" id="L70">					subClass.put(ObjectKey.SOURCE_CAMPAIGN, source.getCampaign());</span>
<span class="nc" id="L71">					subClass.setSourceURI(source.getURI());</span>
<span class="nc" id="L72">					target.addSubClass(subClass);</span>
				}
<span class="nc" id="L74">				parseLineIntoClass(context, subClass, source, restOfLine);</span>
<span class="nc" id="L75">			}</span>
			else
			{
<span class="nc" id="L78">				List&lt;SubClass&gt; subClassList = target.getListFor(ListKey.SUB_CLASS);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">				if (subClassList != null)</span>
				{
<span class="nc" id="L81">					subClass = subClassList.get(subClassList.size() - 1);</span>
<span class="nc" id="L82">					subClass.addToListFor(ListKey.SUB_CLASS_LEVEL,</span>
<span class="nc" id="L83">						new DeferredLine(source, lstLine.substring(14)));</span>
				}
			}
<span class="nc" id="L86">			return target;</span>
		}

<span class="nc bnc" id="L89" title="All 4 branches missed.">		if (lstLine.startsWith(&quot;SUBSTITUTIONCLASS:&quot;) || lstLine.startsWith(&quot;SUBSTITUTIONLEVEL:&quot;))</span>
		{
<span class="nc bnc" id="L91" title="All 2 branches missed.">			if (target == null)</span>
			{
<span class="nc" id="L93">				Logging.errorPrint(</span>
					&quot;Ignoring line: &quot; + lstLine + &quot; as SUBSTITUTIONCLASS* type line appeared before CLASS: line&quot;);
<span class="nc" id="L95">				return null;</span>
			}
			SubstitutionClass substitutionClass;

<span class="nc bnc" id="L99" title="All 2 branches missed.">			if (lstLine.startsWith(&quot;SUBSTITUTIONCLASS:&quot;))</span>
			{
<span class="nc" id="L101">				int tabLoc = lstLine.indexOf('\t');</span>
				String name;
				String restOfLine;
<span class="nc bnc" id="L104" title="All 2 branches missed.">				if (tabLoc &gt; 0)</span>
				{
<span class="nc" id="L106">					name = lstLine.substring(18, tabLoc);</span>
<span class="nc" id="L107">					restOfLine = lstLine.substring(tabLoc);</span>
				}
				else
				{
<span class="nc" id="L111">					name = lstLine.substring(18);</span>
<span class="nc" id="L112">					restOfLine = null;</span>
				}
<span class="nc" id="L114">				substitutionClass = target.getSubstitutionClassKeyed(name);</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">				if (substitutionClass == null)</span>
				{
<span class="nc" id="L118">					substitutionClass = new SubstitutionClass();</span>
<span class="nc" id="L119">					substitutionClass.setName(name);</span>
<span class="nc" id="L120">					substitutionClass.put(ObjectKey.SOURCE_CAMPAIGN, source.getCampaign());</span>
<span class="nc" id="L121">					substitutionClass.setSourceURI(source.getURI());</span>
<span class="nc" id="L122">					target.addSubstitutionClass(substitutionClass);</span>
				}
<span class="nc" id="L124">				parseLineIntoClass(context, substitutionClass, source, restOfLine);</span>
<span class="nc" id="L125">			}</span>
			else
			{
<span class="nc bnc" id="L128" title="All 2 branches missed.">				if (lstLine.indexOf('\t') == -1)</span>
				{
<span class="nc" id="L130">					Logging.errorPrint(&quot;Ignoring line: &quot; + lstLine + &quot; as SUBSTITUTIONLEVEL line was empty&quot;);</span>
<span class="nc" id="L131">					return null;</span>
				}
<span class="nc" id="L133">				List&lt;SubstitutionClass&gt; substitutionClassList = target.getListFor(ListKey.SUBSTITUTION_CLASS);</span>
<span class="nc bnc" id="L134" title="All 6 branches missed.">				if (substitutionClassList != null &amp;&amp; !substitutionClassList.isEmpty() &amp;&amp; lstLine.length() &gt; 18)</span>
				{
<span class="nc" id="L136">					substitutionClass = substitutionClassList.get(substitutionClassList.size() - 1);</span>
<span class="nc" id="L137">					substitutionClass.addToListFor(ListKey.SUB_CLASS_LEVEL,</span>
<span class="nc" id="L138">						new DeferredLine(source, lstLine.substring(18)));</span>
				}
			}
<span class="nc" id="L141">			return target;</span>
		}

<span class="nc" id="L144">		return parseClassLine(context, lstLine, source, target);</span>
	}

	private PCClass parseClassLine(LoadContext context, String lstLine, SourceEntry source, PCClass pcClass)
	{
<span class="nc" id="L149">		int tabLoc = lstLine.indexOf(SystemLoader.TAB_DELIM);</span>
		String lineIdentifier;
		String restOfLine;
<span class="nc bnc" id="L152" title="All 2 branches missed.">		if (tabLoc == -1)</span>
		{
<span class="nc" id="L154">			lineIdentifier = lstLine;</span>
<span class="nc" id="L155">			restOfLine = null;</span>
		}
		else
		{
<span class="nc" id="L159">			lineIdentifier = lstLine.substring(0, tabLoc);</span>
<span class="nc" id="L160">			restOfLine = lstLine.substring(tabLoc + 1);</span>
		}

<span class="nc bnc" id="L163" title="All 2 branches missed.">		if (lineIdentifier.startsWith(&quot;CLASS:&quot;))</span>
		{
<span class="nc" id="L165">			String name = lineIdentifier.substring(6);</span>

<span class="nc bnc" id="L167" title="All 6 branches missed.">			if (pcClass == null || !name.equals(pcClass.getKeyName()) &amp;&amp; (!name.contains(&quot;.MOD&quot;)))</span>
			{
<span class="nc bnc" id="L169" title="All 2 branches missed.">				if (pcClass != null)</span>
				{
<span class="nc" id="L171">					completeObject(context, source, pcClass);</span>
				}
<span class="nc" id="L173">				pcClass = new PCClass();</span>
<span class="nc" id="L174">				pcClass.setName(name);</span>
<span class="nc" id="L175">				pcClass.setSourceURI(source.getURI());</span>
<span class="nc" id="L176">				pcClass.put(ObjectKey.SOURCE_CAMPAIGN, source.getCampaign());</span>
<span class="nc" id="L177">				context.addStatefulInformation(pcClass);</span>
<span class="nc" id="L178">				context.getReferenceContext().importObject(pcClass);</span>
			}
			// need to grab PCClass instance for this .MOD minus the .MOD part of the name
<span class="nc bnc" id="L181" title="All 2 branches missed.">			else if (name.endsWith(&quot;.MOD&quot;))</span>
			{
<span class="nc" id="L183">				pcClass = context.getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class,</span>
<span class="nc" id="L184">					name.substring(0, name.length() - 4));</span>
			}
<span class="nc" id="L186">			parseLineIntoClass(context, pcClass, source, restOfLine);</span>
<span class="nc" id="L187">		}</span>
		else
		{
<span class="nc" id="L190">			parseFullClassLevelLine(context, source, pcClass, lineIdentifier, restOfLine);</span>
		}
<span class="nc" id="L192">		return pcClass;</span>
	}

	private void parseFullClassLevelLine(LoadContext context, SourceEntry source, PCClass pcClass,
		String lineIdentifier, String restOfLine)
	{
		try
		{
<span class="nc" id="L200">			String repeatTag = null;</span>
			String thisLevel;
<span class="nc" id="L202">			int rlLoc = lineIdentifier.indexOf(&quot;:REPEATLEVEL:&quot;);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">			if (rlLoc == -1)</span>
			{
<span class="nc" id="L205">				thisLevel = lineIdentifier;</span>
			}
			else
			{
<span class="nc" id="L209">				thisLevel = lineIdentifier.substring(0, rlLoc);</span>
<span class="nc" id="L210">				repeatTag = lineIdentifier.substring(rlLoc + 13);</span>
			}
<span class="nc" id="L212">			int iLevel = Integer.parseInt(thisLevel);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">			if (iLevel == 0)</span>
			{
				/*
				 * This is for backwards compatibility with PCGen 5.14
				 * getPCCText which writes out things to level 0 :P
				 */
<span class="nc" id="L219">				parseLineIntoClass(context, pcClass, source, restOfLine);</span>
			}
<span class="nc bnc" id="L221" title="All 2 branches missed.">			else if (iLevel &gt; 0)</span>
			{
<span class="nc" id="L223">				parseClassLevelLine(context, pcClass, iLevel, source, restOfLine);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">				if (repeatTag != null)</span>
				{
<span class="nc" id="L226">					parseRepeatClassLevel(context, restOfLine, source, pcClass, iLevel, repeatTag);</span>
				}
			}
			else
			{
<span class="nc" id="L231">				Logging.errorPrint(&quot;Invalid Level Identifier: &quot; + thisLevel + &quot; for &quot; + pcClass.getDisplayName()</span>
					+ &quot;. Value must be greater than zero&quot;);
			}
		}
<span class="nc" id="L235">		catch (NumberFormatException nfe)</span>
		{
			// I think we can ignore this, as
			// it's supposed to be the level #
			// but could be almost anything else
<span class="nc" id="L240">			Logging.errorPrint(&quot;Expected a level value, but got '&quot; + lineIdentifier + &quot;' instead (as a level line in &quot;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">				+ (pcClass == null ? &quot;no class&quot; : pcClass.getKeyName()) + &quot;) in source &quot; + source.getURI());</span>
<span class="nc" id="L242">			Logging.errorPrint(&quot;  Rest of line was: &quot; + restOfLine);</span>
<span class="nc" id="L243">		}</span>
<span class="nc" id="L244">	}</span>

	public void parseClassLevelLine(LoadContext context, PCClass pcClass, int lvl, SourceEntry source,
		String restOfLine)
	{
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (restOfLine == null)</span>
		{
<span class="nc" id="L251">			return;</span>
		}
<span class="nc" id="L253">		PCClassLevel classlevel = pcClass.getOriginalClassLevel(lvl);</span>
<span class="nc" id="L254">		final StringTokenizer colToken = new StringTokenizer(restOfLine, SystemLoader.TAB_DELIM);</span>

		// loop through all the tokens and parse them
<span class="nc bnc" id="L257" title="All 2 branches missed.">		while (colToken.hasMoreTokens())</span>
		{
<span class="nc" id="L259">			String token = colToken.nextToken().trim();</span>
<span class="nc" id="L260">			int colonLoc = token.indexOf(':');</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if (colonLoc == -1)</span>
			{
<span class="nc" id="L263">				Logging.errorPrint(&quot;Invalid Token - does not contain a colon: '&quot; + token + &quot;' in Class &quot;</span>
<span class="nc" id="L264">					+ pcClass.getDisplayName() + &quot; of &quot; + source);</span>
<span class="nc" id="L265">				continue;</span>
			}
<span class="nc bnc" id="L267" title="All 2 branches missed.">			else if (colonLoc == 0)</span>
			{
<span class="nc" id="L269">				Logging.errorPrint(&quot;Invalid Token - starts with a colon: '&quot; + token + &quot;' in Class &quot;</span>
<span class="nc" id="L270">					+ pcClass.getDisplayName() + &quot; of &quot; + source);</span>
<span class="nc" id="L271">				continue;</span>
			}

<span class="nc" id="L274">			String key = token.substring(0, colonLoc);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			String value = (colonLoc == token.length() - 1) ? null : token.substring(colonLoc + 1);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">			if (context.processToken(classlevel, key, value))</span>
			{
<span class="nc" id="L278">				context.commit();</span>
			}
			else
			{
<span class="nc" id="L282">				context.rollback();</span>
<span class="nc" id="L283">				Logging.replayParsedMessages();</span>
			}
<span class="nc" id="L285">			Logging.clearParseMessages();</span>
<span class="nc" id="L286">		}</span>
<span class="nc" id="L287">	}</span>

	public void parseLineIntoClass(LoadContext context, PCClass pcClass, SourceEntry source, String restOfLine)
	{
<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (restOfLine == null)</span>
		{
<span class="nc" id="L293">			return;</span>
		}
<span class="nc" id="L295">		final StringTokenizer colToken = new StringTokenizer(restOfLine, SystemLoader.TAB_DELIM);</span>

		// loop through all the tokens and parse them
<span class="nc bnc" id="L298" title="All 2 branches missed.">		while (colToken.hasMoreTokens())</span>
		{
<span class="nc" id="L300">			String token = colToken.nextToken().trim();</span>
<span class="nc" id="L301">			int colonLoc = token.indexOf(':');</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">			if (colonLoc == -1)</span>
			{
<span class="nc" id="L304">				Logging.errorPrint(&quot;Invalid Token - does not contain a colon: '&quot; + token + &quot;' in Class &quot;</span>
<span class="nc" id="L305">					+ pcClass.getDisplayName() + &quot; of &quot; + source);</span>
<span class="nc" id="L306">				continue;</span>
			}
<span class="nc bnc" id="L308" title="All 2 branches missed.">			else if (colonLoc == 0)</span>
			{
<span class="nc" id="L310">				Logging.errorPrint(&quot;Invalid Token - starts with a colon: '&quot; + token + &quot;' in Class &quot;</span>
<span class="nc" id="L311">					+ pcClass.getDisplayName() + &quot; of &quot; + source);</span>
<span class="nc" id="L312">				continue;</span>
			}

<span class="nc" id="L315">			String key = token.substring(0, colonLoc);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">			String value = (colonLoc == token.length() - 1) ? null : token.substring(colonLoc + 1);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">			if (context.processToken(pcClass, key, value))</span>
			{
<span class="nc" id="L319">				context.commit();</span>
			}
			else
			{
<span class="nc" id="L323">				context.rollback();</span>
<span class="nc" id="L324">				Logging.replayParsedMessages();</span>
			}
<span class="nc" id="L326">			Logging.clearParseMessages();</span>
<span class="nc" id="L327">		}</span>
<span class="nc" id="L328">	}</span>

	private void parseRepeatClassLevel(LoadContext context, String restOfLine, SourceEntry source, PCClass pcClass,
		int iLevel, String colString)
	{
		//
		// REPEAT:&lt;level increment&gt;|&lt;consecutive&gt;|&lt;max level&gt;
		//
<span class="nc" id="L336">		final StringTokenizer repeatToken = new StringTokenizer(colString, &quot;|&quot;);</span>
<span class="nc" id="L337">		final int tokenCount = repeatToken.countTokens();</span>
<span class="nc" id="L338">		int lvlIncrement = 1000; // an arbitrarily large number...</span>
<span class="nc" id="L339">		int consecutive = 0; // 0 means don't skip any</span>
<span class="nc" id="L340">		int maxLevel = 100; // an arbitrarily large number...</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">		if (pcClass.hasMaxLevel())</span>
		{
<span class="nc" id="L343">			maxLevel = pcClass.getSafe(IntegerKey.LEVEL_LIMIT);</span>
		}
<span class="nc bnc" id="L345" title="All 2 branches missed.">		if (tokenCount &gt; 0)</span>
		{
			try
			{
<span class="nc" id="L349">				lvlIncrement = Integer.parseInt(repeatToken.nextToken());</span>
			}
<span class="nc" id="L351">			catch (NumberFormatException nfe)</span>
			{
<span class="nc" id="L353">				Logging.errorPrint(&quot;Non-Numeric Level Increment info '&quot; + colString + &quot;' in &quot; + source.getURI(), nfe);</span>
<span class="nc" id="L354">			}</span>
		}
<span class="nc" id="L356">		boolean oldSyntax = false;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (tokenCount &gt; 1)</span>
		{
<span class="nc" id="L359">			boolean consumed = false;</span>
<span class="nc" id="L360">			String tokenTwo = repeatToken.nextToken();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">			if (tokenTwo.startsWith(&quot;SKIP=&quot;))</span>
			{
<span class="nc" id="L363">				tokenTwo = tokenTwo.substring(5);</span>
			}
<span class="nc bnc" id="L365" title="All 2 branches missed.">			else if (tokenTwo.startsWith(&quot;MAX=&quot;))</span>
			{
<span class="nc bnc" id="L367" title="All 2 branches missed.">				if (tokenCount &gt; 2)</span>
				{
<span class="nc" id="L369">					Logging.errorPrint(</span>
						&quot;MAX= cannot be followed by another item in REPEATLEVEL.  SKIP= must appear before MAX=&quot;);
				}
<span class="nc" id="L372">				String maxString = tokenTwo.substring(4);</span>
				try
				{
<span class="nc" id="L375">					maxLevel = Integer.parseInt(maxString);</span>
				}
<span class="nc" id="L377">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L379">					Logging.errorPrint(&quot;Non-Numeric Max Level info MAX='&quot; + maxLevel + &quot;' in &quot; + source.getURI(), nfe);</span>
<span class="nc" id="L380">				}</span>
<span class="nc" id="L381">				consumed = true;</span>
<span class="nc" id="L382">			}</span>
			else
			{
<span class="nc" id="L385">				oldSyntax = true;</span>
			}
<span class="nc bnc" id="L387" title="All 2 branches missed.">			if (!consumed)</span>
			{
				try
				{
<span class="nc" id="L391">					consecutive = Integer.parseInt(tokenTwo);</span>
				}
<span class="nc" id="L393">				catch (NumberFormatException nfe)</span>
				{
<span class="nc" id="L395">					Logging.errorPrint(&quot;Non-Numeric Consecutive Level info '&quot; + colString + &quot;' in &quot; + source.getURI(),</span>
						nfe);
<span class="nc" id="L397">				}</span>
			}
		}
<span class="nc bnc" id="L400" title="All 2 branches missed.">		if (tokenCount &gt; 2)</span>
		{
<span class="nc" id="L402">			String tokenThree = repeatToken.nextToken();</span>
			String maxString;
<span class="nc bnc" id="L404" title="All 4 branches missed.">			if (!oldSyntax &amp;&amp; tokenThree.startsWith(&quot;MAX=&quot;))</span>
			{
<span class="nc" id="L406">				maxString = tokenThree.substring(4);</span>
			}
			else
			{
<span class="nc" id="L410">				maxString = tokenThree;</span>
			}
			try
			{
<span class="nc" id="L414">				maxLevel = Integer.parseInt(maxString);</span>
			}
<span class="nc" id="L416">			catch (NumberFormatException nfe)</span>
			{
<span class="nc" id="L418">				Logging.errorPrint(&quot;Non-Numeric Max Level info '&quot; + colString + &quot;' in &quot; + source.getURI(), nfe);</span>
<span class="nc" id="L419">			}</span>
		}

<span class="nc" id="L422">		int count = consecutive - 1; // first one already added by processing of lstLine, so skip it</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">		for (int lvl = iLevel + lvlIncrement; lvl &lt;= maxLevel; lvl += lvlIncrement)</span>
		{
<span class="nc bnc" id="L425" title="All 4 branches missed.">			if ((consecutive == 0) || (count != 0))</span>
			{
<span class="nc" id="L427">				parseClassLevelLine(context, pcClass, lvl, source, restOfLine);</span>
			}
<span class="nc bnc" id="L429" title="All 2 branches missed.">			if (consecutive != 0)</span>
			{
<span class="nc bnc" id="L431" title="All 2 branches missed.">				if (count == 0)</span>
				{
<span class="nc" id="L433">					count = consecutive;</span>
				}
				else
				{
<span class="nc" id="L437">					--count;</span>
				}
			}
		}
<span class="nc" id="L441">	}</span>

	@Override
	protected PCClass getObjectKeyed(LoadContext context, String aKey)
	{
<span class="nc" id="L446">		return context.getReferenceContext().silentlyGetConstructedCDOMObject(PCClass.class,</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">			aKey.startsWith(&quot;CLASS:&quot;) ? aKey.substring(6) : aKey);</span>
	}

	public void loadSubLines(LoadContext context)
	{
<span class="nc" id="L452">		Collection&lt;PCClass&gt; allClasses = context.getReferenceContext().getConstructedCDOMObjects(PCClass.class);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">		for (PCClass cl : allClasses)</span>
		{
<span class="nc" id="L455">			List&lt;SubClass&gt; subClasses = cl.getListFor(ListKey.SUB_CLASS);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">			if (subClasses != null)</span>
			{
<span class="nc bnc" id="L458" title="All 2 branches missed.">				for (SubClass sc : subClasses)</span>
				{
<span class="nc" id="L460">					sc.copyLevelsFrom(cl);</span>
<span class="nc" id="L461">					processSubLevelLines(context, cl, sc);</span>
<span class="nc" id="L462">				}</span>
			}
<span class="nc" id="L464">			List&lt;SubstitutionClass&gt; substClasses = cl.getListFor(ListKey.SUBSTITUTION_CLASS);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">			if (substClasses != null)</span>
			{
<span class="nc bnc" id="L467" title="All 2 branches missed.">				for (SubstitutionClass sc : substClasses)</span>
				{
<span class="nc" id="L469">					processSubLevelLines(context, cl, sc);</span>
<span class="nc" id="L470">				}</span>
			}
<span class="nc" id="L472">		}</span>
<span class="nc" id="L473">	}</span>

	private void processSubLevelLines(LoadContext context, PCClass cl, PCClass sc)
	{
<span class="nc bnc" id="L477" title="All 2 branches missed.">		for (DeferredLine dl : sc.getSafeListFor(ListKey.SUB_CLASS_LEVEL))</span>
		{
<span class="nc" id="L479">			context.setSourceURI(dl.source.getURI());</span>
<span class="nc" id="L480">			String lstLine = dl.lstLine;</span>
<span class="nc" id="L481">			int tabLoc = lstLine.indexOf(SystemLoader.TAB_DELIM);</span>
			String lineIdentifier;
			String restOfLine;
<span class="nc bnc" id="L484" title="All 2 branches missed.">			if (tabLoc == -1)</span>
			{
<span class="nc" id="L486">				lineIdentifier = lstLine;</span>
<span class="nc" id="L487">				restOfLine = null;</span>
			}
			else
			{
<span class="nc" id="L491">				lineIdentifier = lstLine.substring(0, tabLoc);</span>
<span class="nc" id="L492">				restOfLine = lstLine.substring(tabLoc + 1);</span>
			}
<span class="nc" id="L494">			parseFullClassLevelLine(context, dl.source, sc, lineIdentifier, restOfLine);</span>
<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">	}</span>

	@Override
	public PCClass getCopy(LoadContext context, String baseName, String copyName, CampaignSourceEntry source)
		throws PersistenceLayerException
	{
<span class="nc" id="L502">		PCClass copy = super.getCopy(context, baseName, copyName, source);</span>
<span class="nc" id="L503">		PCClassKeyChange.changeReferences(baseName, copy);</span>
<span class="nc" id="L504">		return copy;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>