<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LstObjectFileLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcgen</a> &gt; <a href="index.source.html" class="el_package">pcgen.persistence.lst</a> &gt; <span class="el_source">LstObjectFileLoader.java</span></div><h1>LstObjectFileLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2003 (C) David Hibbs &lt;sage_sam@users.sourceforge.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *
 */
package pcgen.persistence.lst;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Observable;
import java.util.Set;

import pcgen.cdom.base.CDOMObject;
import pcgen.cdom.enumeration.ObjectKey;
import pcgen.cdom.enumeration.StringKey;
import pcgen.core.Campaign;
import pcgen.persistence.PersistenceLayerException;
import pcgen.rules.context.LoadContext;
import pcgen.system.LanguageBundle;
import pcgen.system.PCGenSettings;
import pcgen.util.Logging;

/**
 * This class is an extension of the LstFileLoader that loads items
 * that are CDOMObjects and have a source campaign associated with them.
 * Objects loaded by implementations of this class inherit the core
 * MOD/COPY/FORGET funcationality needed for core CDOMObjects used
 * to directly create characters.
 */
<span class="nc" id="L49">public abstract class LstObjectFileLoader&lt;T extends CDOMObject&gt; extends Observable</span>
{
	/** The String that separates fields in the file. */
	private static final String FIELD_SEPARATOR = &quot;\t&quot;; //$NON-NLS-1$

	/** The suffix used to indicate this is a copy operation */
	private static final String COPY_SUFFIX = &quot;.COPY&quot;; //$NON-NLS-1$
	/** The suffix used to indicate this is a mod operation */
	private static final String MOD_SUFFIX = &quot;.MOD&quot;; //$NON-NLS-1$
	/** The suffix used to indicate this is a forget operation */
	private static final String FORGET_SUFFIX = &quot;.FORGET&quot;; //$NON-NLS-1$

<span class="nc" id="L61">	private final Collection&lt;ModEntry&gt; copyLineList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L62">	private final Collection&lt;String&gt; forgetLineList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L63">	private final Collection&lt;List&lt;ModEntry&gt;&gt; modEntryList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L64">	private boolean processComplete = true;</span>
	/** A list of objects that will not be included. */
<span class="nc" id="L66">	private final Collection&lt;String&gt; excludedObjects = new ArrayList&lt;&gt;();</span>

	/**
	 * This method loads the given list of LST files.
	 * @param fileList containing the list of files to read
	 * @throws PersistenceLayerException 
	 */
	public void loadLstFiles(LoadContext context, List&lt;CampaignSourceEntry&gt; fileList) throws PersistenceLayerException
	{
<span class="nc" id="L75">		processComplete = true;</span>
		// Track which sources have been loaded already
<span class="nc" id="L77">		Set&lt;CampaignSourceEntry&gt; loadedFiles = new HashSet&lt;&gt;();</span>

		// Load the files themselves as thoroughly as possible
<span class="nc bnc" id="L80" title="All 2 branches missed.">		for (CampaignSourceEntry sourceEntry : fileList)</span>
		{
<span class="nc bnc" id="L82" title="All 2 branches missed.">			if (sourceEntry == null)</span>
			{
<span class="nc" id="L84">				continue;</span>
			}

			// Check if the CSE has already been loaded before loading it
<span class="nc bnc" id="L88" title="All 2 branches missed.">			if (!loadedFiles.contains(sourceEntry))</span>
			{
<span class="nc" id="L90">				loadLstFile(context, sourceEntry);</span>
<span class="nc" id="L91">				loadedFiles.add(sourceEntry);</span>
			}
<span class="nc" id="L93">		}</span>

		// Next we perform copy operations
<span class="nc" id="L96">		processCopies(context);</span>

		// Now handle .MOD items
<span class="nc" id="L99">		processComplete = false;</span>
<span class="nc" id="L100">		processMods(context);</span>

		// Finally, forget the .FORGET items
<span class="nc" id="L103">		processForgets(context);</span>
<span class="nc" id="L104">	}</span>

	/**
	 * This method parses the LST file line, applying it to the provided target
	 * object.  If the line indicates the start of a new target object, a new
	 * CDOMObject of the appropriate type will be created prior to applying the
	 * line contents.  Because of this behavior, it is necessary for this
	 * method to return the new object.  Implementations of this method also
	 * MUST call {@code completeObject} with the original target prior to
	 * returning the new value.
	 * @param context TODO
	 * @param target CDOMObject to apply the line to, barring the start of a
	 *         new object
	 * @param lstLine String LST formatted line read from the source URL
	 * @param source SourceEntry indicating the file that the line was
	 *         read from as well as the Campaign object that referenced the file
	 *
	 * @return CDOMObject that was either created or modified by the provided
	 *         LST line
	 * @throws PersistenceLayerException if there is a problem with the LST syntax
	 */
	public abstract T parseLine(LoadContext context, T target, String lstLine, SourceEntry source)
		throws PersistenceLayerException;

	/**
	 * This method is called by the loading framework to signify that the
	 * loading of this object is complete and the object should be added to the
	 * system.
	 * 
	 * &lt;p&gt;This method will check that the loaded object should be included via
	 * a call to {@code includeObject} and if not add it to the list of
	 * excluded objects.
	 * 
	 * &lt;p&gt;Once the object has been verified the method will call
	 * {@code finishObject} to give each object a chance to complete
	 * processing.
	 * 
	 * &lt;p&gt;The object is then added to the system if it doesn't already exist.
	 * If the object exists, the object sources are compared by date and if the
	 * System setting allowing over-rides is set it will use the object from the
	 * newer source.
	 * @param context TODO
	 * @param pObj The object that has just completed loading.
	 * 
	 * @see pcgen.persistence.lst.LstObjectFileLoader#includeObject(SourceEntry, CDOMObject)
	 */
	public void completeObject(LoadContext context, SourceEntry source, final T pObj)
	{
<span class="nc bnc" id="L152" title="All 4 branches missed.">		if (!processComplete || pObj == null)</span>
		{
<span class="nc" id="L154">			return;</span>
		}

<span class="nc bnc" id="L157" title="All 2 branches missed.">		if (includeObject(source, pObj))</span>
		{
<span class="nc" id="L159">			storeObject(context, pObj);</span>
		}
		else
		{
<span class="nc" id="L163">			excludedObjects.add(pObj.getKeyName());</span>
<span class="nc" id="L164">			context.getReferenceContext().forget(pObj);</span>
		}
<span class="nc" id="L166">	}</span>

	@SuppressWarnings(&quot;PMD.UnusedNullCheckInEquals&quot;)
	private void storeObject(LoadContext context, T pObj)
	{
<span class="nc" id="L171">		final T currentObj = getMatchingObject(context, pObj);</span>

<span class="nc bnc" id="L173" title="All 6 branches missed.">		if (context.consolidate() &amp;&amp; currentObj != null &amp;&amp; pObj.equals(currentObj))</span>
		{
			//Yes, this is instance equality, NOT .equals!!!!!
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (currentObj != pObj)</span>
			{
<span class="nc" id="L178">				boolean allowoverride =</span>
<span class="nc" id="L179">						PCGenSettings.OPTIONS_CONTEXT.initBoolean(PCGenSettings.OPTION_ALLOW_OVERRIDE_DUPLICATES, true);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">				if (allowoverride)</span>
				{
					// If the new object is more recent than the current
					// one, use the new object
<span class="nc" id="L184">					final Date pObjDate = pObj.get(ObjectKey.SOURCE_DATE);</span>
<span class="nc" id="L185">					final Date currentObjDate = currentObj.get(ObjectKey.SOURCE_DATE);</span>
<span class="nc bnc" id="L186" title="All 6 branches missed.">					if ((pObjDate != null) &amp;&amp; ((currentObjDate == null) || ((pObjDate.compareTo(currentObjDate) &gt; 0))))</span>
					{
<span class="nc" id="L188">						performForget(context, currentObj);</span>
					}
					else
					{
						/*
						 * This does not use performForget since this is only
						 * forgetting something that is local to the context
						 * (was never &quot;added&quot; to the 5.x system)
						 */
<span class="nc" id="L197">						context.getReferenceContext().forget(pObj);</span>
					}
<span class="nc" id="L199">				}</span>
				else
				{
					// Duplicate loading error
<span class="nc" id="L203">					Logging.errorPrintLocalised(&quot;Warnings.LstFileLoader.DuplicateObject&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L204">						pObj.getKeyName(), currentObj.getSourceURI(), pObj.getSourceURI());</span>
				}
			}
		}
<span class="nc" id="L208">	}</span>

	/**
	 * This method should be called by finishObject implementations in
	 * order to check if the parsed object is affected by an INCLUDE or
	 * EXCLUDE request.
	 *
	 * @param cdo CDOMObject to determine whether to include in
	 *         Globals etc.
	 * @return boolean true if the object should be included, else false
	 *         to exclude it
	 */
	protected boolean includeObject(SourceEntry source, CDOMObject cdo)
	{
		// Null check; never add nulls or objects without a name/key name
<span class="nc bnc" id="L223" title="All 6 branches missed.">		if ((cdo == null) || (cdo.getDisplayName() == null) || (cdo.getDisplayName().trim().isEmpty())</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">			|| (cdo.getKeyName() == null) || (cdo.getKeyName().trim().isEmpty()))</span>
		{
<span class="nc" id="L226">			return false;</span>
		}

		// If includes were present, check includes for given object
<span class="nc" id="L230">		List&lt;String&gt; includeItems = source.getIncludeItems();</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (!includeItems.isEmpty())</span>
		{
<span class="nc" id="L234">			return includeItems.contains(cdo.getKeyName());</span>
		}
		// If excludes were present, check excludes for given object
<span class="nc" id="L237">		List&lt;String&gt; excludeItems = source.getExcludeItems();</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">		if (!excludeItems.isEmpty())</span>
		{
<span class="nc bnc" id="L241" title="All 2 branches missed.">			return !excludeItems.contains(cdo.getKeyName());</span>
		}

<span class="nc" id="L244">		return true;</span>
	}

	/**
	 * This method retrieves a CDOMObject from globals by its key.
	 * This is used to avoid duplicate loads, get objects to forget or
	 * modify, etc.
	 * @param context TODO
	 * @param aKey String key of CDOMObject to retrieve
	 * @return CDOMObject of the given key
	 */
	protected abstract T getObjectKeyed(LoadContext context, String aKey);

	/**
	 * This method retrieves a CDOMObject from the global list, attempting to match (by key
	 * and category, if necessary), the given object. This is used to avoid
	 * duplicate loads
	 * @param context TODO
	 * @param key The CDOMObject containing the key to retrieve (for which there may be a duplicate)
	 * 
	 * @return CDOMObject from Globals
	 */
	protected T getMatchingObject(LoadContext context, CDOMObject key)
	{
<span class="nc" id="L268">		return getObjectKeyed(context, key.getKeyName());</span>
	}

	/**
	 * This method loads a single LST formatted file.
	 * @param sourceEntry CampaignSourceEntry containing the absolute file path
	 * or the URL from which to read LST formatted data.
	 */
	protected void loadLstFile(LoadContext context, CampaignSourceEntry sourceEntry)
	{
<span class="nc" id="L278">		setChanged();</span>
<span class="nc" id="L279">		URI uri = sourceEntry.getURI();</span>
<span class="nc" id="L280">		notifyObservers(uri);</span>
		String dataBuffer;
		try
		{
<span class="nc" id="L284">			dataBuffer = LstFileLoader.readFromURI(uri);</span>
		}
<span class="nc" id="L286">		catch (PersistenceLayerException ple)</span>
		{
<span class="nc" id="L288">			String message = LanguageBundle.getFormattedString(&quot;Errors.LstFileLoader.LoadError&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L289">				uri, ple.getMessage());</span>
<span class="nc" id="L290">			Logging.errorPrint(message, ple);</span>
<span class="nc" id="L291">			setChanged();</span>
<span class="nc" id="L292">			return;</span>
<span class="nc" id="L293">		}</span>
<span class="nc" id="L294">		String aString = Objects.requireNonNull(dataBuffer);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if (context != null)</span>
		{
<span class="nc" id="L297">			context.setSourceURI(uri);</span>
		}
<span class="nc" id="L299">		T target = null;</span>
<span class="nc" id="L300">		ArrayList&lt;ModEntry&gt; classModLines = null;</span>
<span class="nc" id="L301">		boolean allowMultiLine =</span>
<span class="nc" id="L302">				PCGenSettings.OPTIONS_CONTEXT.initBoolean(PCGenSettings.OPTION_SOURCES_ALLOW_MULTI_LINE, false);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">		if (allowMultiLine)</span>
		{
			// Support the new file type. All lines that start with a tab belong to the previous line.
<span class="nc" id="L306">			aString = aString.replaceAll(&quot;\r?\n\t&quot;, &quot;\t&quot;);</span>
		}
<span class="nc" id="L308">		String[] fileLines = aString.split(LstFileLoader.LINE_SEPARATOR_REGEXP);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">		for (int i = 0; i &lt; fileLines.length; i++)</span>
		{
<span class="nc" id="L311">			String line = fileLines[i];</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">			if ((line.trim().isEmpty()) || (line.charAt(0) == LstFileLoader.LINE_COMMENT_CHAR))</span>
			{
<span class="nc" id="L314">				continue;</span>
			}
<span class="nc" id="L316">			int sepLoc = line.indexOf(FIELD_SEPARATOR);</span>
			String firstToken;
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (sepLoc == -1)</span>
			{
<span class="nc" id="L320">				firstToken = line;</span>
			}
			else
			{
<span class="nc" id="L324">				firstToken = line.substring(0, sepLoc);</span>
			}
			// Check for continuation of class mods
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (classModLines != null)</span>
			{
				// TODO - Figure out why we need to check CLASS: in this file.
<span class="nc bnc" id="L330" title="All 2 branches missed.">				if (firstToken.startsWith(&quot;CLASS:&quot;)) //$NON-NLS-1$</span>
				{
<span class="nc" id="L332">					modEntryList.add(classModLines);</span>
<span class="nc" id="L333">					classModLines = null;</span>
				}
				else
				{
					// Add the line to the class mod and don't process it yet.
<span class="nc" id="L338">					classModLines.add(new ModEntry(sourceEntry, line, i + 1));</span>
<span class="nc" id="L339">					continue;</span>
				}
			}
			// check for copies, mods, and forgets
			// TODO - Figure out why we need to check SOURCE in this file
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (line.startsWith(&quot;SOURCE&quot;)) //$NON-NLS-1$</span>
			{
<span class="nc" id="L346">				SourceLoader.parseLine(context, line, uri);</span>
			}
<span class="nc bnc" id="L348" title="All 2 branches missed.">			else if (firstToken.indexOf(COPY_SUFFIX) &gt; 0)</span>
			{
<span class="nc" id="L350">				copyLineList.add(new ModEntry(sourceEntry, line, i + 1));</span>
			}
<span class="nc bnc" id="L352" title="All 2 branches missed.">			else if (firstToken.indexOf(MOD_SUFFIX) &gt; 0)</span>
			{
				// TODO - Figure out why we need to check CLASS: in this file.
<span class="nc bnc" id="L355" title="All 2 branches missed.">				if (firstToken.startsWith(&quot;CLASS:&quot;)) //$NON-NLS-1$</span>
				{
					// As CLASS:abc.MOD can be followed by level lines, we place the
					// lines into a list for processing in a group afterwards
<span class="nc" id="L359">					classModLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L360">					classModLines.add(new ModEntry(sourceEntry, line, i + 1));</span>
				}
				else
				{
<span class="nc" id="L364">					List&lt;ModEntry&gt; modLines = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L365">					modLines.add(new ModEntry(sourceEntry, line, i + 1));</span>
<span class="nc" id="L366">					modEntryList.add(modLines);</span>
<span class="nc" id="L367">				}</span>
			}
<span class="nc bnc" id="L369" title="All 2 branches missed.">			else if (firstToken.indexOf(FORGET_SUFFIX) &gt; 0)</span>
			{
<span class="nc" id="L371">				forgetLineList.add(line);</span>
			}
			else
			{
				try
				{
<span class="nc" id="L377">					target = parseLine(context, target, line, sourceEntry);</span>
				}
<span class="nc" id="L379">				catch (PersistenceLayerException ple)</span>
				{
<span class="nc" id="L381">					String message = LanguageBundle.getFormattedString(&quot;Errors.LstFileLoader.ParseError&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L382">						uri, i + 1, ple.getMessage());</span>
<span class="nc" id="L383">					Logging.errorPrint(message);</span>
<span class="nc" id="L384">					setChanged();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">					if (Logging.isDebugMode())</span>
					{
<span class="nc" id="L387">						Logging.debugPrint(&quot;Parse error:&quot;, ple); //$NON-NLS-1$</span>
					}
				}
<span class="nc" id="L390">				catch (Throwable t)</span>
				{
<span class="nc" id="L392">					String message = LanguageBundle.getFormattedString(&quot;Errors.LstFileLoader.ParseError&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L393">						uri, i + 1, t.getMessage());</span>
<span class="nc" id="L394">					Logging.errorPrint(message, t);</span>
<span class="nc" id="L395">					setChanged();</span>
<span class="nc" id="L396">					Logging.errorPrint(LanguageBundle.getString(&quot;Errors.LstFileLoader.Ignoring: &quot; + t.getMessage()));</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">					if (Logging.isDebugMode())</span>
					{
<span class="nc" id="L399">						Logging.errorPrint(LanguageBundle.getString(&quot;Errors.LstFileLoader.Ignoring&quot;), t);</span>
					}
<span class="nc" id="L401">				}</span>
			}
		}
<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (classModLines != null)</span>
		{
<span class="nc" id="L406">			modEntryList.add(classModLines);</span>
		}
<span class="nc bnc" id="L408" title="All 2 branches missed.">		if (target != null)</span>
		{
<span class="nc" id="L410">			completeObject(context, sourceEntry, target);</span>
		}
<span class="nc" id="L412">	}</span>

	/**
	 * This method, when implemented, will perform a single .FORGET
	 * operation.
	 * @param context TODO
	 * @param objToForget containing the object to forget
	 */
	private void performForget(LoadContext context, T objToForget)
	{
<span class="nc" id="L422">		context.getReferenceContext().forget(objToForget);</span>
<span class="nc" id="L423">	}</span>

	/**
	 * This method will perform a single .COPY operation based on the LST
	 * file content.
	 * @param context
	 * @param me 
	 * @throws PersistenceLayerException 
	 */
	private void performCopy(LoadContext context, ModEntry me) throws PersistenceLayerException
	{
		// lstLine String containing the LST source for the COPY operation
<span class="nc" id="L435">		String lstLine = me.getLstLine();</span>
<span class="nc" id="L436">		int sepLoc = lstLine.indexOf(FIELD_SEPARATOR);</span>
		String name;
<span class="nc bnc" id="L438" title="All 2 branches missed.">		if (sepLoc != -1)</span>
		{
<span class="nc" id="L440">			name = lstLine.substring(0, sepLoc);</span>
		}
		else
		{
<span class="nc" id="L444">			name = lstLine;</span>
		}
<span class="nc" id="L446">		final int nameEnd = name.indexOf(COPY_SUFFIX);</span>
<span class="nc" id="L447">		final String baseName = name.substring(0, nameEnd);</span>
<span class="nc" id="L448">		final String copyName = name.substring(nameEnd + 6);</span>
<span class="nc" id="L449">		T copy = getCopy(context, baseName, copyName.intern(), me.source);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (copy != null)</span>
		{
<span class="nc bnc" id="L452" title="All 2 branches missed.">			if (sepLoc != -1)</span>
			{
<span class="nc" id="L454">				String restOfLine = me.getLstLine().substring(nameEnd + 6);</span>
<span class="nc" id="L455">				parseLine(context, copy, restOfLine, me.getSource());</span>
			}
<span class="nc" id="L457">			completeObject(context, me.getSource(), copy);</span>
		}
<span class="nc" id="L459">	}</span>

	/**
	 * Create a copy of an object with a new name. If the base object cannot be found, an error will be reported unless
	 * the copy has been excluded by include/exclude rules for the source.
	 * 
	 * @param context The current load context in whihc the new object is to be created.
	 * @param baseName The name of the object to be copied.
	 * @param copyName The name of the new object.
	 * @param source The source containing the copy.
	 * @return The new object, or null if the base object could not be found.
	 * @throws PersistenceLayerException If an unexpected error occurs.
	 */
	protected T getCopy(LoadContext context, final String baseName, final String copyName, CampaignSourceEntry source)
		throws PersistenceLayerException
	{
<span class="nc" id="L475">		T object = getObjectKeyed(context, baseName);</span>

<span class="nc bnc" id="L477" title="All 2 branches missed.">		if (object == null)</span>
		{
<span class="nc" id="L479">			List&lt;String&gt; includeItems = source.getIncludeItems();</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">			if (!includeItems.isEmpty() &amp;&amp; !includeItems.contains(copyName))</span>
			{
<span class="nc" id="L482">				return null;</span>
			}
<span class="nc" id="L484">			List&lt;String&gt; excludeItems = source.getExcludeItems();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">			if (excludeItems.contains(copyName))</span>
			{
<span class="nc" id="L487">				return null;</span>
			}

<span class="nc" id="L490">			String message = LanguageBundle.getFormattedString(&quot;Errors.LstFileLoader.CopyObjectNotFound&quot;, //$NON-NLS-1$</span>
				baseName);
<span class="nc" id="L492">			Logging.errorPrint(message);</span>
<span class="nc" id="L493">			setChanged();</span>

<span class="nc" id="L495">			return null;</span>
		}

<span class="nc" id="L498">		T obj = context.performCopy(object, copyName);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">		if (obj == null)</span>
		{
<span class="nc" id="L501">			setChanged();</span>
		}
<span class="nc" id="L503">		return obj;</span>
	}

	/**
	 * This method will perform a multi-line .MOD operation. This is used
	 * for example in MODs of CLASSES which can have multiple lines. Loaders
	 * can [typically] use the name without checking
	 * for (or stripping off) .MOD due to the implementation of
	 * CDOMObject.setName()
	 * @param entryList
	 */
	private void performMod(LoadContext context, List&lt;ModEntry&gt; entryList)
	{
<span class="nc" id="L516">		ModEntry entry = entryList.get(0);</span>
		// get the name of the object to modify, trimming off the .MOD
<span class="nc" id="L518">		int nameEnd = entry.getLstLine().indexOf(MOD_SUFFIX);</span>
<span class="nc" id="L519">		String key = entry.getLstLine().substring(0, nameEnd);</span>
<span class="nc" id="L520">		List&lt;String&gt; includeItems = entry.source.getIncludeItems();</span>

		// remove the leading tag, if any (i.e. CLASS:Druid.MOD
<span class="nc" id="L523">		int nameStart = key.indexOf(':');</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">		if (nameStart &gt; 0)</span>
		{
<span class="nc" id="L527">			key = key.substring(nameStart + 1);</span>
		}

		// get the actual object to modify
<span class="nc" id="L531">		T object = context.getReferenceContext().performMod(getObjectKeyed(context, key));</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (object == null)</span>
		{
<span class="nc bnc" id="L535" title="All 4 branches missed.">			if (!includeItems.isEmpty() &amp;&amp; !includeItems.contains(key))</span>
			{
<span class="nc" id="L537">				return;</span>
			}

<span class="nc bnc" id="L540" title="All 2 branches missed.">			if (excludedObjects.contains(key))</span>
			{
<span class="nc" id="L542">				return;</span>
			}

<span class="nc" id="L545">			String message = LanguageBundle.getFormattedString(&quot;Errors.LstFileLoader.ModObjectNotFound&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L546">				entry.getSource().getURI(), entry.getLineNumber(), key);</span>
<span class="nc" id="L547">			Logging.log(Logging.LST_ERROR, message);</span>
<span class="nc" id="L548">			setChanged();</span>
<span class="nc" id="L549">			return;</span>
		}

		// modify the object
<span class="nc bnc" id="L553" title="All 4 branches missed.">		if (includeItems.isEmpty() || includeItems.contains(key))</span>
		{
<span class="nc bnc" id="L555" title="All 2 branches missed.">			for (ModEntry element : entryList)</span>
			{
<span class="nc" id="L557">				context.setSourceURI(element.source.getURI());</span>
				try
				{
<span class="nc" id="L560">					String origPage = object.get(StringKey.SOURCE_PAGE);</span>

<span class="nc" id="L562">					parseLine(context, object, element.getLstLine(), element.getSource());</span>

<span class="nc bnc" id="L564" title="All 2 branches missed.">					if (origPage != object.get(StringKey.SOURCE_PAGE))</span>
					{
<span class="nc" id="L566">						Campaign campaign = element.source.getCampaign();</span>
<span class="nc" id="L567">						object.put(ObjectKey.SOURCE_CAMPAIGN, campaign);</span>
<span class="nc" id="L568">						object.put(StringKey.SOURCE_SHORT, campaign.get(StringKey.SOURCE_SHORT));</span>
<span class="nc" id="L569">						object.put(StringKey.SOURCE_LONG, campaign.get(StringKey.SOURCE_LONG));</span>
<span class="nc" id="L570">						object.put(ObjectKey.SOURCE_DATE, campaign.get(ObjectKey.SOURCE_DATE));</span>
<span class="nc" id="L571">						object.put(StringKey.SOURCE_WEB, campaign.get(StringKey.SOURCE_WEB));</span>
<span class="nc" id="L572">						object.setSourceURI(element.source.getURI());</span>
					}
				}
<span class="nc" id="L575">				catch (PersistenceLayerException ple)</span>
				{
<span class="nc" id="L577">					String message =</span>
<span class="nc" id="L578">							LanguageBundle.getFormattedString(</span>
								&quot;Errors.LstFileLoader.ModParseError&quot;, //$NON-NLS-1$
<span class="nc" id="L580">						element.getSource().getURI(), element.getLineNumber(), ple.getMessage());</span>
<span class="nc" id="L581">					Logging.errorPrint(message);</span>
<span class="nc" id="L582">					setChanged();</span>
<span class="nc" id="L583">				}</span>
<span class="nc" id="L584">			}</span>
		}
<span class="nc" id="L586">		completeObject(context, entry.getSource(), object);</span>
<span class="nc" id="L587">	}</span>

	/**
	 * This method will process the lines containing a .COPY directive
	 * @throws PersistenceLayerException 
	 */
	private void processCopies(LoadContext context) throws PersistenceLayerException
	{
<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (ModEntry me : copyLineList)</span>
		{
<span class="nc" id="L597">			context.setSourceURI(me.source.getURI());</span>
<span class="nc" id="L598">			performCopy(context, me);</span>
<span class="nc" id="L599">		}</span>
<span class="nc" id="L600">		copyLineList.clear();</span>
<span class="nc" id="L601">	}</span>

	/**
	 * This method will process the lines containing a .FORGET directive
	 * @param context TODO
	 */
	private void processForgets(LoadContext context)
	{

<span class="nc bnc" id="L610" title="All 2 branches missed.">		for (String forgetKey : forgetLineList)</span>
		{
<span class="nc" id="L612">			forgetKey = forgetKey.substring(0, forgetKey.indexOf(FORGET_SUFFIX));</span>

<span class="nc bnc" id="L614" title="All 2 branches missed.">			if (excludedObjects.contains(forgetKey))</span>
			{
<span class="nc" id="L616">				continue;</span>
			}
			// Commented out so that deprcated method no longer used
			// performForget(forgetName);

<span class="nc" id="L621">			T objToForget = getObjectKeyed(context, forgetKey);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">			if (objToForget != null)</span>
			{
<span class="nc" id="L624">				performForget(context, objToForget);</span>
			}
<span class="nc" id="L626">		}</span>
<span class="nc" id="L627">		forgetLineList.clear();</span>
<span class="nc" id="L628">	}</span>

	/**
	 * This method will process the lines containing a .MOD directive
	 */
	private void processMods(LoadContext context)
	{
<span class="nc bnc" id="L635" title="All 2 branches missed.">		for (List&lt;ModEntry&gt; modEntry : modEntryList)</span>
		{
<span class="nc" id="L637">			performMod(context, modEntry);</span>
<span class="nc" id="L638">		}</span>
<span class="nc" id="L639">		modEntryList.clear();</span>
<span class="nc" id="L640">	}</span>

	/**
	 * This class is an entry mapping a mod to its source.
	 * Once created, instances of this class are immutable.
	 */
	public static final class ModEntry
	{
		private CampaignSourceEntry source;
		private String lstLine;
		private int lineNumber;

		/**
		 * ModEntry constructor.
		 * @param aSource CampaignSourceEntry containing the MOD line
		 *         [must not be null]
		 * @param aLstLine LST syntax modification
		 *         [must not be null]
		 * @param aLineNumber
		 * 
		 * @throws IllegalArgumentException if aSource or aLstLine is null.
		 */
		private ModEntry(final CampaignSourceEntry aSource, final String aLstLine, final int aLineNumber)
		{
<span class="nc" id="L664">			super();</span>

			// These are programming errors so the msgs don't need to be 
			// internationalized.
<span class="nc" id="L668">			Objects.requireNonNull(aSource, &quot;source must not be null&quot;);</span>

<span class="nc" id="L670">			Objects.requireNonNull(aLstLine, &quot;lstLine must not be null&quot;);</span>

<span class="nc" id="L672">			this.source = aSource;</span>
<span class="nc" id="L673">			this.lstLine = aLstLine;</span>
<span class="nc" id="L674">			this.lineNumber = aLineNumber;</span>
<span class="nc" id="L675">		}</span>

		/**
		 * This method gets the LST formatted source line for the .MOD
		 * @return String in LST format, unmodified from the source file
		 */
		public String getLstLine()
		{
<span class="nc" id="L683">			return lstLine;</span>
		}

		/**
		 * This method gets the source of the .MOD operation
		 * @return CampaignSourceEntry indicating where the .MOD came from
		 */
		public CampaignSourceEntry getSource()
		{
<span class="nc" id="L692">			return source;</span>
		}

		/**
		 *
		 * @return The line number of the original file for this MOD entry
		 */
		private int getLineNumber()
		{
<span class="nc" id="L701">			return lineNumber;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>